# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
BRepBndLib module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_brepbndlib.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepBndLib')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepBndLib')
    _BRepBndLib = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepBndLib', [dirname(__file__)])
        except ImportError:
            import _BRepBndLib
            return _BRepBndLib
        try:
            _mod = imp.load_module('_BRepBndLib', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepBndLib = swig_import_helper()
    del swig_import_helper
else:
    import _BRepBndLib
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepBndLib.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _BRepBndLib.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _BRepBndLib.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _BRepBndLib.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _BRepBndLib.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _BRepBndLib.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _BRepBndLib.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _BRepBndLib.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _BRepBndLib.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _BRepBndLib.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _BRepBndLib.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _BRepBndLib.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _BRepBndLib.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _BRepBndLib.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _BRepBndLib.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _BRepBndLib.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _BRepBndLib.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRepBndLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _BRepBndLib.process_exception(error, method_name, class_name)
process_exception = _BRepBndLib.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TopoDS
import OCC.Core.Message
import OCC.Core.TCollection
import OCC.Core.OSD
import OCC.Core.TColStd
import OCC.Core.TopAbs
import OCC.Core.TopLoc
import OCC.Core.gp
import OCC.Core.Bnd
import OCC.Core.TColgp
import OCC.Core.BVH

from enum import IntEnum
from OCC.Core.Exception import *



class brepbndlib(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, brepbndlib, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, brepbndlib, name)
    __repr__ = _swig_repr

    def Add(*args) -> "void":
        """
        Adds the shape s to the bounding box b. more precisely are successively added to b: - each face of s; the triangulation of the face is used if it exists, - then each edge of s which does not belong to a face, the polygon of the edge is used if it exists - and last each vertex of s which does not belong to an edge. after each elementary operation, the bounding box b is enlarged by the tolerance value of the relative sub-shape. when working with the triangulation of a face this value of enlargement is the sum of the triangulation deflection and the face tolerance. when working with the polygon of an edge this value of enlargement is the sum of the polygon deflection and the edge tolerance. warning - this algorithm is time consuming if triangulation has not been inserted inside the data structure of the shape s. - the resulting bounding box may be somewhat larger than the object.

        Parameters
        ----------
        S: TopoDS_Shape
        B: Bnd_Box
        useTriangulation: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        """
        return _BRepBndLib.brepbndlib_Add(*args)

    Add = staticmethod(Add)

    def AddClose(*args) -> "void":
        """
        Adds the shape s to the bounding box b. this is a quick algorithm but only works if the shape s is composed of polygonal planar faces, as is the case if s is an approached polyhedral representation of an exact shape. pay particular attention to this because this condition is not checked and, if it not respected, an error may occur in the algorithm for which the bounding box is built. note that the resulting bounding box is not enlarged by the tolerance value of the sub-shapes as is the case with the add function. so the added part of the resulting bounding box is closer to the shape s.

        Parameters
        ----------
        S: TopoDS_Shape
        B: Bnd_Box

        Returns
        -------
        None

        """
        return _BRepBndLib.brepbndlib_AddClose(*args)

    AddClose = staticmethod(AddClose)

    def AddOBB(*args) -> "void":
        """
        Computes the oriented bounding box for the shape <thes>. two independent methods of computation are implemented: first method based on set of points (so, it demands the triangulated shape or shape with planar faces and linear edges). the second method is based on use of inertia axes and is called if use of the first method is impossible. if theistriangulationused == false then the triangulation will be ignored at all. if theisshapetoleranceused == true then resulting box will be extended on the tolerance of the shape. theisoptimal flag defines whether to look for the more tight obb for the cost of performance or not.

        Parameters
        ----------
        theS: TopoDS_Shape
        theOBB: Bnd_OBB
        theIsTriangulationUsed: bool,optional
        	default value is Standard_True
        theIsOptimal: bool,optional
        	default value is Standard_False
        theIsShapeToleranceUsed: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        """
        return _BRepBndLib.brepbndlib_AddOBB(*args)

    AddOBB = staticmethod(AddOBB)

    def AddOptimal(*args) -> "void":
        """
        Adds the shape s to the bounding box b. this algorith builds precise bounding box, which differs from exact geometry boundaries of shape only on shape entities tolerances algorithm is the same as for method add(..), but uses more precise methods for building boxes for geometry objects. if useshapetolerance = true, bounding box is enlardged by shape tolerances and these tolerances are used for numerical methods of bounding box size calculations, otherwise bounding box is built according to sizes of uderlined geometrical entities, numerical calculation use tolerance precision::confusion().

        Parameters
        ----------
        S: TopoDS_Shape
        B: Bnd_Box
        useTriangulation: bool,optional
        	default value is Standard_True
        useShapeTolerance: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        return _BRepBndLib.brepbndlib_AddOptimal(*args)

    AddOptimal = staticmethod(AddOptimal)

    __repr__ = _dumps_object


    def __init__(self):
        this = _BRepBndLib.new_brepbndlib()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepBndLib.delete_brepbndlib
    __del__ = lambda self: None
brepbndlib_swigregister = _BRepBndLib.brepbndlib_swigregister
brepbndlib_swigregister(brepbndlib)

def brepbndlib_Add(*args) -> "void":
    """
    Adds the shape s to the bounding box b. more precisely are successively added to b: - each face of s; the triangulation of the face is used if it exists, - then each edge of s which does not belong to a face, the polygon of the edge is used if it exists - and last each vertex of s which does not belong to an edge. after each elementary operation, the bounding box b is enlarged by the tolerance value of the relative sub-shape. when working with the triangulation of a face this value of enlargement is the sum of the triangulation deflection and the face tolerance. when working with the polygon of an edge this value of enlargement is the sum of the polygon deflection and the edge tolerance. warning - this algorithm is time consuming if triangulation has not been inserted inside the data structure of the shape s. - the resulting bounding box may be somewhat larger than the object.

    Parameters
    ----------
    S: TopoDS_Shape
    B: Bnd_Box
    useTriangulation: bool,optional
    	default value is Standard_True

    Returns
    -------
    None

    """
    return _BRepBndLib.brepbndlib_Add(*args)

def brepbndlib_AddClose(*args) -> "void":
    """
    Adds the shape s to the bounding box b. this is a quick algorithm but only works if the shape s is composed of polygonal planar faces, as is the case if s is an approached polyhedral representation of an exact shape. pay particular attention to this because this condition is not checked and, if it not respected, an error may occur in the algorithm for which the bounding box is built. note that the resulting bounding box is not enlarged by the tolerance value of the sub-shapes as is the case with the add function. so the added part of the resulting bounding box is closer to the shape s.

    Parameters
    ----------
    S: TopoDS_Shape
    B: Bnd_Box

    Returns
    -------
    None

    """
    return _BRepBndLib.brepbndlib_AddClose(*args)

def brepbndlib_AddOBB(*args) -> "void":
    """
    Computes the oriented bounding box for the shape <thes>. two independent methods of computation are implemented: first method based on set of points (so, it demands the triangulated shape or shape with planar faces and linear edges). the second method is based on use of inertia axes and is called if use of the first method is impossible. if theistriangulationused == false then the triangulation will be ignored at all. if theisshapetoleranceused == true then resulting box will be extended on the tolerance of the shape. theisoptimal flag defines whether to look for the more tight obb for the cost of performance or not.

    Parameters
    ----------
    theS: TopoDS_Shape
    theOBB: Bnd_OBB
    theIsTriangulationUsed: bool,optional
    	default value is Standard_True
    theIsOptimal: bool,optional
    	default value is Standard_False
    theIsShapeToleranceUsed: bool,optional
    	default value is Standard_True

    Returns
    -------
    None

    """
    return _BRepBndLib.brepbndlib_AddOBB(*args)

def brepbndlib_AddOptimal(*args) -> "void":
    """
    Adds the shape s to the bounding box b. this algorith builds precise bounding box, which differs from exact geometry boundaries of shape only on shape entities tolerances algorithm is the same as for method add(..), but uses more precise methods for building boxes for geometry objects. if useshapetolerance = true, bounding box is enlardged by shape tolerances and these tolerances are used for numerical methods of bounding box size calculations, otherwise bounding box is built according to sizes of uderlined geometrical entities, numerical calculation use tolerance precision::confusion().

    Parameters
    ----------
    S: TopoDS_Shape
    B: Bnd_Box
    useTriangulation: bool,optional
    	default value is Standard_True
    useShapeTolerance: bool,optional
    	default value is Standard_False

    Returns
    -------
    None

    """
    return _BRepBndLib.brepbndlib_AddOptimal(*args)



# This file is compatible with both classic and new-style classes.


