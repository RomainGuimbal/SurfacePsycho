# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
MoniTool module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_monitool.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_MoniTool')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_MoniTool')
    _MoniTool = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_MoniTool', [dirname(__file__)])
        except ImportError:
            import _MoniTool
            return _MoniTool
        try:
            _mod = imp.load_module('_MoniTool', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _MoniTool = swig_import_helper()
    del swig_import_helper
else:
    import _MoniTool
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _MoniTool.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _MoniTool.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _MoniTool.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _MoniTool.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _MoniTool.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _MoniTool.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _MoniTool.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _MoniTool.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _MoniTool.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _MoniTool.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _MoniTool.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _MoniTool.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _MoniTool.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _MoniTool.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _MoniTool.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _MoniTool.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _MoniTool.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _MoniTool.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _MoniTool.process_exception(error, method_name, class_name)
process_exception = _MoniTool.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TCollection
import OCC.Core.TopoDS
import OCC.Core.Message
import OCC.Core.OSD
import OCC.Core.TColStd
import OCC.Core.TopAbs
import OCC.Core.TopLoc
import OCC.Core.gp

from enum import IntEnum
from OCC.Core.Exception import *

MoniTool_ValueMisc = _MoniTool.MoniTool_ValueMisc
MoniTool_ValueInteger = _MoniTool.MoniTool_ValueInteger
MoniTool_ValueReal = _MoniTool.MoniTool_ValueReal
MoniTool_ValueIdent = _MoniTool.MoniTool_ValueIdent
MoniTool_ValueVoid = _MoniTool.MoniTool_ValueVoid
MoniTool_ValueText = _MoniTool.MoniTool_ValueText
MoniTool_ValueEnum = _MoniTool.MoniTool_ValueEnum
MoniTool_ValueLogical = _MoniTool.MoniTool_ValueLogical
MoniTool_ValueSub = _MoniTool.MoniTool_ValueSub
MoniTool_ValueHexa = _MoniTool.MoniTool_ValueHexa
MoniTool_ValueBinary = _MoniTool.MoniTool_ValueBinary


class MoniTool_ValueType(IntEnum):
	MoniTool_ValueMisc = 0
	MoniTool_ValueInteger = 1
	MoniTool_ValueReal = 2
	MoniTool_ValueIdent = 3
	MoniTool_ValueVoid = 4
	MoniTool_ValueText = 5
	MoniTool_ValueEnum = 6
	MoniTool_ValueLogical = 7
	MoniTool_ValueSub = 8
	MoniTool_ValueHexa = 9
	MoniTool_ValueBinary = 10
MoniTool_ValueMisc = MoniTool_ValueType.MoniTool_ValueMisc
MoniTool_ValueInteger = MoniTool_ValueType.MoniTool_ValueInteger
MoniTool_ValueReal = MoniTool_ValueType.MoniTool_ValueReal
MoniTool_ValueIdent = MoniTool_ValueType.MoniTool_ValueIdent
MoniTool_ValueVoid = MoniTool_ValueType.MoniTool_ValueVoid
MoniTool_ValueText = MoniTool_ValueType.MoniTool_ValueText
MoniTool_ValueEnum = MoniTool_ValueType.MoniTool_ValueEnum
MoniTool_ValueLogical = MoniTool_ValueType.MoniTool_ValueLogical
MoniTool_ValueSub = MoniTool_ValueType.MoniTool_ValueSub
MoniTool_ValueHexa = MoniTool_ValueType.MoniTool_ValueHexa
MoniTool_ValueBinary = MoniTool_ValueType.MoniTool_ValueBinary


def Handle_MoniTool_CaseData_Create() -> "opencascade::handle< MoniTool_CaseData >":
    return _MoniTool.Handle_MoniTool_CaseData_Create()
Handle_MoniTool_CaseData_Create = _MoniTool.Handle_MoniTool_CaseData_Create

def Handle_MoniTool_CaseData_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MoniTool_CaseData >":
    return _MoniTool.Handle_MoniTool_CaseData_DownCast(t)
Handle_MoniTool_CaseData_DownCast = _MoniTool.Handle_MoniTool_CaseData_DownCast

def Handle_MoniTool_CaseData_IsNull(t: 'opencascade::handle< MoniTool_CaseData > const &') -> "bool":
    return _MoniTool.Handle_MoniTool_CaseData_IsNull(t)
Handle_MoniTool_CaseData_IsNull = _MoniTool.Handle_MoniTool_CaseData_IsNull

def Handle_MoniTool_Element_Create() -> "opencascade::handle< MoniTool_Element >":
    return _MoniTool.Handle_MoniTool_Element_Create()
Handle_MoniTool_Element_Create = _MoniTool.Handle_MoniTool_Element_Create

def Handle_MoniTool_Element_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MoniTool_Element >":
    return _MoniTool.Handle_MoniTool_Element_DownCast(t)
Handle_MoniTool_Element_DownCast = _MoniTool.Handle_MoniTool_Element_DownCast

def Handle_MoniTool_Element_IsNull(t: 'opencascade::handle< MoniTool_Element > const &') -> "bool":
    return _MoniTool.Handle_MoniTool_Element_IsNull(t)
Handle_MoniTool_Element_IsNull = _MoniTool.Handle_MoniTool_Element_IsNull

def Handle_MoniTool_IntVal_Create() -> "opencascade::handle< MoniTool_IntVal >":
    return _MoniTool.Handle_MoniTool_IntVal_Create()
Handle_MoniTool_IntVal_Create = _MoniTool.Handle_MoniTool_IntVal_Create

def Handle_MoniTool_IntVal_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MoniTool_IntVal >":
    return _MoniTool.Handle_MoniTool_IntVal_DownCast(t)
Handle_MoniTool_IntVal_DownCast = _MoniTool.Handle_MoniTool_IntVal_DownCast

def Handle_MoniTool_IntVal_IsNull(t: 'opencascade::handle< MoniTool_IntVal > const &') -> "bool":
    return _MoniTool.Handle_MoniTool_IntVal_IsNull(t)
Handle_MoniTool_IntVal_IsNull = _MoniTool.Handle_MoniTool_IntVal_IsNull

def Handle_MoniTool_RealVal_Create() -> "opencascade::handle< MoniTool_RealVal >":
    return _MoniTool.Handle_MoniTool_RealVal_Create()
Handle_MoniTool_RealVal_Create = _MoniTool.Handle_MoniTool_RealVal_Create

def Handle_MoniTool_RealVal_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MoniTool_RealVal >":
    return _MoniTool.Handle_MoniTool_RealVal_DownCast(t)
Handle_MoniTool_RealVal_DownCast = _MoniTool.Handle_MoniTool_RealVal_DownCast

def Handle_MoniTool_RealVal_IsNull(t: 'opencascade::handle< MoniTool_RealVal > const &') -> "bool":
    return _MoniTool.Handle_MoniTool_RealVal_IsNull(t)
Handle_MoniTool_RealVal_IsNull = _MoniTool.Handle_MoniTool_RealVal_IsNull

def Handle_MoniTool_SignText_Create() -> "opencascade::handle< MoniTool_SignText >":
    return _MoniTool.Handle_MoniTool_SignText_Create()
Handle_MoniTool_SignText_Create = _MoniTool.Handle_MoniTool_SignText_Create

def Handle_MoniTool_SignText_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MoniTool_SignText >":
    return _MoniTool.Handle_MoniTool_SignText_DownCast(t)
Handle_MoniTool_SignText_DownCast = _MoniTool.Handle_MoniTool_SignText_DownCast

def Handle_MoniTool_SignText_IsNull(t: 'opencascade::handle< MoniTool_SignText > const &') -> "bool":
    return _MoniTool.Handle_MoniTool_SignText_IsNull(t)
Handle_MoniTool_SignText_IsNull = _MoniTool.Handle_MoniTool_SignText_IsNull

def Handle_MoniTool_Timer_Create() -> "opencascade::handle< MoniTool_Timer >":
    return _MoniTool.Handle_MoniTool_Timer_Create()
Handle_MoniTool_Timer_Create = _MoniTool.Handle_MoniTool_Timer_Create

def Handle_MoniTool_Timer_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MoniTool_Timer >":
    return _MoniTool.Handle_MoniTool_Timer_DownCast(t)
Handle_MoniTool_Timer_DownCast = _MoniTool.Handle_MoniTool_Timer_DownCast

def Handle_MoniTool_Timer_IsNull(t: 'opencascade::handle< MoniTool_Timer > const &') -> "bool":
    return _MoniTool.Handle_MoniTool_Timer_IsNull(t)
Handle_MoniTool_Timer_IsNull = _MoniTool.Handle_MoniTool_Timer_IsNull

def Handle_MoniTool_TypedValue_Create() -> "opencascade::handle< MoniTool_TypedValue >":
    return _MoniTool.Handle_MoniTool_TypedValue_Create()
Handle_MoniTool_TypedValue_Create = _MoniTool.Handle_MoniTool_TypedValue_Create

def Handle_MoniTool_TypedValue_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MoniTool_TypedValue >":
    return _MoniTool.Handle_MoniTool_TypedValue_DownCast(t)
Handle_MoniTool_TypedValue_DownCast = _MoniTool.Handle_MoniTool_TypedValue_DownCast

def Handle_MoniTool_TypedValue_IsNull(t: 'opencascade::handle< MoniTool_TypedValue > const &') -> "bool":
    return _MoniTool.Handle_MoniTool_TypedValue_IsNull(t)
Handle_MoniTool_TypedValue_IsNull = _MoniTool.Handle_MoniTool_TypedValue_IsNull

def Handle_MoniTool_SignShape_Create() -> "opencascade::handle< MoniTool_SignShape >":
    return _MoniTool.Handle_MoniTool_SignShape_Create()
Handle_MoniTool_SignShape_Create = _MoniTool.Handle_MoniTool_SignShape_Create

def Handle_MoniTool_SignShape_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MoniTool_SignShape >":
    return _MoniTool.Handle_MoniTool_SignShape_DownCast(t)
Handle_MoniTool_SignShape_DownCast = _MoniTool.Handle_MoniTool_SignShape_DownCast

def Handle_MoniTool_SignShape_IsNull(t: 'opencascade::handle< MoniTool_SignShape > const &') -> "bool":
    return _MoniTool.Handle_MoniTool_SignShape_IsNull(t)
Handle_MoniTool_SignShape_IsNull = _MoniTool.Handle_MoniTool_SignShape_IsNull

def Handle_MoniTool_TransientElem_Create() -> "opencascade::handle< MoniTool_TransientElem >":
    return _MoniTool.Handle_MoniTool_TransientElem_Create()
Handle_MoniTool_TransientElem_Create = _MoniTool.Handle_MoniTool_TransientElem_Create

def Handle_MoniTool_TransientElem_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MoniTool_TransientElem >":
    return _MoniTool.Handle_MoniTool_TransientElem_DownCast(t)
Handle_MoniTool_TransientElem_DownCast = _MoniTool.Handle_MoniTool_TransientElem_DownCast

def Handle_MoniTool_TransientElem_IsNull(t: 'opencascade::handle< MoniTool_TransientElem > const &') -> "bool":
    return _MoniTool.Handle_MoniTool_TransientElem_IsNull(t)
Handle_MoniTool_TransientElem_IsNull = _MoniTool.Handle_MoniTool_TransientElem_IsNull

def Handle_MoniTool_HSequenceOfElement_Create() -> "opencascade::handle< MoniTool_HSequenceOfElement >":
    return _MoniTool.Handle_MoniTool_HSequenceOfElement_Create()
Handle_MoniTool_HSequenceOfElement_Create = _MoniTool.Handle_MoniTool_HSequenceOfElement_Create

def Handle_MoniTool_HSequenceOfElement_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MoniTool_HSequenceOfElement >":
    return _MoniTool.Handle_MoniTool_HSequenceOfElement_DownCast(t)
Handle_MoniTool_HSequenceOfElement_DownCast = _MoniTool.Handle_MoniTool_HSequenceOfElement_DownCast

def Handle_MoniTool_HSequenceOfElement_IsNull(t: 'opencascade::handle< MoniTool_HSequenceOfElement > const &') -> "bool":
    return _MoniTool.Handle_MoniTool_HSequenceOfElement_IsNull(t)
Handle_MoniTool_HSequenceOfElement_IsNull = _MoniTool.Handle_MoniTool_HSequenceOfElement_IsNull
class MoniTool_DataMapOfShapeTransient(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoniTool_DataMapOfShapeTransient, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MoniTool_DataMapOfShapeTransient, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_DataMap< TopoDS_Shape,opencascade::handle< Standard_Transient >,TopTools_ShapeMapHasher >::iterator":
        return _MoniTool.MoniTool_DataMapOfShapeTransient_begin(self)

    def end(self) -> "NCollection_DataMap< TopoDS_Shape,opencascade::handle< Standard_Transient >,TopTools_ShapeMapHasher >::iterator":
        return _MoniTool.MoniTool_DataMapOfShapeTransient_end(self)

    def cbegin(self) -> "NCollection_DataMap< TopoDS_Shape,opencascade::handle< Standard_Transient >,TopTools_ShapeMapHasher >::const_iterator":
        return _MoniTool.MoniTool_DataMapOfShapeTransient_cbegin(self)

    def cend(self) -> "NCollection_DataMap< TopoDS_Shape,opencascade::handle< Standard_Transient >,TopTools_ShapeMapHasher >::const_iterator":
        return _MoniTool.MoniTool_DataMapOfShapeTransient_cend(self)

    def __init__(self, *args):
        this = _MoniTool.new_MoniTool_DataMapOfShapeTransient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, theOther: 'MoniTool_DataMapOfShapeTransient') -> "void":
        return _MoniTool.MoniTool_DataMapOfShapeTransient_Exchange(self, theOther)

    def Assign(self, theOther: 'MoniTool_DataMapOfShapeTransient') -> "NCollection_DataMap< TopoDS_Shape,opencascade::handle< Standard_Transient >,TopTools_ShapeMapHasher > &":
        return _MoniTool.MoniTool_DataMapOfShapeTransient_Assign(self, theOther)

    def Set(self, theOther: 'MoniTool_DataMapOfShapeTransient') -> "NCollection_DataMap< TopoDS_Shape,opencascade::handle< Standard_Transient >,TopTools_ShapeMapHasher > &":
        return _MoniTool.MoniTool_DataMapOfShapeTransient_Set(self, theOther)

    def ReSize(self, N: 'Standard_Integer const') -> "void":
        return _MoniTool.MoniTool_DataMapOfShapeTransient_ReSize(self, N)

    def Bind(self, theKey: 'TopoDS_Shape', theItem: 'opencascade::handle< Standard_Transient > const &') -> "Standard_Boolean":
        return _MoniTool.MoniTool_DataMapOfShapeTransient_Bind(self, theKey, theItem)

    def Bound(self, theKey: 'TopoDS_Shape', theItem: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Standard_Transient > *":
        return _MoniTool.MoniTool_DataMapOfShapeTransient_Bound(self, theKey, theItem)

    def IsBound(self, theKey: 'TopoDS_Shape') -> "Standard_Boolean":
        return _MoniTool.MoniTool_DataMapOfShapeTransient_IsBound(self, theKey)

    def UnBind(self, theKey: 'TopoDS_Shape') -> "Standard_Boolean":
        return _MoniTool.MoniTool_DataMapOfShapeTransient_UnBind(self, theKey)

    def Seek(self, theKey: 'TopoDS_Shape') -> "opencascade::handle< Standard_Transient > const *":
        return _MoniTool.MoniTool_DataMapOfShapeTransient_Seek(self, theKey)

    def Find(self, *args) -> "Standard_Boolean":
        return _MoniTool.MoniTool_DataMapOfShapeTransient_Find(self, *args)

    def ChangeSeek(self, theKey: 'TopoDS_Shape') -> "opencascade::handle< Standard_Transient > *":
        return _MoniTool.MoniTool_DataMapOfShapeTransient_ChangeSeek(self, theKey)

    def ChangeFind(self, theKey: 'TopoDS_Shape') -> "opencascade::handle< Standard_Transient > &":
        return _MoniTool.MoniTool_DataMapOfShapeTransient_ChangeFind(self, theKey)

    def __call__(self, *args) -> "opencascade::handle< Standard_Transient > &":
        return _MoniTool.MoniTool_DataMapOfShapeTransient___call__(self, *args)

    def Clear(self, *args) -> "void":
        return _MoniTool.MoniTool_DataMapOfShapeTransient_Clear(self, *args)
    __swig_destroy__ = _MoniTool.delete_MoniTool_DataMapOfShapeTransient
    __del__ = lambda self: None

    def Size(self) -> "Standard_Integer":
        return _MoniTool.MoniTool_DataMapOfShapeTransient_Size(self)
MoniTool_DataMapOfShapeTransient_swigregister = _MoniTool.MoniTool_DataMapOfShapeTransient_swigregister
MoniTool_DataMapOfShapeTransient_swigregister(MoniTool_DataMapOfShapeTransient)

class MoniTool_DataMapOfTimer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoniTool_DataMapOfTimer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MoniTool_DataMapOfTimer, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_DataMap< char const *,opencascade::handle< MoniTool_Timer >,MoniTool_MTHasher >::iterator":
        return _MoniTool.MoniTool_DataMapOfTimer_begin(self)

    def end(self) -> "NCollection_DataMap< char const *,opencascade::handle< MoniTool_Timer >,MoniTool_MTHasher >::iterator":
        return _MoniTool.MoniTool_DataMapOfTimer_end(self)

    def cbegin(self) -> "NCollection_DataMap< char const *,opencascade::handle< MoniTool_Timer >,MoniTool_MTHasher >::const_iterator":
        return _MoniTool.MoniTool_DataMapOfTimer_cbegin(self)

    def cend(self) -> "NCollection_DataMap< char const *,opencascade::handle< MoniTool_Timer >,MoniTool_MTHasher >::const_iterator":
        return _MoniTool.MoniTool_DataMapOfTimer_cend(self)

    def __init__(self, *args):
        this = _MoniTool.new_MoniTool_DataMapOfTimer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, theOther: 'MoniTool_DataMapOfTimer') -> "void":
        return _MoniTool.MoniTool_DataMapOfTimer_Exchange(self, theOther)

    def Assign(self, theOther: 'MoniTool_DataMapOfTimer') -> "NCollection_DataMap< char const *,opencascade::handle< MoniTool_Timer >,MoniTool_MTHasher > &":
        return _MoniTool.MoniTool_DataMapOfTimer_Assign(self, theOther)

    def Set(self, theOther: 'MoniTool_DataMapOfTimer') -> "NCollection_DataMap< char const *,opencascade::handle< MoniTool_Timer >,MoniTool_MTHasher > &":
        return _MoniTool.MoniTool_DataMapOfTimer_Set(self, theOther)

    def ReSize(self, N: 'Standard_Integer const') -> "void":
        return _MoniTool.MoniTool_DataMapOfTimer_ReSize(self, N)

    def Bind(self, theKey: 'char const *const &', theItem: 'opencascade::handle< MoniTool_Timer > const &') -> "Standard_Boolean":
        return _MoniTool.MoniTool_DataMapOfTimer_Bind(self, theKey, theItem)

    def Bound(self, theKey: 'char const *const &', theItem: 'opencascade::handle< MoniTool_Timer > const &') -> "opencascade::handle< MoniTool_Timer > *":
        return _MoniTool.MoniTool_DataMapOfTimer_Bound(self, theKey, theItem)

    def IsBound(self, theKey: 'char const *const &') -> "Standard_Boolean":
        return _MoniTool.MoniTool_DataMapOfTimer_IsBound(self, theKey)

    def UnBind(self, theKey: 'char const *const &') -> "Standard_Boolean":
        return _MoniTool.MoniTool_DataMapOfTimer_UnBind(self, theKey)

    def Seek(self, theKey: 'char const *const &') -> "opencascade::handle< MoniTool_Timer > const *":
        return _MoniTool.MoniTool_DataMapOfTimer_Seek(self, theKey)

    def Find(self, *args) -> "Standard_Boolean":
        return _MoniTool.MoniTool_DataMapOfTimer_Find(self, *args)

    def ChangeSeek(self, theKey: 'char const *const &') -> "opencascade::handle< MoniTool_Timer > *":
        return _MoniTool.MoniTool_DataMapOfTimer_ChangeSeek(self, theKey)

    def ChangeFind(self, theKey: 'char const *const &') -> "opencascade::handle< MoniTool_Timer > &":
        return _MoniTool.MoniTool_DataMapOfTimer_ChangeFind(self, theKey)

    def __call__(self, *args) -> "opencascade::handle< MoniTool_Timer > &":
        return _MoniTool.MoniTool_DataMapOfTimer___call__(self, *args)

    def Clear(self, *args) -> "void":
        return _MoniTool.MoniTool_DataMapOfTimer_Clear(self, *args)
    __swig_destroy__ = _MoniTool.delete_MoniTool_DataMapOfTimer
    __del__ = lambda self: None

    def Size(self) -> "Standard_Integer":
        return _MoniTool.MoniTool_DataMapOfTimer_Size(self)
MoniTool_DataMapOfTimer_swigregister = _MoniTool.MoniTool_DataMapOfTimer_swigregister
MoniTool_DataMapOfTimer_swigregister(MoniTool_DataMapOfTimer)

class MoniTool_IndexedDataMapOfShapeTransient(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoniTool_IndexedDataMapOfShapeTransient, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MoniTool_IndexedDataMapOfShapeTransient, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_IndexedDataMap< TopoDS_Shape,opencascade::handle< Standard_Transient >,TopTools_ShapeMapHasher >::iterator":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_begin(self)

    def end(self) -> "NCollection_IndexedDataMap< TopoDS_Shape,opencascade::handle< Standard_Transient >,TopTools_ShapeMapHasher >::iterator":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_end(self)

    def cbegin(self) -> "NCollection_IndexedDataMap< TopoDS_Shape,opencascade::handle< Standard_Transient >,TopTools_ShapeMapHasher >::const_iterator":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_cbegin(self)

    def cend(self) -> "NCollection_IndexedDataMap< TopoDS_Shape,opencascade::handle< Standard_Transient >,TopTools_ShapeMapHasher >::const_iterator":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_cend(self)

    def __init__(self, *args):
        this = _MoniTool.new_MoniTool_IndexedDataMapOfShapeTransient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, theOther: 'MoniTool_IndexedDataMapOfShapeTransient') -> "void":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_Exchange(self, theOther)

    def Assign(self, theOther: 'MoniTool_IndexedDataMapOfShapeTransient') -> "NCollection_IndexedDataMap< TopoDS_Shape,opencascade::handle< Standard_Transient >,TopTools_ShapeMapHasher > &":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_Assign(self, theOther)

    def Set(self, theOther: 'MoniTool_IndexedDataMapOfShapeTransient') -> "NCollection_IndexedDataMap< TopoDS_Shape,opencascade::handle< Standard_Transient >,TopTools_ShapeMapHasher > &":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_Set(self, theOther)

    def ReSize(self, N: 'Standard_Integer const') -> "void":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_ReSize(self, N)

    def Add(self, theKey1: 'TopoDS_Shape', theItem: 'opencascade::handle< Standard_Transient > const &') -> "Standard_Integer":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_Add(self, theKey1, theItem)

    def Contains(self, theKey1: 'TopoDS_Shape') -> "Standard_Boolean":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_Contains(self, theKey1)

    def Substitute(self, theIndex: 'Standard_Integer const', theKey1: 'TopoDS_Shape', theItem: 'opencascade::handle< Standard_Transient > const &') -> "void":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_Substitute(self, theIndex, theKey1, theItem)

    def Swap(self, theIndex1: 'Standard_Integer const', theIndex2: 'Standard_Integer const') -> "void":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_Swap(self, theIndex1, theIndex2)

    def RemoveLast(self) -> "void":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_RemoveLast(self)

    def RemoveFromIndex(self, theIndex: 'Standard_Integer const') -> "void":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_RemoveFromIndex(self, theIndex)

    def RemoveKey(self, theKey1: 'TopoDS_Shape') -> "void":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_RemoveKey(self, theKey1)

    def FindKey(self, theIndex: 'Standard_Integer const') -> "TopoDS_Shape const &":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_FindKey(self, theIndex)

    def FindFromIndex(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< Standard_Transient > const &":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_FindFromIndex(self, theIndex)

    def ChangeFromIndex(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< Standard_Transient > &":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_ChangeFromIndex(self, theIndex)

    def __call__(self, *args) -> "opencascade::handle< Standard_Transient > &":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient___call__(self, *args)

    def FindIndex(self, theKey1: 'TopoDS_Shape') -> "Standard_Integer":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_FindIndex(self, theKey1)

    def ChangeFromKey(self, theKey1: 'TopoDS_Shape') -> "opencascade::handle< Standard_Transient > &":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_ChangeFromKey(self, theKey1)

    def Seek(self, theKey1: 'TopoDS_Shape') -> "opencascade::handle< Standard_Transient > const *":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_Seek(self, theKey1)

    def ChangeSeek(self, theKey1: 'TopoDS_Shape') -> "opencascade::handle< Standard_Transient > *":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_ChangeSeek(self, theKey1)

    def FindFromKey(self, *args) -> "Standard_Boolean":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_FindFromKey(self, *args)

    def Clear(self, *args) -> "void":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_Clear(self, *args)
    __swig_destroy__ = _MoniTool.delete_MoniTool_IndexedDataMapOfShapeTransient
    __del__ = lambda self: None

    def Size(self) -> "Standard_Integer":
        return _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_Size(self)
MoniTool_IndexedDataMapOfShapeTransient_swigregister = _MoniTool.MoniTool_IndexedDataMapOfShapeTransient_swigregister
MoniTool_IndexedDataMapOfShapeTransient_swigregister(MoniTool_IndexedDataMapOfShapeTransient)

class MoniTool_SequenceOfElement(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoniTool_SequenceOfElement, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MoniTool_SequenceOfElement, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Sequence< opencascade::handle< MoniTool_Element > >::iterator":
        return _MoniTool.MoniTool_SequenceOfElement_begin(self)

    def end(self) -> "NCollection_Sequence< opencascade::handle< MoniTool_Element > >::iterator":
        return _MoniTool.MoniTool_SequenceOfElement_end(self)

    def cbegin(self) -> "NCollection_Sequence< opencascade::handle< MoniTool_Element > >::const_iterator":
        return _MoniTool.MoniTool_SequenceOfElement_cbegin(self)

    def cend(self) -> "NCollection_Sequence< opencascade::handle< MoniTool_Element > >::const_iterator":
        return _MoniTool.MoniTool_SequenceOfElement_cend(self)

    def __init__(self, *args):
        this = _MoniTool.new_MoniTool_SequenceOfElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self) -> "Standard_Integer":
        return _MoniTool.MoniTool_SequenceOfElement_Size(self)

    def Length(self) -> "Standard_Integer":
        return _MoniTool.MoniTool_SequenceOfElement_Length(self)

    def Lower(self) -> "Standard_Integer":
        return _MoniTool.MoniTool_SequenceOfElement_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _MoniTool.MoniTool_SequenceOfElement_Upper(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _MoniTool.MoniTool_SequenceOfElement_IsEmpty(self)

    def Reverse(self) -> "void":
        return _MoniTool.MoniTool_SequenceOfElement_Reverse(self)

    def Exchange(self, I: 'Standard_Integer const', J: 'Standard_Integer const') -> "void":
        return _MoniTool.MoniTool_SequenceOfElement_Exchange(self, I, J)
    if _newclass:
        delNode = staticmethod(_MoniTool.MoniTool_SequenceOfElement_delNode)
    else:
        delNode = _MoniTool.MoniTool_SequenceOfElement_delNode

    def Clear(self, theAllocator: 'opencascade::handle< NCollection_BaseAllocator > const &'=0) -> "void":
        return _MoniTool.MoniTool_SequenceOfElement_Clear(self, theAllocator)

    def Assign(self, theOther: 'MoniTool_SequenceOfElement') -> "NCollection_Sequence< opencascade::handle< MoniTool_Element > > &":
        return _MoniTool.MoniTool_SequenceOfElement_Assign(self, theOther)

    def Set(self, theOther: 'MoniTool_SequenceOfElement') -> "NCollection_Sequence< opencascade::handle< MoniTool_Element > > &":
        return _MoniTool.MoniTool_SequenceOfElement_Set(self, theOther)

    def Remove(self, *args) -> "void":
        return _MoniTool.MoniTool_SequenceOfElement_Remove(self, *args)

    def Append(self, *args) -> "void":
        return _MoniTool.MoniTool_SequenceOfElement_Append(self, *args)

    def Prepend(self, *args) -> "void":
        return _MoniTool.MoniTool_SequenceOfElement_Prepend(self, *args)

    def InsertBefore(self, *args) -> "void":
        return _MoniTool.MoniTool_SequenceOfElement_InsertBefore(self, *args)

    def InsertAfter(self, *args) -> "void":
        return _MoniTool.MoniTool_SequenceOfElement_InsertAfter(self, *args)

    def Split(self, theIndex: 'Standard_Integer const', theSeq: 'MoniTool_SequenceOfElement') -> "void":
        return _MoniTool.MoniTool_SequenceOfElement_Split(self, theIndex, theSeq)

    def First(self) -> "opencascade::handle< MoniTool_Element > const &":
        return _MoniTool.MoniTool_SequenceOfElement_First(self)

    def ChangeFirst(self) -> "opencascade::handle< MoniTool_Element > &":
        return _MoniTool.MoniTool_SequenceOfElement_ChangeFirst(self)

    def Last(self) -> "opencascade::handle< MoniTool_Element > const &":
        return _MoniTool.MoniTool_SequenceOfElement_Last(self)

    def ChangeLast(self) -> "opencascade::handle< MoniTool_Element > &":
        return _MoniTool.MoniTool_SequenceOfElement_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< MoniTool_Element > const &":
        return _MoniTool.MoniTool_SequenceOfElement_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< MoniTool_Element > &":
        return _MoniTool.MoniTool_SequenceOfElement_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "opencascade::handle< MoniTool_Element > &":
        return _MoniTool.MoniTool_SequenceOfElement___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'opencascade::handle< MoniTool_Element > const &') -> "void":
        return _MoniTool.MoniTool_SequenceOfElement_SetValue(self, theIndex, theItem)
    __swig_destroy__ = _MoniTool.delete_MoniTool_SequenceOfElement
    __del__ = lambda self: None

    def __len__(self):
        return self.Size()

MoniTool_SequenceOfElement_swigregister = _MoniTool.MoniTool_SequenceOfElement_swigregister
MoniTool_SequenceOfElement_swigregister(MoniTool_SequenceOfElement)

def MoniTool_SequenceOfElement_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _MoniTool.MoniTool_SequenceOfElement_delNode(theNode, theAl)
MoniTool_SequenceOfElement_delNode = _MoniTool.MoniTool_SequenceOfElement_delNode

class MoniTool_AttrList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoniTool_AttrList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MoniTool_AttrList, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an attrlist, empty.

        Returns
        -------
        None

        Creates an attrlist from another one, definitions are shared (calls sameattributes).

        Parameters
        ----------
        other: MoniTool_AttrList

        Returns
        -------
        None

        """
        this = _MoniTool.new_MoniTool_AttrList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AttrList(self, *args) -> "NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient > > const &":
        """
        Returns the exhaustive list of attributes.

        Returns
        -------
        NCollection_DataMap<TCollection_AsciiString, opencascade::handle<Standard_Transient>>

        """
        return _MoniTool.MoniTool_AttrList_AttrList(self, *args)


    def Attribute(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Returns an attribute from its name. null handle if not recorded (whatever transient, integer, real ...) integer is recorded as intval real is recorded as realval text is recorded as hasciistring.

        Parameters
        ----------
        name: char *

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _MoniTool.MoniTool_AttrList_Attribute(self, *args)


    def AttributeType(self, *args) -> "MoniTool_ValueType":
        """
        Returns the type of an attribute : valueint , valuereal , valuetext (string) , valueident (any) or valuevoid (not recorded).

        Parameters
        ----------
        name: char *

        Returns
        -------
        MoniTool_ValueType

        """
        return _MoniTool.MoniTool_AttrList_AttributeType(self, *args)


    def GetAttribute(self, *args) -> "Standard_Boolean":
        """
        Returns an attribute from its name, filtered by a type if no attribute has this name, or if it is not kind of this type, <val> is null and returned value is false else, it is true.

        Parameters
        ----------
        name: char *
        type: Standard_Type
        val: Standard_Transient

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_AttrList_GetAttribute(self, *args)


    def GetAttributes(self, *args) -> "void":
        """
        Gets the list of attributes from <other>, by copying it by default, considers all the attributes from <other> if <fromname> is given, considers only the attributes with name beginning by <fromname> //! for each attribute, if <copied> is true (d), its value is also copied if it is a basic type (integer,real,string), else it remains shared between <other> and <self> //! these new attributes are added to the existing ones in <self>, in case of same name, they replace the existing ones.

        Parameters
        ----------
        other: MoniTool_AttrList
        fromname: char *,optional
        	default value is 
        copied: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_AttrList_GetAttributes(self, *args)


    def GetIntegerAttribute(self, *args) -> "Standard_Boolean":
        """
        Returns an attribute from its name, as integer if no attribute has this name, or not an integer, <val> is 0 and returned value is false else, it is true.

        Parameters
        ----------
        name: char *

        Returns
        -------
        val: int

        """
        return _MoniTool.MoniTool_AttrList_GetIntegerAttribute(self, *args)


    def GetRealAttribute(self, *args) -> "Standard_Boolean":
        """
        Returns an attribute from its name, as real if no attribute has this name, or not a real <val> is 0.0 and returned value is false else, it is true.

        Parameters
        ----------
        name: char *

        Returns
        -------
        val: float

        """
        return _MoniTool.MoniTool_AttrList_GetRealAttribute(self, *args)


    def GetStringAttribute(self, *args) -> "Standard_Boolean":
        """
        Returns an attribute from its name, as string if no attribute has this name, or not a string <val> is 0.0 and returned value is false else, it is true.

        Parameters
        ----------
        name: char *
        val: char *

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_AttrList_GetStringAttribute(self, *args)


    def IntegerAttribute(self, *args) -> "Standard_Integer":
        """
        Returns an integer attribute from its name. 0 if not recorded.

        Parameters
        ----------
        name: char *

        Returns
        -------
        int

        """
        return _MoniTool.MoniTool_AttrList_IntegerAttribute(self, *args)


    def RealAttribute(self, *args) -> "Standard_Real":
        """
        Returns a real attribute from its name. 0.0 if not recorded.

        Parameters
        ----------
        name: char *

        Returns
        -------
        float

        """
        return _MoniTool.MoniTool_AttrList_RealAttribute(self, *args)


    def RemoveAttribute(self, *args) -> "Standard_Boolean":
        """
        Removes an attribute returns true when done, false if this attribute did not exist.

        Parameters
        ----------
        name: char *

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_AttrList_RemoveAttribute(self, *args)


    def SameAttributes(self, *args) -> "void":
        """
        Gets the list of attributes from <other>, as such, i.e. not copied : attributes are shared, any attribute edited, added, or removed in <other> is also in <self> and vice versa the former list of attributes of <self> is dropped.

        Parameters
        ----------
        other: MoniTool_AttrList

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_AttrList_SameAttributes(self, *args)


    def SetAttribute(self, *args) -> "void":
        """
        Adds an attribute with a given name (replaces the former one with the same name if already exists).

        Parameters
        ----------
        name: char *
        val: Standard_Transient

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_AttrList_SetAttribute(self, *args)


    def SetIntegerAttribute(self, *args) -> "void":
        """
        Adds an integer value for an attribute.

        Parameters
        ----------
        name: char *
        val: int

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_AttrList_SetIntegerAttribute(self, *args)


    def SetRealAttribute(self, *args) -> "void":
        """
        Adds a real value for an attribute.

        Parameters
        ----------
        name: char *
        val: float

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_AttrList_SetRealAttribute(self, *args)


    def SetStringAttribute(self, *args) -> "void":
        """
        Adds a string value for an attribute.

        Parameters
        ----------
        name: char *
        val: char *

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_AttrList_SetStringAttribute(self, *args)


    def StringAttribute(self, *args) -> "char const *":
        """
        Returns a string attribute from its name. '' if not recorded.

        Parameters
        ----------
        name: char *

        Returns
        -------
        char *

        """
        return _MoniTool.MoniTool_AttrList_StringAttribute(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_AttrList
    __del__ = lambda self: None
MoniTool_AttrList_swigregister = _MoniTool.MoniTool_AttrList_swigregister
MoniTool_AttrList_swigregister(MoniTool_AttrList)

class MoniTool_CaseData(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoniTool_CaseData, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MoniTool_CaseData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a casedata with a caseid and a name (by default not defined).

        Parameters
        ----------
        caseid: char *,optional
        	default value is 
        name: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        this = _MoniTool.new_MoniTool_CaseData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddAny(self, *args) -> "void":
        """
        Adds a transient, with no more meaning.

        Parameters
        ----------
        val: Standard_Transient
        name: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_AddAny(self, *args)


    def AddCPU(self, *args) -> "void":
        """
        Adds the cpu time between lastcpu and now if <curcpu> is given, the cpu amount is curcpu-lastcpu else it is currently measured cpu - lastcpu lastcpu has been read by call to getcpu see getcpu to get amount, and largecpu to test large amount.

        Parameters
        ----------
        lastCPU: float
        curCPU: float,optional
        	default value is 0
        name: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_AddCPU(self, *args)


    def AddData(self, *args) -> "void":
        """
        Unitary adding a data; rather internal.

        Parameters
        ----------
        val: Standard_Transient
        kind: int
        name: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_AddData(self, *args)


    def AddEntity(self, *args) -> "void":
        """
        Adds a transient, as an entity from an interfacemodel for instance : it will then be printed with the help of a dbpe.

        Parameters
        ----------
        ent: Standard_Transient
        name: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_AddEntity(self, *args)


    def AddGeom(self, *args) -> "void":
        """
        Adds a geometric as a transient (curve, surface ...).

        Parameters
        ----------
        geom: Standard_Transient
        name: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_AddGeom(self, *args)


    def AddInteger(self, *args) -> "void":
        """
        Adds an integer.

        Parameters
        ----------
        val: int
        name: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_AddInteger(self, *args)


    def AddRaised(self, *args) -> "void":
        """
        Adds the currently caught exception.

        Parameters
        ----------
        theException: Standard_Failure
        name: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_AddRaised(self, *args)


    def AddReal(self, *args) -> "void":
        """
        Adds a real.

        Parameters
        ----------
        val: float
        name: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_AddReal(self, *args)


    def AddReals(self, *args) -> "void":
        """
        Adds two reals (for instance, two parameters).

        Parameters
        ----------
        v1: float
        v2: float
        name: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_AddReals(self, *args)


    def AddShape(self, *args) -> "void":
        """
        Adds a shape (recorded as a hshape).

        Parameters
        ----------
        sh: TopoDS_Shape
        name: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_AddShape(self, *args)


    def AddText(self, *args) -> "void":
        """
        Adds a text (as hasciistring).

        Parameters
        ----------
        text: char *
        name: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_AddText(self, *args)


    def AddXY(self, *args) -> "void":
        """
        Adds a xy.

        Parameters
        ----------
        aXY: gp_XY
        name: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_AddXY(self, *args)


    def AddXYZ(self, *args) -> "void":
        """
        Adds a xyz.

        Parameters
        ----------
        aXYZ: gp_XYZ
        name: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_AddXYZ(self, *args)


    def CaseId(self, *args) -> "char const *":
        """
        Returns the caseid.

        Returns
        -------
        char *

        """
        return _MoniTool.MoniTool_CaseData_CaseId(self, *args)


    def Data(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Returns a data item (n0 <nd> in the set <num>).

        Parameters
        ----------
        nd: int

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _MoniTool.MoniTool_CaseData_Data(self, *args)


    def DefCheck(*args) -> "Standard_Integer":
        """
        Returns check status for a code : 0 non/info (default), 1 warning, 2 fail //! remark : defcheck is used to set the check status of a casedata when it is attached to a case code, it can be changed later (by setfail, setwarning, resetcheck).

        Parameters
        ----------
        acode: char *

        Returns
        -------
        int

        """
        return _MoniTool.MoniTool_CaseData_DefCheck(*args)

    DefCheck = staticmethod(DefCheck)

    def DefMsg(*args) -> "char const *":
        """
        Returns the message definition for a case code empty if no message attached.

        Parameters
        ----------
        casecode: char *

        Returns
        -------
        char *

        """
        return _MoniTool.MoniTool_CaseData_DefMsg(*args)

    DefMsg = staticmethod(DefMsg)

    def GetCPU(self, *args) -> "Standard_Real":
        """
        Returns the current amount of cpu this allows to laterly test and record cpu amount its value has to be given to largecpu and addcpu.

        Returns
        -------
        float

        """
        return _MoniTool.MoniTool_CaseData_GetCPU(self, *args)


    def GetData(self, *args) -> "Standard_Boolean":
        """
        Returns a data item, under control of a type if the data item is kind of this type, it is returned in <val> and the returned value is true else, <val> is unchanged and the returned value is false.

        Parameters
        ----------
        nd: int
        type: Standard_Type
        val: Standard_Transient

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_CaseData_GetData(self, *args)


    def Integer(self, *args) -> "Standard_Boolean":
        """
        Returns an integer.

        Parameters
        ----------
        nd: int

        Returns
        -------
        val: int

        """
        return _MoniTool.MoniTool_CaseData_Integer(self, *args)


    def IsCheck(self, *args) -> "Standard_Boolean":
        """
        Tells if <self> is check (warning or fail), else it is info.

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_CaseData_IsCheck(self, *args)


    def IsFail(self, *args) -> "Standard_Boolean":
        """
        Tells if <self> is fail.

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_CaseData_IsFail(self, *args)


    def IsWarning(self, *args) -> "Standard_Boolean":
        """
        Tells if <self> is warning.

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_CaseData_IsWarning(self, *args)


    def Kind(self, *args) -> "Standard_Integer":
        """
        Returns the kind of a data : kind type meaning 0 any any (not one of the followings) 1 ex raised exception 2 en entity 3 g geom 4 sh shape 5 xyz xyz 6 xy or uv xy 7 rr 2 reals 8 r 1 real 9 cpu cpu (1 real) 10 t text 11 i integer //! for namenum, these codes for type must be given exact i.e. sh for a shape, not s nor shape nor solid etc.

        Parameters
        ----------
        nd: int

        Returns
        -------
        int

        """
        return _MoniTool.MoniTool_CaseData_Kind(self, *args)


    def LargeCPU(self, *args) -> "Standard_Boolean":
        """
        Tells if a cpu time amount is large <maxcpu> gives the amount over which an amount is large <lastcpu> gives the start cpu amount if <curcpu> is given, the tested cpu amount is curcpu-lastcpu else it is currently measured cpu - lastcpu.

        Parameters
        ----------
        maxCPU: float
        lastCPU: float
        curCPU: float,optional
        	default value is 0

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_CaseData_LargeCPU(self, *args)


    def Msg(self, *args) -> "Message_Msg":
        """
        Returns a msg from a casedata : it is build from defmsg, which gives the message code plus the designation of items of the casedata to be added to the msg empty if no message attached //! remains to be implemented.

        Returns
        -------
        Message_Msg

        """
        return _MoniTool.MoniTool_CaseData_Msg(self, *args)


    def Name(self, *args) -> "TCollection_AsciiString const &":
        """
        Returns the name.

        Returns
        -------
        char *

        Returns the name of a data. if it has no name, the string is empty (length = 0).

        Parameters
        ----------
        nd: int

        Returns
        -------
        TCollection_AsciiString

        """
        return _MoniTool.MoniTool_CaseData_Name(self, *args)


    def NameNum(self, *args) -> "Standard_Integer":
        """
        Returns the first suitable data rank for a given name exact maching (exact case, no completion) is required firstly checks the recorded names if not found, considers the name as follows : name = 'type' : search for the first item with this type name = 'type:nn' : search for the nn.th item with this type see allowed values in method kind.

        Parameters
        ----------
        name: char *

        Returns
        -------
        int

        """
        return _MoniTool.MoniTool_CaseData_NameNum(self, *args)


    def NbData(self, *args) -> "Standard_Integer":
        """
        Returns the count of data recorded to a set.

        Returns
        -------
        int

        """
        return _MoniTool.MoniTool_CaseData_NbData(self, *args)


    def Real(self, *args) -> "Standard_Boolean":
        """
        Returns a real or cpu amount (stored in geom2d_cartesianpoint) (allows an integer converted to a real).

        Parameters
        ----------
        nd: int

        Returns
        -------
        val: float

        """
        return _MoniTool.MoniTool_CaseData_Real(self, *args)


    def Reals(self, *args) -> "Standard_Boolean":
        """
        Returns a couple of reals (stored in geom2d_cartesianpoint).

        Parameters
        ----------
        nd: int

        Returns
        -------
        v1: float
        v2: float

        """
        return _MoniTool.MoniTool_CaseData_Reals(self, *args)


    def RemoveData(self, *args) -> "void":
        """
        Removes a data from its rank. does nothing if out of range.

        Parameters
        ----------
        num: int

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_RemoveData(self, *args)


    def ResetCheck(self, *args) -> "void":
        """
        Resets check status, i.e. sets <self> as info.

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_ResetCheck(self, *args)


    def SetCaseId(self, *args) -> "void":
        """
        Sets a caseid.

        Parameters
        ----------
        caseid: char *

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_SetCaseId(self, *args)


    def SetChange(self, *args) -> "void":
        """
        Sets the next add... not to add but to change the data item designated by its name. if next add... is not called with a name, setchange is ignored reset by next add... , whatever <num> is correct or not.

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_SetChange(self, *args)


    def SetDefFail(*args) -> "void":
        """
        Sets a code to give a fail.

        Parameters
        ----------
        acode: char *

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_SetDefFail(*args)

    SetDefFail = staticmethod(SetDefFail)

    def SetDefMsg(*args) -> "void":
        """
        Attaches a message definition to a case code this definition includes the message code plus designation of items of the casedata to be added to the message (this part not yet implemented).

        Parameters
        ----------
        casecode: char *
        mesdef: char *

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_SetDefMsg(*args)

    SetDefMsg = staticmethod(SetDefMsg)

    def SetDefWarning(*args) -> "void":
        """
        Sets a code to give a warning.

        Parameters
        ----------
        acode: char *

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_SetDefWarning(*args)

    SetDefWarning = staticmethod(SetDefWarning)

    def SetFail(self, *args) -> "void":
        """
        Sets <self> as fail.

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_SetFail(self, *args)


    def SetName(self, *args) -> "void":
        """
        Sets a name.

        Parameters
        ----------
        name: char *

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_SetName(self, *args)


    def SetReplace(self, *args) -> "void":
        """
        Sets the next add... not to add but to replace the data item <num>, if <num> is between 1 and nbdata. reset by next add... , whatever <num> is correct or not.

        Parameters
        ----------
        num: int

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_SetReplace(self, *args)


    def SetWarning(self, *args) -> "void":
        """
        Sets <self> as warning.

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_CaseData_SetWarning(self, *args)


    def Shape(self, *args) -> "TopoDS_Shape":
        """
        Returns a data as a shape, null if not a shape.

        Parameters
        ----------
        nd: int

        Returns
        -------
        TopoDS_Shape

        """
        return _MoniTool.MoniTool_CaseData_Shape(self, *args)


    def Text(self, *args) -> "Standard_Boolean":
        """
        Returns a text (stored in tcollection_hasciistring).

        Parameters
        ----------
        nd: int
        text: char *

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_CaseData_Text(self, *args)


    def XY(self, *args) -> "Standard_Boolean":
        """
        Returns a data as a xy (i.e. geom2d_cartesianpoint) returns false if not the good type.

        Parameters
        ----------
        nd: int
        val: gp_XY

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_CaseData_XY(self, *args)


    def XYZ(self, *args) -> "Standard_Boolean":
        """
        Returns a data as a xyz (i.e. geom_cartesianpoint) returns false if not the good type.

        Parameters
        ----------
        nd: int
        val: gp_XYZ

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_CaseData_XYZ(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MoniTool_CaseData_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_CaseData
    __del__ = lambda self: None
MoniTool_CaseData_swigregister = _MoniTool.MoniTool_CaseData_swigregister
MoniTool_CaseData_swigregister(MoniTool_CaseData)

def MoniTool_CaseData_DefCheck(*args) -> "Standard_Integer":
    """
    Returns check status for a code : 0 non/info (default), 1 warning, 2 fail //! remark : defcheck is used to set the check status of a casedata when it is attached to a case code, it can be changed later (by setfail, setwarning, resetcheck).

    Parameters
    ----------
    acode: char *

    Returns
    -------
    int

    """
    return _MoniTool.MoniTool_CaseData_DefCheck(*args)

def MoniTool_CaseData_DefMsg(*args) -> "char const *":
    """
    Returns the message definition for a case code empty if no message attached.

    Parameters
    ----------
    casecode: char *

    Returns
    -------
    char *

    """
    return _MoniTool.MoniTool_CaseData_DefMsg(*args)

def MoniTool_CaseData_SetDefFail(*args) -> "void":
    """
    Sets a code to give a fail.

    Parameters
    ----------
    acode: char *

    Returns
    -------
    None

    """
    return _MoniTool.MoniTool_CaseData_SetDefFail(*args)

def MoniTool_CaseData_SetDefMsg(*args) -> "void":
    """
    Attaches a message definition to a case code this definition includes the message code plus designation of items of the casedata to be added to the message (this part not yet implemented).

    Parameters
    ----------
    casecode: char *
    mesdef: char *

    Returns
    -------
    None

    """
    return _MoniTool.MoniTool_CaseData_SetDefMsg(*args)

def MoniTool_CaseData_SetDefWarning(*args) -> "void":
    """
    Sets a code to give a warning.

    Parameters
    ----------
    acode: char *

    Returns
    -------
    None

    """
    return _MoniTool.MoniTool_CaseData_SetDefWarning(*args)

class MoniTool_DataInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoniTool_DataInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MoniTool_DataInfo, name)
    __repr__ = _swig_repr

    def Type(*args) -> "opencascade::handle< Standard_Type >":
        """
        Returns the type attached to an object here, the dynamic type of a transient. null type if unknown.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        opencascade::handle<Standard_Type>

        """
        return _MoniTool.MoniTool_DataInfo_Type(*args)

    Type = staticmethod(Type)

    def TypeName(*args) -> "char const *":
        """
        Returns type name (string) allows to name type of non-handled objects.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        char *

        """
        return _MoniTool.MoniTool_DataInfo_TypeName(*args)

    TypeName = staticmethod(TypeName)

    __repr__ = _dumps_object


    def __init__(self):
        this = _MoniTool.new_MoniTool_DataInfo()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MoniTool.delete_MoniTool_DataInfo
    __del__ = lambda self: None
MoniTool_DataInfo_swigregister = _MoniTool.MoniTool_DataInfo_swigregister
MoniTool_DataInfo_swigregister(MoniTool_DataInfo)

def MoniTool_DataInfo_Type(*args) -> "opencascade::handle< Standard_Type >":
    """
    Returns the type attached to an object here, the dynamic type of a transient. null type if unknown.

    Parameters
    ----------
    ent: Standard_Transient

    Returns
    -------
    opencascade::handle<Standard_Type>

    """
    return _MoniTool.MoniTool_DataInfo_Type(*args)

def MoniTool_DataInfo_TypeName(*args) -> "char const *":
    """
    Returns type name (string) allows to name type of non-handled objects.

    Parameters
    ----------
    ent: Standard_Transient

    Returns
    -------
    char *

    """
    return _MoniTool.MoniTool_DataInfo_TypeName(*args)

class MoniTool_ElemHasher(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoniTool_ElemHasher, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MoniTool_ElemHasher, name)
    __repr__ = _swig_repr

    def HashCode(*args) -> "Standard_Integer":
        """
        Returns hash code for the given element, in the range [1, theupperbound]. asks theelement its hashcode, then transforms it to be in the required range. @param theelement the element which hash code is to be computed @param theupperbound the upper bound of the range a computing hash code must be within returns a computed hash code, in the range [1, theupperbound].

        Parameters
        ----------
        theElement: Handle ( MoniTool_Element )
        theUpperBound: int

        Returns
        -------
        int

        """
        return _MoniTool.MoniTool_ElemHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args) -> "Standard_Boolean":
        """
        Returns true if two keys are the same. the test does not work on the elements themselves but by calling their methods equates.

        Parameters
        ----------
        K1: MoniTool_Element
        K2: MoniTool_Element

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_ElemHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    __repr__ = _dumps_object


    def __init__(self):
        this = _MoniTool.new_MoniTool_ElemHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MoniTool.delete_MoniTool_ElemHasher
    __del__ = lambda self: None
MoniTool_ElemHasher_swigregister = _MoniTool.MoniTool_ElemHasher_swigregister
MoniTool_ElemHasher_swigregister(MoniTool_ElemHasher)

def MoniTool_ElemHasher_HashCode(*args) -> "Standard_Integer":
    """
    Returns hash code for the given element, in the range [1, theupperbound]. asks theelement its hashcode, then transforms it to be in the required range. @param theelement the element which hash code is to be computed @param theupperbound the upper bound of the range a computing hash code must be within returns a computed hash code, in the range [1, theupperbound].

    Parameters
    ----------
    theElement: Handle ( MoniTool_Element )
    theUpperBound: int

    Returns
    -------
    int

    """
    return _MoniTool.MoniTool_ElemHasher_HashCode(*args)

def MoniTool_ElemHasher_IsEqual(*args) -> "Standard_Boolean":
    """
    Returns true if two keys are the same. the test does not work on the elements themselves but by calling their methods equates.

    Parameters
    ----------
    K1: MoniTool_Element
    K2: MoniTool_Element

    Returns
    -------
    bool

    """
    return _MoniTool.MoniTool_ElemHasher_IsEqual(*args)

class MoniTool_Element(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoniTool_Element, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MoniTool_Element, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ChangeAttr(self, *args) -> "MoniTool_AttrList &":
        """
        Returns (modifiable) the attribute list.

        Returns
        -------
        MoniTool_AttrList

        """
        return _MoniTool.MoniTool_Element_ChangeAttr(self, *args)


    def Equates(self, *args) -> "Standard_Boolean":
        """
        Specific testof equallity : to be defined by each sub-class, must be false if elements have not the same true type, else their contents must be compared.

        Parameters
        ----------
        other: MoniTool_Element

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_Element_Equates(self, *args)


    def GetHashCode(self, *args) -> "Standard_Integer":
        """
        Returns the hashcode which has been stored by sethashcode (remark that hashcode could be deferred then be defined by sub-classes, the result is the same).

        Returns
        -------
        int

        """
        return _MoniTool.MoniTool_Element_GetHashCode(self, *args)


    def ListAttr(self, *args) -> "MoniTool_AttrList const &":
        """
        Returns (readonly) the attribute list.

        Returns
        -------
        MoniTool_AttrList

        """
        return _MoniTool.MoniTool_Element_ListAttr(self, *args)


    def ValueType(self, *args) -> "opencascade::handle< Standard_Type >":
        """
        Returns the type of the value. by default, returns the dynamictype of <self>, but can be redefined.

        Returns
        -------
        opencascade::handle<Standard_Type>

        """
        return _MoniTool.MoniTool_Element_ValueType(self, *args)


    def ValueTypeName(self, *args) -> "char const *":
        """
        Returns the name of the type of the value. default is name of valuetype, unless it is for a non-handled object.

        Returns
        -------
        char *

        """
        return _MoniTool.MoniTool_Element_ValueTypeName(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MoniTool_Element_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_Element
    __del__ = lambda self: None
MoniTool_Element_swigregister = _MoniTool.MoniTool_Element_swigregister
MoniTool_Element_swigregister(MoniTool_Element)

class MoniTool_IntVal(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoniTool_IntVal, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MoniTool_IntVal, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        val: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        this = _MoniTool.new_MoniTool_IntVal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetCValue(self) -> "Standard_Integer":
        """GetCValue(MoniTool_IntVal self) -> Standard_Integer"""
        return _MoniTool.MoniTool_IntVal_GetCValue(self)


    def SetCValue(self, value: 'Standard_Integer') -> "void":
        """SetCValue(MoniTool_IntVal self, Standard_Integer value)"""
        return _MoniTool.MoniTool_IntVal_SetCValue(self, value)


    def Value(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _MoniTool.MoniTool_IntVal_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MoniTool_IntVal_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_IntVal
    __del__ = lambda self: None
MoniTool_IntVal_swigregister = _MoniTool.MoniTool_IntVal_swigregister
MoniTool_IntVal_swigregister(MoniTool_IntVal)

class MoniTool_MTHasher(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoniTool_MTHasher, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MoniTool_MTHasher, name)
    __repr__ = _swig_repr

    def HashCode(*args) -> "Standard_Integer":
        """
        Returns hash code for the given string, in the range [1, theupperbound] @param thestring the string which hash code is to be computed @param theupperbound the upper bound of the range a computing hash code must be within returns a computed hash code, in the range [1, theupperbound].

        Parameters
        ----------
        theString: char *
        theUpperBound: int

        Returns
        -------
        int

        """
        return _MoniTool.MoniTool_MTHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args) -> "Standard_Boolean":
        """
        Returns true when the two cstring are the same. two same strings must have the same hashcode, the contrary is not necessary. default str1 == str2.

        Parameters
        ----------
        Str1: char *
        Str2: char *

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_MTHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    __repr__ = _dumps_object


    def __init__(self):
        this = _MoniTool.new_MoniTool_MTHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MoniTool.delete_MoniTool_MTHasher
    __del__ = lambda self: None
MoniTool_MTHasher_swigregister = _MoniTool.MoniTool_MTHasher_swigregister
MoniTool_MTHasher_swigregister(MoniTool_MTHasher)

def MoniTool_MTHasher_HashCode(*args) -> "Standard_Integer":
    """
    Returns hash code for the given string, in the range [1, theupperbound] @param thestring the string which hash code is to be computed @param theupperbound the upper bound of the range a computing hash code must be within returns a computed hash code, in the range [1, theupperbound].

    Parameters
    ----------
    theString: char *
    theUpperBound: int

    Returns
    -------
    int

    """
    return _MoniTool.MoniTool_MTHasher_HashCode(*args)

def MoniTool_MTHasher_IsEqual(*args) -> "Standard_Boolean":
    """
    Returns true when the two cstring are the same. two same strings must have the same hashcode, the contrary is not necessary. default str1 == str2.

    Parameters
    ----------
    Str1: char *
    Str2: char *

    Returns
    -------
    bool

    """
    return _MoniTool.MoniTool_MTHasher_IsEqual(*args)

class MoniTool_RealVal(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoniTool_RealVal, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MoniTool_RealVal, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        val: float,optional
        	default value is 0.0

        Returns
        -------
        None

        """
        this = _MoniTool.new_MoniTool_RealVal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetCValue(self) -> "Standard_Real":
        """GetCValue(MoniTool_RealVal self) -> Standard_Real"""
        return _MoniTool.MoniTool_RealVal_GetCValue(self)


    def SetCValue(self, value: 'Standard_Real') -> "void":
        """SetCValue(MoniTool_RealVal self, Standard_Real value)"""
        return _MoniTool.MoniTool_RealVal_SetCValue(self, value)


    def Value(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _MoniTool.MoniTool_RealVal_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MoniTool_RealVal_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_RealVal
    __del__ = lambda self: None
MoniTool_RealVal_swigregister = _MoniTool.MoniTool_RealVal_swigregister
MoniTool_RealVal_swigregister(MoniTool_RealVal)

class MoniTool_SignText(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoniTool_SignText, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MoniTool_SignText, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Name(self, *args) -> "char const *":
        """
        Returns an identification of the signature (a word), given at initialization time.

        Returns
        -------
        char *

        """
        return _MoniTool.MoniTool_SignText_Name(self, *args)


    def Text(self, *args) -> "TCollection_AsciiString":
        """
        Gives a text as a signature for a transient object in a context if the context is senseless, it can be given as null handle empty result if nothing to give (at least the dynamictype could be sent ?).

        Parameters
        ----------
        ent: Standard_Transient
        context: Standard_Transient

        Returns
        -------
        TCollection_AsciiString

        """
        return _MoniTool.MoniTool_SignText_Text(self, *args)


    def TextAlone(self, *args) -> "TCollection_AsciiString":
        """
        Gives a text as a signature for a transient object alone, i.e. without defined context. by default, calls text with undefined context (null handle) and if empty, then returns dynamictype.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        TCollection_AsciiString

        """
        return _MoniTool.MoniTool_SignText_TextAlone(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MoniTool_SignText_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_SignText
    __del__ = lambda self: None
MoniTool_SignText_swigregister = _MoniTool.MoniTool_SignText_swigregister
MoniTool_SignText_swigregister(MoniTool_SignText)

class MoniTool_Stat(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoniTool_Stat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MoniTool_Stat, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a stat form. at start, one default phase is defined, with one default step. then, it suffises to start with a count of items (and cycles if several) then record items, to have a queryable report.

        Parameters
        ----------
        title: char *,optional
        	default value is 

        Returns
        -------
        None

        Used when starting.

        Parameters
        ----------
        other: MoniTool_Stat

        Returns
        -------
        None

        """
        this = _MoniTool.new_MoniTool_Stat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args) -> "void":
        """
        Directly addes items.

        Parameters
        ----------
        nb: int,optional
        	default value is 1

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_Stat_Add(self, *args)


    def AddEnd(self, *args) -> "void":
        """
        Ends the addsub and cumulates the sub-count to current level.

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_Stat_AddEnd(self, *args)


    def AddSub(self, *args) -> "void":
        """
        Declares a count of items to be added later. if a sub-counter is opened, its percentage multiplies this sub-count to compute the percent of current level.

        Parameters
        ----------
        nb: int,optional
        	default value is 1

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_Stat_AddSub(self, *args)


    def Close(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        id: int

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_Stat_Close(self, *args)


    def Current(*args) -> "MoniTool_Stat &":
        """
        No available documentation.

        Returns
        -------
        MoniTool_Stat

        """
        return _MoniTool.MoniTool_Stat_Current(*args)

    Current = staticmethod(Current)

    def Level(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _MoniTool.MoniTool_Stat_Level(self, *args)


    def Open(self, *args) -> "Standard_Integer":
        """
        Opens a new counter with a starting count of items.

        Parameters
        ----------
        nb: int,optional
        	default value is 100

        Returns
        -------
        int

        """
        return _MoniTool.MoniTool_Stat_Open(self, *args)


    def OpenMore(self, *args) -> "void":
        """
        Adds more items to be counted by add... on current level.

        Parameters
        ----------
        id: int
        nb: int

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_Stat_OpenMore(self, *args)


    def Percent(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Parameters
        ----------
        fromlev: int,optional
        	default value is 0

        Returns
        -------
        float

        """
        return _MoniTool.MoniTool_Stat_Percent(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_Stat
    __del__ = lambda self: None
MoniTool_Stat_swigregister = _MoniTool.MoniTool_Stat_swigregister
MoniTool_Stat_swigregister(MoniTool_Stat)

def MoniTool_Stat_Current(*args) -> "MoniTool_Stat &":
    """
    No available documentation.

    Returns
    -------
    MoniTool_Stat

    """
    return _MoniTool.MoniTool_Stat_Current(*args)

class MoniTool_Timer(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoniTool_Timer, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MoniTool_Timer, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Create timer in empty state.

        Returns
        -------
        None

        """
        this = _MoniTool.new_MoniTool_Timer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Amend(self, *args) -> "Standard_Real":
        """
        Return value of accumulated amendment on cpu time.

        Returns
        -------
        float

        """
        return _MoniTool.MoniTool_Timer_Amend(self, *args)


    def CPU(self, *args) -> "Standard_Real":
        """
        Return value of cpu time minus accumulated amendment.

        Returns
        -------
        float

        """
        return _MoniTool.MoniTool_Timer_CPU(self, *args)


    def ClearTimers(*args) -> "void":
        """
        Clears map of timers.

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_Timer_ClearTimers(*args)

    ClearTimers = staticmethod(ClearTimers)

    def ComputeAmendments(*args) -> "void":
        """
        Computes and remembers amendments for times to access, start, and stop of timer, and estimates second-order error measured by 10 nested timers.

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_Timer_ComputeAmendments(*args)

    ComputeAmendments = staticmethod(ComputeAmendments)

    def Count(self, *args) -> "Standard_Integer":
        """
        Return value of hits counter (count of start/stop pairs).

        Returns
        -------
        int

        """
        return _MoniTool.MoniTool_Timer_Count(self, *args)


    def Dictionary(*args) -> "MoniTool_DataMapOfTimer &":
        """
        Returns map of timers.

        Returns
        -------
        MoniTool_DataMapOfTimer

        """
        return _MoniTool.MoniTool_Timer_Dictionary(*args)

    Dictionary = staticmethod(Dictionary)

    def DumpToString(self) -> "std::string":
        """DumpToString(MoniTool_Timer self) -> std::string"""
        return _MoniTool.MoniTool_Timer_DumpToString(self)


    def DumpTimersToString(self) -> "std::string":
        """DumpTimersToString(MoniTool_Timer self) -> std::string"""
        return _MoniTool.MoniTool_Timer_DumpTimersToString(self)


    def GetAmendments(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &":
        """
        The computed amendmens are returned (for information only).

        Parameters
        ----------

        Returns
        -------
        Access: float
        Internal: float
        External: float
        Error10: float

        """
        return _MoniTool.MoniTool_Timer_GetAmendments(*args)

    GetAmendments = staticmethod(GetAmendments)

    def IsRunning(self, *args) -> "Standard_Integer":
        """
        Returns value of nesting counter.

        Returns
        -------
        int

        """
        return _MoniTool.MoniTool_Timer_IsRunning(self, *args)


    def Reset(self, *args) -> "void":
        """
        Start, stop and reset the timer in addition to doing that to embedded osd_timer, manage also counter of hits.

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_Timer_Reset(self, *args)


    def Start(*args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        name: char *

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_Timer_Start(*args)

    Start = staticmethod(Start)

    def Stop(*args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        Inline methods to conveniently start/stop timer by name shortcut to timer(name)->start/stop().

        Parameters
        ----------
        name: char *

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_Timer_Stop(*args)

    Stop = staticmethod(Stop)

    def Timer(*args) -> "opencascade::handle< MoniTool_Timer >":
        """
        No available documentation.

        Returns
        -------
        OSD_Timer

        Returns a timer from a dictionary by its name if timer not existed, creates a new one.

        Parameters
        ----------
        name: char *

        Returns
        -------
        opencascade::handle<MoniTool_Timer>

        """
        return _MoniTool.MoniTool_Timer_Timer(*args)

    Timer = staticmethod(Timer)


    @staticmethod
    def DownCast(t):
      return Handle_MoniTool_Timer_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_Timer
    __del__ = lambda self: None
MoniTool_Timer_swigregister = _MoniTool.MoniTool_Timer_swigregister
MoniTool_Timer_swigregister(MoniTool_Timer)

def MoniTool_Timer_ClearTimers(*args) -> "void":
    """
    Clears map of timers.

    Returns
    -------
    None

    """
    return _MoniTool.MoniTool_Timer_ClearTimers(*args)

def MoniTool_Timer_ComputeAmendments(*args) -> "void":
    """
    Computes and remembers amendments for times to access, start, and stop of timer, and estimates second-order error measured by 10 nested timers.

    Returns
    -------
    None

    """
    return _MoniTool.MoniTool_Timer_ComputeAmendments(*args)

def MoniTool_Timer_Dictionary(*args) -> "MoniTool_DataMapOfTimer &":
    """
    Returns map of timers.

    Returns
    -------
    MoniTool_DataMapOfTimer

    """
    return _MoniTool.MoniTool_Timer_Dictionary(*args)

def MoniTool_Timer_GetAmendments(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &":
    """
    The computed amendmens are returned (for information only).

    Parameters
    ----------

    Returns
    -------
    Access: float
    Internal: float
    External: float
    Error10: float

    """
    return _MoniTool.MoniTool_Timer_GetAmendments(*args)

def MoniTool_Timer_Start(*args) -> "void":
    """
    No available documentation.

    Returns
    -------
    None

    No available documentation.

    Parameters
    ----------
    name: char *

    Returns
    -------
    None

    """
    return _MoniTool.MoniTool_Timer_Start(*args)

def MoniTool_Timer_Stop(*args) -> "void":
    """
    No available documentation.

    Returns
    -------
    None

    Inline methods to conveniently start/stop timer by name shortcut to timer(name)->start/stop().

    Parameters
    ----------
    name: char *

    Returns
    -------
    None

    """
    return _MoniTool.MoniTool_Timer_Stop(*args)

def MoniTool_Timer_Timer(*args) -> "opencascade::handle< MoniTool_Timer >":
    """
    No available documentation.

    Returns
    -------
    OSD_Timer

    Returns a timer from a dictionary by its name if timer not existed, creates a new one.

    Parameters
    ----------
    name: char *

    Returns
    -------
    opencascade::handle<MoniTool_Timer>

    """
    return _MoniTool.MoniTool_Timer_Timer(*args)

class MoniTool_TimerSentry(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoniTool_TimerSentry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MoniTool_TimerSentry, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Constructor creates an instance and runs the corresponding timer.

        Parameters
        ----------
        cname: char *

        Returns
        -------
        None

        Constructor creates an instance and runs the corresponding timer.

        Parameters
        ----------
        timer: MoniTool_Timer

        Returns
        -------
        None

        """
        this = _MoniTool.new_MoniTool_TimerSentry(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Stop(self, *args) -> "void":
        """
        Manually stops the timer.

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_TimerSentry_Stop(self, *args)


    def Timer(self, *args) -> "opencascade::handle< MoniTool_Timer >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<MoniTool_Timer>

        """
        return _MoniTool.MoniTool_TimerSentry_Timer(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_TimerSentry
    __del__ = lambda self: None
MoniTool_TimerSentry_swigregister = _MoniTool.MoniTool_TimerSentry_swigregister
MoniTool_TimerSentry_swigregister(MoniTool_TimerSentry)

class MoniTool_TypedValue(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoniTool_TypedValue, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MoniTool_TypedValue, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a typedvalue, with a name //! type gives the type of the parameter, default is free text also available : integer, real, enum, entity (i.e. object) more precise specifications, titles, can be given to the typedvalue once created //! init gives an initial value. if it is not given, the typedvalue begins as 'not set', its value is empty.

        Parameters
        ----------
        name: char *
        type: MoniTool_ValueType,optional
        	default value is MoniTool_ValueText
        init: char *,optional
        	default value is 

        Returns
        -------
        None

        Creates a typedvalue from another one, by duplication.

        Parameters
        ----------
        other: MoniTool_TypedValue

        Returns
        -------
        None

        """
        this = _MoniTool.new_MoniTool_TypedValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddDef(self, *args) -> "Standard_Boolean":
        """
        Completes the definition of a typedvalue by command <initext>, once created with its type returns true if done, false if could not be interpreted <initext> may be : imin ival : minimum value for an integer imax ival : maximum value for an integer rmin rval : minimum value for a real rmax rval : maximum value for a real unit name : name of unit ematch i : enum from integer value i, match required enum i : enum from integer value i, match not required eval text : add an enumerative value (increments max by 1) eval : add a non-authorised enum value (to be skipped) tmax l : maximum length for a text.

        Parameters
        ----------
        initext: char *

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_TypedValue_AddDef(self, *args)


    def AddEnum(self, *args) -> "void":
        """
        Adds enumerative definitions. for more than 10, several calls.

        Parameters
        ----------
        v1: char *,optional
        	default value is 
        v2: char *,optional
        	default value is 
        v3: char *,optional
        	default value is 
        v4: char *,optional
        	default value is 
        v5: char *,optional
        	default value is 
        v6: char *,optional
        	default value is 
        v7: char *,optional
        	default value is 
        v8: char *,optional
        	default value is 
        v9: char *,optional
        	default value is 
        v10: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_TypedValue_AddEnum(self, *args)


    def AddEnumValue(self, *args) -> "void":
        """
        Adds an enumeration definition, by its string and numeric values. if it is the first setting for this value, it is recorded as main value. else, it is recognized as alternate string for this numeric value.

        Parameters
        ----------
        val: char *
        num: int

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_TypedValue_AddEnumValue(self, *args)


    def AddLib(*args) -> "Standard_Boolean":
        """
        Adds a typedvalue in the library. it is recorded then will be accessed by its name its definition may be imposed, else it is computed as usual by default it will be accessed by its definition (string) returns true if done, false if tv is null or brings no definition or <def> not defined //! if a typedvalue was already recorded under this name, it is replaced.

        Parameters
        ----------
        tv: MoniTool_TypedValue
        def: char *,optional
        	default value is 

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_TypedValue_AddLib(*args)

    AddLib = staticmethod(AddLib)

    def CStringValue(self, *args) -> "char const *":
        """
        Returns the value, as a cstring. empty if not set.

        Returns
        -------
        char *

        """
        return _MoniTool.MoniTool_TypedValue_CStringValue(self, *args)


    def ClearValue(self, *args) -> "void":
        """
        Clears the recorded value : it is now unset.

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_TypedValue_ClearValue(self, *args)


    def Definition(self, *args) -> "TCollection_AsciiString":
        """
        Returns the definition by priority, the enforced one, else an automatic one, computed from the specification.

        Returns
        -------
        TCollection_AsciiString

        """
        return _MoniTool.MoniTool_TypedValue_Definition(self, *args)


    def EnumCase(self, *args) -> "Standard_Integer":
        """
        Returns the case number which cooresponds to a string value works with main and additionnal values returns (startenum - 1) if not ok, -1 if not an enum.

        Parameters
        ----------
        val: char *

        Returns
        -------
        int

        """
        return _MoniTool.MoniTool_TypedValue_EnumCase(self, *args)


    def EnumDef(self, *args) -> "Standard_Boolean":
        """
        Gives the enum definitions : start value, end value, match status. returns true for an enum, false else.

        Parameters
        ----------

        Returns
        -------
        startcase: int
        endcase: int
        match: bool

        """
        return _MoniTool.MoniTool_TypedValue_EnumDef(self, *args)


    def EnumVal(self, *args) -> "char const *":
        """
        Returns the value of an enumerative definition, from its rank empty string if out of range or not an enum.

        Parameters
        ----------
        num: int

        Returns
        -------
        char *

        """
        return _MoniTool.MoniTool_TypedValue_EnumVal(self, *args)


    def FromLib(*args) -> "opencascade::handle< MoniTool_TypedValue >":
        """
        Returns a copy of the typedvalue bound with a given name null handle if none recorded.

        Parameters
        ----------
        def: char *

        Returns
        -------
        opencascade::handle<MoniTool_TypedValue>

        """
        return _MoniTool.MoniTool_TypedValue_FromLib(*args)

    FromLib = staticmethod(FromLib)

    def GetObjectValue(self, *args) -> "void":
        """
        Same as objectvalue, but avoids downcast : the receiving variable is directly loaded. it is assumed that it complies with the definition of objecttype ! otherwise, big trouble.

        Parameters
        ----------
        val: Standard_Transient

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_TypedValue_GetObjectValue(self, *args)


    def HStringValue(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Returns the value, as a handle (can then be shared) null if not defined.

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _MoniTool.MoniTool_TypedValue_HStringValue(self, *args)


    def HasInterpret(self, *args) -> "Standard_Boolean":
        """
        Tells if a typedvalue has an interpret.

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_TypedValue_HasInterpret(self, *args)


    def IntegerLimit(self, *args) -> "Standard_Boolean":
        """
        Gives an integer limit (upper if <max> true, lower if <max> false). returns true if this limit is defined, false else (in that case, gives the natural limit for integer).

        Parameters
        ----------
        max: bool

        Returns
        -------
        val: int

        """
        return _MoniTool.MoniTool_TypedValue_IntegerLimit(self, *args)


    def IntegerValue(self, *args) -> "Standard_Integer":
        """
        Returns the value as integer, i.e. : for type = integer, the integer itself; 0 if not set for type = enum, the designated rank (see enum definition) startenum - 1 if not set or not in the definition else, returns 0.

        Returns
        -------
        int

        """
        return _MoniTool.MoniTool_TypedValue_IntegerValue(self, *args)


    def Internals(self, *args) -> "void":
        """
        Access to internal data which have no other access.

        Parameters
        ----------
        interp: MoniTool_ValueInterpret
        satisf: MoniTool_ValueSatisfies
        satisname: char *
        enums: NCollection_DataMap<TCollection_AsciiString, int>

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_TypedValue_Internals(self, *args)


    def Interpret(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Interprets a value. <native> true : returns a native value <native> false : returns a coded value if the interpret function is set, calls it else, for an enum, native returns the text, coded returns the number standard returns : = hval means no specific interpretation null means senseless can also be redefined.

        Parameters
        ----------
        hval: TCollection_HAsciiString
        native: bool

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _MoniTool.MoniTool_TypedValue_Interpret(self, *args)


    def IsSetValue(self, *args) -> "Standard_Boolean":
        """
        Returns true if the value is set (not empty/not null object).

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_TypedValue_IsSetValue(self, *args)


    def Label(self, *args) -> "char const *":
        """
        Returns the label, if set; else returns an empty string.

        Returns
        -------
        char *

        """
        return _MoniTool.MoniTool_TypedValue_Label(self, *args)


    def Lib(*args) -> "opencascade::handle< MoniTool_TypedValue >":
        """
        Returns the typedvalue bound with a given name null handle if none recorded warning : it is the original, not duplicated.

        Parameters
        ----------
        def: char *

        Returns
        -------
        opencascade::handle<MoniTool_TypedValue>

        """
        return _MoniTool.MoniTool_TypedValue_Lib(*args)

    Lib = staticmethod(Lib)

    def LibList(*args) -> "opencascade::handle< TColStd_HSequenceOfAsciiString >":
        """
        Returns the list of names of items of the library of types -- library of typedvalue as valued parameters, -- -- accessed by parameter name for use by management of static parameters.

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfAsciiString>

        """
        return _MoniTool.MoniTool_TypedValue_LibList(*args)

    LibList = staticmethod(LibList)

    def MaxLength(self, *args) -> "Standard_Integer":
        """
        Returns the maximum length, 0 if not set.

        Returns
        -------
        int

        """
        return _MoniTool.MoniTool_TypedValue_MaxLength(self, *args)


    def Name(self, *args) -> "char const *":
        """
        Returns the name.

        Returns
        -------
        char *

        """
        return _MoniTool.MoniTool_TypedValue_Name(self, *args)


    def ObjectType(self, *args) -> "opencascade::handle< Standard_Type >":
        """
        Returns the type of which an object typedvalue must be kind of default is standard_transient null for a typedvalue not an object.

        Returns
        -------
        opencascade::handle<Standard_Type>

        """
        return _MoniTool.MoniTool_TypedValue_ObjectType(self, *args)


    def ObjectTypeName(self, *args) -> "char const *":
        """
        Returns the type name of the objectvalue, or an empty string if not set.

        Returns
        -------
        char *

        """
        return _MoniTool.MoniTool_TypedValue_ObjectTypeName(self, *args)


    def ObjectValue(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Returns the value as transient object, only for object/entity remark that the 'hstring value' is ignored here null if not set; remains to be casted.

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _MoniTool.MoniTool_TypedValue_ObjectValue(self, *args)


    def PrintToString(self) -> "std::string":
        """PrintToString(MoniTool_TypedValue self) -> std::string"""
        return _MoniTool.MoniTool_TypedValue_PrintToString(self)


    def PrintValueToString(self) -> "std::string":
        """PrintValueToString(MoniTool_TypedValue self) -> std::string"""
        return _MoniTool.MoniTool_TypedValue_PrintValueToString(self)


    def RealLimit(self, *args) -> "Standard_Boolean":
        """
        Gives an real limit (upper if <max> true, lower if <max> false). returns true if this limit is defined, false else (in that case, gives the natural limit for real).

        Parameters
        ----------
        max: bool

        Returns
        -------
        val: float

        """
        return _MoniTool.MoniTool_TypedValue_RealLimit(self, *args)


    def RealValue(self, *args) -> "Standard_Real":
        """
        Returns the value as real, for a real type typedvalue else, returns 0.

        Returns
        -------
        float

        """
        return _MoniTool.MoniTool_TypedValue_RealValue(self, *args)


    def Satisfies(self, *args) -> "Standard_Boolean":
        """
        Returns true if a value statifies the specification (remark : does not apply to entity : see objecttype, for this type, the string is just a comment).

        Parameters
        ----------
        hval: TCollection_HAsciiString

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_TypedValue_Satisfies(self, *args)


    def SatisfiesName(self, *args) -> "char const *":
        """
        Returns name of specific satisfy, empty string if none.

        Returns
        -------
        char *

        """
        return _MoniTool.MoniTool_TypedValue_SatisfiesName(self, *args)


    def SetCStringValue(self, *args) -> "Standard_Boolean":
        """
        Changes the value. the new one must satisfy the specification returns false (and did not set) if the new value does not satisfy the specification can be redefined to be managed (in a subclass).

        Parameters
        ----------
        val: char *

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_TypedValue_SetCStringValue(self, *args)


    def SetDefinition(self, *args) -> "void":
        """
        Enforces a definition.

        Parameters
        ----------
        deftext: char *

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_TypedValue_SetDefinition(self, *args)


    def SetHStringValue(self, *args) -> "Standard_Boolean":
        """
        Forces a new handle for the value it can be empty, else (if type is not free text), it must satisfy the specification. not only the value is changed, but also the way it is shared remark : for type=object, this value is not controlled, it can be set as a comment returns false (and did not set) if the new value does not satisfy the specification can be redefined to be managed (in a subclass).

        Parameters
        ----------
        hval: TCollection_HAsciiString

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_TypedValue_SetHStringValue(self, *args)


    def SetIntegerLimit(self, *args) -> "void":
        """
        Sets an integer limit (included) to <val>, the upper limit if <max> is true, the lower limit if <max> is false.

        Parameters
        ----------
        max: bool
        val: int

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_TypedValue_SetIntegerLimit(self, *args)


    def SetIntegerValue(self, *args) -> "Standard_Boolean":
        """
        Changes the value as an integer, only for integer or enum.

        Parameters
        ----------
        ival: int

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_TypedValue_SetIntegerValue(self, *args)


    def SetInterpret(self, *args) -> "void":
        """
        Sets a specific interpret function.

        Parameters
        ----------
        func: MoniTool_ValueInterpret

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_TypedValue_SetInterpret(self, *args)


    def SetLabel(self, *args) -> "void":
        """
        Sets a label, which can then be displayed.

        Parameters
        ----------
        label: char *

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_TypedValue_SetLabel(self, *args)


    def SetMaxLength(self, *args) -> "void":
        """
        Sets a maximum length for a text (active only for a free text).

        Parameters
        ----------
        max: int

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_TypedValue_SetMaxLength(self, *args)


    def SetObjectType(self, *args) -> "void":
        """
        Sets type of which an object typedvalue must be kind of error for a typedvalue not an object (entity).

        Parameters
        ----------
        typ: Standard_Type

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_TypedValue_SetObjectType(self, *args)


    def SetObjectValue(self, *args) -> "Standard_Boolean":
        """
        Changes the value as transient object, only for object/entity returns false if dynamictype does not satisfy objecttype can be redefined to be managed (in a subclass).

        Parameters
        ----------
        obj: Standard_Transient

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_TypedValue_SetObjectValue(self, *args)


    def SetRealLimit(self, *args) -> "void":
        """
        Sets a real limit (included) to <val>, the upper limit if <max> is true, the lower limit if <max> is false.

        Parameters
        ----------
        max: bool
        val: float

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_TypedValue_SetRealLimit(self, *args)


    def SetRealValue(self, *args) -> "Standard_Boolean":
        """
        Changes the value as a real, only for real.

        Parameters
        ----------
        rval: float

        Returns
        -------
        bool

        """
        return _MoniTool.MoniTool_TypedValue_SetRealValue(self, *args)


    def SetSatisfies(self, *args) -> "void":
        """
        Sets a specific satisfies function : it is added to the already defined criteria it must match the form : statisfies (val : hasciistring) returns boolean.

        Parameters
        ----------
        func: MoniTool_ValueSatisfies
        name: char *

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_TypedValue_SetSatisfies(self, *args)


    def SetUnitDef(self, *args) -> "void":
        """
        Sets (clears if <def> empty) a unit definition, as an equation of dimensions. typedvalue just records this definition, does not exploit it, to be done as required by user applications.

        Parameters
        ----------
        def: char *

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_TypedValue_SetUnitDef(self, *args)


    def StartEnum(self, *args) -> "void":
        """
        For an enumeration, precises the starting value (default 0) and the match condition : if true (d), the string value must match the definition, else it may take another value : in that case, the integer value will be start - 1. (empty value remains allowed).

        Parameters
        ----------
        start: int,optional
        	default value is 0
        match: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        """
        return _MoniTool.MoniTool_TypedValue_StartEnum(self, *args)


    def StaticValue(*args) -> "opencascade::handle< MoniTool_TypedValue >":
        """
        Returns a static value from its name, null if unknown.

        Parameters
        ----------
        name: char *

        Returns
        -------
        opencascade::handle<MoniTool_TypedValue>

        """
        return _MoniTool.MoniTool_TypedValue_StaticValue(*args)

    StaticValue = staticmethod(StaticValue)

    def UnitDef(self, *args) -> "char const *":
        """
        Returns the recorded unit definition, empty if not set.

        Returns
        -------
        char *

        """
        return _MoniTool.MoniTool_TypedValue_UnitDef(self, *args)


    def ValueType(self, *args) -> "MoniTool_ValueType":
        """
        Returns the type of the value.

        Returns
        -------
        MoniTool_ValueType

        """
        return _MoniTool.MoniTool_TypedValue_ValueType(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MoniTool_TypedValue_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_TypedValue
    __del__ = lambda self: None
MoniTool_TypedValue_swigregister = _MoniTool.MoniTool_TypedValue_swigregister
MoniTool_TypedValue_swigregister(MoniTool_TypedValue)

def MoniTool_TypedValue_AddLib(*args) -> "Standard_Boolean":
    """
    Adds a typedvalue in the library. it is recorded then will be accessed by its name its definition may be imposed, else it is computed as usual by default it will be accessed by its definition (string) returns true if done, false if tv is null or brings no definition or <def> not defined //! if a typedvalue was already recorded under this name, it is replaced.

    Parameters
    ----------
    tv: MoniTool_TypedValue
    def: char *,optional
    	default value is 

    Returns
    -------
    bool

    """
    return _MoniTool.MoniTool_TypedValue_AddLib(*args)

def MoniTool_TypedValue_FromLib(*args) -> "opencascade::handle< MoniTool_TypedValue >":
    """
    Returns a copy of the typedvalue bound with a given name null handle if none recorded.

    Parameters
    ----------
    def: char *

    Returns
    -------
    opencascade::handle<MoniTool_TypedValue>

    """
    return _MoniTool.MoniTool_TypedValue_FromLib(*args)

def MoniTool_TypedValue_Lib(*args) -> "opencascade::handle< MoniTool_TypedValue >":
    """
    Returns the typedvalue bound with a given name null handle if none recorded warning : it is the original, not duplicated.

    Parameters
    ----------
    def: char *

    Returns
    -------
    opencascade::handle<MoniTool_TypedValue>

    """
    return _MoniTool.MoniTool_TypedValue_Lib(*args)

def MoniTool_TypedValue_LibList(*args) -> "opencascade::handle< TColStd_HSequenceOfAsciiString >":
    """
    Returns the list of names of items of the library of types -- library of typedvalue as valued parameters, -- -- accessed by parameter name for use by management of static parameters.

    Returns
    -------
    opencascade::handle<TColStd_HSequenceOfAsciiString>

    """
    return _MoniTool.MoniTool_TypedValue_LibList(*args)

def MoniTool_TypedValue_StaticValue(*args) -> "opencascade::handle< MoniTool_TypedValue >":
    """
    Returns a static value from its name, null if unknown.

    Parameters
    ----------
    name: char *

    Returns
    -------
    opencascade::handle<MoniTool_TypedValue>

    """
    return _MoniTool.MoniTool_TypedValue_StaticValue(*args)

class MoniTool_SignShape(MoniTool_SignText):
    __swig_setmethods__ = {}
    for _s in [MoniTool_SignText]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoniTool_SignShape, name, value)
    __swig_getmethods__ = {}
    for _s in [MoniTool_SignText]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MoniTool_SignShape, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        """
        this = _MoniTool.new_MoniTool_SignShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_MoniTool_SignShape_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_SignShape
    __del__ = lambda self: None
MoniTool_SignShape_swigregister = _MoniTool.MoniTool_SignShape_swigregister
MoniTool_SignShape_swigregister(MoniTool_SignShape)

class MoniTool_TransientElem(MoniTool_Element):
    __swig_setmethods__ = {}
    for _s in [MoniTool_Element]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoniTool_TransientElem, name, value)
    __swig_getmethods__ = {}
    for _s in [MoniTool_Element]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MoniTool_TransientElem, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a transientelem with a value. this value can then not be changed. it is used by the hasher to compute the hashcode, which will then be stored for an immediate reading.

        Parameters
        ----------
        akey: Standard_Transient

        Returns
        -------
        None

        """
        this = _MoniTool.new_MoniTool_TransientElem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        Returns the contained value.

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _MoniTool.MoniTool_TransientElem_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MoniTool_TransientElem_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MoniTool.delete_MoniTool_TransientElem
    __del__ = lambda self: None
MoniTool_TransientElem_swigregister = _MoniTool.MoniTool_TransientElem_swigregister
MoniTool_TransientElem_swigregister(MoniTool_TransientElem)

class MoniTool_HSequenceOfElement(MoniTool_SequenceOfElement, OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [MoniTool_SequenceOfElement, OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MoniTool_HSequenceOfElement, name, value)
    __swig_getmethods__ = {}
    for _s in [MoniTool_SequenceOfElement, OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MoniTool_HSequenceOfElement, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _MoniTool.new_MoniTool_HSequenceOfElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Sequence(self) -> "MoniTool_SequenceOfElement const &":
        return _MoniTool.MoniTool_HSequenceOfElement_Sequence(self)

    def Append(self, *args) -> "void":
        return _MoniTool.MoniTool_HSequenceOfElement_Append(self, *args)

    def ChangeSequence(self) -> "MoniTool_SequenceOfElement &":
        return _MoniTool.MoniTool_HSequenceOfElement_ChangeSequence(self)


    @staticmethod
    def DownCast(t):
      return Handle_MoniTool_HSequenceOfElement_DownCast(t)

    __swig_destroy__ = _MoniTool.delete_MoniTool_HSequenceOfElement
    __del__ = lambda self: None
MoniTool_HSequenceOfElement_swigregister = _MoniTool.MoniTool_HSequenceOfElement_swigregister
MoniTool_HSequenceOfElement_swigregister(MoniTool_HSequenceOfElement)



# This file is compatible with both classic and new-style classes.


