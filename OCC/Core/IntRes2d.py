# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
IntRes2d module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_intres2d.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IntRes2d')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IntRes2d')
    _IntRes2d = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IntRes2d', [dirname(__file__)])
        except ImportError:
            import _IntRes2d
            return _IntRes2d
        try:
            _mod = imp.load_module('_IntRes2d', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IntRes2d = swig_import_helper()
    del swig_import_helper
else:
    import _IntRes2d
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IntRes2d.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _IntRes2d.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _IntRes2d.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _IntRes2d.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _IntRes2d.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _IntRes2d.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _IntRes2d.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _IntRes2d.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _IntRes2d.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _IntRes2d.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _IntRes2d.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _IntRes2d.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _IntRes2d.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _IntRes2d.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _IntRes2d.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _IntRes2d.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _IntRes2d.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _IntRes2d.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _IntRes2d.process_exception(error, method_name, class_name)
process_exception = _IntRes2d.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.gp
import OCC.Core.TColStd
import OCC.Core.TCollection

from enum import IntEnum
from OCC.Core.Exception import *

IntRes2d_Head = _IntRes2d.IntRes2d_Head
IntRes2d_Middle = _IntRes2d.IntRes2d_Middle
IntRes2d_End = _IntRes2d.IntRes2d_End
IntRes2d_Inside = _IntRes2d.IntRes2d_Inside
IntRes2d_Outside = _IntRes2d.IntRes2d_Outside
IntRes2d_Unknown = _IntRes2d.IntRes2d_Unknown
IntRes2d_In = _IntRes2d.IntRes2d_In
IntRes2d_Out = _IntRes2d.IntRes2d_Out
IntRes2d_Touch = _IntRes2d.IntRes2d_Touch
IntRes2d_Undecided = _IntRes2d.IntRes2d_Undecided


class IntRes2d_Position(IntEnum):
	IntRes2d_Head = 0
	IntRes2d_Middle = 1
	IntRes2d_End = 2
IntRes2d_Head = IntRes2d_Position.IntRes2d_Head
IntRes2d_Middle = IntRes2d_Position.IntRes2d_Middle
IntRes2d_End = IntRes2d_Position.IntRes2d_End

class IntRes2d_Situation(IntEnum):
	IntRes2d_Inside = 0
	IntRes2d_Outside = 1
	IntRes2d_Unknown = 2
IntRes2d_Inside = IntRes2d_Situation.IntRes2d_Inside
IntRes2d_Outside = IntRes2d_Situation.IntRes2d_Outside
IntRes2d_Unknown = IntRes2d_Situation.IntRes2d_Unknown

class IntRes2d_TypeTrans(IntEnum):
	IntRes2d_In = 0
	IntRes2d_Out = 1
	IntRes2d_Touch = 2
	IntRes2d_Undecided = 3
IntRes2d_In = IntRes2d_TypeTrans.IntRes2d_In
IntRes2d_Out = IntRes2d_TypeTrans.IntRes2d_Out
IntRes2d_Touch = IntRes2d_TypeTrans.IntRes2d_Touch
IntRes2d_Undecided = IntRes2d_TypeTrans.IntRes2d_Undecided

class IntRes2d_SequenceOfIntersectionPoint(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntRes2d_SequenceOfIntersectionPoint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntRes2d_SequenceOfIntersectionPoint, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Sequence< IntRes2d_IntersectionPoint >::iterator":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_begin(self)

    def end(self) -> "NCollection_Sequence< IntRes2d_IntersectionPoint >::iterator":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_end(self)

    def cbegin(self) -> "NCollection_Sequence< IntRes2d_IntersectionPoint >::const_iterator":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_cbegin(self)

    def cend(self) -> "NCollection_Sequence< IntRes2d_IntersectionPoint >::const_iterator":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_cend(self)

    def __init__(self, *args):
        this = _IntRes2d.new_IntRes2d_SequenceOfIntersectionPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self) -> "Standard_Integer":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_Size(self)

    def Length(self) -> "Standard_Integer":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_Length(self)

    def Lower(self) -> "Standard_Integer":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_Upper(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_IsEmpty(self)

    def Reverse(self) -> "void":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_Reverse(self)

    def Exchange(self, I: 'Standard_Integer const', J: 'Standard_Integer const') -> "void":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_Exchange(self, I, J)
    if _newclass:
        delNode = staticmethod(_IntRes2d.IntRes2d_SequenceOfIntersectionPoint_delNode)
    else:
        delNode = _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_delNode

    def Clear(self, theAllocator: 'opencascade::handle< NCollection_BaseAllocator > const &'=0) -> "void":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_Clear(self, theAllocator)

    def Assign(self, theOther: 'IntRes2d_SequenceOfIntersectionPoint') -> "NCollection_Sequence< IntRes2d_IntersectionPoint > &":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_Assign(self, theOther)

    def Set(self, theOther: 'IntRes2d_SequenceOfIntersectionPoint') -> "NCollection_Sequence< IntRes2d_IntersectionPoint > &":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_Set(self, theOther)

    def Remove(self, *args) -> "void":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_Remove(self, *args)

    def Append(self, *args) -> "void":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_Append(self, *args)

    def Prepend(self, *args) -> "void":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_Prepend(self, *args)

    def InsertBefore(self, *args) -> "void":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_InsertBefore(self, *args)

    def InsertAfter(self, *args) -> "void":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_InsertAfter(self, *args)

    def Split(self, theIndex: 'Standard_Integer const', theSeq: 'IntRes2d_SequenceOfIntersectionPoint') -> "void":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_Split(self, theIndex, theSeq)

    def First(self) -> "IntRes2d_IntersectionPoint const &":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_First(self)

    def ChangeFirst(self) -> "IntRes2d_IntersectionPoint &":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_ChangeFirst(self)

    def Last(self) -> "IntRes2d_IntersectionPoint const &":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_Last(self)

    def ChangeLast(self) -> "IntRes2d_IntersectionPoint &":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "IntRes2d_IntersectionPoint const &":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "IntRes2d_IntersectionPoint &":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "IntRes2d_IntersectionPoint &":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'IntRes2d_IntersectionPoint') -> "void":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_SetValue(self, theIndex, theItem)
    __swig_destroy__ = _IntRes2d.delete_IntRes2d_SequenceOfIntersectionPoint
    __del__ = lambda self: None

    def __len__(self):
        return self.Size()

IntRes2d_SequenceOfIntersectionPoint_swigregister = _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_swigregister
IntRes2d_SequenceOfIntersectionPoint_swigregister(IntRes2d_SequenceOfIntersectionPoint)

def IntRes2d_SequenceOfIntersectionPoint_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_delNode(theNode, theAl)
IntRes2d_SequenceOfIntersectionPoint_delNode = _IntRes2d.IntRes2d_SequenceOfIntersectionPoint_delNode

class IntRes2d_SequenceOfIntersectionSegment(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntRes2d_SequenceOfIntersectionSegment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntRes2d_SequenceOfIntersectionSegment, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Sequence< IntRes2d_IntersectionSegment >::iterator":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_begin(self)

    def end(self) -> "NCollection_Sequence< IntRes2d_IntersectionSegment >::iterator":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_end(self)

    def cbegin(self) -> "NCollection_Sequence< IntRes2d_IntersectionSegment >::const_iterator":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_cbegin(self)

    def cend(self) -> "NCollection_Sequence< IntRes2d_IntersectionSegment >::const_iterator":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_cend(self)

    def __init__(self, *args):
        this = _IntRes2d.new_IntRes2d_SequenceOfIntersectionSegment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self) -> "Standard_Integer":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_Size(self)

    def Length(self) -> "Standard_Integer":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_Length(self)

    def Lower(self) -> "Standard_Integer":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_Upper(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_IsEmpty(self)

    def Reverse(self) -> "void":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_Reverse(self)

    def Exchange(self, I: 'Standard_Integer const', J: 'Standard_Integer const') -> "void":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_Exchange(self, I, J)
    if _newclass:
        delNode = staticmethod(_IntRes2d.IntRes2d_SequenceOfIntersectionSegment_delNode)
    else:
        delNode = _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_delNode

    def Clear(self, theAllocator: 'opencascade::handle< NCollection_BaseAllocator > const &'=0) -> "void":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_Clear(self, theAllocator)

    def Assign(self, theOther: 'IntRes2d_SequenceOfIntersectionSegment') -> "NCollection_Sequence< IntRes2d_IntersectionSegment > &":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_Assign(self, theOther)

    def Set(self, theOther: 'IntRes2d_SequenceOfIntersectionSegment') -> "NCollection_Sequence< IntRes2d_IntersectionSegment > &":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_Set(self, theOther)

    def Remove(self, *args) -> "void":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_Remove(self, *args)

    def Append(self, *args) -> "void":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_Append(self, *args)

    def Prepend(self, *args) -> "void":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_Prepend(self, *args)

    def InsertBefore(self, *args) -> "void":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_InsertBefore(self, *args)

    def InsertAfter(self, *args) -> "void":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_InsertAfter(self, *args)

    def Split(self, theIndex: 'Standard_Integer const', theSeq: 'IntRes2d_SequenceOfIntersectionSegment') -> "void":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_Split(self, theIndex, theSeq)

    def First(self) -> "IntRes2d_IntersectionSegment const &":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_First(self)

    def ChangeFirst(self) -> "IntRes2d_IntersectionSegment &":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_ChangeFirst(self)

    def Last(self) -> "IntRes2d_IntersectionSegment const &":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_Last(self)

    def ChangeLast(self) -> "IntRes2d_IntersectionSegment &":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "IntRes2d_IntersectionSegment const &":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "IntRes2d_IntersectionSegment &":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "IntRes2d_IntersectionSegment &":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'IntRes2d_IntersectionSegment') -> "void":
        return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_SetValue(self, theIndex, theItem)
    __swig_destroy__ = _IntRes2d.delete_IntRes2d_SequenceOfIntersectionSegment
    __del__ = lambda self: None

    def __len__(self):
        return self.Size()

IntRes2d_SequenceOfIntersectionSegment_swigregister = _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_swigregister
IntRes2d_SequenceOfIntersectionSegment_swigregister(IntRes2d_SequenceOfIntersectionSegment)

def IntRes2d_SequenceOfIntersectionSegment_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_delNode(theNode, theAl)
IntRes2d_SequenceOfIntersectionSegment_delNode = _IntRes2d.IntRes2d_SequenceOfIntersectionSegment_delNode

class IntRes2d_Domain(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntRes2d_Domain, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntRes2d_Domain, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an infinite domain (hasfirstpoint = false and haslastpoint = false).

        Returns
        -------
        None

        Creates a bounded domain.

        Parameters
        ----------
        Pnt1: gp_Pnt2d
        Par1: float
        Tol1: float
        Pnt2: gp_Pnt2d
        Par2: float
        Tol2: float

        Returns
        -------
        None

        Creates a semi-infinite domain. if first is set to true, the given point is the first point of the domain, otherwise it is the last point.

        Parameters
        ----------
        Pnt: gp_Pnt2d
        Par: float
        Tol: float
        First: bool

        Returns
        -------
        None

        """
        this = _IntRes2d.new_IntRes2d_Domain(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def EquivalentParameters(self, *args) -> "void":
        """
        Returns equivalent parameters if the domain is closed. otherwise, the exception domainerror is raised.

        Parameters
        ----------

        Returns
        -------
        zero: float
        zeroplusperiod: float

        """
        return _IntRes2d.IntRes2d_Domain_EquivalentParameters(self, *args)


    def FirstParameter(self, *args) -> "Standard_Real":
        """
        Returns the parameter of the first point of the domain the exception domainerror is raised if hasfirstpoint returns false.

        Returns
        -------
        float

        """
        return _IntRes2d.IntRes2d_Domain_FirstParameter(self, *args)


    def FirstPoint(self, *args) -> "gp_Pnt2d const":
        """
        Returns the first point of the domain. the exception domainerror is raised if hasfirstpoint returns false.

        Returns
        -------
        gp_Pnt2d

        """
        return _IntRes2d.IntRes2d_Domain_FirstPoint(self, *args)


    def FirstTolerance(self, *args) -> "Standard_Real":
        """
        Returns the tolerance of the first (left) bound. the exception domainerror is raised if hasfirstpoint returns false.

        Returns
        -------
        float

        """
        return _IntRes2d.IntRes2d_Domain_FirstTolerance(self, *args)


    def HasFirstPoint(self, *args) -> "Standard_Boolean":
        """
        Returns true if the domain has a first point, i-e a point defining the lowest admitted parameter on the curve.

        Returns
        -------
        bool

        """
        return _IntRes2d.IntRes2d_Domain_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args) -> "Standard_Boolean":
        """
        Returns true if the domain has a last point, i-e a point defining the highest admitted parameter on the curve.

        Returns
        -------
        bool

        """
        return _IntRes2d.IntRes2d_Domain_HasLastPoint(self, *args)


    def IsClosed(self, *args) -> "Standard_Boolean":
        """
        Returns true if the domain is closed.

        Returns
        -------
        bool

        """
        return _IntRes2d.IntRes2d_Domain_IsClosed(self, *args)


    def LastParameter(self, *args) -> "Standard_Real":
        """
        Returns the parameter of the last point of the domain. the exception domainerror is raised if haslastpoint returns false.

        Returns
        -------
        float

        """
        return _IntRes2d.IntRes2d_Domain_LastParameter(self, *args)


    def LastPoint(self, *args) -> "gp_Pnt2d const":
        """
        Returns the last point of the domain. the exception domainerror is raised if haslastpoint returns false.

        Returns
        -------
        gp_Pnt2d

        """
        return _IntRes2d.IntRes2d_Domain_LastPoint(self, *args)


    def LastTolerance(self, *args) -> "Standard_Real":
        """
        Returns the tolerance of the last (right) bound. the exception domainerror is raised if haslastpoint returns false.

        Returns
        -------
        float

        """
        return _IntRes2d.IntRes2d_Domain_LastTolerance(self, *args)


    def SetEquivalentParameters(self, *args) -> "void":
        """
        Defines a closed domain.

        Parameters
        ----------
        zero: float
        period: float

        Returns
        -------
        None

        """
        return _IntRes2d.IntRes2d_Domain_SetEquivalentParameters(self, *args)


    def SetValues(self, *args) -> "void":
        """
        Sets the values for a bounded domain.

        Parameters
        ----------
        Pnt1: gp_Pnt2d
        Par1: float
        Tol1: float
        Pnt2: gp_Pnt2d
        Par2: float
        Tol2: float

        Returns
        -------
        None

        Sets the values for an infinite domain.

        Returns
        -------
        None

        Sets the values for a semi-infinite domain.

        Parameters
        ----------
        Pnt: gp_Pnt2d
        Par: float
        Tol: float
        First: bool

        Returns
        -------
        None

        """
        return _IntRes2d.IntRes2d_Domain_SetValues(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntRes2d.delete_IntRes2d_Domain
    __del__ = lambda self: None
IntRes2d_Domain_swigregister = _IntRes2d.IntRes2d_Domain_swigregister
IntRes2d_Domain_swigregister(IntRes2d_Domain)

class IntRes2d_Intersection(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntRes2d_Intersection, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntRes2d_Intersection, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true when the computation was successful.

        Returns
        -------
        bool

        """
        return _IntRes2d.IntRes2d_Intersection_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        Returns true if there is no intersection between the given arguments. the exception notdone is raised if isdone returns false.

        Returns
        -------
        bool

        """
        return _IntRes2d.IntRes2d_Intersection_IsEmpty(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        This function returns the number of intersection points between the 2 curves. the exception notdone is raised if isdone returns false.

        Returns
        -------
        int

        """
        return _IntRes2d.IntRes2d_Intersection_NbPoints(self, *args)


    def NbSegments(self, *args) -> "Standard_Integer":
        """
        This function returns the number of intersection segments between the two curves. the exception notdone is raised if isdone returns false.

        Returns
        -------
        int

        """
        return _IntRes2d.IntRes2d_Intersection_NbSegments(self, *args)


    def Point(self, *args) -> "IntRes2d_IntersectionPoint const &":
        """
        This function returns the intersection point of range n; the exception notdone is raised if isdone returns false. the exception outofrange is raised if (n <= 0) or (n > nbpoints).

        Parameters
        ----------
        N: int

        Returns
        -------
        IntRes2d_IntersectionPoint

        """
        return _IntRes2d.IntRes2d_Intersection_Point(self, *args)


    def Segment(self, *args) -> "IntRes2d_IntersectionSegment const &":
        """
        This function returns the intersection segment of range n; the exception notdone is raised if isdone returns false. the exception outofrange is raised if (n <= 0) or (n > nbpoints).

        Parameters
        ----------
        N: int

        Returns
        -------
        IntRes2d_IntersectionSegment

        """
        return _IntRes2d.IntRes2d_Intersection_Segment(self, *args)


    def SetReversedParameters(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        Reverseflag: bool

        Returns
        -------
        None

        """
        return _IntRes2d.IntRes2d_Intersection_SetReversedParameters(self, *args)


    __repr__ = _dumps_object

IntRes2d_Intersection_swigregister = _IntRes2d.IntRes2d_Intersection_swigregister
IntRes2d_Intersection_swigregister(IntRes2d_Intersection)

class IntRes2d_IntersectionPoint(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntRes2d_IntersectionPoint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntRes2d_IntersectionPoint, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Empty constructor.

        Returns
        -------
        None

        Creates an intersectionpoint. if reversedflag is false, the parameter uc1(resp. uc2) and the transition trans1 (resp. trans2) refer to the first curve (resp. second curve) otherwise uc1 and trans1 (resp. uc2 and trans2) refer to the second curve (resp. the first curve).

        Parameters
        ----------
        P: gp_Pnt2d
        Uc1: float
        Uc2: float
        Trans1: IntRes2d_Transition
        Trans2: IntRes2d_Transition
        ReversedFlag: bool

        Returns
        -------
        None

        """
        this = _IntRes2d.new_IntRes2d_IntersectionPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ParamOnFirst(self, *args) -> "Standard_Real":
        """
        Returns the parameter on the first curve.

        Returns
        -------
        float

        """
        return _IntRes2d.IntRes2d_IntersectionPoint_ParamOnFirst(self, *args)


    def ParamOnSecond(self, *args) -> "Standard_Real":
        """
        Returns the parameter on the second curve.

        Returns
        -------
        float

        """
        return _IntRes2d.IntRes2d_IntersectionPoint_ParamOnSecond(self, *args)


    def SetValues(self, *args) -> "void":
        """
        Sets the values for an existing intersection point. the meaning of the parameters are the same as for the create.

        Parameters
        ----------
        P: gp_Pnt2d
        Uc1: float
        Uc2: float
        Trans1: IntRes2d_Transition
        Trans2: IntRes2d_Transition
        ReversedFlag: bool

        Returns
        -------
        None

        """
        return _IntRes2d.IntRes2d_IntersectionPoint_SetValues(self, *args)


    def TransitionOfFirst(self, *args) -> "IntRes2d_Transition const &":
        """
        Returns the transition of the 1st curve compared to the 2nd one.

        Returns
        -------
        IntRes2d_Transition

        """
        return _IntRes2d.IntRes2d_IntersectionPoint_TransitionOfFirst(self, *args)


    def TransitionOfSecond(self, *args) -> "IntRes2d_Transition const &":
        """
        Returns the transition of the 2nd curve compared to the 1st one.

        Returns
        -------
        IntRes2d_Transition

        """
        return _IntRes2d.IntRes2d_IntersectionPoint_TransitionOfSecond(self, *args)


    def Value(self, *args) -> "gp_Pnt2d const":
        """
        Returns the value of the coordinates of the intersection point in the 2d space.

        Returns
        -------
        gp_Pnt2d

        """
        return _IntRes2d.IntRes2d_IntersectionPoint_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntRes2d.delete_IntRes2d_IntersectionPoint
    __del__ = lambda self: None
IntRes2d_IntersectionPoint_swigregister = _IntRes2d.IntRes2d_IntersectionPoint_swigregister
IntRes2d_IntersectionPoint_swigregister(IntRes2d_IntersectionPoint)

class IntRes2d_IntersectionSegment(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntRes2d_IntersectionSegment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntRes2d_IntersectionSegment, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Empty constructor.

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        P1: IntRes2d_IntersectionPoint
        P2: IntRes2d_IntersectionPoint
        Oppos: bool
        ReverseFlag: bool

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        P: IntRes2d_IntersectionPoint
        First: bool
        Oppos: bool
        ReverseFlag: bool

        Returns
        -------
        None

        Creates an infinite segment of intersection.

        Parameters
        ----------
        Oppos: bool

        Returns
        -------
        None

        """
        this = _IntRes2d.new_IntRes2d_IntersectionSegment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def FirstPoint(self, *args) -> "IntRes2d_IntersectionPoint const &":
        """
        Returns the first point of the segment as an intersectionpoint (with a transition). the exception domainerror is raised if hasfirstpoint returns false.

        Returns
        -------
        IntRes2d_IntersectionPoint

        """
        return _IntRes2d.IntRes2d_IntersectionSegment_FirstPoint(self, *args)


    def HasFirstPoint(self, *args) -> "Standard_Boolean":
        """
        Returns true if the segment is limited by a first point. this point defines the lowest parameter admitted on the first curve for the segment. if isopposite returns false, it defines the lowest parameter on the second curve, otherwise, it is the highest parameter on the second curve.

        Returns
        -------
        bool

        """
        return _IntRes2d.IntRes2d_IntersectionSegment_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args) -> "Standard_Boolean":
        """
        Returns true if the segment is limited by a last point. this point defines the highest parameter admitted on the first curve for the segment. if isopposite returns false, it defines the highest parameter on the second curve, otherwise, it is the lowest parameter on the second curve.

        Returns
        -------
        bool

        """
        return _IntRes2d.IntRes2d_IntersectionSegment_HasLastPoint(self, *args)


    def IsOpposite(self, *args) -> "Standard_Boolean":
        """
        Returns false if the intersection segment has got the same orientation on both curves.

        Returns
        -------
        bool

        """
        return _IntRes2d.IntRes2d_IntersectionSegment_IsOpposite(self, *args)


    def LastPoint(self, *args) -> "IntRes2d_IntersectionPoint const &":
        """
        Returns the last point of the segment as an intersectionpoint (with a transition). the exception domainerror is raised if haslastextremity returns false.

        Returns
        -------
        IntRes2d_IntersectionPoint

        """
        return _IntRes2d.IntRes2d_IntersectionSegment_LastPoint(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntRes2d.delete_IntRes2d_IntersectionSegment
    __del__ = lambda self: None
IntRes2d_IntersectionSegment_swigregister = _IntRes2d.IntRes2d_IntersectionSegment_swigregister
IntRes2d_IntersectionSegment_swigregister(IntRes2d_IntersectionSegment)

class IntRes2d_Transition(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntRes2d_Transition, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntRes2d_Transition, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Empty constructor.

        Returns
        -------
        None

        Creates an in or out transition.

        Parameters
        ----------
        Tangent: bool
        Pos: IntRes2d_Position
        Type: IntRes2d_TypeTrans

        Returns
        -------
        None

        Creates a touch transition.

        Parameters
        ----------
        Tangent: bool
        Pos: IntRes2d_Position
        Situ: IntRes2d_Situation
        Oppos: bool

        Returns
        -------
        None

        Creates an undecided transition.

        Parameters
        ----------
        Pos: IntRes2d_Position

        Returns
        -------
        None

        """
        this = _IntRes2d.new_IntRes2d_Transition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsOpposite(self, *args) -> "Standard_Boolean":
        """
        Returns a significant value if transitiontype returns touch. in this case, the function returns true when the 2 curves locally define two different parts of the space. if transitiontype returns in or out or undecided, the exception domainerror is raised.

        Returns
        -------
        bool

        """
        return _IntRes2d.IntRes2d_Transition_IsOpposite(self, *args)


    def IsTangent(self, *args) -> "Standard_Boolean":
        """
        Returns true when the 2 curves are tangent at the intersection point. theexception domainerror is raised if the type of transition is undecided.

        Returns
        -------
        bool

        """
        return _IntRes2d.IntRes2d_Transition_IsTangent(self, *args)


    def PositionOnCurve(self, *args) -> "IntRes2d_Position":
        """
        Indicates if the intersection is at the beginning (intres2d_head), at the end (intres2d_end), or in the middle (intres2d_middle) of the curve.

        Returns
        -------
        IntRes2d_Position

        """
        return _IntRes2d.IntRes2d_Transition_PositionOnCurve(self, *args)


    def SetPosition(self, *args) -> "void":
        """
        Sets the value of the position.

        Parameters
        ----------
        Pos: IntRes2d_Position

        Returns
        -------
        None

        """
        return _IntRes2d.IntRes2d_Transition_SetPosition(self, *args)


    def SetValue(self, *args) -> "void":
        """
        Sets the values of an in or out transition.

        Parameters
        ----------
        Tangent: bool
        Pos: IntRes2d_Position
        Type: IntRes2d_TypeTrans

        Returns
        -------
        None

        Sets the values of a touch transition.

        Parameters
        ----------
        Tangent: bool
        Pos: IntRes2d_Position
        Situ: IntRes2d_Situation
        Oppos: bool

        Returns
        -------
        None

        Sets the values of an undecided transition.

        Parameters
        ----------
        Pos: IntRes2d_Position

        Returns
        -------
        None

        """
        return _IntRes2d.IntRes2d_Transition_SetValue(self, *args)


    def Situation(self, *args) -> "IntRes2d_Situation":
        """
        Returns a significant value if transitiontype returns touch. in this case, the function returns : inside when the curve remains inside the other one, outside when it remains outside the other one, unknown when the calculus, based on the second derivatives cannot give the result. if transitiontype returns in or out or undecided, the exception domainerror is raised.

        Returns
        -------
        IntRes2d_Situation

        """
        return _IntRes2d.IntRes2d_Transition_Situation(self, *args)


    def TransitionType(self, *args) -> "IntRes2d_TypeTrans":
        """
        Returns the type of transition at the intersection. it may be in or out or touch, or undecided if the two first derivatives are not enough to give the tangent to one of the two curves.

        Returns
        -------
        IntRes2d_TypeTrans

        """
        return _IntRes2d.IntRes2d_Transition_TransitionType(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntRes2d.delete_IntRes2d_Transition
    __del__ = lambda self: None
IntRes2d_Transition_swigregister = _IntRes2d.IntRes2d_Transition_swigregister
IntRes2d_Transition_swigregister(IntRes2d_Transition)



# This file is compatible with both classic and new-style classes.


