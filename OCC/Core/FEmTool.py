# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
FEmTool module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_femtool.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_FEmTool')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_FEmTool')
    _FEmTool = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_FEmTool', [dirname(__file__)])
        except ImportError:
            import _FEmTool
            return _FEmTool
        try:
            _mod = imp.load_module('_FEmTool', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _FEmTool = swig_import_helper()
    del swig_import_helper
else:
    import _FEmTool
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _FEmTool.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _FEmTool.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _FEmTool.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _FEmTool.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _FEmTool.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _FEmTool.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _FEmTool.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _FEmTool.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _FEmTool.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _FEmTool.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _FEmTool.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _FEmTool.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _FEmTool.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _FEmTool.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _FEmTool.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _FEmTool.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _FEmTool.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _FEmTool.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _FEmTool.process_exception(error, method_name, class_name)
process_exception = _FEmTool.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.math
import OCC.Core.Message
import OCC.Core.OSD
import OCC.Core.gp
import OCC.Core.PLib
import OCC.Core.TColgp
import OCC.Core.GeomAbs

from enum import IntEnum
from OCC.Core.Exception import *




def Handle_FEmTool_Curve_Create() -> "opencascade::handle< FEmTool_Curve >":
    return _FEmTool.Handle_FEmTool_Curve_Create()
Handle_FEmTool_Curve_Create = _FEmTool.Handle_FEmTool_Curve_Create

def Handle_FEmTool_Curve_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< FEmTool_Curve >":
    return _FEmTool.Handle_FEmTool_Curve_DownCast(t)
Handle_FEmTool_Curve_DownCast = _FEmTool.Handle_FEmTool_Curve_DownCast

def Handle_FEmTool_Curve_IsNull(t: 'opencascade::handle< FEmTool_Curve > const &') -> "bool":
    return _FEmTool.Handle_FEmTool_Curve_IsNull(t)
Handle_FEmTool_Curve_IsNull = _FEmTool.Handle_FEmTool_Curve_IsNull

def Handle_FEmTool_ElementaryCriterion_Create() -> "opencascade::handle< FEmTool_ElementaryCriterion >":
    return _FEmTool.Handle_FEmTool_ElementaryCriterion_Create()
Handle_FEmTool_ElementaryCriterion_Create = _FEmTool.Handle_FEmTool_ElementaryCriterion_Create

def Handle_FEmTool_ElementaryCriterion_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< FEmTool_ElementaryCriterion >":
    return _FEmTool.Handle_FEmTool_ElementaryCriterion_DownCast(t)
Handle_FEmTool_ElementaryCriterion_DownCast = _FEmTool.Handle_FEmTool_ElementaryCriterion_DownCast

def Handle_FEmTool_ElementaryCriterion_IsNull(t: 'opencascade::handle< FEmTool_ElementaryCriterion > const &') -> "bool":
    return _FEmTool.Handle_FEmTool_ElementaryCriterion_IsNull(t)
Handle_FEmTool_ElementaryCriterion_IsNull = _FEmTool.Handle_FEmTool_ElementaryCriterion_IsNull

def Handle_FEmTool_SparseMatrix_Create() -> "opencascade::handle< FEmTool_SparseMatrix >":
    return _FEmTool.Handle_FEmTool_SparseMatrix_Create()
Handle_FEmTool_SparseMatrix_Create = _FEmTool.Handle_FEmTool_SparseMatrix_Create

def Handle_FEmTool_SparseMatrix_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< FEmTool_SparseMatrix >":
    return _FEmTool.Handle_FEmTool_SparseMatrix_DownCast(t)
Handle_FEmTool_SparseMatrix_DownCast = _FEmTool.Handle_FEmTool_SparseMatrix_DownCast

def Handle_FEmTool_SparseMatrix_IsNull(t: 'opencascade::handle< FEmTool_SparseMatrix > const &') -> "bool":
    return _FEmTool.Handle_FEmTool_SparseMatrix_IsNull(t)
Handle_FEmTool_SparseMatrix_IsNull = _FEmTool.Handle_FEmTool_SparseMatrix_IsNull

def Handle_FEmTool_LinearFlexion_Create() -> "opencascade::handle< FEmTool_LinearFlexion >":
    return _FEmTool.Handle_FEmTool_LinearFlexion_Create()
Handle_FEmTool_LinearFlexion_Create = _FEmTool.Handle_FEmTool_LinearFlexion_Create

def Handle_FEmTool_LinearFlexion_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< FEmTool_LinearFlexion >":
    return _FEmTool.Handle_FEmTool_LinearFlexion_DownCast(t)
Handle_FEmTool_LinearFlexion_DownCast = _FEmTool.Handle_FEmTool_LinearFlexion_DownCast

def Handle_FEmTool_LinearFlexion_IsNull(t: 'opencascade::handle< FEmTool_LinearFlexion > const &') -> "bool":
    return _FEmTool.Handle_FEmTool_LinearFlexion_IsNull(t)
Handle_FEmTool_LinearFlexion_IsNull = _FEmTool.Handle_FEmTool_LinearFlexion_IsNull

def Handle_FEmTool_LinearJerk_Create() -> "opencascade::handle< FEmTool_LinearJerk >":
    return _FEmTool.Handle_FEmTool_LinearJerk_Create()
Handle_FEmTool_LinearJerk_Create = _FEmTool.Handle_FEmTool_LinearJerk_Create

def Handle_FEmTool_LinearJerk_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< FEmTool_LinearJerk >":
    return _FEmTool.Handle_FEmTool_LinearJerk_DownCast(t)
Handle_FEmTool_LinearJerk_DownCast = _FEmTool.Handle_FEmTool_LinearJerk_DownCast

def Handle_FEmTool_LinearJerk_IsNull(t: 'opencascade::handle< FEmTool_LinearJerk > const &') -> "bool":
    return _FEmTool.Handle_FEmTool_LinearJerk_IsNull(t)
Handle_FEmTool_LinearJerk_IsNull = _FEmTool.Handle_FEmTool_LinearJerk_IsNull

def Handle_FEmTool_LinearTension_Create() -> "opencascade::handle< FEmTool_LinearTension >":
    return _FEmTool.Handle_FEmTool_LinearTension_Create()
Handle_FEmTool_LinearTension_Create = _FEmTool.Handle_FEmTool_LinearTension_Create

def Handle_FEmTool_LinearTension_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< FEmTool_LinearTension >":
    return _FEmTool.Handle_FEmTool_LinearTension_DownCast(t)
Handle_FEmTool_LinearTension_DownCast = _FEmTool.Handle_FEmTool_LinearTension_DownCast

def Handle_FEmTool_LinearTension_IsNull(t: 'opencascade::handle< FEmTool_LinearTension > const &') -> "bool":
    return _FEmTool.Handle_FEmTool_LinearTension_IsNull(t)
Handle_FEmTool_LinearTension_IsNull = _FEmTool.Handle_FEmTool_LinearTension_IsNull

def Handle_FEmTool_ProfileMatrix_Create() -> "opencascade::handle< FEmTool_ProfileMatrix >":
    return _FEmTool.Handle_FEmTool_ProfileMatrix_Create()
Handle_FEmTool_ProfileMatrix_Create = _FEmTool.Handle_FEmTool_ProfileMatrix_Create

def Handle_FEmTool_ProfileMatrix_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< FEmTool_ProfileMatrix >":
    return _FEmTool.Handle_FEmTool_ProfileMatrix_DownCast(t)
Handle_FEmTool_ProfileMatrix_DownCast = _FEmTool.Handle_FEmTool_ProfileMatrix_DownCast

def Handle_FEmTool_ProfileMatrix_IsNull(t: 'opencascade::handle< FEmTool_ProfileMatrix > const &') -> "bool":
    return _FEmTool.Handle_FEmTool_ProfileMatrix_IsNull(t)
Handle_FEmTool_ProfileMatrix_IsNull = _FEmTool.Handle_FEmTool_ProfileMatrix_IsNull

def Handle_FEmTool_HAssemblyTable_Create() -> "opencascade::handle< FEmTool_HAssemblyTable >":
    return _FEmTool.Handle_FEmTool_HAssemblyTable_Create()
Handle_FEmTool_HAssemblyTable_Create = _FEmTool.Handle_FEmTool_HAssemblyTable_Create

def Handle_FEmTool_HAssemblyTable_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< FEmTool_HAssemblyTable >":
    return _FEmTool.Handle_FEmTool_HAssemblyTable_DownCast(t)
Handle_FEmTool_HAssemblyTable_DownCast = _FEmTool.Handle_FEmTool_HAssemblyTable_DownCast

def Handle_FEmTool_HAssemblyTable_IsNull(t: 'opencascade::handle< FEmTool_HAssemblyTable > const &') -> "bool":
    return _FEmTool.Handle_FEmTool_HAssemblyTable_IsNull(t)
Handle_FEmTool_HAssemblyTable_IsNull = _FEmTool.Handle_FEmTool_HAssemblyTable_IsNull
class FEmTool_AssemblyTable(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FEmTool_AssemblyTable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FEmTool_AssemblyTable, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _FEmTool.new_FEmTool_AssemblyTable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, theValue: 'opencascade::handle< TColStd_HArray1OfInteger > const &') -> "void":
        return _FEmTool.FEmTool_AssemblyTable_Init(self, theValue)

    def Size(self) -> "Standard_Integer":
        return _FEmTool.FEmTool_AssemblyTable_Size(self)

    def Length(self) -> "Standard_Integer":
        return _FEmTool.FEmTool_AssemblyTable_Length(self)

    def NbRows(self) -> "Standard_Integer":
        return _FEmTool.FEmTool_AssemblyTable_NbRows(self)

    def NbColumns(self) -> "Standard_Integer":
        return _FEmTool.FEmTool_AssemblyTable_NbColumns(self)

    def RowLength(self) -> "Standard_Integer":
        return _FEmTool.FEmTool_AssemblyTable_RowLength(self)

    def ColLength(self) -> "Standard_Integer":
        return _FEmTool.FEmTool_AssemblyTable_ColLength(self)

    def LowerRow(self) -> "Standard_Integer":
        return _FEmTool.FEmTool_AssemblyTable_LowerRow(self)

    def UpperRow(self) -> "Standard_Integer":
        return _FEmTool.FEmTool_AssemblyTable_UpperRow(self)

    def LowerCol(self) -> "Standard_Integer":
        return _FEmTool.FEmTool_AssemblyTable_LowerCol(self)

    def UpperCol(self) -> "Standard_Integer":
        return _FEmTool.FEmTool_AssemblyTable_UpperCol(self)

    def IsDeletable(self) -> "Standard_Boolean":
        return _FEmTool.FEmTool_AssemblyTable_IsDeletable(self)

    def Assign(self, theOther: 'FEmTool_AssemblyTable') -> "NCollection_Array2< opencascade::handle< TColStd_HArray1OfInteger > > &":
        return _FEmTool.FEmTool_AssemblyTable_Assign(self, theOther)

    def Move(self, theOther: 'FEmTool_AssemblyTable') -> "NCollection_Array2< opencascade::handle< TColStd_HArray1OfInteger > > &":
        return _FEmTool.FEmTool_AssemblyTable_Move(self, theOther)

    def Set(self, *args) -> "NCollection_Array2< opencascade::handle< TColStd_HArray1OfInteger > > &":
        return _FEmTool.FEmTool_AssemblyTable_Set(self, *args)

    def Value(self, theRow: 'Standard_Integer const', theCol: 'Standard_Integer const') -> "opencascade::handle< TColStd_HArray1OfInteger > const &":
        return _FEmTool.FEmTool_AssemblyTable_Value(self, theRow, theCol)

    def ChangeValue(self, theRow: 'Standard_Integer const', theCol: 'Standard_Integer const') -> "opencascade::handle< TColStd_HArray1OfInteger > &":
        return _FEmTool.FEmTool_AssemblyTable_ChangeValue(self, theRow, theCol)

    def __call__(self, *args) -> "opencascade::handle< TColStd_HArray1OfInteger > &":
        return _FEmTool.FEmTool_AssemblyTable___call__(self, *args)

    def SetValue(self, theRow: 'Standard_Integer const', theCol: 'Standard_Integer const', theItem: 'opencascade::handle< TColStd_HArray1OfInteger > const &') -> "void":
        return _FEmTool.FEmTool_AssemblyTable_SetValue(self, theRow, theCol, theItem)

    def Resize(self, theRowLower: 'Standard_Integer', theRowUpper: 'Standard_Integer', theColLower: 'Standard_Integer', theColUpper: 'Standard_Integer', theToCopyData: 'Standard_Boolean') -> "void":
        return _FEmTool.FEmTool_AssemblyTable_Resize(self, theRowLower, theRowUpper, theColLower, theColUpper, theToCopyData)
    __swig_destroy__ = _FEmTool.delete_FEmTool_AssemblyTable
    __del__ = lambda self: None
FEmTool_AssemblyTable_swigregister = _FEmTool.FEmTool_AssemblyTable_swigregister
FEmTool_AssemblyTable_swigregister(FEmTool_AssemblyTable)

class FEmTool_ListIteratorOfListOfVectors(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FEmTool_ListIteratorOfListOfVectors, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FEmTool_ListIteratorOfListOfVectors, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _FEmTool.new_FEmTool_ListIteratorOfListOfVectors(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def More(self) -> "Standard_Boolean":
        return _FEmTool.FEmTool_ListIteratorOfListOfVectors_More(self)

    def Next(self) -> "void":
        return _FEmTool.FEmTool_ListIteratorOfListOfVectors_Next(self)

    def Value(self) -> "opencascade::handle< TColStd_HArray1OfReal > const &":
        return _FEmTool.FEmTool_ListIteratorOfListOfVectors_Value(self)

    def ChangeValue(self) -> "opencascade::handle< TColStd_HArray1OfReal > &":
        return _FEmTool.FEmTool_ListIteratorOfListOfVectors_ChangeValue(self)
    __swig_destroy__ = _FEmTool.delete_FEmTool_ListIteratorOfListOfVectors
    __del__ = lambda self: None
FEmTool_ListIteratorOfListOfVectors_swigregister = _FEmTool.FEmTool_ListIteratorOfListOfVectors_swigregister
FEmTool_ListIteratorOfListOfVectors_swigregister(FEmTool_ListIteratorOfListOfVectors)

class FEmTool_ListOfVectors(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FEmTool_ListOfVectors, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FEmTool_ListOfVectors, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_List< opencascade::handle< TColStd_HArray1OfReal > >::iterator":
        return _FEmTool.FEmTool_ListOfVectors_begin(self)

    def end(self) -> "NCollection_List< opencascade::handle< TColStd_HArray1OfReal > >::iterator":
        return _FEmTool.FEmTool_ListOfVectors_end(self)

    def cbegin(self) -> "NCollection_List< opencascade::handle< TColStd_HArray1OfReal > >::const_iterator":
        return _FEmTool.FEmTool_ListOfVectors_cbegin(self)

    def cend(self) -> "NCollection_List< opencascade::handle< TColStd_HArray1OfReal > >::const_iterator":
        return _FEmTool.FEmTool_ListOfVectors_cend(self)

    def __init__(self, *args):
        this = _FEmTool.new_FEmTool_ListOfVectors(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self) -> "Standard_Integer":
        return _FEmTool.FEmTool_ListOfVectors_Size(self)

    def Assign(self, theOther: 'FEmTool_ListOfVectors') -> "NCollection_List< opencascade::handle< TColStd_HArray1OfReal > > &":
        return _FEmTool.FEmTool_ListOfVectors_Assign(self, theOther)

    def Set(self, theOther: 'FEmTool_ListOfVectors') -> "NCollection_List< opencascade::handle< TColStd_HArray1OfReal > > &":
        return _FEmTool.FEmTool_ListOfVectors_Set(self, theOther)

    def Clear(self, theAllocator: 'opencascade::handle< NCollection_BaseAllocator > const &'=0) -> "void":
        return _FEmTool.FEmTool_ListOfVectors_Clear(self, theAllocator)

    def First(self) -> "opencascade::handle< TColStd_HArray1OfReal > const &":
        return _FEmTool.FEmTool_ListOfVectors_First(self)

    def Last(self) -> "opencascade::handle< TColStd_HArray1OfReal > const &":
        return _FEmTool.FEmTool_ListOfVectors_Last(self)

    def Append(self, *args) -> "void":
        return _FEmTool.FEmTool_ListOfVectors_Append(self, *args)

    def Prepend(self, *args) -> "void":
        return _FEmTool.FEmTool_ListOfVectors_Prepend(self, *args)

    def RemoveFirst(self) -> "void":
        return _FEmTool.FEmTool_ListOfVectors_RemoveFirst(self)

    def Remove(self, theIter: 'FEmTool_ListIteratorOfListOfVectors') -> "void":
        return _FEmTool.FEmTool_ListOfVectors_Remove(self, theIter)

    def InsertBefore(self, *args) -> "void":
        return _FEmTool.FEmTool_ListOfVectors_InsertBefore(self, *args)

    def InsertAfter(self, *args) -> "void":
        return _FEmTool.FEmTool_ListOfVectors_InsertAfter(self, *args)

    def Reverse(self) -> "void":
        return _FEmTool.FEmTool_ListOfVectors_Reverse(self)
    __swig_destroy__ = _FEmTool.delete_FEmTool_ListOfVectors
    __del__ = lambda self: None

    def __len__(self):
        return self.Size()

FEmTool_ListOfVectors_swigregister = _FEmTool.FEmTool_ListOfVectors_swigregister
FEmTool_ListOfVectors_swigregister(FEmTool_ListOfVectors)

class FEmTool_SeqOfLinConstr(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FEmTool_SeqOfLinConstr, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FEmTool_SeqOfLinConstr, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Sequence< FEmTool_ListOfVectors >::iterator":
        return _FEmTool.FEmTool_SeqOfLinConstr_begin(self)

    def end(self) -> "NCollection_Sequence< FEmTool_ListOfVectors >::iterator":
        return _FEmTool.FEmTool_SeqOfLinConstr_end(self)

    def cbegin(self) -> "NCollection_Sequence< FEmTool_ListOfVectors >::const_iterator":
        return _FEmTool.FEmTool_SeqOfLinConstr_cbegin(self)

    def cend(self) -> "NCollection_Sequence< FEmTool_ListOfVectors >::const_iterator":
        return _FEmTool.FEmTool_SeqOfLinConstr_cend(self)

    def __init__(self, *args):
        this = _FEmTool.new_FEmTool_SeqOfLinConstr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self) -> "Standard_Integer":
        return _FEmTool.FEmTool_SeqOfLinConstr_Size(self)

    def Length(self) -> "Standard_Integer":
        return _FEmTool.FEmTool_SeqOfLinConstr_Length(self)

    def Lower(self) -> "Standard_Integer":
        return _FEmTool.FEmTool_SeqOfLinConstr_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _FEmTool.FEmTool_SeqOfLinConstr_Upper(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _FEmTool.FEmTool_SeqOfLinConstr_IsEmpty(self)

    def Reverse(self) -> "void":
        return _FEmTool.FEmTool_SeqOfLinConstr_Reverse(self)

    def Exchange(self, I: 'Standard_Integer const', J: 'Standard_Integer const') -> "void":
        return _FEmTool.FEmTool_SeqOfLinConstr_Exchange(self, I, J)
    if _newclass:
        delNode = staticmethod(_FEmTool.FEmTool_SeqOfLinConstr_delNode)
    else:
        delNode = _FEmTool.FEmTool_SeqOfLinConstr_delNode

    def Clear(self, theAllocator: 'opencascade::handle< NCollection_BaseAllocator > const &'=0) -> "void":
        return _FEmTool.FEmTool_SeqOfLinConstr_Clear(self, theAllocator)

    def Assign(self, theOther: 'FEmTool_SeqOfLinConstr') -> "NCollection_Sequence< FEmTool_ListOfVectors > &":
        return _FEmTool.FEmTool_SeqOfLinConstr_Assign(self, theOther)

    def Set(self, theOther: 'FEmTool_SeqOfLinConstr') -> "NCollection_Sequence< FEmTool_ListOfVectors > &":
        return _FEmTool.FEmTool_SeqOfLinConstr_Set(self, theOther)

    def Remove(self, *args) -> "void":
        return _FEmTool.FEmTool_SeqOfLinConstr_Remove(self, *args)

    def Append(self, *args) -> "void":
        return _FEmTool.FEmTool_SeqOfLinConstr_Append(self, *args)

    def Prepend(self, *args) -> "void":
        return _FEmTool.FEmTool_SeqOfLinConstr_Prepend(self, *args)

    def InsertBefore(self, *args) -> "void":
        return _FEmTool.FEmTool_SeqOfLinConstr_InsertBefore(self, *args)

    def InsertAfter(self, *args) -> "void":
        return _FEmTool.FEmTool_SeqOfLinConstr_InsertAfter(self, *args)

    def Split(self, theIndex: 'Standard_Integer const', theSeq: 'FEmTool_SeqOfLinConstr') -> "void":
        return _FEmTool.FEmTool_SeqOfLinConstr_Split(self, theIndex, theSeq)

    def First(self) -> "FEmTool_ListOfVectors const &":
        return _FEmTool.FEmTool_SeqOfLinConstr_First(self)

    def ChangeFirst(self) -> "FEmTool_ListOfVectors &":
        return _FEmTool.FEmTool_SeqOfLinConstr_ChangeFirst(self)

    def Last(self) -> "FEmTool_ListOfVectors const &":
        return _FEmTool.FEmTool_SeqOfLinConstr_Last(self)

    def ChangeLast(self) -> "FEmTool_ListOfVectors &":
        return _FEmTool.FEmTool_SeqOfLinConstr_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "FEmTool_ListOfVectors const &":
        return _FEmTool.FEmTool_SeqOfLinConstr_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "FEmTool_ListOfVectors &":
        return _FEmTool.FEmTool_SeqOfLinConstr_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "FEmTool_ListOfVectors &":
        return _FEmTool.FEmTool_SeqOfLinConstr___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'FEmTool_ListOfVectors') -> "void":
        return _FEmTool.FEmTool_SeqOfLinConstr_SetValue(self, theIndex, theItem)
    __swig_destroy__ = _FEmTool.delete_FEmTool_SeqOfLinConstr
    __del__ = lambda self: None

    def __len__(self):
        return self.Size()

FEmTool_SeqOfLinConstr_swigregister = _FEmTool.FEmTool_SeqOfLinConstr_swigregister
FEmTool_SeqOfLinConstr_swigregister(FEmTool_SeqOfLinConstr)

def FEmTool_SeqOfLinConstr_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _FEmTool.FEmTool_SeqOfLinConstr_delNode(theNode, theAl)
FEmTool_SeqOfLinConstr_delNode = _FEmTool.FEmTool_SeqOfLinConstr_delNode

class FEmTool_Assembly(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FEmTool_Assembly, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FEmTool_Assembly, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        Dependence: TColStd_Array2OfInteger
        Table: FEmTool_HAssemblyTable

        Returns
        -------
        None

        """
        this = _FEmTool.new_FEmTool_Assembly(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddConstraint(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        IndexofConstraint: int
        Element: int
        Dimension: int
        LinearForm: math_Vector
        Value: float

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_Assembly_AddConstraint(self, *args)


    def AddMatrix(self, *args) -> "void":
        """
        Add an elementary matrix in the assembly matrix if dependence(dimension1,dimension2) is false.

        Parameters
        ----------
        Element: int
        Dimension1: int
        Dimension2: int
        Mat: math_Matrix

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_Assembly_AddMatrix(self, *args)


    def AddVector(self, *args) -> "void":
        """
        Add an elementary vector in the assembly vector (second member).

        Parameters
        ----------
        Element: int
        Dimension: int
        Vec: math_Vector

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_Assembly_AddVector(self, *args)


    def GetAssemblyTable(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        AssTable: FEmTool_HAssemblyTable

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_Assembly_GetAssemblyTable(self, *args)


    def NbGlobVar(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _FEmTool.FEmTool_Assembly_NbGlobVar(self, *args)


    def NullifyConstraint(self, *args) -> "void":
        """
        Nullify all constraints.

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_Assembly_NullifyConstraint(self, *args)


    def NullifyMatrix(self, *args) -> "void":
        """
        Nullify all matrix 's coefficient.

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_Assembly_NullifyMatrix(self, *args)


    def NullifyVector(self, *args) -> "void":
        """
        Nullify all coordinate of assembly vector (second member).

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_Assembly_NullifyVector(self, *args)


    def ResetConstraint(self, *args) -> "void":
        """
        Delete all constraints.

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_Assembly_ResetConstraint(self, *args)


    def Solution(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        Solution: math_Vector

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_Assembly_Solution(self, *args)


    def Solve(self, *args) -> "Standard_Boolean":
        """
        Solve the assembly system returns standard_false if the computation failed.

        Returns
        -------
        bool

        """
        return _FEmTool.FEmTool_Assembly_Solve(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _FEmTool.delete_FEmTool_Assembly
    __del__ = lambda self: None
FEmTool_Assembly_swigregister = _FEmTool.FEmTool_Assembly_swigregister
FEmTool_Assembly_swigregister(FEmTool_Assembly)

class FEmTool_Curve(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FEmTool_Curve, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FEmTool_Curve, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        Dimension: int
        NbElements: int
        TheBase: PLib_Base
        Tolerance: float

        Returns
        -------
        None

        """
        this = _FEmTool.new_FEmTool_Curve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Base(self, *args) -> "opencascade::handle< PLib_Base >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<PLib_Base>

        """
        return _FEmTool.FEmTool_Curve_Base(self, *args)


    def D0(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        U: float
        Pnt: TColStd_Array1OfReal

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_Curve_D0(self, *args)


    def D1(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        U: float
        Vec: TColStd_Array1OfReal

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_Curve_D1(self, *args)


    def D2(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        U: float
        Vec: TColStd_Array1OfReal

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_Curve_D2(self, *args)


    def Degree(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Parameters
        ----------
        IndexOfElement: int

        Returns
        -------
        int

        """
        return _FEmTool.FEmTool_Curve_Degree(self, *args)


    def Dimension(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _FEmTool.FEmTool_Curve_Dimension(self, *args)


    def GetElement(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        IndexOfElement: int
        Coeffs: TColStd_Array2OfReal

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_Curve_GetElement(self, *args)


    def GetPolynom(self, *args) -> "void":
        """
        Returns coefficients of all elements in canonical base.

        Parameters
        ----------
        Coeffs: TColStd_Array1OfReal

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_Curve_GetPolynom(self, *args)


    def Knots(self, *args) -> "TColStd_Array1OfReal &":
        """
        No available documentation.

        Returns
        -------
        TColStd_Array1OfReal

        """
        return _FEmTool.FEmTool_Curve_Knots(self, *args)


    def Length(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        FirstU: float
        LastU: float

        Returns
        -------
        Length: float

        """
        return _FEmTool.FEmTool_Curve_Length(self, *args)


    def NbElements(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _FEmTool.FEmTool_Curve_NbElements(self, *args)


    def ReduceDegree(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        IndexOfElement: int
        Tol: float

        Returns
        -------
        NewDegree: int
        MaxError: float

        """
        return _FEmTool.FEmTool_Curve_ReduceDegree(self, *args)


    def SetDegree(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        IndexOfElement: int
        Degree: int

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_Curve_SetDegree(self, *args)


    def SetElement(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        IndexOfElement: int
        Coeffs: TColStd_Array2OfReal

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_Curve_SetElement(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_FEmTool_Curve_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _FEmTool.delete_FEmTool_Curve
    __del__ = lambda self: None
FEmTool_Curve_swigregister = _FEmTool.FEmTool_Curve_swigregister
FEmTool_Curve_swigregister(FEmTool_Curve)

class FEmTool_ElementaryCriterion(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FEmTool_ElementaryCriterion, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FEmTool_ElementaryCriterion, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def DependenceTable(self, *args) -> "opencascade::handle< TColStd_HArray2OfInteger >":
        """
        To know if two dimension are independent.

        Returns
        -------
        opencascade::handle<TColStd_HArray2OfInteger>

        """
        return _FEmTool.FEmTool_ElementaryCriterion_DependenceTable(self, *args)


    def Gradient(self, *args) -> "void":
        """
        To compute the coefficients in the dimension <dim> of the j(e)'s gradient where e is the current element.

        Parameters
        ----------
        Dim: int
        G: math_Vector

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_ElementaryCriterion_Gradient(self, *args)


    def Hessian(self, *args) -> "void":
        """
        To compute j(e) the coefficients of hessian matrix of j(e) wich are crossed derivatives in dimensions <dim1> and <dim2>. if dependencetable(dimension1,dimension2) is false.

        Parameters
        ----------
        Dim1: int
        Dim2: int
        H: math_Matrix

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_ElementaryCriterion_Hessian(self, *args)


    def Set(self, *args) -> "void":
        """
        Set the coefficient of the element (the curve).

        Parameters
        ----------
        Coeff: TColStd_HArray2OfReal

        Returns
        -------
        None

        Set the definition interval of the element.

        Parameters
        ----------
        FirstKnot: float
        LastKnot: float

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_ElementaryCriterion_Set(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        To compute j(e) where e is the current element.

        Returns
        -------
        float

        """
        return _FEmTool.FEmTool_ElementaryCriterion_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_FEmTool_ElementaryCriterion_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _FEmTool.delete_FEmTool_ElementaryCriterion
    __del__ = lambda self: None
FEmTool_ElementaryCriterion_swigregister = _FEmTool.FEmTool_ElementaryCriterion_swigregister
FEmTool_ElementaryCriterion_swigregister(FEmTool_ElementaryCriterion)

class FEmTool_ElementsOfRefMatrix(OCC.Core.math.math_FunctionSet):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.math.math_FunctionSet]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FEmTool_ElementsOfRefMatrix, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.math.math_FunctionSet]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FEmTool_ElementsOfRefMatrix, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        TheBase: PLib_Base
        DerOrder: int

        Returns
        -------
        None

        """
        this = _FEmTool.new_FEmTool_ElementsOfRefMatrix(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    __repr__ = _dumps_object

    __swig_destroy__ = _FEmTool.delete_FEmTool_ElementsOfRefMatrix
    __del__ = lambda self: None
FEmTool_ElementsOfRefMatrix_swigregister = _FEmTool.FEmTool_ElementsOfRefMatrix_swigregister
FEmTool_ElementsOfRefMatrix_swigregister(FEmTool_ElementsOfRefMatrix)

class FEmTool_SparseMatrix(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FEmTool_SparseMatrix, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FEmTool_SparseMatrix, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ChangeValue(self, *args) -> "Standard_Real &":
        """
        No available documentation.

        Parameters
        ----------
        I: int
        J: int

        Returns
        -------
        float

        """
        return _FEmTool.FEmTool_SparseMatrix_ChangeValue(self, *args)


    def ColNumber(self, *args) -> "Standard_Integer":
        """
        Returns the column range of the matrix.

        Returns
        -------
        int

        """
        return _FEmTool.FEmTool_SparseMatrix_ColNumber(self, *args)


    def Decompose(self, *args) -> "Standard_Boolean":
        """
        To make a factorization of <self>.

        Returns
        -------
        bool

        """
        return _FEmTool.FEmTool_SparseMatrix_Decompose(self, *args)


    def Init(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        Value: float

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_SparseMatrix_Init(self, *args)


    def Multiplied(self, *args) -> "void":
        """
        Returns the product of a sparsematrix by a vector. an exception is raised if the dimensions are different.

        Parameters
        ----------
        X: math_Vector
        MX: math_Vector

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_SparseMatrix_Multiplied(self, *args)


    def Prepare(self, *args) -> "Standard_Boolean":
        """
        Make preparation to iterative solve.

        Returns
        -------
        bool

        """
        return _FEmTool.FEmTool_SparseMatrix_Prepare(self, *args)


    def RowNumber(self, *args) -> "Standard_Integer":
        """
        Returns the row range of a matrix.

        Returns
        -------
        int

        """
        return _FEmTool.FEmTool_SparseMatrix_RowNumber(self, *args)


    def Solve(self, *args) -> "void":
        """
        Direct solve of ax = b.

        Parameters
        ----------
        B: math_Vector
        X: math_Vector

        Returns
        -------
        None

        Iterative solve of ax = b.

        Parameters
        ----------
        B: math_Vector
        Init: math_Vector
        X: math_Vector
        Residual: math_Vector
        Tolerance: float,optional
        	default value is 1.0e-8
        NbIterations: int,optional
        	default value is 50

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_SparseMatrix_Solve(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_FEmTool_SparseMatrix_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _FEmTool.delete_FEmTool_SparseMatrix
    __del__ = lambda self: None
FEmTool_SparseMatrix_swigregister = _FEmTool.FEmTool_SparseMatrix_swigregister
FEmTool_SparseMatrix_swigregister(FEmTool_SparseMatrix)

class FEmTool_LinearFlexion(FEmTool_ElementaryCriterion):
    __swig_setmethods__ = {}
    for _s in [FEmTool_ElementaryCriterion]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FEmTool_LinearFlexion, name, value)
    __swig_getmethods__ = {}
    for _s in [FEmTool_ElementaryCriterion]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FEmTool_LinearFlexion, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        WorkDegree: int
        ConstraintOrder: GeomAbs_Shape

        Returns
        -------
        None

        """
        this = _FEmTool.new_FEmTool_LinearFlexion(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_FEmTool_LinearFlexion_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _FEmTool.delete_FEmTool_LinearFlexion
    __del__ = lambda self: None
FEmTool_LinearFlexion_swigregister = _FEmTool.FEmTool_LinearFlexion_swigregister
FEmTool_LinearFlexion_swigregister(FEmTool_LinearFlexion)

class FEmTool_LinearJerk(FEmTool_ElementaryCriterion):
    __swig_setmethods__ = {}
    for _s in [FEmTool_ElementaryCriterion]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FEmTool_LinearJerk, name, value)
    __swig_getmethods__ = {}
    for _s in [FEmTool_ElementaryCriterion]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FEmTool_LinearJerk, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        WorkDegree: int
        ConstraintOrder: GeomAbs_Shape

        Returns
        -------
        None

        """
        this = _FEmTool.new_FEmTool_LinearJerk(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_FEmTool_LinearJerk_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _FEmTool.delete_FEmTool_LinearJerk
    __del__ = lambda self: None
FEmTool_LinearJerk_swigregister = _FEmTool.FEmTool_LinearJerk_swigregister
FEmTool_LinearJerk_swigregister(FEmTool_LinearJerk)

class FEmTool_LinearTension(FEmTool_ElementaryCriterion):
    __swig_setmethods__ = {}
    for _s in [FEmTool_ElementaryCriterion]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FEmTool_LinearTension, name, value)
    __swig_getmethods__ = {}
    for _s in [FEmTool_ElementaryCriterion]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FEmTool_LinearTension, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        WorkDegree: int
        ConstraintOrder: GeomAbs_Shape

        Returns
        -------
        None

        """
        this = _FEmTool.new_FEmTool_LinearTension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_FEmTool_LinearTension_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _FEmTool.delete_FEmTool_LinearTension
    __del__ = lambda self: None
FEmTool_LinearTension_swigregister = _FEmTool.FEmTool_LinearTension_swigregister
FEmTool_LinearTension_swigregister(FEmTool_LinearTension)

class FEmTool_ProfileMatrix(FEmTool_SparseMatrix):
    __swig_setmethods__ = {}
    for _s in [FEmTool_SparseMatrix]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FEmTool_ProfileMatrix, name, value)
    __swig_getmethods__ = {}
    for _s in [FEmTool_SparseMatrix]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FEmTool_ProfileMatrix, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        FirstIndexes: TColStd_Array1OfInteger

        Returns
        -------
        None

        """
        this = _FEmTool.new_FEmTool_ProfileMatrix(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetChangeValue(self, I: 'Standard_Integer const', J: 'Standard_Integer const') -> "Standard_Real":
        """GetChangeValue(FEmTool_ProfileMatrix self, Standard_Integer const I, Standard_Integer const J) -> Standard_Real"""
        return _FEmTool.FEmTool_ProfileMatrix_GetChangeValue(self, I, J)


    def SetChangeValue(self, I: 'Standard_Integer const', J: 'Standard_Integer const', value: 'Standard_Real') -> "void":
        """SetChangeValue(FEmTool_ProfileMatrix self, Standard_Integer const I, Standard_Integer const J, Standard_Real value)"""
        return _FEmTool.FEmTool_ProfileMatrix_SetChangeValue(self, I, J, value)


    def IsInProfile(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Parameters
        ----------
        i: int
        j: int

        Returns
        -------
        bool

        """
        return _FEmTool.FEmTool_ProfileMatrix_IsInProfile(self, *args)


    def OutM(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_ProfileMatrix_OutM(self, *args)


    def OutS(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_ProfileMatrix_OutS(self, *args)


    def Solve(self, *args) -> "void":
        """
        Direct solve of ax = b.

        Parameters
        ----------
        B: math_Vector
        X: math_Vector

        Returns
        -------
        None

        Iterative solve of ax = b.

        Parameters
        ----------
        B: math_Vector
        Init: math_Vector
        X: math_Vector
        Residual: math_Vector
        Tolerance: float,optional
        	default value is 1.0e-8
        NbIterations: int,optional
        	default value is 50

        Returns
        -------
        None

        """
        return _FEmTool.FEmTool_ProfileMatrix_Solve(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_FEmTool_ProfileMatrix_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _FEmTool.delete_FEmTool_ProfileMatrix
    __del__ = lambda self: None
FEmTool_ProfileMatrix_swigregister = _FEmTool.FEmTool_ProfileMatrix_swigregister
FEmTool_ProfileMatrix_swigregister(FEmTool_ProfileMatrix)

class FEmTool_HAssemblyTable(FEmTool_AssemblyTable, OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [FEmTool_AssemblyTable, OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FEmTool_HAssemblyTable, name, value)
    __swig_getmethods__ = {}
    for _s in [FEmTool_AssemblyTable, OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FEmTool_HAssemblyTable, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _FEmTool.new_FEmTool_HAssemblyTable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Array2(self) -> "FEmTool_AssemblyTable const &":
        return _FEmTool.FEmTool_HAssemblyTable_Array2(self)

    def ChangeArray2(self) -> "FEmTool_AssemblyTable &":
        return _FEmTool.FEmTool_HAssemblyTable_ChangeArray2(self)


    @staticmethod
    def DownCast(t):
      return Handle_FEmTool_HAssemblyTable_DownCast(t)

    __swig_destroy__ = _FEmTool.delete_FEmTool_HAssemblyTable
    __del__ = lambda self: None
FEmTool_HAssemblyTable_swigregister = _FEmTool.FEmTool_HAssemblyTable_swigregister
FEmTool_HAssemblyTable_swigregister(FEmTool_HAssemblyTable)



# This file is compatible with both classic and new-style classes.


