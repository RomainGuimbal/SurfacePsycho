# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
MAT module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_mat.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_MAT')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_MAT')
    _MAT = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_MAT', [dirname(__file__)])
        except ImportError:
            import _MAT
            return _MAT
        try:
            _mod = imp.load_module('_MAT', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _MAT = swig_import_helper()
    del swig_import_helper
else:
    import _MAT
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _MAT.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _MAT.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _MAT.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _MAT.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _MAT.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _MAT.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _MAT.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _MAT.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _MAT.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _MAT.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _MAT.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _MAT.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _MAT.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _MAT.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _MAT.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _MAT.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _MAT.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _MAT.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _MAT.process_exception(error, method_name, class_name)
process_exception = _MAT.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection

from enum import IntEnum
from OCC.Core.Exception import *

MAT_Left = _MAT.MAT_Left
MAT_Right = _MAT.MAT_Right


class MAT_Side(IntEnum):
	MAT_Left = 0
	MAT_Right = 1
MAT_Left = MAT_Side.MAT_Left
MAT_Right = MAT_Side.MAT_Right


def Handle_MAT_Arc_Create() -> "opencascade::handle< MAT_Arc >":
    return _MAT.Handle_MAT_Arc_Create()
Handle_MAT_Arc_Create = _MAT.Handle_MAT_Arc_Create

def Handle_MAT_Arc_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_Arc >":
    return _MAT.Handle_MAT_Arc_DownCast(t)
Handle_MAT_Arc_DownCast = _MAT.Handle_MAT_Arc_DownCast

def Handle_MAT_Arc_IsNull(t: 'opencascade::handle< MAT_Arc > const &') -> "bool":
    return _MAT.Handle_MAT_Arc_IsNull(t)
Handle_MAT_Arc_IsNull = _MAT.Handle_MAT_Arc_IsNull

def Handle_MAT_BasicElt_Create() -> "opencascade::handle< MAT_BasicElt >":
    return _MAT.Handle_MAT_BasicElt_Create()
Handle_MAT_BasicElt_Create = _MAT.Handle_MAT_BasicElt_Create

def Handle_MAT_BasicElt_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_BasicElt >":
    return _MAT.Handle_MAT_BasicElt_DownCast(t)
Handle_MAT_BasicElt_DownCast = _MAT.Handle_MAT_BasicElt_DownCast

def Handle_MAT_BasicElt_IsNull(t: 'opencascade::handle< MAT_BasicElt > const &') -> "bool":
    return _MAT.Handle_MAT_BasicElt_IsNull(t)
Handle_MAT_BasicElt_IsNull = _MAT.Handle_MAT_BasicElt_IsNull

def Handle_MAT_Bisector_Create() -> "opencascade::handle< MAT_Bisector >":
    return _MAT.Handle_MAT_Bisector_Create()
Handle_MAT_Bisector_Create = _MAT.Handle_MAT_Bisector_Create

def Handle_MAT_Bisector_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_Bisector >":
    return _MAT.Handle_MAT_Bisector_DownCast(t)
Handle_MAT_Bisector_DownCast = _MAT.Handle_MAT_Bisector_DownCast

def Handle_MAT_Bisector_IsNull(t: 'opencascade::handle< MAT_Bisector > const &') -> "bool":
    return _MAT.Handle_MAT_Bisector_IsNull(t)
Handle_MAT_Bisector_IsNull = _MAT.Handle_MAT_Bisector_IsNull

def Handle_MAT_Edge_Create() -> "opencascade::handle< MAT_Edge >":
    return _MAT.Handle_MAT_Edge_Create()
Handle_MAT_Edge_Create = _MAT.Handle_MAT_Edge_Create

def Handle_MAT_Edge_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_Edge >":
    return _MAT.Handle_MAT_Edge_DownCast(t)
Handle_MAT_Edge_DownCast = _MAT.Handle_MAT_Edge_DownCast

def Handle_MAT_Edge_IsNull(t: 'opencascade::handle< MAT_Edge > const &') -> "bool":
    return _MAT.Handle_MAT_Edge_IsNull(t)
Handle_MAT_Edge_IsNull = _MAT.Handle_MAT_Edge_IsNull

def Handle_MAT_Graph_Create() -> "opencascade::handle< MAT_Graph >":
    return _MAT.Handle_MAT_Graph_Create()
Handle_MAT_Graph_Create = _MAT.Handle_MAT_Graph_Create

def Handle_MAT_Graph_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_Graph >":
    return _MAT.Handle_MAT_Graph_DownCast(t)
Handle_MAT_Graph_DownCast = _MAT.Handle_MAT_Graph_DownCast

def Handle_MAT_Graph_IsNull(t: 'opencascade::handle< MAT_Graph > const &') -> "bool":
    return _MAT.Handle_MAT_Graph_IsNull(t)
Handle_MAT_Graph_IsNull = _MAT.Handle_MAT_Graph_IsNull

def Handle_MAT_ListOfBisector_Create() -> "opencascade::handle< MAT_ListOfBisector >":
    return _MAT.Handle_MAT_ListOfBisector_Create()
Handle_MAT_ListOfBisector_Create = _MAT.Handle_MAT_ListOfBisector_Create

def Handle_MAT_ListOfBisector_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_ListOfBisector >":
    return _MAT.Handle_MAT_ListOfBisector_DownCast(t)
Handle_MAT_ListOfBisector_DownCast = _MAT.Handle_MAT_ListOfBisector_DownCast

def Handle_MAT_ListOfBisector_IsNull(t: 'opencascade::handle< MAT_ListOfBisector > const &') -> "bool":
    return _MAT.Handle_MAT_ListOfBisector_IsNull(t)
Handle_MAT_ListOfBisector_IsNull = _MAT.Handle_MAT_ListOfBisector_IsNull

def Handle_MAT_ListOfEdge_Create() -> "opencascade::handle< MAT_ListOfEdge >":
    return _MAT.Handle_MAT_ListOfEdge_Create()
Handle_MAT_ListOfEdge_Create = _MAT.Handle_MAT_ListOfEdge_Create

def Handle_MAT_ListOfEdge_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_ListOfEdge >":
    return _MAT.Handle_MAT_ListOfEdge_DownCast(t)
Handle_MAT_ListOfEdge_DownCast = _MAT.Handle_MAT_ListOfEdge_DownCast

def Handle_MAT_ListOfEdge_IsNull(t: 'opencascade::handle< MAT_ListOfEdge > const &') -> "bool":
    return _MAT.Handle_MAT_ListOfEdge_IsNull(t)
Handle_MAT_ListOfEdge_IsNull = _MAT.Handle_MAT_ListOfEdge_IsNull

def Handle_MAT_Node_Create() -> "opencascade::handle< MAT_Node >":
    return _MAT.Handle_MAT_Node_Create()
Handle_MAT_Node_Create = _MAT.Handle_MAT_Node_Create

def Handle_MAT_Node_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_Node >":
    return _MAT.Handle_MAT_Node_DownCast(t)
Handle_MAT_Node_DownCast = _MAT.Handle_MAT_Node_DownCast

def Handle_MAT_Node_IsNull(t: 'opencascade::handle< MAT_Node > const &') -> "bool":
    return _MAT.Handle_MAT_Node_IsNull(t)
Handle_MAT_Node_IsNull = _MAT.Handle_MAT_Node_IsNull

def Handle_MAT_TListNodeOfListOfBisector_Create() -> "opencascade::handle< MAT_TListNodeOfListOfBisector >":
    return _MAT.Handle_MAT_TListNodeOfListOfBisector_Create()
Handle_MAT_TListNodeOfListOfBisector_Create = _MAT.Handle_MAT_TListNodeOfListOfBisector_Create

def Handle_MAT_TListNodeOfListOfBisector_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_TListNodeOfListOfBisector >":
    return _MAT.Handle_MAT_TListNodeOfListOfBisector_DownCast(t)
Handle_MAT_TListNodeOfListOfBisector_DownCast = _MAT.Handle_MAT_TListNodeOfListOfBisector_DownCast

def Handle_MAT_TListNodeOfListOfBisector_IsNull(t: 'opencascade::handle< MAT_TListNodeOfListOfBisector > const &') -> "bool":
    return _MAT.Handle_MAT_TListNodeOfListOfBisector_IsNull(t)
Handle_MAT_TListNodeOfListOfBisector_IsNull = _MAT.Handle_MAT_TListNodeOfListOfBisector_IsNull

def Handle_MAT_TListNodeOfListOfEdge_Create() -> "opencascade::handle< MAT_TListNodeOfListOfEdge >":
    return _MAT.Handle_MAT_TListNodeOfListOfEdge_Create()
Handle_MAT_TListNodeOfListOfEdge_Create = _MAT.Handle_MAT_TListNodeOfListOfEdge_Create

def Handle_MAT_TListNodeOfListOfEdge_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_TListNodeOfListOfEdge >":
    return _MAT.Handle_MAT_TListNodeOfListOfEdge_DownCast(t)
Handle_MAT_TListNodeOfListOfEdge_DownCast = _MAT.Handle_MAT_TListNodeOfListOfEdge_DownCast

def Handle_MAT_TListNodeOfListOfEdge_IsNull(t: 'opencascade::handle< MAT_TListNodeOfListOfEdge > const &') -> "bool":
    return _MAT.Handle_MAT_TListNodeOfListOfEdge_IsNull(t)
Handle_MAT_TListNodeOfListOfEdge_IsNull = _MAT.Handle_MAT_TListNodeOfListOfEdge_IsNull

def Handle_MAT_Zone_Create() -> "opencascade::handle< MAT_Zone >":
    return _MAT.Handle_MAT_Zone_Create()
Handle_MAT_Zone_Create = _MAT.Handle_MAT_Zone_Create

def Handle_MAT_Zone_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< MAT_Zone >":
    return _MAT.Handle_MAT_Zone_DownCast(t)
Handle_MAT_Zone_DownCast = _MAT.Handle_MAT_Zone_DownCast

def Handle_MAT_Zone_IsNull(t: 'opencascade::handle< MAT_Zone > const &') -> "bool":
    return _MAT.Handle_MAT_Zone_IsNull(t)
Handle_MAT_Zone_IsNull = _MAT.Handle_MAT_Zone_IsNull
class MAT_DataMapOfIntegerArc(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MAT_DataMapOfIntegerArc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MAT_DataMapOfIntegerArc, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_DataMap< int,opencascade::handle< MAT_Arc >,TColStd_MapIntegerHasher >::iterator":
        return _MAT.MAT_DataMapOfIntegerArc_begin(self)

    def end(self) -> "NCollection_DataMap< int,opencascade::handle< MAT_Arc >,TColStd_MapIntegerHasher >::iterator":
        return _MAT.MAT_DataMapOfIntegerArc_end(self)

    def cbegin(self) -> "NCollection_DataMap< int,opencascade::handle< MAT_Arc >,TColStd_MapIntegerHasher >::const_iterator":
        return _MAT.MAT_DataMapOfIntegerArc_cbegin(self)

    def cend(self) -> "NCollection_DataMap< int,opencascade::handle< MAT_Arc >,TColStd_MapIntegerHasher >::const_iterator":
        return _MAT.MAT_DataMapOfIntegerArc_cend(self)

    def __init__(self, *args):
        this = _MAT.new_MAT_DataMapOfIntegerArc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, theOther: 'MAT_DataMapOfIntegerArc') -> "void":
        return _MAT.MAT_DataMapOfIntegerArc_Exchange(self, theOther)

    def Assign(self, theOther: 'MAT_DataMapOfIntegerArc') -> "NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_Arc >,TColStd_MapIntegerHasher > &":
        return _MAT.MAT_DataMapOfIntegerArc_Assign(self, theOther)

    def Set(self, theOther: 'MAT_DataMapOfIntegerArc') -> "NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_Arc >,TColStd_MapIntegerHasher > &":
        return _MAT.MAT_DataMapOfIntegerArc_Set(self, theOther)

    def ReSize(self, N: 'Standard_Integer const') -> "void":
        return _MAT.MAT_DataMapOfIntegerArc_ReSize(self, N)

    def Bind(self, theKey: 'int const &', theItem: 'opencascade::handle< MAT_Arc > const &') -> "Standard_Boolean":
        return _MAT.MAT_DataMapOfIntegerArc_Bind(self, theKey, theItem)

    def Bound(self, theKey: 'int const &', theItem: 'opencascade::handle< MAT_Arc > const &') -> "opencascade::handle< MAT_Arc > *":
        return _MAT.MAT_DataMapOfIntegerArc_Bound(self, theKey, theItem)

    def IsBound(self, theKey: 'int const &') -> "Standard_Boolean":
        return _MAT.MAT_DataMapOfIntegerArc_IsBound(self, theKey)

    def UnBind(self, theKey: 'int const &') -> "Standard_Boolean":
        return _MAT.MAT_DataMapOfIntegerArc_UnBind(self, theKey)

    def Seek(self, theKey: 'int const &') -> "opencascade::handle< MAT_Arc > const *":
        return _MAT.MAT_DataMapOfIntegerArc_Seek(self, theKey)

    def Find(self, *args) -> "Standard_Boolean":
        return _MAT.MAT_DataMapOfIntegerArc_Find(self, *args)

    def ChangeSeek(self, theKey: 'int const &') -> "opencascade::handle< MAT_Arc > *":
        return _MAT.MAT_DataMapOfIntegerArc_ChangeSeek(self, theKey)

    def ChangeFind(self, theKey: 'int const &') -> "opencascade::handle< MAT_Arc > &":
        return _MAT.MAT_DataMapOfIntegerArc_ChangeFind(self, theKey)

    def __call__(self, *args) -> "opencascade::handle< MAT_Arc > &":
        return _MAT.MAT_DataMapOfIntegerArc___call__(self, *args)

    def Clear(self, *args) -> "void":
        return _MAT.MAT_DataMapOfIntegerArc_Clear(self, *args)
    __swig_destroy__ = _MAT.delete_MAT_DataMapOfIntegerArc
    __del__ = lambda self: None

    def Size(self) -> "Standard_Integer":
        return _MAT.MAT_DataMapOfIntegerArc_Size(self)

    def Keys(self) -> "PyObject *":
        return _MAT.MAT_DataMapOfIntegerArc_Keys(self)
MAT_DataMapOfIntegerArc_swigregister = _MAT.MAT_DataMapOfIntegerArc_swigregister
MAT_DataMapOfIntegerArc_swigregister(MAT_DataMapOfIntegerArc)

class MAT_DataMapOfIntegerBasicElt(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MAT_DataMapOfIntegerBasicElt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MAT_DataMapOfIntegerBasicElt, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_DataMap< int,opencascade::handle< MAT_BasicElt >,TColStd_MapIntegerHasher >::iterator":
        return _MAT.MAT_DataMapOfIntegerBasicElt_begin(self)

    def end(self) -> "NCollection_DataMap< int,opencascade::handle< MAT_BasicElt >,TColStd_MapIntegerHasher >::iterator":
        return _MAT.MAT_DataMapOfIntegerBasicElt_end(self)

    def cbegin(self) -> "NCollection_DataMap< int,opencascade::handle< MAT_BasicElt >,TColStd_MapIntegerHasher >::const_iterator":
        return _MAT.MAT_DataMapOfIntegerBasicElt_cbegin(self)

    def cend(self) -> "NCollection_DataMap< int,opencascade::handle< MAT_BasicElt >,TColStd_MapIntegerHasher >::const_iterator":
        return _MAT.MAT_DataMapOfIntegerBasicElt_cend(self)

    def __init__(self, *args):
        this = _MAT.new_MAT_DataMapOfIntegerBasicElt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, theOther: 'MAT_DataMapOfIntegerBasicElt') -> "void":
        return _MAT.MAT_DataMapOfIntegerBasicElt_Exchange(self, theOther)

    def Assign(self, theOther: 'MAT_DataMapOfIntegerBasicElt') -> "NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_BasicElt >,TColStd_MapIntegerHasher > &":
        return _MAT.MAT_DataMapOfIntegerBasicElt_Assign(self, theOther)

    def Set(self, theOther: 'MAT_DataMapOfIntegerBasicElt') -> "NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_BasicElt >,TColStd_MapIntegerHasher > &":
        return _MAT.MAT_DataMapOfIntegerBasicElt_Set(self, theOther)

    def ReSize(self, N: 'Standard_Integer const') -> "void":
        return _MAT.MAT_DataMapOfIntegerBasicElt_ReSize(self, N)

    def Bind(self, theKey: 'int const &', theItem: 'opencascade::handle< MAT_BasicElt > const &') -> "Standard_Boolean":
        return _MAT.MAT_DataMapOfIntegerBasicElt_Bind(self, theKey, theItem)

    def Bound(self, theKey: 'int const &', theItem: 'opencascade::handle< MAT_BasicElt > const &') -> "opencascade::handle< MAT_BasicElt > *":
        return _MAT.MAT_DataMapOfIntegerBasicElt_Bound(self, theKey, theItem)

    def IsBound(self, theKey: 'int const &') -> "Standard_Boolean":
        return _MAT.MAT_DataMapOfIntegerBasicElt_IsBound(self, theKey)

    def UnBind(self, theKey: 'int const &') -> "Standard_Boolean":
        return _MAT.MAT_DataMapOfIntegerBasicElt_UnBind(self, theKey)

    def Seek(self, theKey: 'int const &') -> "opencascade::handle< MAT_BasicElt > const *":
        return _MAT.MAT_DataMapOfIntegerBasicElt_Seek(self, theKey)

    def Find(self, *args) -> "Standard_Boolean":
        return _MAT.MAT_DataMapOfIntegerBasicElt_Find(self, *args)

    def ChangeSeek(self, theKey: 'int const &') -> "opencascade::handle< MAT_BasicElt > *":
        return _MAT.MAT_DataMapOfIntegerBasicElt_ChangeSeek(self, theKey)

    def ChangeFind(self, theKey: 'int const &') -> "opencascade::handle< MAT_BasicElt > &":
        return _MAT.MAT_DataMapOfIntegerBasicElt_ChangeFind(self, theKey)

    def __call__(self, *args) -> "opencascade::handle< MAT_BasicElt > &":
        return _MAT.MAT_DataMapOfIntegerBasicElt___call__(self, *args)

    def Clear(self, *args) -> "void":
        return _MAT.MAT_DataMapOfIntegerBasicElt_Clear(self, *args)
    __swig_destroy__ = _MAT.delete_MAT_DataMapOfIntegerBasicElt
    __del__ = lambda self: None

    def Size(self) -> "Standard_Integer":
        return _MAT.MAT_DataMapOfIntegerBasicElt_Size(self)

    def Keys(self) -> "PyObject *":
        return _MAT.MAT_DataMapOfIntegerBasicElt_Keys(self)
MAT_DataMapOfIntegerBasicElt_swigregister = _MAT.MAT_DataMapOfIntegerBasicElt_swigregister
MAT_DataMapOfIntegerBasicElt_swigregister(MAT_DataMapOfIntegerBasicElt)

class MAT_DataMapOfIntegerBisector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MAT_DataMapOfIntegerBisector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MAT_DataMapOfIntegerBisector, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_DataMap< int,opencascade::handle< MAT_Bisector >,TColStd_MapIntegerHasher >::iterator":
        return _MAT.MAT_DataMapOfIntegerBisector_begin(self)

    def end(self) -> "NCollection_DataMap< int,opencascade::handle< MAT_Bisector >,TColStd_MapIntegerHasher >::iterator":
        return _MAT.MAT_DataMapOfIntegerBisector_end(self)

    def cbegin(self) -> "NCollection_DataMap< int,opencascade::handle< MAT_Bisector >,TColStd_MapIntegerHasher >::const_iterator":
        return _MAT.MAT_DataMapOfIntegerBisector_cbegin(self)

    def cend(self) -> "NCollection_DataMap< int,opencascade::handle< MAT_Bisector >,TColStd_MapIntegerHasher >::const_iterator":
        return _MAT.MAT_DataMapOfIntegerBisector_cend(self)

    def __init__(self, *args):
        this = _MAT.new_MAT_DataMapOfIntegerBisector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, theOther: 'MAT_DataMapOfIntegerBisector') -> "void":
        return _MAT.MAT_DataMapOfIntegerBisector_Exchange(self, theOther)

    def Assign(self, theOther: 'MAT_DataMapOfIntegerBisector') -> "NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_Bisector >,TColStd_MapIntegerHasher > &":
        return _MAT.MAT_DataMapOfIntegerBisector_Assign(self, theOther)

    def Set(self, theOther: 'MAT_DataMapOfIntegerBisector') -> "NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_Bisector >,TColStd_MapIntegerHasher > &":
        return _MAT.MAT_DataMapOfIntegerBisector_Set(self, theOther)

    def ReSize(self, N: 'Standard_Integer const') -> "void":
        return _MAT.MAT_DataMapOfIntegerBisector_ReSize(self, N)

    def Bind(self, theKey: 'int const &', theItem: 'opencascade::handle< MAT_Bisector > const &') -> "Standard_Boolean":
        return _MAT.MAT_DataMapOfIntegerBisector_Bind(self, theKey, theItem)

    def Bound(self, theKey: 'int const &', theItem: 'opencascade::handle< MAT_Bisector > const &') -> "opencascade::handle< MAT_Bisector > *":
        return _MAT.MAT_DataMapOfIntegerBisector_Bound(self, theKey, theItem)

    def IsBound(self, theKey: 'int const &') -> "Standard_Boolean":
        return _MAT.MAT_DataMapOfIntegerBisector_IsBound(self, theKey)

    def UnBind(self, theKey: 'int const &') -> "Standard_Boolean":
        return _MAT.MAT_DataMapOfIntegerBisector_UnBind(self, theKey)

    def Seek(self, theKey: 'int const &') -> "opencascade::handle< MAT_Bisector > const *":
        return _MAT.MAT_DataMapOfIntegerBisector_Seek(self, theKey)

    def Find(self, *args) -> "Standard_Boolean":
        return _MAT.MAT_DataMapOfIntegerBisector_Find(self, *args)

    def ChangeSeek(self, theKey: 'int const &') -> "opencascade::handle< MAT_Bisector > *":
        return _MAT.MAT_DataMapOfIntegerBisector_ChangeSeek(self, theKey)

    def ChangeFind(self, theKey: 'int const &') -> "opencascade::handle< MAT_Bisector > &":
        return _MAT.MAT_DataMapOfIntegerBisector_ChangeFind(self, theKey)

    def __call__(self, *args) -> "opencascade::handle< MAT_Bisector > &":
        return _MAT.MAT_DataMapOfIntegerBisector___call__(self, *args)

    def Clear(self, *args) -> "void":
        return _MAT.MAT_DataMapOfIntegerBisector_Clear(self, *args)
    __swig_destroy__ = _MAT.delete_MAT_DataMapOfIntegerBisector
    __del__ = lambda self: None

    def Size(self) -> "Standard_Integer":
        return _MAT.MAT_DataMapOfIntegerBisector_Size(self)

    def Keys(self) -> "PyObject *":
        return _MAT.MAT_DataMapOfIntegerBisector_Keys(self)
MAT_DataMapOfIntegerBisector_swigregister = _MAT.MAT_DataMapOfIntegerBisector_swigregister
MAT_DataMapOfIntegerBisector_swigregister(MAT_DataMapOfIntegerBisector)

class MAT_DataMapOfIntegerNode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MAT_DataMapOfIntegerNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MAT_DataMapOfIntegerNode, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_DataMap< int,opencascade::handle< MAT_Node >,TColStd_MapIntegerHasher >::iterator":
        return _MAT.MAT_DataMapOfIntegerNode_begin(self)

    def end(self) -> "NCollection_DataMap< int,opencascade::handle< MAT_Node >,TColStd_MapIntegerHasher >::iterator":
        return _MAT.MAT_DataMapOfIntegerNode_end(self)

    def cbegin(self) -> "NCollection_DataMap< int,opencascade::handle< MAT_Node >,TColStd_MapIntegerHasher >::const_iterator":
        return _MAT.MAT_DataMapOfIntegerNode_cbegin(self)

    def cend(self) -> "NCollection_DataMap< int,opencascade::handle< MAT_Node >,TColStd_MapIntegerHasher >::const_iterator":
        return _MAT.MAT_DataMapOfIntegerNode_cend(self)

    def __init__(self, *args):
        this = _MAT.new_MAT_DataMapOfIntegerNode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, theOther: 'MAT_DataMapOfIntegerNode') -> "void":
        return _MAT.MAT_DataMapOfIntegerNode_Exchange(self, theOther)

    def Assign(self, theOther: 'MAT_DataMapOfIntegerNode') -> "NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_Node >,TColStd_MapIntegerHasher > &":
        return _MAT.MAT_DataMapOfIntegerNode_Assign(self, theOther)

    def Set(self, theOther: 'MAT_DataMapOfIntegerNode') -> "NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_Node >,TColStd_MapIntegerHasher > &":
        return _MAT.MAT_DataMapOfIntegerNode_Set(self, theOther)

    def ReSize(self, N: 'Standard_Integer const') -> "void":
        return _MAT.MAT_DataMapOfIntegerNode_ReSize(self, N)

    def Bind(self, theKey: 'int const &', theItem: 'opencascade::handle< MAT_Node > const &') -> "Standard_Boolean":
        return _MAT.MAT_DataMapOfIntegerNode_Bind(self, theKey, theItem)

    def Bound(self, theKey: 'int const &', theItem: 'opencascade::handle< MAT_Node > const &') -> "opencascade::handle< MAT_Node > *":
        return _MAT.MAT_DataMapOfIntegerNode_Bound(self, theKey, theItem)

    def IsBound(self, theKey: 'int const &') -> "Standard_Boolean":
        return _MAT.MAT_DataMapOfIntegerNode_IsBound(self, theKey)

    def UnBind(self, theKey: 'int const &') -> "Standard_Boolean":
        return _MAT.MAT_DataMapOfIntegerNode_UnBind(self, theKey)

    def Seek(self, theKey: 'int const &') -> "opencascade::handle< MAT_Node > const *":
        return _MAT.MAT_DataMapOfIntegerNode_Seek(self, theKey)

    def Find(self, *args) -> "Standard_Boolean":
        return _MAT.MAT_DataMapOfIntegerNode_Find(self, *args)

    def ChangeSeek(self, theKey: 'int const &') -> "opencascade::handle< MAT_Node > *":
        return _MAT.MAT_DataMapOfIntegerNode_ChangeSeek(self, theKey)

    def ChangeFind(self, theKey: 'int const &') -> "opencascade::handle< MAT_Node > &":
        return _MAT.MAT_DataMapOfIntegerNode_ChangeFind(self, theKey)

    def __call__(self, *args) -> "opencascade::handle< MAT_Node > &":
        return _MAT.MAT_DataMapOfIntegerNode___call__(self, *args)

    def Clear(self, *args) -> "void":
        return _MAT.MAT_DataMapOfIntegerNode_Clear(self, *args)
    __swig_destroy__ = _MAT.delete_MAT_DataMapOfIntegerNode
    __del__ = lambda self: None

    def Size(self) -> "Standard_Integer":
        return _MAT.MAT_DataMapOfIntegerNode_Size(self)

    def Keys(self) -> "PyObject *":
        return _MAT.MAT_DataMapOfIntegerNode_Keys(self)
MAT_DataMapOfIntegerNode_swigregister = _MAT.MAT_DataMapOfIntegerNode_swigregister
MAT_DataMapOfIntegerNode_swigregister(MAT_DataMapOfIntegerNode)

class MAT_SequenceOfArc(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MAT_SequenceOfArc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MAT_SequenceOfArc, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Sequence< opencascade::handle< MAT_Arc > >::iterator":
        return _MAT.MAT_SequenceOfArc_begin(self)

    def end(self) -> "NCollection_Sequence< opencascade::handle< MAT_Arc > >::iterator":
        return _MAT.MAT_SequenceOfArc_end(self)

    def cbegin(self) -> "NCollection_Sequence< opencascade::handle< MAT_Arc > >::const_iterator":
        return _MAT.MAT_SequenceOfArc_cbegin(self)

    def cend(self) -> "NCollection_Sequence< opencascade::handle< MAT_Arc > >::const_iterator":
        return _MAT.MAT_SequenceOfArc_cend(self)

    def __init__(self, *args):
        this = _MAT.new_MAT_SequenceOfArc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self) -> "Standard_Integer":
        return _MAT.MAT_SequenceOfArc_Size(self)

    def Length(self) -> "Standard_Integer":
        return _MAT.MAT_SequenceOfArc_Length(self)

    def Lower(self) -> "Standard_Integer":
        return _MAT.MAT_SequenceOfArc_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _MAT.MAT_SequenceOfArc_Upper(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _MAT.MAT_SequenceOfArc_IsEmpty(self)

    def Reverse(self) -> "void":
        return _MAT.MAT_SequenceOfArc_Reverse(self)

    def Exchange(self, I: 'Standard_Integer const', J: 'Standard_Integer const') -> "void":
        return _MAT.MAT_SequenceOfArc_Exchange(self, I, J)
    if _newclass:
        delNode = staticmethod(_MAT.MAT_SequenceOfArc_delNode)
    else:
        delNode = _MAT.MAT_SequenceOfArc_delNode

    def Clear(self, theAllocator: 'opencascade::handle< NCollection_BaseAllocator > const &'=0) -> "void":
        return _MAT.MAT_SequenceOfArc_Clear(self, theAllocator)

    def Assign(self, theOther: 'MAT_SequenceOfArc') -> "NCollection_Sequence< opencascade::handle< MAT_Arc > > &":
        return _MAT.MAT_SequenceOfArc_Assign(self, theOther)

    def Set(self, theOther: 'MAT_SequenceOfArc') -> "NCollection_Sequence< opencascade::handle< MAT_Arc > > &":
        return _MAT.MAT_SequenceOfArc_Set(self, theOther)

    def Remove(self, *args) -> "void":
        return _MAT.MAT_SequenceOfArc_Remove(self, *args)

    def Append(self, *args) -> "void":
        return _MAT.MAT_SequenceOfArc_Append(self, *args)

    def Prepend(self, *args) -> "void":
        return _MAT.MAT_SequenceOfArc_Prepend(self, *args)

    def InsertBefore(self, *args) -> "void":
        return _MAT.MAT_SequenceOfArc_InsertBefore(self, *args)

    def InsertAfter(self, *args) -> "void":
        return _MAT.MAT_SequenceOfArc_InsertAfter(self, *args)

    def Split(self, theIndex: 'Standard_Integer const', theSeq: 'MAT_SequenceOfArc') -> "void":
        return _MAT.MAT_SequenceOfArc_Split(self, theIndex, theSeq)

    def First(self) -> "opencascade::handle< MAT_Arc > const &":
        return _MAT.MAT_SequenceOfArc_First(self)

    def ChangeFirst(self) -> "opencascade::handle< MAT_Arc > &":
        return _MAT.MAT_SequenceOfArc_ChangeFirst(self)

    def Last(self) -> "opencascade::handle< MAT_Arc > const &":
        return _MAT.MAT_SequenceOfArc_Last(self)

    def ChangeLast(self) -> "opencascade::handle< MAT_Arc > &":
        return _MAT.MAT_SequenceOfArc_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< MAT_Arc > const &":
        return _MAT.MAT_SequenceOfArc_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< MAT_Arc > &":
        return _MAT.MAT_SequenceOfArc_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "opencascade::handle< MAT_Arc > &":
        return _MAT.MAT_SequenceOfArc___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'opencascade::handle< MAT_Arc > const &') -> "void":
        return _MAT.MAT_SequenceOfArc_SetValue(self, theIndex, theItem)
    __swig_destroy__ = _MAT.delete_MAT_SequenceOfArc
    __del__ = lambda self: None

    def __len__(self):
        return self.Size()

MAT_SequenceOfArc_swigregister = _MAT.MAT_SequenceOfArc_swigregister
MAT_SequenceOfArc_swigregister(MAT_SequenceOfArc)

def MAT_SequenceOfArc_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _MAT.MAT_SequenceOfArc_delNode(theNode, theAl)
MAT_SequenceOfArc_delNode = _MAT.MAT_SequenceOfArc_delNode

class MAT_SequenceOfBasicElt(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MAT_SequenceOfBasicElt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MAT_SequenceOfBasicElt, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Sequence< opencascade::handle< MAT_BasicElt > >::iterator":
        return _MAT.MAT_SequenceOfBasicElt_begin(self)

    def end(self) -> "NCollection_Sequence< opencascade::handle< MAT_BasicElt > >::iterator":
        return _MAT.MAT_SequenceOfBasicElt_end(self)

    def cbegin(self) -> "NCollection_Sequence< opencascade::handle< MAT_BasicElt > >::const_iterator":
        return _MAT.MAT_SequenceOfBasicElt_cbegin(self)

    def cend(self) -> "NCollection_Sequence< opencascade::handle< MAT_BasicElt > >::const_iterator":
        return _MAT.MAT_SequenceOfBasicElt_cend(self)

    def __init__(self, *args):
        this = _MAT.new_MAT_SequenceOfBasicElt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self) -> "Standard_Integer":
        return _MAT.MAT_SequenceOfBasicElt_Size(self)

    def Length(self) -> "Standard_Integer":
        return _MAT.MAT_SequenceOfBasicElt_Length(self)

    def Lower(self) -> "Standard_Integer":
        return _MAT.MAT_SequenceOfBasicElt_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _MAT.MAT_SequenceOfBasicElt_Upper(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _MAT.MAT_SequenceOfBasicElt_IsEmpty(self)

    def Reverse(self) -> "void":
        return _MAT.MAT_SequenceOfBasicElt_Reverse(self)

    def Exchange(self, I: 'Standard_Integer const', J: 'Standard_Integer const') -> "void":
        return _MAT.MAT_SequenceOfBasicElt_Exchange(self, I, J)
    if _newclass:
        delNode = staticmethod(_MAT.MAT_SequenceOfBasicElt_delNode)
    else:
        delNode = _MAT.MAT_SequenceOfBasicElt_delNode

    def Clear(self, theAllocator: 'opencascade::handle< NCollection_BaseAllocator > const &'=0) -> "void":
        return _MAT.MAT_SequenceOfBasicElt_Clear(self, theAllocator)

    def Assign(self, theOther: 'MAT_SequenceOfBasicElt') -> "NCollection_Sequence< opencascade::handle< MAT_BasicElt > > &":
        return _MAT.MAT_SequenceOfBasicElt_Assign(self, theOther)

    def Set(self, theOther: 'MAT_SequenceOfBasicElt') -> "NCollection_Sequence< opencascade::handle< MAT_BasicElt > > &":
        return _MAT.MAT_SequenceOfBasicElt_Set(self, theOther)

    def Remove(self, *args) -> "void":
        return _MAT.MAT_SequenceOfBasicElt_Remove(self, *args)

    def Append(self, *args) -> "void":
        return _MAT.MAT_SequenceOfBasicElt_Append(self, *args)

    def Prepend(self, *args) -> "void":
        return _MAT.MAT_SequenceOfBasicElt_Prepend(self, *args)

    def InsertBefore(self, *args) -> "void":
        return _MAT.MAT_SequenceOfBasicElt_InsertBefore(self, *args)

    def InsertAfter(self, *args) -> "void":
        return _MAT.MAT_SequenceOfBasicElt_InsertAfter(self, *args)

    def Split(self, theIndex: 'Standard_Integer const', theSeq: 'MAT_SequenceOfBasicElt') -> "void":
        return _MAT.MAT_SequenceOfBasicElt_Split(self, theIndex, theSeq)

    def First(self) -> "opencascade::handle< MAT_BasicElt > const &":
        return _MAT.MAT_SequenceOfBasicElt_First(self)

    def ChangeFirst(self) -> "opencascade::handle< MAT_BasicElt > &":
        return _MAT.MAT_SequenceOfBasicElt_ChangeFirst(self)

    def Last(self) -> "opencascade::handle< MAT_BasicElt > const &":
        return _MAT.MAT_SequenceOfBasicElt_Last(self)

    def ChangeLast(self) -> "opencascade::handle< MAT_BasicElt > &":
        return _MAT.MAT_SequenceOfBasicElt_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< MAT_BasicElt > const &":
        return _MAT.MAT_SequenceOfBasicElt_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< MAT_BasicElt > &":
        return _MAT.MAT_SequenceOfBasicElt_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "opencascade::handle< MAT_BasicElt > &":
        return _MAT.MAT_SequenceOfBasicElt___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'opencascade::handle< MAT_BasicElt > const &') -> "void":
        return _MAT.MAT_SequenceOfBasicElt_SetValue(self, theIndex, theItem)
    __swig_destroy__ = _MAT.delete_MAT_SequenceOfBasicElt
    __del__ = lambda self: None

    def __len__(self):
        return self.Size()

MAT_SequenceOfBasicElt_swigregister = _MAT.MAT_SequenceOfBasicElt_swigregister
MAT_SequenceOfBasicElt_swigregister(MAT_SequenceOfBasicElt)

def MAT_SequenceOfBasicElt_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _MAT.MAT_SequenceOfBasicElt_delNode(theNode, theAl)
MAT_SequenceOfBasicElt_delNode = _MAT.MAT_SequenceOfBasicElt_delNode

class MAT_Arc(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MAT_Arc, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MAT_Arc, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        ArcIndex: int
        GeomIndex: int
        FirstElement: MAT_BasicElt
        SecondElement: MAT_BasicElt

        Returns
        -------
        None

        """
        this = _MAT.new_MAT_Arc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def FirstElement(self, *args) -> "opencascade::handle< MAT_BasicElt >":
        """
        Returns one of the basicelt equidistant from <self>.

        Returns
        -------
        opencascade::handle<MAT_BasicElt>

        """
        return _MAT.MAT_Arc_FirstElement(self, *args)


    def FirstNode(self, *args) -> "opencascade::handle< MAT_Node >":
        """
        Returns one node extremity of <self>.

        Returns
        -------
        opencascade::handle<MAT_Node>

        """
        return _MAT.MAT_Arc_FirstNode(self, *args)


    def GeomIndex(self, *args) -> "Standard_Integer":
        """
        Returns the index associated of the geometric representation of <self>.

        Returns
        -------
        int

        """
        return _MAT.MAT_Arc_GeomIndex(self, *args)


    def HasNeighbour(self, *args) -> "Standard_Boolean":
        """
        Returnst true is there is an arc linked to the node <anode> located on the side <aside> of <self>; if <anode> is not on <self>.

        Parameters
        ----------
        aNode: MAT_Node
        aSide: MAT_Side

        Returns
        -------
        bool

        """
        return _MAT.MAT_Arc_HasNeighbour(self, *args)


    def Index(self, *args) -> "Standard_Integer":
        """
        Returns the index of <self> in graph.thearcs.

        Returns
        -------
        int

        """
        return _MAT.MAT_Arc_Index(self, *args)


    def Neighbour(self, *args) -> "opencascade::handle< MAT_Arc >":
        """
        Returns the first arc linked to the node <anode> located on the side <aside> of <self>; if hasneighbour() returns false.

        Parameters
        ----------
        aNode: MAT_Node
        aSide: MAT_Side

        Returns
        -------
        opencascade::handle<MAT_Arc>

        """
        return _MAT.MAT_Arc_Neighbour(self, *args)


    def SecondElement(self, *args) -> "opencascade::handle< MAT_BasicElt >":
        """
        Returns the other basicelt equidistant from <self>.

        Returns
        -------
        opencascade::handle<MAT_BasicElt>

        """
        return _MAT.MAT_Arc_SecondElement(self, *args)


    def SecondNode(self, *args) -> "opencascade::handle< MAT_Node >":
        """
        Returns the other node extremity of <self>.

        Returns
        -------
        opencascade::handle<MAT_Node>

        """
        return _MAT.MAT_Arc_SecondNode(self, *args)


    def SetFirstArc(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        aSide: MAT_Side
        anArc: MAT_Arc

        Returns
        -------
        None

        """
        return _MAT.MAT_Arc_SetFirstArc(self, *args)


    def SetFirstElement(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        aBasicElt: MAT_BasicElt

        Returns
        -------
        None

        """
        return _MAT.MAT_Arc_SetFirstElement(self, *args)


    def SetFirstNode(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        aNode: MAT_Node

        Returns
        -------
        None

        """
        return _MAT.MAT_Arc_SetFirstNode(self, *args)


    def SetGeomIndex(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        anInteger: int

        Returns
        -------
        None

        """
        return _MAT.MAT_Arc_SetGeomIndex(self, *args)


    def SetIndex(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        anInteger: int

        Returns
        -------
        None

        """
        return _MAT.MAT_Arc_SetIndex(self, *args)


    def SetNeighbour(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        aSide: MAT_Side
        aNode: MAT_Node
        anArc: MAT_Arc

        Returns
        -------
        None

        """
        return _MAT.MAT_Arc_SetNeighbour(self, *args)


    def SetSecondArc(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        aSide: MAT_Side
        anArc: MAT_Arc

        Returns
        -------
        None

        """
        return _MAT.MAT_Arc_SetSecondArc(self, *args)


    def SetSecondElement(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        aBasicElt: MAT_BasicElt

        Returns
        -------
        None

        """
        return _MAT.MAT_Arc_SetSecondElement(self, *args)


    def SetSecondNode(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        aNode: MAT_Node

        Returns
        -------
        None

        """
        return _MAT.MAT_Arc_SetSecondNode(self, *args)


    def TheOtherNode(self, *args) -> "opencascade::handle< MAT_Node >":
        """
        An arc has two node, if <anode> egal one returns the other. //! if <anode> is not oh <self>.

        Parameters
        ----------
        aNode: MAT_Node

        Returns
        -------
        opencascade::handle<MAT_Node>

        """
        return _MAT.MAT_Arc_TheOtherNode(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_Arc_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_Arc
    __del__ = lambda self: None
MAT_Arc_swigregister = _MAT.MAT_Arc_swigregister
MAT_Arc_swigregister(MAT_Arc)

class MAT_BasicElt(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MAT_BasicElt, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MAT_BasicElt, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Constructor, <aninteger> is the <index> of <self>.

        Parameters
        ----------
        anInteger: int

        Returns
        -------
        None

        """
        this = _MAT.new_MAT_BasicElt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def EndArc(self, *args) -> "opencascade::handle< MAT_Arc >":
        """
        Return <endarcleft> or <endarcright> corresponding to <aside>.

        Returns
        -------
        opencascade::handle<MAT_Arc>

        """
        return _MAT.MAT_BasicElt_EndArc(self, *args)


    def GeomIndex(self, *args) -> "Standard_Integer":
        """
        Return the <geomindex> of <self>.

        Returns
        -------
        int

        """
        return _MAT.MAT_BasicElt_GeomIndex(self, *args)


    def Index(self, *args) -> "Standard_Integer":
        """
        Return the <index> of <self> in graph.thebasicelts.

        Returns
        -------
        int

        """
        return _MAT.MAT_BasicElt_Index(self, *args)


    def SetEndArc(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        anArc: MAT_Arc

        Returns
        -------
        None

        """
        return _MAT.MAT_BasicElt_SetEndArc(self, *args)


    def SetGeomIndex(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        anInteger: int

        Returns
        -------
        None

        """
        return _MAT.MAT_BasicElt_SetGeomIndex(self, *args)


    def SetIndex(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        anInteger: int

        Returns
        -------
        None

        """
        return _MAT.MAT_BasicElt_SetIndex(self, *args)


    def SetStartArc(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        anArc: MAT_Arc

        Returns
        -------
        None

        """
        return _MAT.MAT_BasicElt_SetStartArc(self, *args)


    def StartArc(self, *args) -> "opencascade::handle< MAT_Arc >":
        """
        Return <startarcleft> or <startarcright> corresponding to <aside>.

        Returns
        -------
        opencascade::handle<MAT_Arc>

        """
        return _MAT.MAT_BasicElt_StartArc(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_BasicElt_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_BasicElt
    __del__ = lambda self: None
MAT_BasicElt_swigregister = _MAT.MAT_BasicElt_swigregister
MAT_BasicElt_swigregister(MAT_BasicElt)

class MAT_Bisector(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MAT_Bisector, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MAT_Bisector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        """
        this = _MAT.new_MAT_Bisector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddBisector(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        abisector: MAT_Bisector

        Returns
        -------
        None

        """
        return _MAT.MAT_Bisector_AddBisector(self, *args)


    def BisectorNumber(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Parameters
        ----------
        anumber: int

        Returns
        -------
        None

        No available documentation.

        Returns
        -------
        int

        """
        return _MAT.MAT_Bisector_BisectorNumber(self, *args)


    def DistIssuePoint(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Parameters
        ----------
        areal: float

        Returns
        -------
        None

        No available documentation.

        Returns
        -------
        float

        """
        return _MAT.MAT_Bisector_DistIssuePoint(self, *args)


    def Dump(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        ashift: int
        alevel: int

        Returns
        -------
        None

        """
        return _MAT.MAT_Bisector_Dump(self, *args)


    def EndPoint(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Parameters
        ----------
        apoint: int

        Returns
        -------
        None

        No available documentation.

        Returns
        -------
        int

        """
        return _MAT.MAT_Bisector_EndPoint(self, *args)


    def FirstBisector(self, *args) -> "opencascade::handle< MAT_Bisector >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_Bisector>

        """
        return _MAT.MAT_Bisector_FirstBisector(self, *args)


    def FirstEdge(self, *args) -> "opencascade::handle< MAT_Edge >":
        """
        No available documentation.

        Parameters
        ----------
        anedge: MAT_Edge

        Returns
        -------
        None

        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_Edge>

        """
        return _MAT.MAT_Bisector_FirstEdge(self, *args)


    def FirstParameter(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Parameters
        ----------
        aparameter: float

        Returns
        -------
        None

        No available documentation.

        Returns
        -------
        float

        """
        return _MAT.MAT_Bisector_FirstParameter(self, *args)


    def FirstVector(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Parameters
        ----------
        avector: int

        Returns
        -------
        None

        No available documentation.

        Returns
        -------
        int

        """
        return _MAT.MAT_Bisector_FirstVector(self, *args)


    def IndexNumber(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Parameters
        ----------
        anumber: int

        Returns
        -------
        None

        No available documentation.

        Returns
        -------
        int

        """
        return _MAT.MAT_Bisector_IndexNumber(self, *args)


    def IssuePoint(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Parameters
        ----------
        apoint: int

        Returns
        -------
        None

        No available documentation.

        Returns
        -------
        int

        """
        return _MAT.MAT_Bisector_IssuePoint(self, *args)


    def LastBisector(self, *args) -> "opencascade::handle< MAT_Bisector >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_Bisector>

        """
        return _MAT.MAT_Bisector_LastBisector(self, *args)


    def List(self, *args) -> "opencascade::handle< MAT_ListOfBisector >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_ListOfBisector>

        """
        return _MAT.MAT_Bisector_List(self, *args)


    def SecondEdge(self, *args) -> "opencascade::handle< MAT_Edge >":
        """
        No available documentation.

        Parameters
        ----------
        anedge: MAT_Edge

        Returns
        -------
        None

        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_Edge>

        """
        return _MAT.MAT_Bisector_SecondEdge(self, *args)


    def SecondParameter(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Parameters
        ----------
        aparameter: float

        Returns
        -------
        None

        No available documentation.

        Returns
        -------
        float

        """
        return _MAT.MAT_Bisector_SecondParameter(self, *args)


    def SecondVector(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Parameters
        ----------
        avector: int

        Returns
        -------
        None

        No available documentation.

        Returns
        -------
        int

        """
        return _MAT.MAT_Bisector_SecondVector(self, *args)


    def Sense(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Parameters
        ----------
        asense: float

        Returns
        -------
        None

        No available documentation.

        Returns
        -------
        float

        """
        return _MAT.MAT_Bisector_Sense(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_Bisector_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_Bisector
    __del__ = lambda self: None
MAT_Bisector_swigregister = _MAT.MAT_Bisector_swigregister
MAT_Bisector_swigregister(MAT_Bisector)

class MAT_Edge(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MAT_Edge, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MAT_Edge, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        """
        this = _MAT.new_MAT_Edge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Distance(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Parameters
        ----------
        adistance: float

        Returns
        -------
        None

        No available documentation.

        Returns
        -------
        float

        """
        return _MAT.MAT_Edge_Distance(self, *args)


    def Dump(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        ashift: int
        alevel: int

        Returns
        -------
        None

        """
        return _MAT.MAT_Edge_Dump(self, *args)


    def EdgeNumber(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Parameters
        ----------
        anumber: int

        Returns
        -------
        None

        No available documentation.

        Returns
        -------
        int

        """
        return _MAT.MAT_Edge_EdgeNumber(self, *args)


    def FirstBisector(self, *args) -> "opencascade::handle< MAT_Bisector >":
        """
        No available documentation.

        Parameters
        ----------
        abisector: MAT_Bisector

        Returns
        -------
        None

        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_Bisector>

        """
        return _MAT.MAT_Edge_FirstBisector(self, *args)


    def IntersectionPoint(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Parameters
        ----------
        apoint: int

        Returns
        -------
        None

        No available documentation.

        Returns
        -------
        int

        """
        return _MAT.MAT_Edge_IntersectionPoint(self, *args)


    def SecondBisector(self, *args) -> "opencascade::handle< MAT_Bisector >":
        """
        No available documentation.

        Parameters
        ----------
        abisector: MAT_Bisector

        Returns
        -------
        None

        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_Bisector>

        """
        return _MAT.MAT_Edge_SecondBisector(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_Edge_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_Edge
    __del__ = lambda self: None
MAT_Edge_swigregister = _MAT.MAT_Edge_swigregister
MAT_Edge_swigregister(MAT_Edge)

class MAT_Graph(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MAT_Graph, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MAT_Graph, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Empty constructor.

        Returns
        -------
        None

        """
        this = _MAT.new_MAT_Graph(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Arc(self, *args) -> "opencascade::handle< MAT_Arc >":
        """
        Return the arc of index <index> in <thearcs>.

        Parameters
        ----------
        Index: int

        Returns
        -------
        opencascade::handle<MAT_Arc>

        """
        return _MAT.MAT_Graph_Arc(self, *args)


    def BasicElt(self, *args) -> "opencascade::handle< MAT_BasicElt >":
        """
        Return the basicelt of index <index> in <thebasicelts>.

        Parameters
        ----------
        Index: int

        Returns
        -------
        opencascade::handle<MAT_BasicElt>

        """
        return _MAT.MAT_Graph_BasicElt(self, *args)


    def ChangeBasicElt(self, *args) -> "opencascade::handle< MAT_BasicElt >":
        """
        No available documentation.

        Parameters
        ----------
        Index: int

        Returns
        -------
        opencascade::handle<MAT_BasicElt>

        """
        return _MAT.MAT_Graph_ChangeBasicElt(self, *args)


    def ChangeBasicElts(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        NewMap: MAT_DataMapOfIntegerBasicElt

        Returns
        -------
        None

        """
        return _MAT.MAT_Graph_ChangeBasicElts(self, *args)


    def CompactArcs(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _MAT.MAT_Graph_CompactArcs(self, *args)


    def CompactNodes(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _MAT.MAT_Graph_CompactNodes(self, *args)


    def FusionOfBasicElts(self, *args) -> "void":
        """
        Merge two basicelts. the end of the basicelt elt1 of indexelt1 becomes the end of the basicelt elt2 of indexelt2. elt2 is replaced in the arcs by elt1, elt2 is eliminated. //! <mergearc1> is true if the fusion of the basicelts => a fusion of two arcs which separated the same elements. in this case <geomindexarc1> and <geomindexarc2> are the geometric index of this arcs. //! if the basicelt corresponds to a close line , the startarc and the endarc of elt1 can separate the same elements . in this case there is a fusion of this arcs, <mergearc2> is true and <geomindexarc3> and <geomindexarc4> are the geometric index of this arcs.

        Parameters
        ----------
        IndexElt1: int
        IndexElt2: int

        Returns
        -------
        MergeArc1: bool
        GeomIndexArc1: int
        GeomIndexArc2: int
        MergeArc2: bool
        GeomIndexArc3: int
        GeomIndexArc4: int

        """
        return _MAT.MAT_Graph_FusionOfBasicElts(self, *args)


    def Node(self, *args) -> "opencascade::handle< MAT_Node >":
        """
        Return the node of index <index> in <thenodes>.

        Parameters
        ----------
        Index: int

        Returns
        -------
        opencascade::handle<MAT_Node>

        """
        return _MAT.MAT_Graph_Node(self, *args)


    def NumberOfArcs(self, *args) -> "Standard_Integer":
        """
        Return the number of arcs of <self>.

        Returns
        -------
        int

        """
        return _MAT.MAT_Graph_NumberOfArcs(self, *args)


    def NumberOfBasicElts(self, *args) -> "Standard_Integer":
        """
        Return the number of basic elements of <self>.

        Returns
        -------
        int

        """
        return _MAT.MAT_Graph_NumberOfBasicElts(self, *args)


    def NumberOfInfiniteNodes(self, *args) -> "Standard_Integer":
        """
        Return the number of infinites nodes of <self>.

        Returns
        -------
        int

        """
        return _MAT.MAT_Graph_NumberOfInfiniteNodes(self, *args)


    def NumberOfNodes(self, *args) -> "Standard_Integer":
        """
        Return the number of nodes of <self>.

        Returns
        -------
        int

        """
        return _MAT.MAT_Graph_NumberOfNodes(self, *args)


    def Perform(self, *args) -> "void":
        """
        Construct <self> from the result of the method <createmat> of the class <mat> from <mat>. //! <semiinfinite> : if some bisector are infinites. <theroots> : set of the bisectors. <nbbasicelts> : number of basic elements. <nbarcs> : number of arcs = number of bisectors.

        Parameters
        ----------
        SemiInfinite: bool
        TheRoots: MAT_ListOfBisector
        NbBasicElts: int
        NbArcs: int

        Returns
        -------
        None

        """
        return _MAT.MAT_Graph_Perform(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_Graph_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_Graph
    __del__ = lambda self: None
MAT_Graph_swigregister = _MAT.MAT_Graph_swigregister
MAT_Graph_swigregister(MAT_Graph)

class MAT_ListOfBisector(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MAT_ListOfBisector, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MAT_ListOfBisector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        """
        this = _MAT.new_MAT_ListOfBisector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def BackAdd(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        anitem: MAT_Bisector

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfBisector_BackAdd(self, *args)


    def Brackets(self, *args) -> "opencascade::handle< MAT_Bisector >":
        """
        No available documentation.

        Parameters
        ----------
        anindex: int

        Returns
        -------
        opencascade::handle<MAT_Bisector>

        """
        return _MAT.MAT_ListOfBisector_Brackets(self, *args)


    def Current(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_Bisector>

        No available documentation.

        Parameters
        ----------
        anitem: MAT_Bisector

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfBisector_Current(self, *args)


    def Dump(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        ashift: int
        alevel: int

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfBisector_Dump(self, *args)


    def First(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfBisector_First(self, *args)


    def FirstItem(self, *args) -> "opencascade::handle< MAT_Bisector >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_Bisector>

        """
        return _MAT.MAT_ListOfBisector_FirstItem(self, *args)


    def FrontAdd(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        anitem: MAT_Bisector

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfBisector_FrontAdd(self, *args)


    def Index(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _MAT.MAT_ListOfBisector_Index(self, *args)


    def Init(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        aniten: MAT_Bisector

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfBisector_Init(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _MAT.MAT_ListOfBisector_IsEmpty(self, *args)


    def Last(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfBisector_Last(self, *args)


    def LastItem(self, *args) -> "opencascade::handle< MAT_Bisector >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_Bisector>

        """
        return _MAT.MAT_ListOfBisector_LastItem(self, *args)


    def LinkAfter(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        anitem: MAT_Bisector

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfBisector_LinkAfter(self, *args)


    def LinkBefore(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        anitem: MAT_Bisector

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfBisector_LinkBefore(self, *args)


    def Loop(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfBisector_Loop(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _MAT.MAT_ListOfBisector_More(self, *args)


    def Next(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfBisector_Next(self, *args)


    def NextItem(self, *args) -> "opencascade::handle< MAT_Bisector >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_Bisector>

        """
        return _MAT.MAT_ListOfBisector_NextItem(self, *args)


    def Number(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _MAT.MAT_ListOfBisector_Number(self, *args)


    def Permute(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfBisector_Permute(self, *args)


    def Previous(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfBisector_Previous(self, *args)


    def PreviousItem(self, *args) -> "opencascade::handle< MAT_Bisector >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_Bisector>

        """
        return _MAT.MAT_ListOfBisector_PreviousItem(self, *args)


    def Unlink(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfBisector_Unlink(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_ListOfBisector_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_ListOfBisector
    __del__ = lambda self: None
MAT_ListOfBisector_swigregister = _MAT.MAT_ListOfBisector_swigregister
MAT_ListOfBisector_swigregister(MAT_ListOfBisector)

class MAT_ListOfEdge(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MAT_ListOfEdge, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MAT_ListOfEdge, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        """
        this = _MAT.new_MAT_ListOfEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def BackAdd(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        anitem: MAT_Edge

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfEdge_BackAdd(self, *args)


    def Brackets(self, *args) -> "opencascade::handle< MAT_Edge >":
        """
        No available documentation.

        Parameters
        ----------
        anindex: int

        Returns
        -------
        opencascade::handle<MAT_Edge>

        """
        return _MAT.MAT_ListOfEdge_Brackets(self, *args)


    def Current(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_Edge>

        No available documentation.

        Parameters
        ----------
        anitem: MAT_Edge

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfEdge_Current(self, *args)


    def Dump(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        ashift: int
        alevel: int

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfEdge_Dump(self, *args)


    def First(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfEdge_First(self, *args)


    def FirstItem(self, *args) -> "opencascade::handle< MAT_Edge >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_Edge>

        """
        return _MAT.MAT_ListOfEdge_FirstItem(self, *args)


    def FrontAdd(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        anitem: MAT_Edge

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfEdge_FrontAdd(self, *args)


    def Index(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _MAT.MAT_ListOfEdge_Index(self, *args)


    def Init(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        aniten: MAT_Edge

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfEdge_Init(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _MAT.MAT_ListOfEdge_IsEmpty(self, *args)


    def Last(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfEdge_Last(self, *args)


    def LastItem(self, *args) -> "opencascade::handle< MAT_Edge >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_Edge>

        """
        return _MAT.MAT_ListOfEdge_LastItem(self, *args)


    def LinkAfter(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        anitem: MAT_Edge

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfEdge_LinkAfter(self, *args)


    def LinkBefore(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        anitem: MAT_Edge

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfEdge_LinkBefore(self, *args)


    def Loop(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfEdge_Loop(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _MAT.MAT_ListOfEdge_More(self, *args)


    def Next(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfEdge_Next(self, *args)


    def NextItem(self, *args) -> "opencascade::handle< MAT_Edge >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_Edge>

        """
        return _MAT.MAT_ListOfEdge_NextItem(self, *args)


    def Number(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _MAT.MAT_ListOfEdge_Number(self, *args)


    def Permute(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfEdge_Permute(self, *args)


    def Previous(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfEdge_Previous(self, *args)


    def PreviousItem(self, *args) -> "opencascade::handle< MAT_Edge >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_Edge>

        """
        return _MAT.MAT_ListOfEdge_PreviousItem(self, *args)


    def Unlink(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _MAT.MAT_ListOfEdge_Unlink(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_ListOfEdge_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_ListOfEdge
    __del__ = lambda self: None
MAT_ListOfEdge_swigregister = _MAT.MAT_ListOfEdge_swigregister
MAT_ListOfEdge_swigregister(MAT_ListOfEdge)

class MAT_Node(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MAT_Node, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MAT_Node, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        GeomIndex: int
        LinkedArc: MAT_Arc
        Distance: float

        Returns
        -------
        None

        """
        this = _MAT.new_MAT_Node(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Distance(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _MAT.MAT_Node_Distance(self, *args)


    def GeomIndex(self, *args) -> "Standard_Integer":
        """
        Returns the index associated of the geometric representation of <self>.

        Returns
        -------
        int

        """
        return _MAT.MAT_Node_GeomIndex(self, *args)


    def Index(self, *args) -> "Standard_Integer":
        """
        Returns the index associated of the node.

        Returns
        -------
        int

        """
        return _MAT.MAT_Node_Index(self, *args)


    def Infinite(self, *args) -> "Standard_Boolean":
        """
        Returns true if the distance of <self> is infinite.

        Returns
        -------
        bool

        """
        return _MAT.MAT_Node_Infinite(self, *args)


    def LinkedArcs(self, *args) -> "void":
        """
        Returns in <s> the arcs linked to <self>.

        Parameters
        ----------
        S: MAT_SequenceOfArc

        Returns
        -------
        None

        """
        return _MAT.MAT_Node_LinkedArcs(self, *args)


    def NearElts(self, *args) -> "void":
        """
        Returns in <s> the basicelts equidistant to <self>.

        Parameters
        ----------
        S: MAT_SequenceOfBasicElt

        Returns
        -------
        None

        """
        return _MAT.MAT_Node_NearElts(self, *args)


    def OnBasicElt(self, *args) -> "Standard_Boolean":
        """
        Returns true if <self> belongs to the figure.

        Returns
        -------
        bool

        """
        return _MAT.MAT_Node_OnBasicElt(self, *args)


    def PendingNode(self, *args) -> "Standard_Boolean":
        """
        Returns true if <self> is a pending node. (ie : the number of arc linked = 1).

        Returns
        -------
        bool

        """
        return _MAT.MAT_Node_PendingNode(self, *args)


    def SetIndex(self, *args) -> "void":
        """
        Set the index associated of the node.

        Parameters
        ----------
        anIndex: int

        Returns
        -------
        None

        """
        return _MAT.MAT_Node_SetIndex(self, *args)


    def SetLinkedArc(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        anArc: MAT_Arc

        Returns
        -------
        None

        """
        return _MAT.MAT_Node_SetLinkedArc(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_Node_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_Node
    __del__ = lambda self: None
MAT_Node_swigregister = _MAT.MAT_Node_swigregister
MAT_Node_swigregister(MAT_Node)

class MAT_TListNodeOfListOfBisector(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MAT_TListNodeOfListOfBisector, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MAT_TListNodeOfListOfBisector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        anitem: MAT_Bisector

        Returns
        -------
        None

        """
        this = _MAT.new_MAT_TListNodeOfListOfBisector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Dummy(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _MAT.MAT_TListNodeOfListOfBisector_Dummy(self, *args)


    def GetItem(self, *args) -> "opencascade::handle< MAT_Bisector >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_Bisector>

        """
        return _MAT.MAT_TListNodeOfListOfBisector_GetItem(self, *args)


    def Next(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_TListNodeOfListOfBisector>

        No available documentation.

        Parameters
        ----------
        atlistnode: MAT_TListNodeOfListOfBisector

        Returns
        -------
        None

        """
        return _MAT.MAT_TListNodeOfListOfBisector_Next(self, *args)


    def Previous(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_TListNodeOfListOfBisector>

        No available documentation.

        Parameters
        ----------
        atlistnode: MAT_TListNodeOfListOfBisector

        Returns
        -------
        None

        """
        return _MAT.MAT_TListNodeOfListOfBisector_Previous(self, *args)


    def SetItem(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        anitem: MAT_Bisector

        Returns
        -------
        None

        """
        return _MAT.MAT_TListNodeOfListOfBisector_SetItem(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_TListNodeOfListOfBisector_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_TListNodeOfListOfBisector
    __del__ = lambda self: None
MAT_TListNodeOfListOfBisector_swigregister = _MAT.MAT_TListNodeOfListOfBisector_swigregister
MAT_TListNodeOfListOfBisector_swigregister(MAT_TListNodeOfListOfBisector)

class MAT_TListNodeOfListOfEdge(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MAT_TListNodeOfListOfEdge, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MAT_TListNodeOfListOfEdge, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        anitem: MAT_Edge

        Returns
        -------
        None

        """
        this = _MAT.new_MAT_TListNodeOfListOfEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Dummy(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _MAT.MAT_TListNodeOfListOfEdge_Dummy(self, *args)


    def GetItem(self, *args) -> "opencascade::handle< MAT_Edge >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_Edge>

        """
        return _MAT.MAT_TListNodeOfListOfEdge_GetItem(self, *args)


    def Next(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_TListNodeOfListOfEdge>

        No available documentation.

        Parameters
        ----------
        atlistnode: MAT_TListNodeOfListOfEdge

        Returns
        -------
        None

        """
        return _MAT.MAT_TListNodeOfListOfEdge_Next(self, *args)


    def Previous(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<MAT_TListNodeOfListOfEdge>

        No available documentation.

        Parameters
        ----------
        atlistnode: MAT_TListNodeOfListOfEdge

        Returns
        -------
        None

        """
        return _MAT.MAT_TListNodeOfListOfEdge_Previous(self, *args)


    def SetItem(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        anitem: MAT_Edge

        Returns
        -------
        None

        """
        return _MAT.MAT_TListNodeOfListOfEdge_SetItem(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_TListNodeOfListOfEdge_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_TListNodeOfListOfEdge
    __del__ = lambda self: None
MAT_TListNodeOfListOfEdge_swigregister = _MAT.MAT_TListNodeOfListOfEdge_swigregister
MAT_TListNodeOfListOfEdge_swigregister(MAT_TListNodeOfListOfEdge)

class MAT_Zone(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MAT_Zone, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MAT_Zone, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        Compute the frontier of the zone of proximity.

        Parameters
        ----------
        aBasicElt: MAT_BasicElt

        Returns
        -------
        None

        """
        this = _MAT.new_MAT_Zone(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ArcOnFrontier(self, *args) -> "opencascade::handle< MAT_Arc >":
        """
        Return the arc number <index> on the frontier. of <self>.

        Parameters
        ----------
        Index: int

        Returns
        -------
        opencascade::handle<MAT_Arc>

        """
        return _MAT.MAT_Zone_ArcOnFrontier(self, *args)


    def Limited(self, *args) -> "Standard_Boolean":
        """
        Return true if <self> is limited.

        Returns
        -------
        bool

        """
        return _MAT.MAT_Zone_Limited(self, *args)


    def NoEmptyZone(self, *args) -> "Standard_Boolean":
        """
        Return true if <self> is not empty .

        Returns
        -------
        bool

        """
        return _MAT.MAT_Zone_NoEmptyZone(self, *args)


    def NumberOfArcs(self, *args) -> "Standard_Integer":
        """
        Return the number of arcs on the frontier of <self>.

        Returns
        -------
        int

        """
        return _MAT.MAT_Zone_NumberOfArcs(self, *args)


    def Perform(self, *args) -> "void":
        """
        Compute the frontier of the zone of proximity.

        Parameters
        ----------
        aBasicElt: MAT_BasicElt

        Returns
        -------
        None

        """
        return _MAT.MAT_Zone_Perform(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_MAT_Zone_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _MAT.delete_MAT_Zone
    __del__ = lambda self: None
MAT_Zone_swigregister = _MAT.MAT_Zone_swigregister
MAT_Zone_swigregister(MAT_Zone)



# This file is compatible with both classic and new-style classes.


