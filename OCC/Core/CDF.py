# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
CDF module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_cdf.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_CDF')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_CDF')
    _CDF = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_CDF', [dirname(__file__)])
        except ImportError:
            import _CDF
            return _CDF
        try:
            _mod = imp.load_module('_CDF', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _CDF = swig_import_helper()
    del swig_import_helper
else:
    import _CDF
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _CDF.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _CDF.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _CDF.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _CDF.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _CDF.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _CDF.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _CDF.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _CDF.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _CDF.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _CDF.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _CDF.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _CDF.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _CDF.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _CDF.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _CDF.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _CDF.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _CDF.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _CDF.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _CDF.process_exception(error, method_name, class_name)
process_exception = _CDF.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.CDM
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Message
import OCC.Core.OSD
import OCC.Core.Resource
import OCC.Core.PCDM
import OCC.Core.Storage

from enum import IntEnum
from OCC.Core.Exception import *

CDF_TOA_New = _CDF.CDF_TOA_New
CDF_TOA_Modified = _CDF.CDF_TOA_Modified
CDF_TOA_Unchanged = _CDF.CDF_TOA_Unchanged
CDF_TS_OK = _CDF.CDF_TS_OK
CDF_TS_NoCurrentDocument = _CDF.CDF_TS_NoCurrentDocument
CDF_TS_NoDriver = _CDF.CDF_TS_NoDriver
CDF_TS_NoSubComponentDriver = _CDF.CDF_TS_NoSubComponentDriver
CDF_SCS_Consistent = _CDF.CDF_SCS_Consistent
CDF_SCS_Unconsistent = _CDF.CDF_SCS_Unconsistent
CDF_SCS_Stored = _CDF.CDF_SCS_Stored
CDF_SCS_Modified = _CDF.CDF_SCS_Modified
CDF_SSNS_OK = _CDF.CDF_SSNS_OK
CDF_SSNS_ReplacingAnExistentDocument = _CDF.CDF_SSNS_ReplacingAnExistentDocument
CDF_SSNS_OpenDocument = _CDF.CDF_SSNS_OpenDocument


class CDF_TypeOfActivation(IntEnum):
	CDF_TOA_New = 0
	CDF_TOA_Modified = 1
	CDF_TOA_Unchanged = 2
CDF_TOA_New = CDF_TypeOfActivation.CDF_TOA_New
CDF_TOA_Modified = CDF_TypeOfActivation.CDF_TOA_Modified
CDF_TOA_Unchanged = CDF_TypeOfActivation.CDF_TOA_Unchanged

class CDF_TryStoreStatus(IntEnum):
	CDF_TS_OK = 0
	CDF_TS_NoCurrentDocument = 1
	CDF_TS_NoDriver = 2
	CDF_TS_NoSubComponentDriver = 3
CDF_TS_OK = CDF_TryStoreStatus.CDF_TS_OK
CDF_TS_NoCurrentDocument = CDF_TryStoreStatus.CDF_TS_NoCurrentDocument
CDF_TS_NoDriver = CDF_TryStoreStatus.CDF_TS_NoDriver
CDF_TS_NoSubComponentDriver = CDF_TryStoreStatus.CDF_TS_NoSubComponentDriver

class CDF_SubComponentStatus(IntEnum):
	CDF_SCS_Consistent = 0
	CDF_SCS_Unconsistent = 1
	CDF_SCS_Stored = 2
	CDF_SCS_Modified = 3
CDF_SCS_Consistent = CDF_SubComponentStatus.CDF_SCS_Consistent
CDF_SCS_Unconsistent = CDF_SubComponentStatus.CDF_SCS_Unconsistent
CDF_SCS_Stored = CDF_SubComponentStatus.CDF_SCS_Stored
CDF_SCS_Modified = CDF_SubComponentStatus.CDF_SCS_Modified

class CDF_StoreSetNameStatus(IntEnum):
	CDF_SSNS_OK = 0
	CDF_SSNS_ReplacingAnExistentDocument = 1
	CDF_SSNS_OpenDocument = 2
CDF_SSNS_OK = CDF_StoreSetNameStatus.CDF_SSNS_OK
CDF_SSNS_ReplacingAnExistentDocument = CDF_StoreSetNameStatus.CDF_SSNS_ReplacingAnExistentDocument
CDF_SSNS_OpenDocument = CDF_StoreSetNameStatus.CDF_SSNS_OpenDocument


def Handle_CDF_Application_Create() -> "opencascade::handle< CDF_Application >":
    return _CDF.Handle_CDF_Application_Create()
Handle_CDF_Application_Create = _CDF.Handle_CDF_Application_Create

def Handle_CDF_Application_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< CDF_Application >":
    return _CDF.Handle_CDF_Application_DownCast(t)
Handle_CDF_Application_DownCast = _CDF.Handle_CDF_Application_DownCast

def Handle_CDF_Application_IsNull(t: 'opencascade::handle< CDF_Application > const &') -> "bool":
    return _CDF.Handle_CDF_Application_IsNull(t)
Handle_CDF_Application_IsNull = _CDF.Handle_CDF_Application_IsNull

def Handle_CDF_Directory_Create() -> "opencascade::handle< CDF_Directory >":
    return _CDF.Handle_CDF_Directory_Create()
Handle_CDF_Directory_Create = _CDF.Handle_CDF_Directory_Create

def Handle_CDF_Directory_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< CDF_Directory >":
    return _CDF.Handle_CDF_Directory_DownCast(t)
Handle_CDF_Directory_DownCast = _CDF.Handle_CDF_Directory_DownCast

def Handle_CDF_Directory_IsNull(t: 'opencascade::handle< CDF_Directory > const &') -> "bool":
    return _CDF.Handle_CDF_Directory_IsNull(t)
Handle_CDF_Directory_IsNull = _CDF.Handle_CDF_Directory_IsNull

def Handle_CDF_MetaDataDriver_Create() -> "opencascade::handle< CDF_MetaDataDriver >":
    return _CDF.Handle_CDF_MetaDataDriver_Create()
Handle_CDF_MetaDataDriver_Create = _CDF.Handle_CDF_MetaDataDriver_Create

def Handle_CDF_MetaDataDriver_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< CDF_MetaDataDriver >":
    return _CDF.Handle_CDF_MetaDataDriver_DownCast(t)
Handle_CDF_MetaDataDriver_DownCast = _CDF.Handle_CDF_MetaDataDriver_DownCast

def Handle_CDF_MetaDataDriver_IsNull(t: 'opencascade::handle< CDF_MetaDataDriver > const &') -> "bool":
    return _CDF.Handle_CDF_MetaDataDriver_IsNull(t)
Handle_CDF_MetaDataDriver_IsNull = _CDF.Handle_CDF_MetaDataDriver_IsNull

def Handle_CDF_MetaDataDriverFactory_Create() -> "opencascade::handle< CDF_MetaDataDriverFactory >":
    return _CDF.Handle_CDF_MetaDataDriverFactory_Create()
Handle_CDF_MetaDataDriverFactory_Create = _CDF.Handle_CDF_MetaDataDriverFactory_Create

def Handle_CDF_MetaDataDriverFactory_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< CDF_MetaDataDriverFactory >":
    return _CDF.Handle_CDF_MetaDataDriverFactory_DownCast(t)
Handle_CDF_MetaDataDriverFactory_DownCast = _CDF.Handle_CDF_MetaDataDriverFactory_DownCast

def Handle_CDF_MetaDataDriverFactory_IsNull(t: 'opencascade::handle< CDF_MetaDataDriverFactory > const &') -> "bool":
    return _CDF.Handle_CDF_MetaDataDriverFactory_IsNull(t)
Handle_CDF_MetaDataDriverFactory_IsNull = _CDF.Handle_CDF_MetaDataDriverFactory_IsNull

def Handle_CDF_StoreList_Create() -> "opencascade::handle< CDF_StoreList >":
    return _CDF.Handle_CDF_StoreList_Create()
Handle_CDF_StoreList_Create = _CDF.Handle_CDF_StoreList_Create

def Handle_CDF_StoreList_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< CDF_StoreList >":
    return _CDF.Handle_CDF_StoreList_DownCast(t)
Handle_CDF_StoreList_DownCast = _CDF.Handle_CDF_StoreList_DownCast

def Handle_CDF_StoreList_IsNull(t: 'opencascade::handle< CDF_StoreList > const &') -> "bool":
    return _CDF.Handle_CDF_StoreList_IsNull(t)
Handle_CDF_StoreList_IsNull = _CDF.Handle_CDF_StoreList_IsNull

def Handle_CDF_FWOSDriver_Create() -> "opencascade::handle< CDF_FWOSDriver >":
    return _CDF.Handle_CDF_FWOSDriver_Create()
Handle_CDF_FWOSDriver_Create = _CDF.Handle_CDF_FWOSDriver_Create

def Handle_CDF_FWOSDriver_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< CDF_FWOSDriver >":
    return _CDF.Handle_CDF_FWOSDriver_DownCast(t)
Handle_CDF_FWOSDriver_DownCast = _CDF.Handle_CDF_FWOSDriver_DownCast

def Handle_CDF_FWOSDriver_IsNull(t: 'opencascade::handle< CDF_FWOSDriver > const &') -> "bool":
    return _CDF.Handle_CDF_FWOSDriver_IsNull(t)
Handle_CDF_FWOSDriver_IsNull = _CDF.Handle_CDF_FWOSDriver_IsNull
class CDF_Application(OCC.Core.CDM.CDM_Application):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.CDM.CDM_Application]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CDF_Application, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.CDM.CDM_Application]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CDF_Application, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_setmethods__["myMetaDataDriver"] = _CDF.CDF_Application_myMetaDataDriver_set
    __swig_getmethods__["myMetaDataDriver"] = _CDF.CDF_Application_myMetaDataDriver_get
    if _newclass:
        myMetaDataDriver = _swig_property(_CDF.CDF_Application_myMetaDataDriver_get, _CDF.CDF_Application_myMetaDataDriver_set)
    __swig_setmethods__["myDirectory"] = _CDF.CDF_Application_myDirectory_set
    __swig_getmethods__["myDirectory"] = _CDF.CDF_Application_myDirectory_get
    if _newclass:
        myDirectory = _swig_property(_CDF.CDF_Application_myDirectory_get, _CDF.CDF_Application_myDirectory_set)

    def CanClose(self, *args) -> "CDM_CanCloseStatus":
        """
        No available documentation.

        Parameters
        ----------
        aDocument: CDM_Document

        Returns
        -------
        CDM_CanCloseStatus

        """
        return _CDF.CDF_Application_CanClose(self, *args)


    def CanRetrieve(self, *args) -> "PCDM_ReaderStatus":
        """
        No available documentation.

        Parameters
        ----------
        aFolder: TCollection_ExtendedString
        aName: TCollection_ExtendedString

        Returns
        -------
        PCDM_ReaderStatus

        No available documentation.

        Parameters
        ----------
        aFolder: TCollection_ExtendedString
        aName: TCollection_ExtendedString
        aVersion: TCollection_ExtendedString

        Returns
        -------
        PCDM_ReaderStatus

        """
        return _CDF.CDF_Application_CanRetrieve(self, *args)


    def Close(self, *args) -> "void":
        """
        Removes the document of the current session directory and closes the document;.

        Parameters
        ----------
        aDocument: CDM_Document

        Returns
        -------
        None

        """
        return _CDF.CDF_Application_Close(self, *args)


    def DefaultFolder(self, *args) -> "Standard_ExtString":
        """
        No available documentation.

        Returns
        -------
        Standard_ExtString

        """
        return _CDF.CDF_Application_DefaultFolder(self, *args)


    def Format(self, *args) -> "Standard_Boolean":
        """
        Try to retrieve a format directly in the file or in application resource by using extension. returns true if found;.

        Parameters
        ----------
        aFileName: TCollection_ExtendedString
        theFormat: TCollection_ExtendedString

        Returns
        -------
        bool

        """
        return _CDF.CDF_Application_Format(self, *args)


    def GetRetrieveStatus(self, *args) -> "PCDM_ReaderStatus":
        """
        Checks status after retrieve.

        Returns
        -------
        PCDM_ReaderStatus

        """
        return _CDF.CDF_Application_GetRetrieveStatus(self, *args)


    def Load(*args) -> "opencascade::handle< CDF_Application >":
        """
        Plugs an application. //! open is used - for opening a document that has been created in an application - for opening a document from the database - for opening a document from a file. the open methods always add the document in the session directory and calls the virtual activate method. the document is considered to be opened until close is used. to be storable, a document must be opened by an application since the application resources are needed to store it.

        Parameters
        ----------
        aGUID: Standard_GUID

        Returns
        -------
        opencascade::handle<CDF_Application>

        """
        return _CDF.CDF_Application_Load(*args)

    Load = staticmethod(Load)

    def MetaDataDriver(self, *args) -> "opencascade::handle< CDF_MetaDataDriver >":
        """
        Returns metadatddriver of this application.

        Returns
        -------
        opencascade::handle<CDF_MetaDataDriver>

        """
        return _CDF.CDF_Application_MetaDataDriver(self, *args)


    def Open(self, *args) -> "void":
        """
        Puts the document in the current session directory and calls the virtual method activate on it.

        Parameters
        ----------
        aDocument: CDM_Document

        Returns
        -------
        None

        """
        return _CDF.CDF_Application_Open(self, *args)


    def ReadFromString(self, src: 'std::string') -> "void":
        """ReadFromString(CDF_Application self, std::string src)"""
        return _CDF.CDF_Application_ReadFromString(self, src)


    def ReaderFromFormat(self, *args) -> "opencascade::handle< PCDM_Reader >":
        """
        Returns instance of read driver for specified format. //! default implementation uses plugin mechanism to load reader dynamically. for this to work, application resources should define guid of the plugin as value of [format].retrievalplugin, and 'plugin' resource should define name of plugin library to be loaded as value of [guid].location. plugin library should provide method pluginfactory returning instance of the reader for the same guid (see plugin_macro.hxx). //! in case if reader is not available, will raise standard_nosuchobject or other exception if raised by plugin loader.

        Parameters
        ----------
        aFormat: TCollection_ExtendedString

        Returns
        -------
        opencascade::handle<PCDM_Reader>

        """
        return _CDF.CDF_Application_ReaderFromFormat(self, *args)


    def Retrieve(self, *args) -> "opencascade::handle< CDM_Document >":
        """
        This method retrieves a document from the database. if the document references other documents which have been updated, the latest version of these documents will be used if {usestorageconfiguration} is standard_true. the content of {afolder}, {aname} and {aversion} depends on the database manager system. if the dbms is only based on the os, {afolder} is a directory and {aname} is the name of a file. in this case the use of the syntax with {aversion} has no sense. for example: //! opencascade::handle<cdm_document> thedocument=myapplication->retrieve('/home/cascade','box.dsg'); if the dbms is euclid/design manager, {afolder}, {aname} have the form they have in euclid/design manager. for example: //! opencascade::handle<cdm_document> thedocument=myapplication->retrieve('|user|cascade','box'); //! since the version is not specified in this syntax, the latest wil be used. a link is kept with the database through an instance of cdm_metadata.

        Parameters
        ----------
        aFolder: TCollection_ExtendedString
        aName: TCollection_ExtendedString
        UseStorageConfiguration: bool,optional
        	default value is Standard_True
        theRange: Message_ProgressRange,optional
        	default value is Message_ProgressRange()

        Returns
        -------
        opencascade::handle<CDM_Document>

        This method retrieves a document from the database. if the document references other documents which have been updated, the latest version of these documents will be used if {usestorageconfiguration} is standard_true. -- if the dbms is only based on the os, this syntax should not be used. //! if the dbms is euclid/design manager, {afolder}, {aname} and {aversion} have the form they have in euclid/design manager. for example: //! opencascade::handle<cdm_document> thedocument=myapplication->retrieve('|user|cascade','box','2'); a link is kept with the database through an instance of cdm_metadata.

        Parameters
        ----------
        aFolder: TCollection_ExtendedString
        aName: TCollection_ExtendedString
        aVersion: TCollection_ExtendedString
        UseStorageConfiguration: bool,optional
        	default value is Standard_True
        theRange: Message_ProgressRange,optional
        	default value is Message_ProgressRange()

        Returns
        -------
        opencascade::handle<CDM_Document>

        """
        return _CDF.CDF_Application_Retrieve(self, *args)


    def SetDefaultFolder(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Parameters
        ----------
        aFolder: Standard_ExtString

        Returns
        -------
        bool

        """
        return _CDF.CDF_Application_SetDefaultFolder(self, *args)


    def WriterFromFormat(self, *args) -> "opencascade::handle< PCDM_StorageDriver >":
        """
        Returns instance of storage driver for specified format. //! default implementation uses plugin mechanism to load driver dynamically. for this to work, application resources should define guid of the plugin as value of [format].storageplugin, and 'plugin' resource should define name of plugin library to be loaded as value of [guid].location. plugin library should provide method pluginfactory returning instance of the reader for the same guid (see plugin_macro.hxx). //! in case if driver is not available, will raise standard_nosuchobject or other exception if raised by plugin loader.

        Parameters
        ----------
        aFormat: TCollection_ExtendedString

        Returns
        -------
        opencascade::handle<PCDM_StorageDriver>

        """
        return _CDF.CDF_Application_WriterFromFormat(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_CDF_Application_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _CDF.delete_CDF_Application
    __del__ = lambda self: None
CDF_Application_swigregister = _CDF.CDF_Application_swigregister
CDF_Application_swigregister(CDF_Application)

def CDF_Application_Load(*args) -> "opencascade::handle< CDF_Application >":
    """
    Plugs an application. //! open is used - for opening a document that has been created in an application - for opening a document from the database - for opening a document from a file. the open methods always add the document in the session directory and calls the virtual activate method. the document is considered to be opened until close is used. to be storable, a document must be opened by an application since the application resources are needed to store it.

    Parameters
    ----------
    aGUID: Standard_GUID

    Returns
    -------
    opencascade::handle<CDF_Application>

    """
    return _CDF.CDF_Application_Load(*args)

class CDF_Directory(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CDF_Directory, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CDF_Directory, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an empty directory.

        Returns
        -------
        None

        """
        this = _CDF.new_CDF_Directory(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args) -> "void":
        """
        Adds a document into the directory.

        Parameters
        ----------
        aDocument: CDM_Document

        Returns
        -------
        None

        """
        return _CDF.CDF_Directory_Add(self, *args)


    def Contains(self, *args) -> "Standard_Boolean":
        """
        Returns true if the document adocument is in the directory.

        Parameters
        ----------
        aDocument: CDM_Document

        Returns
        -------
        bool

        """
        return _CDF.CDF_Directory_Contains(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        Returns true if the directory is empty.

        Returns
        -------
        bool

        """
        return _CDF.CDF_Directory_IsEmpty(self, *args)


    def Last(self, *args) -> "opencascade::handle< CDM_Document >":
        """
        Returns the last document (if any) which has been added in the directory.

        Returns
        -------
        opencascade::handle<CDM_Document>

        """
        return _CDF.CDF_Directory_Last(self, *args)


    def Length(self, *args) -> "Standard_Integer":
        """
        Returns the number of documents of the directory.

        Returns
        -------
        int

        """
        return _CDF.CDF_Directory_Length(self, *args)


    def Remove(self, *args) -> "void":
        """
        Removes the document.

        Parameters
        ----------
        aDocument: CDM_Document

        Returns
        -------
        None

        """
        return _CDF.CDF_Directory_Remove(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_CDF_Directory_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _CDF.delete_CDF_Directory
    __del__ = lambda self: None
CDF_Directory_swigregister = _CDF.CDF_Directory_swigregister
CDF_Directory_swigregister(CDF_Directory)

class CDF_MetaDataDriver(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CDF_MetaDataDriver, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CDF_MetaDataDriver, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def BuildFileName(self, *args) -> "TCollection_ExtendedString":
        """
        No available documentation.

        Parameters
        ----------
        aDocument: CDM_Document

        Returns
        -------
        TCollection_ExtendedString

        """
        return _CDF.CDF_MetaDataDriver_BuildFileName(self, *args)


    def CreateDependsOn(self, *args) -> "void":
        """
        Creates a 'depends on' relation between two datas. by default does nothing.

        Parameters
        ----------
        aFirstData: CDM_MetaData
        aSecondData: CDM_MetaData

        Returns
        -------
        None

        """
        return _CDF.CDF_MetaDataDriver_CreateDependsOn(self, *args)


    def CreateMetaData(self, *args) -> "opencascade::handle< CDM_MetaData >":
        """
        Should create meta-data corresponding to adata and maintaining a meta-link between these meta-data and afilename createmetadata is called by createdata if the metadata-driver has version capabilities, version must be set in the returned data.

        Parameters
        ----------
        aDocument: CDM_Document
        aFileName: TCollection_ExtendedString

        Returns
        -------
        opencascade::handle<CDM_MetaData>

        """
        return _CDF.CDF_MetaDataDriver_CreateMetaData(self, *args)


    def CreateReference(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        aFrom: CDM_MetaData
        aTo: CDM_MetaData
        aReferenceIdentifier: int
        aToDocumentVersion: int

        Returns
        -------
        None

        """
        return _CDF.CDF_MetaDataDriver_CreateReference(self, *args)


    def DefaultFolder(self, *args) -> "TCollection_ExtendedString":
        """
        No available documentation.

        Returns
        -------
        TCollection_ExtendedString

        """
        return _CDF.CDF_MetaDataDriver_DefaultFolder(self, *args)


    def Find(self, *args) -> "Standard_Boolean":
        """
        Should indicate whether meta-data exist in the dbms corresponding to the data. aversion may be null;.

        Parameters
        ----------
        aFolder: TCollection_ExtendedString
        aName: TCollection_ExtendedString
        aVersion: TCollection_ExtendedString

        Returns
        -------
        bool

        Calls find with an empty version.

        Parameters
        ----------
        aFolder: TCollection_ExtendedString
        aName: TCollection_ExtendedString

        Returns
        -------
        bool

        """
        return _CDF.CDF_MetaDataDriver_Find(self, *args)


    def FindFolder(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Parameters
        ----------
        aFolder: TCollection_ExtendedString

        Returns
        -------
        bool

        """
        return _CDF.CDF_MetaDataDriver_FindFolder(self, *args)


    def HasReadPermission(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Parameters
        ----------
        aFolder: TCollection_ExtendedString
        aName: TCollection_ExtendedString
        aVersion: TCollection_ExtendedString

        Returns
        -------
        bool

        """
        return _CDF.CDF_MetaDataDriver_HasReadPermission(self, *args)


    def HasVersion(self, *args) -> "Standard_Boolean":
        """
        By default return standard_true.

        Parameters
        ----------
        aFolder: TCollection_ExtendedString
        aName: TCollection_ExtendedString

        Returns
        -------
        bool

        """
        return _CDF.CDF_MetaDataDriver_HasVersion(self, *args)


    def HasVersionCapability(self, *args) -> "Standard_Boolean":
        """
        Returns true if the metadatadriver can manage different versions of a data. by default, returns standard_false.

        Returns
        -------
        bool

        """
        return _CDF.CDF_MetaDataDriver_HasVersionCapability(self, *args)


    def LastVersion(self, *args) -> "opencascade::handle< CDM_MetaData >":
        """
        By default returns ametadata should return the metadata stored in the dbms with the meta-data corresponding to the path. if the metadatadriver has version management capabilities the version has to be set in the returned metadata. metadata is called by getmetadata if the version is not included in the path , metadata should return the last version of the metadata is deferred;.

        Parameters
        ----------
        aMetaData: CDM_MetaData

        Returns
        -------
        opencascade::handle<CDM_MetaData>

        """
        return _CDF.CDF_MetaDataDriver_LastVersion(self, *args)


    def MetaData(self, *args) -> "opencascade::handle< CDM_MetaData >":
        """
        Should return the metadata stored in the dbms with the meta-data corresponding to the data. if the metadatadriver has version management capabilities the version has to be set in the returned metadata. aversion may be null metadata is called by getmetadata if the version is set to null, metadata should return the last version of the metadata.

        Parameters
        ----------
        aFolder: TCollection_ExtendedString
        aName: TCollection_ExtendedString
        aVersion: TCollection_ExtendedString

        Returns
        -------
        opencascade::handle<CDM_MetaData>

        Calls metadata with an empty version.

        Parameters
        ----------
        aFolder: TCollection_ExtendedString
        aName: TCollection_ExtendedString

        Returns
        -------
        opencascade::handle<CDM_MetaData>

        """
        return _CDF.CDF_MetaDataDriver_MetaData(self, *args)


    def ReferenceIterator(self, *args) -> "opencascade::handle< PCDM_ReferenceIterator >":
        """
        No available documentation.

        Parameters
        ----------
        theMessageDriver: Message_Messenger

        Returns
        -------
        opencascade::handle<PCDM_ReferenceIterator>

        """
        return _CDF.CDF_MetaDataDriver_ReferenceIterator(self, *args)


    def SetName(self, *args) -> "TCollection_ExtendedString":
        """
        This methods is usefull if the name of an object -- depends on the metadatadriver. for example a driver -- based on the operating system can choose to add the extension of file to create to the object.

        Parameters
        ----------
        aDocument: CDM_Document
        aName: TCollection_ExtendedString

        Returns
        -------
        TCollection_ExtendedString

        """
        return _CDF.CDF_MetaDataDriver_SetName(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_CDF_MetaDataDriver_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _CDF.delete_CDF_MetaDataDriver
    __del__ = lambda self: None
CDF_MetaDataDriver_swigregister = _CDF.CDF_MetaDataDriver_swigregister
CDF_MetaDataDriver_swigregister(CDF_MetaDataDriver)

class CDF_MetaDataDriverFactory(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CDF_MetaDataDriverFactory, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CDF_MetaDataDriverFactory, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Build(self, *args) -> "opencascade::handle< CDF_MetaDataDriver >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<CDF_MetaDataDriver>

        """
        return _CDF.CDF_MetaDataDriverFactory_Build(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_CDF_MetaDataDriverFactory_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _CDF.delete_CDF_MetaDataDriverFactory
    __del__ = lambda self: None
CDF_MetaDataDriverFactory_swigregister = _CDF.CDF_MetaDataDriverFactory_swigregister
CDF_MetaDataDriverFactory_swigregister(CDF_MetaDataDriverFactory)

class CDF_Store(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CDF_Store, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CDF_Store, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a store list from the document of the current selection.

        Parameters
        ----------
        aDocument: CDM_Document

        Returns
        -------
        None

        """
        this = _CDF.new_CDF_Store(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AssociatedStatusText(self, *args) -> "Standard_ExtString":
        """
        No available documentation.

        Returns
        -------
        Standard_ExtString

        """
        return _CDF.CDF_Store_AssociatedStatusText(self, *args)


    def Comment(self, *args) -> "opencascade::handle< TCollection_HExtendedString >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<TCollection_HExtendedString>

        """
        return _CDF.CDF_Store_Comment(self, *args)


    def CurrentIsConsistent(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _CDF.CDF_Store_CurrentIsConsistent(self, *args)


    def Description(self, *args) -> "opencascade::handle< TCollection_HExtendedString >":
        """
        Returns the description of the format of the main object.

        Returns
        -------
        opencascade::handle<TCollection_HExtendedString>

        """
        return _CDF.CDF_Store_Description(self, *args)


    def Folder(self, *args) -> "opencascade::handle< TCollection_HExtendedString >":
        """
        Returns the folder in which the current document will be stored.

        Returns
        -------
        opencascade::handle<TCollection_HExtendedString>

        """
        return _CDF.CDF_Store_Folder(self, *args)


    def HasAPreviousVersion(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _CDF.CDF_Store_HasAPreviousVersion(self, *args)


    def IsConsistent(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _CDF.CDF_Store_IsConsistent(self, *args)


    def IsMainDocument(self, *args) -> "Standard_Boolean":
        """
        Returns true if the currentdocument is the main one, ie the document of the current selection.

        Returns
        -------
        bool

        """
        return _CDF.CDF_Store_IsMainDocument(self, *args)


    def IsModified(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _CDF.CDF_Store_IsModified(self, *args)


    def IsStored(self, *args) -> "Standard_Boolean":
        """
        Returns true if the current document is already stored.

        Returns
        -------
        bool

        """
        return _CDF.CDF_Store_IsStored(self, *args)


    def MetaDataPath(self, *args) -> "opencascade::handle< TCollection_HExtendedString >":
        """
        Returns the path of the previous store is the object is already stored, otherwise an empty string;.

        Returns
        -------
        opencascade::handle<TCollection_HExtendedString>

        """
        return _CDF.CDF_Store_MetaDataPath(self, *args)


    def Name(self, *args) -> "opencascade::handle< TCollection_HExtendedString >":
        """
        Returns the name under which the current document will be stored.

        Returns
        -------
        opencascade::handle<TCollection_HExtendedString>

        """
        return _CDF.CDF_Store_Name(self, *args)


    def Path(self, *args) -> "Standard_ExtString":
        """
        Returns the complete path of the created meta-data.

        Returns
        -------
        Standard_ExtString

        """
        return _CDF.CDF_Store_Path(self, *args)


    def PreviousVersion(self, *args) -> "opencascade::handle< TCollection_HExtendedString >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<TCollection_HExtendedString>

        """
        return _CDF.CDF_Store_PreviousVersion(self, *args)


    def Realize(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        theRange: Message_ProgressRange,optional
        	default value is Message_ProgressRange()

        Returns
        -------
        None

        """
        return _CDF.CDF_Store_Realize(self, *args)


    def RecheckName(self, *args) -> "CDF_StoreSetNameStatus":
        """
        Defines the name under which the document should be stored. uses for example after modification of the folder.

        Returns
        -------
        CDF_StoreSetNameStatus

        """
        return _CDF.CDF_Store_RecheckName(self, *args)


    def SetComment(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        aComment: Standard_ExtString

        Returns
        -------
        None

        """
        return _CDF.CDF_Store_SetComment(self, *args)


    def SetCurrent(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        aPresentation: Standard_ExtString

        Returns
        -------
        None

        """
        return _CDF.CDF_Store_SetCurrent(self, *args)


    def SetFolder(self, *args) -> "Standard_Boolean":
        """
        Defines the folder in which the document should be stored. returns standard_true if the folder exists, standard_false otherwise.

        Parameters
        ----------
        aFolder: TCollection_ExtendedString

        Returns
        -------
        bool

        Defines the folder in which the document should be stored. returns standard_true if the folder exists, standard_false otherwise.

        Parameters
        ----------
        aFolder: Standard_ExtString

        Returns
        -------
        bool

        """
        return _CDF.CDF_Store_SetFolder(self, *args)


    def SetMain(self, *args) -> "void":
        """
        The two following methods can be used just after realize or import -- method to know if thes methods worked correctly, and if not why.

        Returns
        -------
        None

        """
        return _CDF.CDF_Store_SetMain(self, *args)


    def SetName(self, *args) -> "CDF_StoreSetNameStatus":
        """
        Defines the name under which the document should be stored.

        Parameters
        ----------
        aName: Standard_ExtString

        Returns
        -------
        CDF_StoreSetNameStatus

        Defines the name under which the document should be stored.

        Parameters
        ----------
        aName: TCollection_ExtendedString

        Returns
        -------
        CDF_StoreSetNameStatus

        """
        return _CDF.CDF_Store_SetName(self, *args)


    def SetPreviousVersion(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Parameters
        ----------
        aPreviousVersion: Standard_ExtString

        Returns
        -------
        bool

        """
        return _CDF.CDF_Store_SetPreviousVersion(self, *args)


    def StoreStatus(self, *args) -> "PCDM_StoreStatus":
        """
        No available documentation.

        Returns
        -------
        PCDM_StoreStatus

        """
        return _CDF.CDF_Store_StoreStatus(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _CDF.delete_CDF_Store
    __del__ = lambda self: None
CDF_Store_swigregister = _CDF.CDF_Store_swigregister
CDF_Store_swigregister(CDF_Store)

class CDF_StoreList(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CDF_StoreList, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CDF_StoreList, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        aDocument: CDM_Document

        Returns
        -------
        None

        """
        this = _CDF.new_CDF_StoreList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _CDF.CDF_StoreList_Init(self, *args)


    def IsConsistent(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _CDF.CDF_StoreList_IsConsistent(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _CDF.CDF_StoreList_More(self, *args)


    def Next(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _CDF.CDF_StoreList_Next(self, *args)


    def Store(self, *args) -> "PCDM_StoreStatus":
        """
        Stores each object of the storelist in the reverse order of which they had been added.

        Parameters
        ----------
        aMetaData: CDM_MetaData
        aStatusAssociatedText: TCollection_ExtendedString
        theRange: Message_ProgressRange,optional
        	default value is Message_ProgressRange()

        Returns
        -------
        PCDM_StoreStatus

        """
        return _CDF.CDF_StoreList_Store(self, *args)


    def Value(self, *args) -> "opencascade::handle< CDM_Document >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<CDM_Document>

        """
        return _CDF.CDF_StoreList_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_CDF_StoreList_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _CDF.delete_CDF_StoreList
    __del__ = lambda self: None
CDF_StoreList_swigregister = _CDF.CDF_StoreList_swigregister
CDF_StoreList_swigregister(CDF_StoreList)

class CDF_FWOSDriver(CDF_MetaDataDriver):
    __swig_setmethods__ = {}
    for _s in [CDF_MetaDataDriver]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CDF_FWOSDriver, name, value)
    __swig_getmethods__ = {}
    for _s in [CDF_MetaDataDriver]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CDF_FWOSDriver, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Initializes the metadatadriver connected to specified look-up table. note that the created driver will keep reference to the table, thus it must have life time longer than this object.

        Parameters
        ----------
        theLookUpTable: CDM_MetaDataLookUpTable

        Returns
        -------
        None

        """
        this = _CDF.new_CDF_FWOSDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_CDF_FWOSDriver_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _CDF.delete_CDF_FWOSDriver
    __del__ = lambda self: None
CDF_FWOSDriver_swigregister = _CDF.CDF_FWOSDriver_swigregister
CDF_FWOSDriver_swigregister(CDF_FWOSDriver)


@classnotwrapped
class CDF_DirectoryIterator:
	pass




# This file is compatible with both classic and new-style classes.


