# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""
CPnts module, see official documentation at
https://dev.opencascade.org/doc/occt-7.7.0/refman/html/package_cpnts.html
"""

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _CPnts
else:
    import _CPnts

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _CPnts.delete_SwigPyIterator

    def value(self):
        return _CPnts.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _CPnts.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _CPnts.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _CPnts.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _CPnts.SwigPyIterator_equal(self, x)

    def copy(self):
        return _CPnts.SwigPyIterator_copy(self)

    def next(self):
        return _CPnts.SwigPyIterator_next(self)

    def __next__(self):
        return _CPnts.SwigPyIterator___next__(self)

    def previous(self):
        return _CPnts.SwigPyIterator_previous(self)

    def advance(self, n):
        return _CPnts.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _CPnts.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _CPnts.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _CPnts.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _CPnts.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _CPnts.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _CPnts.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _CPnts:
_CPnts.SwigPyIterator_swigregister(SwigPyIterator)

def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error, method_name, class_name):
    return _CPnts.process_exception(error, method_name, class_name)

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

class ios_base(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    erase_event = _CPnts.ios_base_erase_event
    imbue_event = _CPnts.ios_base_imbue_event
    copyfmt_event = _CPnts.ios_base_copyfmt_event

    def register_callback(self, __fn, __index):
        return _CPnts.ios_base_register_callback(self, __fn, __index)

    def flags(self, *args):
        return _CPnts.ios_base_flags(self, *args)

    def setf(self, *args):
        return _CPnts.ios_base_setf(self, *args)

    def unsetf(self, __mask):
        return _CPnts.ios_base_unsetf(self, __mask)

    def precision(self, *args):
        return _CPnts.ios_base_precision(self, *args)

    def width(self, *args):
        return _CPnts.ios_base_width(self, *args)

    @staticmethod
    def sync_with_stdio(__sync=True):
        return _CPnts.ios_base_sync_with_stdio(__sync)

    def imbue(self, __loc):
        return _CPnts.ios_base_imbue(self, __loc)

    def getloc(self):
        return _CPnts.ios_base_getloc(self)

    @staticmethod
    def xalloc():
        return _CPnts.ios_base_xalloc()

    def iword(self, __ix):
        return _CPnts.ios_base_iword(self, __ix)

    def pword(self, __ix):
        return _CPnts.ios_base_pword(self, __ix)
    __swig_destroy__ = _CPnts.delete_ios_base

# Register ios_base in _CPnts:
_CPnts.ios_base_swigregister(ios_base)
cvar = _CPnts.cvar
ios_base.boolalpha = _CPnts.cvar.ios_base_boolalpha
ios_base.dec = _CPnts.cvar.ios_base_dec
ios_base.fixed = _CPnts.cvar.ios_base_fixed
ios_base.hex = _CPnts.cvar.ios_base_hex
ios_base.internal = _CPnts.cvar.ios_base_internal
ios_base.left = _CPnts.cvar.ios_base_left
ios_base.oct = _CPnts.cvar.ios_base_oct
ios_base.right = _CPnts.cvar.ios_base_right
ios_base.scientific = _CPnts.cvar.ios_base_scientific
ios_base.showbase = _CPnts.cvar.ios_base_showbase
ios_base.showpoint = _CPnts.cvar.ios_base_showpoint
ios_base.showpos = _CPnts.cvar.ios_base_showpos
ios_base.skipws = _CPnts.cvar.ios_base_skipws
ios_base.unitbuf = _CPnts.cvar.ios_base_unitbuf
ios_base.uppercase = _CPnts.cvar.ios_base_uppercase
ios_base.adjustfield = _CPnts.cvar.ios_base_adjustfield
ios_base.basefield = _CPnts.cvar.ios_base_basefield
ios_base.floatfield = _CPnts.cvar.ios_base_floatfield
ios_base.badbit = _CPnts.cvar.ios_base_badbit
ios_base.eofbit = _CPnts.cvar.ios_base_eofbit
ios_base.failbit = _CPnts.cvar.ios_base_failbit
ios_base.goodbit = _CPnts.cvar.ios_base_goodbit
ios_base.app = _CPnts.cvar.ios_base_app
ios_base.ate = _CPnts.cvar.ios_base_ate
ios_base.binary = _CPnts.cvar.ios_base_binary
ios_base.ios_base_in = _CPnts.cvar.ios_base_ios_base_in
ios_base.out = _CPnts.cvar.ios_base_out
ios_base.trunc = _CPnts.cvar.ios_base_trunc
ios_base.beg = _CPnts.cvar.ios_base_beg
ios_base.cur = _CPnts.cvar.ios_base_cur
ios_base.end = _CPnts.cvar.ios_base_end

class ios(ios_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def rdstate(self):
        return _CPnts.ios_rdstate(self)

    def clear(self, *args):
        return _CPnts.ios_clear(self, *args)

    def setstate(self, __state):
        return _CPnts.ios_setstate(self, __state)

    def good(self):
        return _CPnts.ios_good(self)

    def eof(self):
        return _CPnts.ios_eof(self)

    def fail(self):
        return _CPnts.ios_fail(self)

    def bad(self):
        return _CPnts.ios_bad(self)

    def exceptions(self, *args):
        return _CPnts.ios_exceptions(self, *args)

    def __init__(self, __sb):
        _CPnts.ios_swiginit(self, _CPnts.new_ios(__sb))
    __swig_destroy__ = _CPnts.delete_ios

    def tie(self, *args):
        return _CPnts.ios_tie(self, *args)

    def rdbuf(self, *args):
        return _CPnts.ios_rdbuf(self, *args)

    def copyfmt(self, __rhs):
        return _CPnts.ios_copyfmt(self, __rhs)

    def fill(self, *args):
        return _CPnts.ios_fill(self, *args)

    def imbue(self, __loc):
        return _CPnts.ios_imbue(self, __loc)

    def narrow(self, __c, __dfault):
        return _CPnts.ios_narrow(self, __c, __dfault)

    def widen(self, __c):
        return _CPnts.ios_widen(self, __c)

# Register ios in _CPnts:
_CPnts.ios_swigregister(ios)
class ostream(ios):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        _CPnts.ostream_swiginit(self, _CPnts.new_ostream(__sb))
    __swig_destroy__ = _CPnts.delete_ostream

    def __lshift__(self, *args):
        return _CPnts.ostream___lshift__(self, *args)

    def put(self, __c):
        return _CPnts.ostream_put(self, __c)

    def write(self, __s, __n):
        return _CPnts.ostream_write(self, __s, __n)

    def flush(self):
        return _CPnts.ostream_flush(self)

    def tellp(self):
        return _CPnts.ostream_tellp(self)

    def seekp(self, *args):
        return _CPnts.ostream_seekp(self, *args)

# Register ostream in _CPnts:
_CPnts.ostream_swigregister(ostream)
class istream(ios):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        _CPnts.istream_swiginit(self, _CPnts.new_istream(__sb))
    __swig_destroy__ = _CPnts.delete_istream

    def __rshift__(self, *args):
        return _CPnts.istream___rshift__(self, *args)

    def gcount(self):
        return _CPnts.istream_gcount(self)

    def get(self, *args):
        return _CPnts.istream_get(self, *args)

    def getline(self, *args):
        return _CPnts.istream_getline(self, *args)

    def ignore(self, *args):
        return _CPnts.istream_ignore(self, *args)

    def peek(self):
        return _CPnts.istream_peek(self)

    def read(self, __s, __n):
        return _CPnts.istream_read(self, __s, __n)

    def readsome(self, __s, __n):
        return _CPnts.istream_readsome(self, __s, __n)

    def putback(self, __c):
        return _CPnts.istream_putback(self, __c)

    def unget(self):
        return _CPnts.istream_unget(self)

    def sync(self):
        return _CPnts.istream_sync(self)

    def tellg(self):
        return _CPnts.istream_tellg(self)

    def seekg(self, *args):
        return _CPnts.istream_seekg(self, *args)

# Register istream in _CPnts:
_CPnts.istream_swigregister(istream)
class iostream(istream, ostream):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, __sb):
        _CPnts.iostream_swiginit(self, _CPnts.new_iostream(__sb))
    __swig_destroy__ = _CPnts.delete_iostream

# Register iostream in _CPnts:
_CPnts.iostream_swigregister(iostream)
cin = cvar.cin
cout = cvar.cout
cerr = cvar.cerr
clog = cvar.clog

endl_cb_ptr = _CPnts.endl_cb_ptr
endl = _CPnts.endl
ends_cb_ptr = _CPnts.ends_cb_ptr
ends = _CPnts.ends
flush_cb_ptr = _CPnts.flush_cb_ptr
flush = _CPnts.flush
import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.Adaptor3d
import OCC.Core.Geom
import OCC.Core.gp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.math
import OCC.Core.Message
import OCC.Core.OSD

from enum import IntEnum
from OCC.Core.Exception import *



class CPnts_AbscissaPoint(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        No available documentation.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Abscissa: float
        U0: float
        Resolution: float

        Return
        -------
        None

        Description
        -----------
        The algorithm computes a point on a curve <curve> at the distance <abscissa> from the point of parameter <u0>. <resolution> is the error allowed in the computation. the computed point can be outside of the curve 's bounds.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Abscissa: float
        U0: float
        Resolution: float

        Return
        -------
        None

        Description
        -----------
        The algorithm computes a point on a curve <curve> at the distance <abscissa> from the point of parameter <u0>. <resolution> is the error allowed in the computation. the computed point can be outside of the curve 's bounds.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Abscissa: float
        U0: float
        Ui: float
        Resolution: float

        Return
        -------
        None

        Description
        -----------
        The algorithm computes a point on a curve <curve> at the distance <abscissa> from the point of parameter <u0>. <ui> is the starting value used in the iterative process which find the solution, it must be closed to the final solution <resolution> is the error allowed in the computation. the computed point can be outside of the curve 's bounds.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Abscissa: float
        U0: float
        Ui: float
        Resolution: float

        Return
        -------
        None

        Description
        -----------
        The algorithm computes a point on a curve <curve> at the distance <abscissa> from the point of parameter <u0>. <ui> is the starting value used in the iterative process which find the solution, it must be closed to the final solution <resolution> is the error allowed in the computation. the computed point can be outside of the curve 's bounds.

        """
        _CPnts.CPnts_AbscissaPoint_swiginit(self, _CPnts.new_CPnts_AbscissaPoint(*args))

    def AdvPerform(self, *args):
        r"""

        Parameters
        ----------
        Abscissa: float
        U0: float
        Ui: float
        Resolution: float

        Return
        -------
        None

        Description
        -----------
        Computes the point at the distance <abscissa> of the curve; performs more appropriate tolerance management; to use this method in right way it is necessary to call empty constructor. then call method init with tolerance = resolution, then call advpermorm. u0 is the parameter of the point from which the distance is measured and ui is the starting value for the iterative process (should be close to the final solution).

        """
        return _CPnts.CPnts_AbscissaPoint_AdvPerform(self, *args)

    def Init(self, *args):
        r"""

        Parameters
        ----------
        C: Adaptor3d_Curve

        Return
        -------
        None

        Description
        -----------
        Initializes the resolution function with <c>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d

        Return
        -------
        None

        Description
        -----------
        Initializes the resolution function with <c>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Tol: float

        Return
        -------
        None

        Description
        -----------
        Initializes the resolution function with <c>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Tol: float

        Return
        -------
        None

        Description
        -----------
        Initializes the resolution function with <c>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        U1: float
        U2: float

        Return
        -------
        None

        Description
        -----------
        Initializes the resolution function with <c> between u1 and u2.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        U1: float
        U2: float

        Return
        -------
        None

        Description
        -----------
        Initializes the resolution function with <c> between u1 and u2.

        Parameters
        ----------
        C: Adaptor3d_Curve
        U1: float
        U2: float
        Tol: float

        Return
        -------
        None

        Description
        -----------
        Initializes the resolution function with <c> between u1 and u2.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        U1: float
        U2: float
        Tol: float

        Return
        -------
        None

        Description
        -----------
        Initializes the resolution function with <c> between u1 and u2.

        """
        return _CPnts.CPnts_AbscissaPoint_Init(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        True if the computation was successful, false otherwise.

        """
        return _CPnts.CPnts_AbscissaPoint_IsDone(self, *args)

    @staticmethod
    def Length(*args):
        r"""

        Parameters
        ----------
        C: Adaptor3d_Curve

        Return
        -------
        float

        Description
        -----------
        Computes the length of the curve <c>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d

        Return
        -------
        float

        Description
        -----------
        Computes the length of the curve <c>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Tol: float

        Return
        -------
        float

        Description
        -----------
        Computes the length of the curve <c> with the given tolerance.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Tol: float

        Return
        -------
        float

        Description
        -----------
        Computes the length of the curve <c> with the given tolerance.

        Parameters
        ----------
        C: Adaptor3d_Curve
        U1: float
        U2: float

        Return
        -------
        float

        Description
        -----------
        Computes the length of the curve <c> between <u1> and <u2>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        U1: float
        U2: float

        Return
        -------
        float

        Description
        -----------
        Computes the length of the curve <c> between <u1> and <u2>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        U1: float
        U2: float
        Tol: float

        Return
        -------
        float

        Description
        -----------
        Computes the length of the curve <c> between <u1> and <u2> with the given tolerance.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        U1: float
        U2: float
        Tol: float

        Return
        -------
        float

        Description
        -----------
        Computes the length of the curve <c> between <u1> and <u2> with the given tolerance. creation of a indefinite abscissapoint.

        """
        return _CPnts.CPnts_AbscissaPoint_Length(*args)

    def Parameter(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        Returns the parameter of the solution.

        """
        return _CPnts.CPnts_AbscissaPoint_Parameter(self, *args)

    def Perform(self, *args):
        r"""

        Parameters
        ----------
        Abscissa: float
        U0: float
        Resolution: float

        Return
        -------
        None

        Description
        -----------
        Computes the point at the distance <abscissa> of the curve. u0 is the parameter of the point from which the distance is measured.

        Parameters
        ----------
        Abscissa: float
        U0: float
        Ui: float
        Resolution: float

        Return
        -------
        None

        Description
        -----------
        Computes the point at the distance <abscissa> of the curve. u0 is the parameter of the point from which the distance is measured and ui is the starting value for the iterative process (should be close to the final solution).

        """
        return _CPnts.CPnts_AbscissaPoint_Perform(self, *args)

    def SetParameter(self, *args):
        r"""

        Parameters
        ----------
        P: float

        Return
        -------
        None

        Description
        -----------
        Enforce the solution, used by gcpnts.

        """
        return _CPnts.CPnts_AbscissaPoint_SetParameter(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _CPnts.delete_CPnts_AbscissaPoint

# Register CPnts_AbscissaPoint in _CPnts:
_CPnts.CPnts_AbscissaPoint_swigregister(CPnts_AbscissaPoint)
class CPnts_MyGaussFunction(OCC.Core.math.math_Function):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _CPnts.CPnts_MyGaussFunction_swiginit(self, _CPnts.new_CPnts_MyGaussFunction(*args))

    def Init(self, *args):
        r"""

        Parameters
        ----------
        F: CPnts_RealFunction
        D: Standard_Address

        Return
        -------
        None

        Description
        -----------
        F is a pointer on a function d is a client data //! each value is computed with f(d).

        """
        return _CPnts.CPnts_MyGaussFunction_Init(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _CPnts.delete_CPnts_MyGaussFunction

# Register CPnts_MyGaussFunction in _CPnts:
_CPnts.CPnts_MyGaussFunction_swigregister(CPnts_MyGaussFunction)
class CPnts_MyRootFunction(OCC.Core.math.math_FunctionWithDerivative):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _CPnts.CPnts_MyRootFunction_swiginit(self, _CPnts.new_CPnts_MyRootFunction(*args))

    def Init(self, *args):
        r"""

        Parameters
        ----------
        F: CPnts_RealFunction
        D: Standard_Address
        Order: int

        Return
        -------
        None

        Description
        -----------
        F is a pointer on a function d is a client data order is the order of integration to use.

        Parameters
        ----------
        X0: float
        L: float

        Return
        -------
        None

        Description
        -----------
        We want to solve integral(x0,x,f(x,d)) = l.

        Parameters
        ----------
        X0: float
        L: float
        Tol: float

        Return
        -------
        None

        Description
        -----------
        We want to solve integral(x0,x,f(x,d)) = l with given tolerance.

        """
        return _CPnts.CPnts_MyRootFunction_Init(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _CPnts.delete_CPnts_MyRootFunction

# Register CPnts_MyRootFunction in _CPnts:
_CPnts.CPnts_MyRootFunction_swigregister(CPnts_MyRootFunction)
class CPnts_UniformDeflection(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        Creation of a indefinite uniformdeflection.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Deflection: float
        Resolution: float
        WithControl: bool

        Return
        -------
        None

        Description
        -----------
        Computes a uniform deflection distribution of points on the curve <c>. <deflection> defines the constant deflection value. the algorithm computes the number of points and the points. the curve <c> must be at least c2 else the computation can fail. if just some parts of the curve is c2 it is better to give the parameters bounds and to use the below constructor . if <withcontrol> is true, the algorithm controls the estimate deflection when the curve is singular at the point p(u),the algorithm computes the next point as p(u + max(currentstep,abs(lastparameter-firstparameter))) if the singularity is at the first point ,the next point calculated is the p(lastparameter).

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Deflection: float
        Resolution: float
        WithControl: bool

        Return
        -------
        None

        Description
        -----------
        As above with 2d curve.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Deflection: float
        U1: float
        U2: float
        Resolution: float
        WithControl: bool

        Return
        -------
        None

        Description
        -----------
        Computes an uniform deflection distribution of points on a part of the curve <c>. deflection defines the step between the points. <u1> and <u2> define the distribution span. <u1> and <u2> must be in the parametric range of the curve.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Deflection: float
        U1: float
        U2: float
        Resolution: float
        WithControl: bool

        Return
        -------
        None

        Description
        -----------
        As above with 2d curve.

        """
        _CPnts.CPnts_UniformDeflection_swiginit(self, _CPnts.new_CPnts_UniformDeflection(*args))

    def Initialize(self, *args):
        r"""

        Parameters
        ----------
        C: Adaptor3d_Curve
        Deflection: float
        Resolution: float
        WithControl: bool

        Return
        -------
        None

        Description
        -----------
        Initialize the algorithms with <c>, <deflection>, <ustep>, <resolution> and <withcontrol>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Deflection: float
        Resolution: float
        WithControl: bool

        Return
        -------
        None

        Description
        -----------
        Initialize the algorithms with <c>, <deflection>, <ustep>, <resolution> and <withcontrol>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Deflection: float
        U1: float
        U2: float
        Resolution: float
        WithControl: bool

        Return
        -------
        None

        Description
        -----------
        Initialize the algorithms with <c>, <deflection>, <ustep>, <u1>, <u2> and <withcontrol>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Deflection: float
        U1: float
        U2: float
        Resolution: float
        WithControl: bool

        Return
        -------
        None

        Description
        -----------
        Initialize the algorithms with <c>, <deflection>, <ustep>, <u1>, <u2> and <withcontrol>.

        """
        return _CPnts.CPnts_UniformDeflection_Initialize(self, *args)

    def IsAllDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        To know if all the calculus were done successfully (ie all the points have been computed). the calculus can fail if the curve is not c1 in the considered domain. returns true if the calculus was successful.

        """
        return _CPnts.CPnts_UniformDeflection_IsAllDone(self, *args)

    def More(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if it exists a next point.

        """
        return _CPnts.CPnts_UniformDeflection_More(self, *args)

    def Next(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        Go to the next point.

        """
        return _CPnts.CPnts_UniformDeflection_Next(self, *args)

    def Point(self, *args):
        r"""
        Return
        -------
        gp_Pnt

        Description
        -----------
        Return the computed parameter.

        """
        return _CPnts.CPnts_UniformDeflection_Point(self, *args)

    def Value(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        Return the computed parameter.

        """
        return _CPnts.CPnts_UniformDeflection_Value(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _CPnts.delete_CPnts_UniformDeflection

# Register CPnts_UniformDeflection in _CPnts:
_CPnts.CPnts_UniformDeflection_swigregister(CPnts_UniformDeflection)



@deprecated
def CPnts_AbscissaPoint_Length(*args):
	return CPnts_AbscissaPoint.Length(*args)

@deprecated
def CPnts_AbscissaPoint_Length(*args):
	return CPnts_AbscissaPoint.Length(*args)

@deprecated
def CPnts_AbscissaPoint_Length(*args):
	return CPnts_AbscissaPoint.Length(*args)

@deprecated
def CPnts_AbscissaPoint_Length(*args):
	return CPnts_AbscissaPoint.Length(*args)

@deprecated
def CPnts_AbscissaPoint_Length(*args):
	return CPnts_AbscissaPoint.Length(*args)

@deprecated
def CPnts_AbscissaPoint_Length(*args):
	return CPnts_AbscissaPoint.Length(*args)

@deprecated
def CPnts_AbscissaPoint_Length(*args):
	return CPnts_AbscissaPoint.Length(*args)

@deprecated
def CPnts_AbscissaPoint_Length(*args):
	return CPnts_AbscissaPoint.Length(*args)



