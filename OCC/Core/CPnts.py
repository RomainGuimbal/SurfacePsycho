# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""
CPnts module, see official documentation at
https://www.opencascade.com/doc/occt-7.7.0/refman/html/package_cpnts.html
"""

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _CPnts
else:
    import _CPnts

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _CPnts.delete_SwigPyIterator

    def value(self):
        return _CPnts.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _CPnts.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _CPnts.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _CPnts.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _CPnts.SwigPyIterator_equal(self, x)

    def copy(self):
        return _CPnts.SwigPyIterator_copy(self)

    def next(self):
        return _CPnts.SwigPyIterator_next(self)

    def __next__(self):
        return _CPnts.SwigPyIterator___next__(self)

    def previous(self):
        return _CPnts.SwigPyIterator_previous(self)

    def advance(self, n):
        return _CPnts.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _CPnts.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _CPnts.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _CPnts.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _CPnts.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _CPnts.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _CPnts.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _CPnts:
_CPnts.SwigPyIterator_swigregister(SwigPyIterator)

def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error, method_name, class_name):
    return _CPnts.process_exception(error, method_name, class_name)

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.Adaptor3d
import OCC.Core.Geom
import OCC.Core.gp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.math
import OCC.Core.Message
import OCC.Core.OSD

from enum import IntEnum
from OCC.Core.Exception import *



class CPnts_AbscissaPoint(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        No available documentation.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Abscissa: float
        U0: float
        Resolution: float

        Return
        -------
        None

        Description
        -----------
        The algorithm computes a point on a curve <curve> at the distance <abscissa> from the point of parameter <u0>. <resolution> is the error allowed in the computation. the computed point can be outside of the curve 's bounds.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Abscissa: float
        U0: float
        Resolution: float

        Return
        -------
        None

        Description
        -----------
        The algorithm computes a point on a curve <curve> at the distance <abscissa> from the point of parameter <u0>. <resolution> is the error allowed in the computation. the computed point can be outside of the curve 's bounds.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Abscissa: float
        U0: float
        Ui: float
        Resolution: float

        Return
        -------
        None

        Description
        -----------
        The algorithm computes a point on a curve <curve> at the distance <abscissa> from the point of parameter <u0>. <ui> is the starting value used in the iterative process which find the solution, it must be closed to the final solution <resolution> is the error allowed in the computation. the computed point can be outside of the curve 's bounds.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Abscissa: float
        U0: float
        Ui: float
        Resolution: float

        Return
        -------
        None

        Description
        -----------
        The algorithm computes a point on a curve <curve> at the distance <abscissa> from the point of parameter <u0>. <ui> is the starting value used in the iterative process which find the solution, it must be closed to the final solution <resolution> is the error allowed in the computation. the computed point can be outside of the curve 's bounds.

        """
        _CPnts.CPnts_AbscissaPoint_swiginit(self, _CPnts.new_CPnts_AbscissaPoint(*args))

    def AdvPerform(self, *args):
        r"""

        Parameters
        ----------
        Abscissa: float
        U0: float
        Ui: float
        Resolution: float

        Return
        -------
        None

        Description
        -----------
        Computes the point at the distance <abscissa> of the curve; performs more appropriate tolerance management; to use this method in right way it is necessary to call empty constructor. then call method init with tolerance = resolution, then call advpermorm. u0 is the parameter of the point from which the distance is measured and ui is the starting value for the iterative process (should be close to the final solution).

        """
        return _CPnts.CPnts_AbscissaPoint_AdvPerform(self, *args)

    def Init(self, *args):
        r"""

        Parameters
        ----------
        C: Adaptor3d_Curve

        Return
        -------
        None

        Description
        -----------
        Initializes the resolution function with <c>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d

        Return
        -------
        None

        Description
        -----------
        Initializes the resolution function with <c>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Tol: float

        Return
        -------
        None

        Description
        -----------
        Initializes the resolution function with <c>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Tol: float

        Return
        -------
        None

        Description
        -----------
        Initializes the resolution function with <c>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        U1: float
        U2: float

        Return
        -------
        None

        Description
        -----------
        Initializes the resolution function with <c> between u1 and u2.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        U1: float
        U2: float

        Return
        -------
        None

        Description
        -----------
        Initializes the resolution function with <c> between u1 and u2.

        Parameters
        ----------
        C: Adaptor3d_Curve
        U1: float
        U2: float
        Tol: float

        Return
        -------
        None

        Description
        -----------
        Initializes the resolution function with <c> between u1 and u2.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        U1: float
        U2: float
        Tol: float

        Return
        -------
        None

        Description
        -----------
        Initializes the resolution function with <c> between u1 and u2.

        """
        return _CPnts.CPnts_AbscissaPoint_Init(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        True if the computation was successful, false otherwise.

        """
        return _CPnts.CPnts_AbscissaPoint_IsDone(self, *args)

    @staticmethod
    def Length(*args):
        r"""

        Parameters
        ----------
        C: Adaptor3d_Curve

        Return
        -------
        float

        Description
        -----------
        Computes the length of the curve <c>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d

        Return
        -------
        float

        Description
        -----------
        Computes the length of the curve <c>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Tol: float

        Return
        -------
        float

        Description
        -----------
        Computes the length of the curve <c> with the given tolerance.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Tol: float

        Return
        -------
        float

        Description
        -----------
        Computes the length of the curve <c> with the given tolerance.

        Parameters
        ----------
        C: Adaptor3d_Curve
        U1: float
        U2: float

        Return
        -------
        float

        Description
        -----------
        Computes the length of the curve <c> between <u1> and <u2>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        U1: float
        U2: float

        Return
        -------
        float

        Description
        -----------
        Computes the length of the curve <c> between <u1> and <u2>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        U1: float
        U2: float
        Tol: float

        Return
        -------
        float

        Description
        -----------
        Computes the length of the curve <c> between <u1> and <u2> with the given tolerance.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        U1: float
        U2: float
        Tol: float

        Return
        -------
        float

        Description
        -----------
        Computes the length of the curve <c> between <u1> and <u2> with the given tolerance. creation of a indefinite abscissapoint.

        """
        return _CPnts.CPnts_AbscissaPoint_Length(*args)

    def Parameter(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        Returns the parameter of the solution.

        """
        return _CPnts.CPnts_AbscissaPoint_Parameter(self, *args)

    def Perform(self, *args):
        r"""

        Parameters
        ----------
        Abscissa: float
        U0: float
        Resolution: float

        Return
        -------
        None

        Description
        -----------
        Computes the point at the distance <abscissa> of the curve. u0 is the parameter of the point from which the distance is measured.

        Parameters
        ----------
        Abscissa: float
        U0: float
        Ui: float
        Resolution: float

        Return
        -------
        None

        Description
        -----------
        Computes the point at the distance <abscissa> of the curve. u0 is the parameter of the point from which the distance is measured and ui is the starting value for the iterative process (should be close to the final solution).

        """
        return _CPnts.CPnts_AbscissaPoint_Perform(self, *args)

    def SetParameter(self, *args):
        r"""

        Parameters
        ----------
        P: float

        Return
        -------
        None

        Description
        -----------
        Enforce the solution, used by gcpnts.

        """
        return _CPnts.CPnts_AbscissaPoint_SetParameter(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _CPnts.delete_CPnts_AbscissaPoint

# Register CPnts_AbscissaPoint in _CPnts:
_CPnts.CPnts_AbscissaPoint_swigregister(CPnts_AbscissaPoint)
class CPnts_MyGaussFunction(OCC.Core.math.math_Function):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _CPnts.CPnts_MyGaussFunction_swiginit(self, _CPnts.new_CPnts_MyGaussFunction(*args))

    def Init(self, *args):
        r"""

        Parameters
        ----------
        F: CPnts_RealFunction
        D: Standard_Address

        Return
        -------
        None

        Description
        -----------
        F is a pointer on a function d is a client data //! each value is computed with f(d).

        """
        return _CPnts.CPnts_MyGaussFunction_Init(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _CPnts.delete_CPnts_MyGaussFunction

# Register CPnts_MyGaussFunction in _CPnts:
_CPnts.CPnts_MyGaussFunction_swigregister(CPnts_MyGaussFunction)
class CPnts_MyRootFunction(OCC.Core.math.math_FunctionWithDerivative):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _CPnts.CPnts_MyRootFunction_swiginit(self, _CPnts.new_CPnts_MyRootFunction(*args))

    def Init(self, *args):
        r"""

        Parameters
        ----------
        F: CPnts_RealFunction
        D: Standard_Address
        Order: int

        Return
        -------
        None

        Description
        -----------
        F is a pointer on a function d is a client data order is the order of integration to use.

        Parameters
        ----------
        X0: float
        L: float

        Return
        -------
        None

        Description
        -----------
        We want to solve integral(x0,x,f(x,d)) = l.

        Parameters
        ----------
        X0: float
        L: float
        Tol: float

        Return
        -------
        None

        Description
        -----------
        We want to solve integral(x0,x,f(x,d)) = l with given tolerance.

        """
        return _CPnts.CPnts_MyRootFunction_Init(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _CPnts.delete_CPnts_MyRootFunction

# Register CPnts_MyRootFunction in _CPnts:
_CPnts.CPnts_MyRootFunction_swigregister(CPnts_MyRootFunction)
class CPnts_UniformDeflection(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        Creation of a indefinite uniformdeflection.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Deflection: float
        Resolution: float
        WithControl: bool

        Return
        -------
        None

        Description
        -----------
        Computes a uniform deflection distribution of points on the curve <c>. <deflection> defines the constant deflection value. the algorithm computes the number of points and the points. the curve <c> must be at least c2 else the computation can fail. if just some parts of the curve is c2 it is better to give the parameters bounds and to use the below constructor . if <withcontrol> is true, the algorithm controls the estimate deflection when the curve is singular at the point p(u),the algorithm computes the next point as p(u + max(currentstep,abs(lastparameter-firstparameter))) if the singularity is at the first point ,the next point calculated is the p(lastparameter).

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Deflection: float
        Resolution: float
        WithControl: bool

        Return
        -------
        None

        Description
        -----------
        As above with 2d curve.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Deflection: float
        U1: float
        U2: float
        Resolution: float
        WithControl: bool

        Return
        -------
        None

        Description
        -----------
        Computes an uniform deflection distribution of points on a part of the curve <c>. deflection defines the step between the points. <u1> and <u2> define the distribution span. <u1> and <u2> must be in the parametric range of the curve.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Deflection: float
        U1: float
        U2: float
        Resolution: float
        WithControl: bool

        Return
        -------
        None

        Description
        -----------
        As above with 2d curve.

        """
        _CPnts.CPnts_UniformDeflection_swiginit(self, _CPnts.new_CPnts_UniformDeflection(*args))

    def Initialize(self, *args):
        r"""

        Parameters
        ----------
        C: Adaptor3d_Curve
        Deflection: float
        Resolution: float
        WithControl: bool

        Return
        -------
        None

        Description
        -----------
        Initialize the algorithms with <c>, <deflection>, <ustep>, <resolution> and <withcontrol>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Deflection: float
        Resolution: float
        WithControl: bool

        Return
        -------
        None

        Description
        -----------
        Initialize the algorithms with <c>, <deflection>, <ustep>, <resolution> and <withcontrol>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Deflection: float
        U1: float
        U2: float
        Resolution: float
        WithControl: bool

        Return
        -------
        None

        Description
        -----------
        Initialize the algorithms with <c>, <deflection>, <ustep>, <u1>, <u2> and <withcontrol>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Deflection: float
        U1: float
        U2: float
        Resolution: float
        WithControl: bool

        Return
        -------
        None

        Description
        -----------
        Initialize the algorithms with <c>, <deflection>, <ustep>, <u1>, <u2> and <withcontrol>.

        """
        return _CPnts.CPnts_UniformDeflection_Initialize(self, *args)

    def IsAllDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        To know if all the calculus were done successfully (ie all the points have been computed). the calculus can fail if the curve is not c1 in the considered domain. returns true if the calculus was successful.

        """
        return _CPnts.CPnts_UniformDeflection_IsAllDone(self, *args)

    def More(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if it exists a next point.

        """
        return _CPnts.CPnts_UniformDeflection_More(self, *args)

    def Next(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        Go to the next point.

        """
        return _CPnts.CPnts_UniformDeflection_Next(self, *args)

    def Point(self, *args):
        r"""
        Return
        -------
        gp_Pnt

        Description
        -----------
        Return the computed parameter.

        """
        return _CPnts.CPnts_UniformDeflection_Point(self, *args)

    def Value(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        Return the computed parameter.

        """
        return _CPnts.CPnts_UniformDeflection_Value(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _CPnts.delete_CPnts_UniformDeflection

# Register CPnts_UniformDeflection in _CPnts:
_CPnts.CPnts_UniformDeflection_swigregister(CPnts_UniformDeflection)



@deprecated
def CPnts_AbscissaPoint_Length(*args):
	return CPnts_AbscissaPoint.Length(*args)

@deprecated
def CPnts_AbscissaPoint_Length(*args):
	return CPnts_AbscissaPoint.Length(*args)

@deprecated
def CPnts_AbscissaPoint_Length(*args):
	return CPnts_AbscissaPoint.Length(*args)

@deprecated
def CPnts_AbscissaPoint_Length(*args):
	return CPnts_AbscissaPoint.Length(*args)

@deprecated
def CPnts_AbscissaPoint_Length(*args):
	return CPnts_AbscissaPoint.Length(*args)

@deprecated
def CPnts_AbscissaPoint_Length(*args):
	return CPnts_AbscissaPoint.Length(*args)

@deprecated
def CPnts_AbscissaPoint_Length(*args):
	return CPnts_AbscissaPoint.Length(*args)

@deprecated
def CPnts_AbscissaPoint_Length(*args):
	return CPnts_AbscissaPoint.Length(*args)



