# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
BOPTools module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_boptools.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BOPTools')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BOPTools')
    _BOPTools = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BOPTools', [dirname(__file__)])
        except ImportError:
            import _BOPTools
            return _BOPTools
        try:
            _mod = imp.load_module('_BOPTools', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BOPTools = swig_import_helper()
    del swig_import_helper
else:
    import _BOPTools
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BOPTools.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _BOPTools.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _BOPTools.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _BOPTools.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _BOPTools.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _BOPTools.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _BOPTools.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _BOPTools.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _BOPTools.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _BOPTools.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _BOPTools.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _BOPTools.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _BOPTools.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _BOPTools.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _BOPTools.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _BOPTools.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _BOPTools.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BOPTools.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _BOPTools.process_exception(error, method_name, class_name)
process_exception = _BOPTools.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TopoDS
import OCC.Core.Message
import OCC.Core.TCollection
import OCC.Core.OSD
import OCC.Core.TColStd
import OCC.Core.TopAbs
import OCC.Core.TopLoc
import OCC.Core.gp
import OCC.Core.IntTools
import OCC.Core.BRepAdaptor
import OCC.Core.Adaptor3d
import OCC.Core.Geom
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.math
import OCC.Core.GeomAdaptor
import OCC.Core.Geom2dAdaptor
import OCC.Core.Bnd
import OCC.Core.BVH
import OCC.Core.Geom2dHatch
import OCC.Core.IntRes2d
import OCC.Core.HatchGen
import OCC.Core.Geom2dInt
import OCC.Core.IntCurve
import OCC.Core.Extrema
import OCC.Core.Intf
import OCC.Core.GeomAPI
import OCC.Core.Approx
import OCC.Core.AppCont
import OCC.Core.AppParCurves
import OCC.Core.BRepClass3d
import OCC.Core.IntCurveSurface
import OCC.Core.IntSurf
import OCC.Core.TopTools
import OCC.Core.IntCurvesFace
import OCC.Core.IntPatch
import OCC.Core.IntAna
import OCC.Core.GeomInt
import OCC.Core.IntImp
import OCC.Core.ApproxInt

from enum import IntEnum
from OCC.Core.Exception import *



class BOPTools_IndexedDataMapOfSetShape(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BOPTools_IndexedDataMapOfSetShape, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BOPTools_IndexedDataMapOfSetShape, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_IndexedDataMap< BOPTools_Set,TopoDS_Shape,BOPTools_SetMapHasher >::iterator":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_begin(self)

    def end(self) -> "NCollection_IndexedDataMap< BOPTools_Set,TopoDS_Shape,BOPTools_SetMapHasher >::iterator":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_end(self)

    def cbegin(self) -> "NCollection_IndexedDataMap< BOPTools_Set,TopoDS_Shape,BOPTools_SetMapHasher >::const_iterator":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_cbegin(self)

    def cend(self) -> "NCollection_IndexedDataMap< BOPTools_Set,TopoDS_Shape,BOPTools_SetMapHasher >::const_iterator":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_cend(self)

    def __init__(self, *args):
        this = _BOPTools.new_BOPTools_IndexedDataMapOfSetShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, theOther: 'BOPTools_IndexedDataMapOfSetShape') -> "void":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_Exchange(self, theOther)

    def Assign(self, theOther: 'BOPTools_IndexedDataMapOfSetShape') -> "NCollection_IndexedDataMap< BOPTools_Set,TopoDS_Shape,BOPTools_SetMapHasher > &":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_Assign(self, theOther)

    def Set(self, theOther: 'BOPTools_IndexedDataMapOfSetShape') -> "NCollection_IndexedDataMap< BOPTools_Set,TopoDS_Shape,BOPTools_SetMapHasher > &":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_Set(self, theOther)

    def ReSize(self, N: 'Standard_Integer const') -> "void":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_ReSize(self, N)

    def Add(self, theKey1: 'BOPTools_Set', theItem: 'TopoDS_Shape') -> "Standard_Integer":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_Add(self, theKey1, theItem)

    def Contains(self, theKey1: 'BOPTools_Set') -> "Standard_Boolean":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_Contains(self, theKey1)

    def Substitute(self, theIndex: 'Standard_Integer const', theKey1: 'BOPTools_Set', theItem: 'TopoDS_Shape') -> "void":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_Substitute(self, theIndex, theKey1, theItem)

    def Swap(self, theIndex1: 'Standard_Integer const', theIndex2: 'Standard_Integer const') -> "void":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_Swap(self, theIndex1, theIndex2)

    def RemoveLast(self) -> "void":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_RemoveLast(self)

    def RemoveFromIndex(self, theIndex: 'Standard_Integer const') -> "void":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_RemoveFromIndex(self, theIndex)

    def RemoveKey(self, theKey1: 'BOPTools_Set') -> "void":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_RemoveKey(self, theKey1)

    def FindKey(self, theIndex: 'Standard_Integer const') -> "BOPTools_Set const &":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_FindKey(self, theIndex)

    def FindFromIndex(self, theIndex: 'Standard_Integer const') -> "TopoDS_Shape const &":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_FindFromIndex(self, theIndex)

    def ChangeFromIndex(self, theIndex: 'Standard_Integer const') -> "TopoDS_Shape &":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_ChangeFromIndex(self, theIndex)

    def __call__(self, *args) -> "TopoDS_Shape &":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape___call__(self, *args)

    def FindIndex(self, theKey1: 'BOPTools_Set') -> "Standard_Integer":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_FindIndex(self, theKey1)

    def ChangeFromKey(self, theKey1: 'BOPTools_Set') -> "TopoDS_Shape &":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_ChangeFromKey(self, theKey1)

    def Seek(self, theKey1: 'BOPTools_Set') -> "TopoDS_Shape const *":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_Seek(self, theKey1)

    def ChangeSeek(self, theKey1: 'BOPTools_Set') -> "TopoDS_Shape *":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_ChangeSeek(self, theKey1)

    def FindFromKey(self, *args) -> "Standard_Boolean":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_FindFromKey(self, *args)

    def Clear(self, *args) -> "void":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_Clear(self, *args)
    __swig_destroy__ = _BOPTools.delete_BOPTools_IndexedDataMapOfSetShape
    __del__ = lambda self: None

    def Size(self) -> "Standard_Integer":
        return _BOPTools.BOPTools_IndexedDataMapOfSetShape_Size(self)
BOPTools_IndexedDataMapOfSetShape_swigregister = _BOPTools.BOPTools_IndexedDataMapOfSetShape_swigregister
BOPTools_IndexedDataMapOfSetShape_swigregister(BOPTools_IndexedDataMapOfSetShape)

class BOPTools_ListOfConnexityBlock(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BOPTools_ListOfConnexityBlock, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BOPTools_ListOfConnexityBlock, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_List< BOPTools_ConnexityBlock >::iterator":
        return _BOPTools.BOPTools_ListOfConnexityBlock_begin(self)

    def end(self) -> "NCollection_List< BOPTools_ConnexityBlock >::iterator":
        return _BOPTools.BOPTools_ListOfConnexityBlock_end(self)

    def cbegin(self) -> "NCollection_List< BOPTools_ConnexityBlock >::const_iterator":
        return _BOPTools.BOPTools_ListOfConnexityBlock_cbegin(self)

    def cend(self) -> "NCollection_List< BOPTools_ConnexityBlock >::const_iterator":
        return _BOPTools.BOPTools_ListOfConnexityBlock_cend(self)

    def __init__(self, *args):
        this = _BOPTools.new_BOPTools_ListOfConnexityBlock(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self) -> "Standard_Integer":
        return _BOPTools.BOPTools_ListOfConnexityBlock_Size(self)

    def Assign(self, theOther: 'BOPTools_ListOfConnexityBlock') -> "NCollection_List< BOPTools_ConnexityBlock > &":
        return _BOPTools.BOPTools_ListOfConnexityBlock_Assign(self, theOther)

    def Set(self, theOther: 'BOPTools_ListOfConnexityBlock') -> "NCollection_List< BOPTools_ConnexityBlock > &":
        return _BOPTools.BOPTools_ListOfConnexityBlock_Set(self, theOther)

    def Clear(self, theAllocator: 'IntSurf_Allocator'=0) -> "void":
        return _BOPTools.BOPTools_ListOfConnexityBlock_Clear(self, theAllocator)

    def First(self) -> "BOPTools_ConnexityBlock const &":
        return _BOPTools.BOPTools_ListOfConnexityBlock_First(self)

    def Last(self) -> "BOPTools_ConnexityBlock const &":
        return _BOPTools.BOPTools_ListOfConnexityBlock_Last(self)

    def Append(self, *args) -> "void":
        return _BOPTools.BOPTools_ListOfConnexityBlock_Append(self, *args)

    def Prepend(self, *args) -> "void":
        return _BOPTools.BOPTools_ListOfConnexityBlock_Prepend(self, *args)

    def RemoveFirst(self) -> "void":
        return _BOPTools.BOPTools_ListOfConnexityBlock_RemoveFirst(self)

    def Remove(self, theIter: 'NCollection_List< BOPTools_ConnexityBlock >::Iterator &') -> "void":
        return _BOPTools.BOPTools_ListOfConnexityBlock_Remove(self, theIter)

    def InsertBefore(self, *args) -> "void":
        return _BOPTools.BOPTools_ListOfConnexityBlock_InsertBefore(self, *args)

    def InsertAfter(self, *args) -> "void":
        return _BOPTools.BOPTools_ListOfConnexityBlock_InsertAfter(self, *args)

    def Reverse(self) -> "void":
        return _BOPTools.BOPTools_ListOfConnexityBlock_Reverse(self)
    __swig_destroy__ = _BOPTools.delete_BOPTools_ListOfConnexityBlock
    __del__ = lambda self: None

    def __len__(self):
        return self.Size()

BOPTools_ListOfConnexityBlock_swigregister = _BOPTools.BOPTools_ListOfConnexityBlock_swigregister
BOPTools_ListOfConnexityBlock_swigregister(BOPTools_ListOfConnexityBlock)

class BOPTools_ListOfCoupleOfShape(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BOPTools_ListOfCoupleOfShape, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BOPTools_ListOfCoupleOfShape, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_List< BOPTools_CoupleOfShape >::iterator":
        return _BOPTools.BOPTools_ListOfCoupleOfShape_begin(self)

    def end(self) -> "NCollection_List< BOPTools_CoupleOfShape >::iterator":
        return _BOPTools.BOPTools_ListOfCoupleOfShape_end(self)

    def cbegin(self) -> "NCollection_List< BOPTools_CoupleOfShape >::const_iterator":
        return _BOPTools.BOPTools_ListOfCoupleOfShape_cbegin(self)

    def cend(self) -> "NCollection_List< BOPTools_CoupleOfShape >::const_iterator":
        return _BOPTools.BOPTools_ListOfCoupleOfShape_cend(self)

    def __init__(self, *args):
        this = _BOPTools.new_BOPTools_ListOfCoupleOfShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self) -> "Standard_Integer":
        return _BOPTools.BOPTools_ListOfCoupleOfShape_Size(self)

    def Assign(self, theOther: 'BOPTools_ListOfCoupleOfShape') -> "NCollection_List< BOPTools_CoupleOfShape > &":
        return _BOPTools.BOPTools_ListOfCoupleOfShape_Assign(self, theOther)

    def Set(self, theOther: 'BOPTools_ListOfCoupleOfShape') -> "NCollection_List< BOPTools_CoupleOfShape > &":
        return _BOPTools.BOPTools_ListOfCoupleOfShape_Set(self, theOther)

    def Clear(self, theAllocator: 'IntSurf_Allocator'=0) -> "void":
        return _BOPTools.BOPTools_ListOfCoupleOfShape_Clear(self, theAllocator)

    def First(self) -> "BOPTools_CoupleOfShape const &":
        return _BOPTools.BOPTools_ListOfCoupleOfShape_First(self)

    def Last(self) -> "BOPTools_CoupleOfShape const &":
        return _BOPTools.BOPTools_ListOfCoupleOfShape_Last(self)

    def Append(self, *args) -> "void":
        return _BOPTools.BOPTools_ListOfCoupleOfShape_Append(self, *args)

    def Prepend(self, *args) -> "void":
        return _BOPTools.BOPTools_ListOfCoupleOfShape_Prepend(self, *args)

    def RemoveFirst(self) -> "void":
        return _BOPTools.BOPTools_ListOfCoupleOfShape_RemoveFirst(self)

    def Remove(self, theIter: 'NCollection_List< BOPTools_CoupleOfShape >::Iterator &') -> "void":
        return _BOPTools.BOPTools_ListOfCoupleOfShape_Remove(self, theIter)

    def InsertBefore(self, *args) -> "void":
        return _BOPTools.BOPTools_ListOfCoupleOfShape_InsertBefore(self, *args)

    def InsertAfter(self, *args) -> "void":
        return _BOPTools.BOPTools_ListOfCoupleOfShape_InsertAfter(self, *args)

    def Reverse(self) -> "void":
        return _BOPTools.BOPTools_ListOfCoupleOfShape_Reverse(self)
    __swig_destroy__ = _BOPTools.delete_BOPTools_ListOfCoupleOfShape
    __del__ = lambda self: None

    def __len__(self):
        return self.Size()

BOPTools_ListOfCoupleOfShape_swigregister = _BOPTools.BOPTools_ListOfCoupleOfShape_swigregister
BOPTools_ListOfCoupleOfShape_swigregister(BOPTools_ListOfCoupleOfShape)

class BOPTools_MapOfSet(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BOPTools_MapOfSet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BOPTools_MapOfSet, name)
    __repr__ = _swig_repr

    def cbegin(self) -> "NCollection_Map< BOPTools_Set,BOPTools_SetMapHasher >::const_iterator":
        return _BOPTools.BOPTools_MapOfSet_cbegin(self)

    def cend(self) -> "NCollection_Map< BOPTools_Set,BOPTools_SetMapHasher >::const_iterator":
        return _BOPTools.BOPTools_MapOfSet_cend(self)

    def __init__(self, *args):
        this = _BOPTools.new_BOPTools_MapOfSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, theOther: 'BOPTools_MapOfSet') -> "void":
        return _BOPTools.BOPTools_MapOfSet_Exchange(self, theOther)

    def Assign(self, theOther: 'BOPTools_MapOfSet') -> "NCollection_Map< BOPTools_Set,BOPTools_SetMapHasher > &":
        return _BOPTools.BOPTools_MapOfSet_Assign(self, theOther)

    def Set(self, theOther: 'BOPTools_MapOfSet') -> "NCollection_Map< BOPTools_Set,BOPTools_SetMapHasher > &":
        return _BOPTools.BOPTools_MapOfSet_Set(self, theOther)

    def ReSize(self, N: 'Standard_Integer const') -> "void":
        return _BOPTools.BOPTools_MapOfSet_ReSize(self, N)

    def Add(self, K: 'BOPTools_Set') -> "Standard_Boolean":
        return _BOPTools.BOPTools_MapOfSet_Add(self, K)

    def Added(self, K: 'BOPTools_Set') -> "BOPTools_Set const &":
        return _BOPTools.BOPTools_MapOfSet_Added(self, K)

    def Remove(self, K: 'BOPTools_Set') -> "Standard_Boolean":
        return _BOPTools.BOPTools_MapOfSet_Remove(self, K)

    def Clear(self, *args) -> "void":
        return _BOPTools.BOPTools_MapOfSet_Clear(self, *args)
    __swig_destroy__ = _BOPTools.delete_BOPTools_MapOfSet
    __del__ = lambda self: None

    def Size(self) -> "Standard_Integer":
        return _BOPTools.BOPTools_MapOfSet_Size(self)

    def IsEqual(self, theOther: 'BOPTools_MapOfSet') -> "Standard_Boolean":
        return _BOPTools.BOPTools_MapOfSet_IsEqual(self, theOther)

    def Contains(self, *args) -> "Standard_Boolean":
        return _BOPTools.BOPTools_MapOfSet_Contains(self, *args)

    def Union(self, theLeft: 'BOPTools_MapOfSet', theRight: 'BOPTools_MapOfSet') -> "void":
        return _BOPTools.BOPTools_MapOfSet_Union(self, theLeft, theRight)

    def Unite(self, theOther: 'BOPTools_MapOfSet') -> "Standard_Boolean":
        return _BOPTools.BOPTools_MapOfSet_Unite(self, theOther)

    def HasIntersection(self, theMap: 'BOPTools_MapOfSet') -> "Standard_Boolean":
        return _BOPTools.BOPTools_MapOfSet_HasIntersection(self, theMap)

    def Intersection(self, theLeft: 'BOPTools_MapOfSet', theRight: 'BOPTools_MapOfSet') -> "void":
        return _BOPTools.BOPTools_MapOfSet_Intersection(self, theLeft, theRight)

    def Intersect(self, theOther: 'BOPTools_MapOfSet') -> "Standard_Boolean":
        return _BOPTools.BOPTools_MapOfSet_Intersect(self, theOther)

    def Subtraction(self, theLeft: 'BOPTools_MapOfSet', theRight: 'BOPTools_MapOfSet') -> "void":
        return _BOPTools.BOPTools_MapOfSet_Subtraction(self, theLeft, theRight)

    def Subtract(self, theOther: 'BOPTools_MapOfSet') -> "Standard_Boolean":
        return _BOPTools.BOPTools_MapOfSet_Subtract(self, theOther)

    def Difference(self, theLeft: 'BOPTools_MapOfSet', theRight: 'BOPTools_MapOfSet') -> "void":
        return _BOPTools.BOPTools_MapOfSet_Difference(self, theLeft, theRight)

    def Differ(self, theOther: 'BOPTools_MapOfSet') -> "Standard_Boolean":
        return _BOPTools.BOPTools_MapOfSet_Differ(self, theOther)
BOPTools_MapOfSet_swigregister = _BOPTools.BOPTools_MapOfSet_swigregister
BOPTools_MapOfSet_swigregister(BOPTools_MapOfSet)

class BOPTools_AlgoTools(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BOPTools_AlgoTools, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BOPTools_AlgoTools, name)
    __repr__ = _swig_repr

    def AreFacesSameDomain(*args) -> "Standard_Boolean":
        """
        Checks if the given faces are same-domain, i.e. coincide.

        Parameters
        ----------
        theF1: TopoDS_Face
        theF2: TopoDS_Face
        theContext: IntTools_Context
        theFuzz: float,optional
        	default value is Precision::Confusion()

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_AlgoTools_AreFacesSameDomain(*args)

    AreFacesSameDomain = staticmethod(AreFacesSameDomain)

    def ComputeState(*args) -> "TopAbs_State":
        """
        Computes the 3-d state of the point thepoint toward solid thesolid. thetol - value of precision of computation thecontext- cahed geometrical tools returns 3-d state.

        Parameters
        ----------
        thePoint: gp_Pnt
        theSolid: TopoDS_Solid
        theTol: float
        theContext: IntTools_Context

        Returns
        -------
        TopAbs_State

        Computes the 3-d state of the vertex thevertex toward solid thesolid. thetol - value of precision of computation thecontext- cahed geometrical tools returns 3-d state.

        Parameters
        ----------
        theVertex: TopoDS_Vertex
        theSolid: TopoDS_Solid
        theTol: float
        theContext: IntTools_Context

        Returns
        -------
        TopAbs_State

        Computes the 3-d state of the edge theedge toward solid thesolid. thetol - value of precision of computation thecontext- cahed geometrical tools returns 3-d state.

        Parameters
        ----------
        theEdge: TopoDS_Edge
        theSolid: TopoDS_Solid
        theTol: float
        theContext: IntTools_Context

        Returns
        -------
        TopAbs_State

        Computes the 3-d state of the face theface toward solid thesolid. thetol - value of precision of computation thebounds - set of edges of <thesolid> to avoid thecontext- cahed geometrical tools returns 3-d state.

        Parameters
        ----------
        theFace: TopoDS_Face
        theSolid: TopoDS_Solid
        theTol: float
        theBounds: TopTools_IndexedMapOfShape
        theContext: IntTools_Context

        Returns
        -------
        TopAbs_State

        """
        return _BOPTools.BOPTools_AlgoTools_ComputeState(*args)

    ComputeState = staticmethod(ComputeState)

    def ComputeStateByOnePoint(*args) -> "TopAbs_State":
        """
        Computes the 3-d state of the shape theshape toward solid thesolid. thetol - value of precision of computation thecontext- cahed geometrical tools returns 3-d state.

        Parameters
        ----------
        theShape: TopoDS_Shape
        theSolid: TopoDS_Solid
        theTol: float
        theContext: IntTools_Context

        Returns
        -------
        TopAbs_State

        """
        return _BOPTools.BOPTools_AlgoTools_ComputeStateByOnePoint(*args)

    ComputeStateByOnePoint = staticmethod(ComputeStateByOnePoint)

    def ComputeTolerance(*args) -> "Standard_Real &, Standard_Real &":
        """
        Computes the necessary value of the tolerance for the edge.

        Parameters
        ----------
        theFace: TopoDS_Face
        theEdge: TopoDS_Edge

        Returns
        -------
        theMaxDist: float
        theMaxPar: float

        """
        return _BOPTools.BOPTools_AlgoTools_ComputeTolerance(*args)

    ComputeTolerance = staticmethod(ComputeTolerance)

    def ComputeVV(*args) -> "Standard_Integer":
        """
        Intersects the vertex <thev1> with the point <thep> with tolerance <thetolp>. returns the error status: - 0 - no error, meaning that the vertex intersects the point; - 1 - the distance between vertex and point is grater than the sum of tolerances.

        Parameters
        ----------
        theV: TopoDS_Vertex
        theP: gp_Pnt
        theTolP: float

        Returns
        -------
        int

        Intersects the given vertices with given fuzzy value. returns the error status: - 0 - no error, meaning that the vertices interferes with given tolerance; - 1 - the distance between vertices is grater than the sum of their tolerances.

        Parameters
        ----------
        theV1: TopoDS_Vertex
        theV2: TopoDS_Vertex
        theFuzz: float,optional
        	default value is Precision::Confusion()

        Returns
        -------
        int

        """
        return _BOPTools.BOPTools_AlgoTools_ComputeVV(*args)

    ComputeVV = staticmethod(ComputeVV)

    def CopyEdge(*args) -> "TopoDS_Edge":
        """
        Makes a copy of <theedge> with vertices.

        Parameters
        ----------
        theEdge: TopoDS_Edge

        Returns
        -------
        TopoDS_Edge

        """
        return _BOPTools.BOPTools_AlgoTools_CopyEdge(*args)

    CopyEdge = staticmethod(CopyEdge)

    def CorrectCurveOnSurface(*args) -> "void":
        """
        Provides valid values of tolerances for the shape <thes> in terms of brepcheck_invalidcurveonsurface.

        Parameters
        ----------
        theS: TopoDS_Shape
        theMapToAvoid: TopTools_IndexedMapOfShape
        theTolMax: float,optional
        	default value is 0.0001
        theRunParallel: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools_CorrectCurveOnSurface(*args)

    CorrectCurveOnSurface = staticmethod(CorrectCurveOnSurface)

    def CorrectPointOnCurve(*args) -> "void":
        """
        Provides valid values of tolerances for the shape <thes> in terms of brepcheck_invalidpointoncurve.

        Parameters
        ----------
        theS: TopoDS_Shape
        theMapToAvoid: TopTools_IndexedMapOfShape
        theTolMax: float,optional
        	default value is 0.0001
        theRunParallel: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools_CorrectPointOnCurve(*args)

    CorrectPointOnCurve = staticmethod(CorrectPointOnCurve)

    def CorrectRange(*args) -> "void":
        """
        Correct shrunk range <asr> taking into account 3d-curve resolution and corresponding tolerance values of <ae1>, <ae2>.

        Parameters
        ----------
        aE1: TopoDS_Edge
        aE2: TopoDS_Edge
        aSR: IntTools_Range
        aNewSR: IntTools_Range

        Returns
        -------
        None

        Correct shrunk range <asr> taking into account 3d-curve resolution and corresponding tolerance values of <ae>, <af>.

        Parameters
        ----------
        aE: TopoDS_Edge
        aF: TopoDS_Face
        aSR: IntTools_Range
        aNewSR: IntTools_Range

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools_CorrectRange(*args)

    CorrectRange = staticmethod(CorrectRange)

    def CorrectShapeTolerances(*args) -> "void":
        """
        Corrects tolerance values of the sub-shapes of the shape <thes> if needed.

        Parameters
        ----------
        theS: TopoDS_Shape
        theMapToAvoid: TopTools_IndexedMapOfShape
        theRunParallel: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools_CorrectShapeTolerances(*args)

    CorrectShapeTolerances = staticmethod(CorrectShapeTolerances)

    def CorrectTolerances(*args) -> "void":
        """
        Provides valid values of tolerances for the shape <thes> <thetolmax> is max value of the tolerance that can be accepted for correction. if real value of the tolerance will be greater than <atolmax>, the correction does not perform.

        Parameters
        ----------
        theS: TopoDS_Shape
        theMapToAvoid: TopTools_IndexedMapOfShape
        theTolMax: float,optional
        	default value is 0.0001
        theRunParallel: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools_CorrectTolerances(*args)

    CorrectTolerances = staticmethod(CorrectTolerances)

    def DTolerance(*args) -> "Standard_Real":
        """
        Additional tolerance (delta tolerance) is used in boolean operations to ensure that the tolerance of new/old entities obtained by intersection of two shapes is slightly bigger than the actual distances to these shapes. it helps to avoid numerical instability which may occur when comparing distances and tolerances.

        Returns
        -------
        float

        """
        return _BOPTools.BOPTools_AlgoTools_DTolerance(*args)

    DTolerance = staticmethod(DTolerance)

    def Dimension(*args) -> "Standard_Integer":
        """
        Returns dimension of the shape <thes>. if the shape contains elements of different dimension, -1 is returned.

        Parameters
        ----------
        theS: TopoDS_Shape

        Returns
        -------
        int

        """
        return _BOPTools.BOPTools_AlgoTools_Dimension(*args)

    Dimension = staticmethod(Dimension)

    def Dimensions(*args) -> "Standard_Integer &, Standard_Integer &":
        """
        Returns the min and max dimensions of the shape <thes>.

        Parameters
        ----------
        theS: TopoDS_Shape

        Returns
        -------
        theDMin: int
        theDMax: int

        """
        return _BOPTools.BOPTools_AlgoTools_Dimensions(*args)

    Dimensions = staticmethod(Dimensions)

    def GetEdgeOff(*args) -> "Standard_Boolean":
        """
        Returns true if the face theface contains the edge theedge but with opposite orientation. if the method returns true theedgeoff is the edge founded.

        Parameters
        ----------
        theEdge: TopoDS_Edge
        theFace: TopoDS_Face
        theEdgeOff: TopoDS_Edge

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_AlgoTools_GetEdgeOff(*args)

    GetEdgeOff = staticmethod(GetEdgeOff)

    def GetEdgeOnFace(*args) -> "Standard_Boolean":
        """
        For the face theface gets the edge theedgeonf that is the same as theedge returns true if such edge exists returns false if there is no such edge.

        Parameters
        ----------
        theEdge: TopoDS_Edge
        theFace: TopoDS_Face
        theEdgeOnF: TopoDS_Edge

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_AlgoTools_GetEdgeOnFace(*args)

    GetEdgeOnFace = staticmethod(GetEdgeOnFace)

    def GetFaceOff(*args) -> "Standard_Boolean":
        """
        For the face theface and its edge theedge finds the face suitable to produce shell. thelcef - set of faces to search. all faces from thelcef must share edge theedge.

        Parameters
        ----------
        theEdge: TopoDS_Edge
        theFace: TopoDS_Face
        theLCEF: BOPTools_ListOfCoupleOfShape
        theFaceOff: TopoDS_Face
        theContext: IntTools_Context

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_AlgoTools_GetFaceOff(*args)

    GetFaceOff = staticmethod(GetFaceOff)

    def IsBlockInOnFace(*args) -> "Standard_Boolean":
        """
        Returns true if paveblock <apb> lays on the face <af>, i.e the <pb> is in or on in 2d of <af>.

        Parameters
        ----------
        aShR: IntTools_Range
        aF: TopoDS_Face
        aE: TopoDS_Edge
        aContext: IntTools_Context

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_AlgoTools_IsBlockInOnFace(*args)

    IsBlockInOnFace = staticmethod(IsBlockInOnFace)

    def IsHole(*args) -> "Standard_Boolean":
        """
        Checks if the wire is a hole for the face.

        Parameters
        ----------
        theW: TopoDS_Shape
        theF: TopoDS_Shape

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_AlgoTools_IsHole(*args)

    IsHole = staticmethod(IsHole)

    def IsInternalFace(*args) -> "Standard_Boolean":
        """
        Returns true if the face theface is inside of the couple of faces theface1, theface2. the faces theface, theface1, theface2 must share the edge theedge return values: * 0 state is not in * 1 state is in * 2 state can not be found by the method of angles.

        Parameters
        ----------
        theFace: TopoDS_Face
        theEdge: TopoDS_Edge
        theFace1: TopoDS_Face
        theFace2: TopoDS_Face
        theContext: IntTools_Context

        Returns
        -------
        int

        Returns true if the face theface is inside of the appropriate couple of faces (from the set thelf) . the faces of the set thelf and theface must share the edge theedge * 0 state is not in * 1 state is in * 2 state can not be found by the method of angles.

        Parameters
        ----------
        theFace: TopoDS_Face
        theEdge: TopoDS_Edge
        theLF: TopTools_ListOfShape
        theContext: IntTools_Context

        Returns
        -------
        int

        Returns true if the face theface is inside the solid thesolid. themef - map edge/faces for thesolid thetol - value of precision of computation thecontext- cahed geometrical tools.

        Parameters
        ----------
        theFace: TopoDS_Face
        theSolid: TopoDS_Solid
        theMEF: TopTools_IndexedDataMapOfShapeListOfShape
        theTol: float
        theContext: IntTools_Context

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_AlgoTools_IsInternalFace(*args)

    IsInternalFace = staticmethod(IsInternalFace)

    def IsInvertedSolid(*args) -> "Standard_Boolean":
        """
        Returns true if the solid <thesolid> is inverted.

        Parameters
        ----------
        theSolid: TopoDS_Solid

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_AlgoTools_IsInvertedSolid(*args)

    IsInvertedSolid = staticmethod(IsInvertedSolid)

    def IsMicroEdge(*args) -> "Standard_Boolean":
        """
        Checks if it is possible to compute shrunk range for the edge <ae> flag <thechecksplittable> defines whether to take into account the possibility to split the edge or not.

        Parameters
        ----------
        theEdge: TopoDS_Edge
        theContext: IntTools_Context
        theCheckSplittable: bool,optional
        	default value is Standard_True

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_AlgoTools_IsMicroEdge(*args)

    IsMicroEdge = staticmethod(IsMicroEdge)

    def IsOpenShell(*args) -> "Standard_Boolean":
        """
        Returns true if the shell <theshell> is open.

        Parameters
        ----------
        theShell: TopoDS_Shell

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_AlgoTools_IsOpenShell(*args)

    IsOpenShell = staticmethod(IsOpenShell)

    def IsSplitToReverse(*args) -> "Standard_Boolean":
        """
        Checks if the direction of the split shape is opposite to the direction of the original shape. the method is an overload for (edge,edge) and (face,face) corresponding methods and checks only these types of shapes. for faces the method checks if normal directions are opposite. for edges the method checks if tangent vectors are opposite. //! in case the directions do not coincide, it returns true, meaning that split shape has to be reversed to match the direction of the original shape. //! if requested (<theerror> is not null), the method returns the status of the operation: - 0 - no error; - error from (edge,edge) or (face,face) corresponding method - 100 - bad types. in case of any error the method always returns false. //! @param thesplit [in] split shape @param theshape [in] original shape @param thecontext [in] cashed geometrical tools @param theerror [out] error status of the operation.

        Parameters
        ----------
        theSplit: TopoDS_Shape
        theShape: TopoDS_Shape
        theContext: IntTools_Context
        theError: int *,optional
        	default value is NULL

        Returns
        -------
        bool

        Checks if the normal direction of the split face is opposite to the normal direction of the original face. the normal directions for both faces are taken in the same point - point inside the split face is projected onto the original face. returns true if the normals do not coincide, meaning the necessity to revert the orientation of the split face to match the direction of the original face. //! if requested (<theerror> is not null), the method returns the status of the operation: - 0 - no error; - 1 - unable to find the point inside split face; - 2 - unable to compute the normal for the split face; - 3 - unable to project the point inside the split face on the original face; - 4 - unable to compute the normal for the original face. in case of any error the method always returns false. //! @param thesplit [in] split face @param theshape [in] original face @param thecontext [in] cashed geometrical tools @param theerror [out] error status of the operation.

        Parameters
        ----------
        theSplit: TopoDS_Face
        theShape: TopoDS_Face
        theContext: IntTools_Context
        theError: int *,optional
        	default value is NULL

        Returns
        -------
        bool

        Checks if the tangent vector of the split edge is opposite to the tangent vector of the original edge. the tangent vectors for both edges are computed in the same point - point inside the split edge is projected onto the original edge. returns true if the tangent vectors do not coincide, meaning the necessity to revert the orientation of the split edge to match the direction of the original edge. //! if requested (<theerror> is not null), the method returns the status of the operation: - 0 - no error; - 1 - degenerated edges are given; - 2 - unable to compute the tangent vector for the split edge; - 3 - unable to project the point inside the split edge on the original edge; - 4 - unable to compute the tangent vector for the original edge; in case of any error the method always returns false. //! @param thesplit [in] split edge @param theshape [in] original edge @param thecontext [in] cashed geometrical tools @param theerror [out] error status of the operation.

        Parameters
        ----------
        theSplit: TopoDS_Edge
        theShape: TopoDS_Edge
        theContext: IntTools_Context
        theError: int *,optional
        	default value is NULL

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_AlgoTools_IsSplitToReverse(*args)

    IsSplitToReverse = staticmethod(IsSplitToReverse)

    def IsSplitToReverseWithWarn(*args) -> "Standard_Boolean":
        """
        Add-on for the *issplittoreverse()* to check for its errors and in case of any add the *bopalgo_alertunabletoorienttheshape* warning to the report.

        Parameters
        ----------
        theSplit: TopoDS_Shape
        theShape: TopoDS_Shape
        theContext: IntTools_Context
        theReport: Message_Report,optional
        	default value is NULL

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_AlgoTools_IsSplitToReverseWithWarn(*args)

    IsSplitToReverseWithWarn = staticmethod(IsSplitToReverseWithWarn)

    def MakeConnexityBlock(*args) -> "void":
        """
        For the list of faces thels build block thelscb in terms of connexity by edges themapavoid - set of edges to avoid for the treatment.

        Parameters
        ----------
        theLS: TopTools_ListOfShape
        theMapAvoid: TopTools_IndexedMapOfShape
        theLSCB: TopTools_ListOfShape
        theAllocator: NCollection_BaseAllocator

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools_MakeConnexityBlock(*args)

    MakeConnexityBlock = staticmethod(MakeConnexityBlock)

    def MakeConnexityBlocks(*args) -> "void":
        """
        For the compound <thes> builds the blocks (compounds) of elements of type <theelementtype> connected through the shapes of the type <theconnectiontype>. the blocks are stored into the list <thelcb>.

        Parameters
        ----------
        theS: TopoDS_Shape
        theConnectionType: TopAbs_ShapeEnum
        theElementType: TopAbs_ShapeEnum
        theLCB: TopTools_ListOfShape

        Returns
        -------
        None

        For the compound <thes> builds the blocks (compounds) of elements of type <theelementtype> connected through the shapes of the type <theconnectiontype>. the blocks are stored into the list of lists <thelcb>. returns also the connection map <theconnectionmap>, filled during operation.

        Parameters
        ----------
        theS: TopoDS_Shape
        theConnectionType: TopAbs_ShapeEnum
        theElementType: TopAbs_ShapeEnum
        theLCB: TopTools_ListOfListOfShape
        theConnectionMap: TopTools_IndexedDataMapOfShapeListOfShape

        Returns
        -------
        None

        Makes connexity blocks of elements of the given type with the given type of the connecting elements. the blocks are checked on regularity (multi-connectivity) and stored to the list of blocks <thelcb>.

        Parameters
        ----------
        theLS: TopTools_ListOfShape
        theConnectionType: TopAbs_ShapeEnum
        theElementType: TopAbs_ShapeEnum
        theLCB: BOPTools_ListOfConnexityBlock

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools_MakeConnexityBlocks(*args)

    MakeConnexityBlocks = staticmethod(MakeConnexityBlocks)

    def MakeContainer(*args) -> "void":
        """
        Makes empty container of requested type.

        Parameters
        ----------
        theType: TopAbs_ShapeEnum
        theShape: TopoDS_Shape

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools_MakeContainer(*args)

    MakeContainer = staticmethod(MakeContainer)

    def MakeEdge(*args) -> "void":
        """
        Makes the edge based on the given curve with given bounding vertices.

        Parameters
        ----------
        theCurve: IntTools_Curve
        theV1: TopoDS_Vertex
        theT1: float
        theV2: TopoDS_Vertex
        theT2: float
        theTolR3D: float
        theE: TopoDS_Edge

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools_MakeEdge(*args)

    MakeEdge = staticmethod(MakeEdge)

    def MakeNewVertex(*args) -> "void":
        """
        Make a vertex using 3d-point <ap1> and 3d-tolerance value <atol>.

        Parameters
        ----------
        aP1: gp_Pnt
        aTol: float
        aNewVertex: TopoDS_Vertex

        Returns
        -------
        None

        Make a vertex using couple of vertices <av1, av2>.

        Parameters
        ----------
        aV1: TopoDS_Vertex
        aV2: TopoDS_Vertex
        aNewVertex: TopoDS_Vertex

        Returns
        -------
        None

        Make a vertex in place of intersection between two edges <ae1, ae2> with parameters <ap1, ap2>.

        Parameters
        ----------
        aE1: TopoDS_Edge
        aP1: float
        aE2: TopoDS_Edge
        aP2: float
        aNewVertex: TopoDS_Vertex

        Returns
        -------
        None

        Make a vertex in place of intersection between the edge <ae1> with parameter <ap1> and the face <af2>.

        Parameters
        ----------
        aE1: TopoDS_Edge
        aP1: float
        aF2: TopoDS_Face
        aNewVertex: TopoDS_Vertex

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools_MakeNewVertex(*args)

    MakeNewVertex = staticmethod(MakeNewVertex)

    def MakePCurve(*args) -> "void":
        """
        Makes 2d curve of the edge <thee> on the faces <thef1> and <thef2>. <thecontext> - storage for caching the geometrical tools.

        Parameters
        ----------
        theE: TopoDS_Edge
        theF1: TopoDS_Face
        theF2: TopoDS_Face
        theCurve: IntTools_Curve
        thePC1: bool
        thePC2: bool
        theContext: IntTools_Context,optional
        	default value is opencascade::handle<IntTools_Context>()

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools_MakePCurve(*args)

    MakePCurve = staticmethod(MakePCurve)

    def MakeSectEdge(*args) -> "void":
        """
        Make the edge from 3d-curve <aic> and two vertices <av1,av2> at parameters <ap1,ap2>.

        Parameters
        ----------
        aIC: IntTools_Curve
        aV1: TopoDS_Vertex
        aP1: float
        aV2: TopoDS_Vertex
        aP2: float
        aNewEdge: TopoDS_Edge

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools_MakeSectEdge(*args)

    MakeSectEdge = staticmethod(MakeSectEdge)

    def MakeSplitEdge(*args) -> "void":
        """
        Make the edge from base edge <ae1> and two vertices <av1,av2> at parameters <ap1,ap2>.

        Parameters
        ----------
        aE1: TopoDS_Edge
        aV1: TopoDS_Vertex
        aP1: float
        aV2: TopoDS_Vertex
        aP2: float
        aNewEdge: TopoDS_Edge

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools_MakeSplitEdge(*args)

    MakeSplitEdge = staticmethod(MakeSplitEdge)

    def MakeVertex(*args) -> "void":
        """
        Makes the vertex in the middle of given vertices with the tolerance covering all tolerance spheres of vertices.

        Parameters
        ----------
        theLV: TopTools_ListOfShape
        theV: TopoDS_Vertex

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools_MakeVertex(*args)

    MakeVertex = staticmethod(MakeVertex)

    def OrientEdgesOnWire(*args) -> "void":
        """
        Correctly orients edges on the wire.

        Parameters
        ----------
        theWire: TopoDS_Shape

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools_OrientEdgesOnWire(*args)

    OrientEdgesOnWire = staticmethod(OrientEdgesOnWire)

    def OrientFacesOnShell(*args) -> "void":
        """
        Correctly orients faces on the shell.

        Parameters
        ----------
        theShell: TopoDS_Shape

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools_OrientFacesOnShell(*args)

    OrientFacesOnShell = staticmethod(OrientFacesOnShell)

    def PointOnEdge(*args) -> "void":
        """
        Compute a 3d-point on the edge <aedge> at parameter <aprm>.

        Parameters
        ----------
        aEdge: TopoDS_Edge
        aPrm: float
        aP: gp_Pnt

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools_PointOnEdge(*args)

    PointOnEdge = staticmethod(PointOnEdge)

    def Sense(*args) -> "Standard_Integer":
        """
        Checks if the normals direction of the given faces computed near the shared edge coincide. returns the status of operation: * 0 - in case of error (shared edge not found or directions are not collinear) * 1 - normal directions coincide; * -1 - normal directions are opposite.

        Parameters
        ----------
        theF1: TopoDS_Face
        theF2: TopoDS_Face
        theContext: IntTools_Context

        Returns
        -------
        int

        """
        return _BOPTools.BOPTools_AlgoTools_Sense(*args)

    Sense = staticmethod(Sense)

    def TreatCompound(*args) -> "void":
        """
        Collects in the output list recursively all non-compound sub-shapes of the first level of the given shape thes. the optional map themap is used to avoid the duplicates in the output list, so it will also contain all non-compound sub-shapes.

        Parameters
        ----------
        theS: TopoDS_Shape
        theList: TopTools_ListOfShape
        theMap: TopTools_MapOfShape *,optional
        	default value is NULL

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools_TreatCompound(*args)

    TreatCompound = staticmethod(TreatCompound)

    def UpdateVertex(*args) -> "void":
        """
        Update the tolerance value for vertex <av> taking into account the fact that <av> lays on the curve <aic>.

        Parameters
        ----------
        aIC: IntTools_Curve
        aT: float
        aV: TopoDS_Vertex

        Returns
        -------
        None

        Update the tolerance value for vertex <av> taking into account the fact that <av> lays on the edge <ae>.

        Parameters
        ----------
        aE: TopoDS_Edge
        aT: float
        aV: TopoDS_Vertex

        Returns
        -------
        None

        Update the tolerance value for vertex <avn> taking into account the fact that <avn> should cover tolerance zone of <avf>.

        Parameters
        ----------
        aVF: TopoDS_Vertex
        aVN: TopoDS_Vertex

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools_UpdateVertex(*args)

    UpdateVertex = staticmethod(UpdateVertex)

    __repr__ = _dumps_object


    def __init__(self):
        this = _BOPTools.new_BOPTools_AlgoTools()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPTools.delete_BOPTools_AlgoTools
    __del__ = lambda self: None
BOPTools_AlgoTools_swigregister = _BOPTools.BOPTools_AlgoTools_swigregister
BOPTools_AlgoTools_swigregister(BOPTools_AlgoTools)

def BOPTools_AlgoTools_AreFacesSameDomain(*args) -> "Standard_Boolean":
    """
    Checks if the given faces are same-domain, i.e. coincide.

    Parameters
    ----------
    theF1: TopoDS_Face
    theF2: TopoDS_Face
    theContext: IntTools_Context
    theFuzz: float,optional
    	default value is Precision::Confusion()

    Returns
    -------
    bool

    """
    return _BOPTools.BOPTools_AlgoTools_AreFacesSameDomain(*args)

def BOPTools_AlgoTools_ComputeState(*args) -> "TopAbs_State":
    """
    Computes the 3-d state of the point thepoint toward solid thesolid. thetol - value of precision of computation thecontext- cahed geometrical tools returns 3-d state.

    Parameters
    ----------
    thePoint: gp_Pnt
    theSolid: TopoDS_Solid
    theTol: float
    theContext: IntTools_Context

    Returns
    -------
    TopAbs_State

    Computes the 3-d state of the vertex thevertex toward solid thesolid. thetol - value of precision of computation thecontext- cahed geometrical tools returns 3-d state.

    Parameters
    ----------
    theVertex: TopoDS_Vertex
    theSolid: TopoDS_Solid
    theTol: float
    theContext: IntTools_Context

    Returns
    -------
    TopAbs_State

    Computes the 3-d state of the edge theedge toward solid thesolid. thetol - value of precision of computation thecontext- cahed geometrical tools returns 3-d state.

    Parameters
    ----------
    theEdge: TopoDS_Edge
    theSolid: TopoDS_Solid
    theTol: float
    theContext: IntTools_Context

    Returns
    -------
    TopAbs_State

    Computes the 3-d state of the face theface toward solid thesolid. thetol - value of precision of computation thebounds - set of edges of <thesolid> to avoid thecontext- cahed geometrical tools returns 3-d state.

    Parameters
    ----------
    theFace: TopoDS_Face
    theSolid: TopoDS_Solid
    theTol: float
    theBounds: TopTools_IndexedMapOfShape
    theContext: IntTools_Context

    Returns
    -------
    TopAbs_State

    """
    return _BOPTools.BOPTools_AlgoTools_ComputeState(*args)

def BOPTools_AlgoTools_ComputeStateByOnePoint(*args) -> "TopAbs_State":
    """
    Computes the 3-d state of the shape theshape toward solid thesolid. thetol - value of precision of computation thecontext- cahed geometrical tools returns 3-d state.

    Parameters
    ----------
    theShape: TopoDS_Shape
    theSolid: TopoDS_Solid
    theTol: float
    theContext: IntTools_Context

    Returns
    -------
    TopAbs_State

    """
    return _BOPTools.BOPTools_AlgoTools_ComputeStateByOnePoint(*args)

def BOPTools_AlgoTools_ComputeTolerance(*args) -> "Standard_Real &, Standard_Real &":
    """
    Computes the necessary value of the tolerance for the edge.

    Parameters
    ----------
    theFace: TopoDS_Face
    theEdge: TopoDS_Edge

    Returns
    -------
    theMaxDist: float
    theMaxPar: float

    """
    return _BOPTools.BOPTools_AlgoTools_ComputeTolerance(*args)

def BOPTools_AlgoTools_ComputeVV(*args) -> "Standard_Integer":
    """
    Intersects the vertex <thev1> with the point <thep> with tolerance <thetolp>. returns the error status: - 0 - no error, meaning that the vertex intersects the point; - 1 - the distance between vertex and point is grater than the sum of tolerances.

    Parameters
    ----------
    theV: TopoDS_Vertex
    theP: gp_Pnt
    theTolP: float

    Returns
    -------
    int

    Intersects the given vertices with given fuzzy value. returns the error status: - 0 - no error, meaning that the vertices interferes with given tolerance; - 1 - the distance between vertices is grater than the sum of their tolerances.

    Parameters
    ----------
    theV1: TopoDS_Vertex
    theV2: TopoDS_Vertex
    theFuzz: float,optional
    	default value is Precision::Confusion()

    Returns
    -------
    int

    """
    return _BOPTools.BOPTools_AlgoTools_ComputeVV(*args)

def BOPTools_AlgoTools_CopyEdge(*args) -> "TopoDS_Edge":
    """
    Makes a copy of <theedge> with vertices.

    Parameters
    ----------
    theEdge: TopoDS_Edge

    Returns
    -------
    TopoDS_Edge

    """
    return _BOPTools.BOPTools_AlgoTools_CopyEdge(*args)

def BOPTools_AlgoTools_CorrectCurveOnSurface(*args) -> "void":
    """
    Provides valid values of tolerances for the shape <thes> in terms of brepcheck_invalidcurveonsurface.

    Parameters
    ----------
    theS: TopoDS_Shape
    theMapToAvoid: TopTools_IndexedMapOfShape
    theTolMax: float,optional
    	default value is 0.0001
    theRunParallel: bool,optional
    	default value is Standard_False

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools_CorrectCurveOnSurface(*args)

def BOPTools_AlgoTools_CorrectPointOnCurve(*args) -> "void":
    """
    Provides valid values of tolerances for the shape <thes> in terms of brepcheck_invalidpointoncurve.

    Parameters
    ----------
    theS: TopoDS_Shape
    theMapToAvoid: TopTools_IndexedMapOfShape
    theTolMax: float,optional
    	default value is 0.0001
    theRunParallel: bool,optional
    	default value is Standard_False

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools_CorrectPointOnCurve(*args)

def BOPTools_AlgoTools_CorrectRange(*args) -> "void":
    """
    Correct shrunk range <asr> taking into account 3d-curve resolution and corresponding tolerance values of <ae1>, <ae2>.

    Parameters
    ----------
    aE1: TopoDS_Edge
    aE2: TopoDS_Edge
    aSR: IntTools_Range
    aNewSR: IntTools_Range

    Returns
    -------
    None

    Correct shrunk range <asr> taking into account 3d-curve resolution and corresponding tolerance values of <ae>, <af>.

    Parameters
    ----------
    aE: TopoDS_Edge
    aF: TopoDS_Face
    aSR: IntTools_Range
    aNewSR: IntTools_Range

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools_CorrectRange(*args)

def BOPTools_AlgoTools_CorrectShapeTolerances(*args) -> "void":
    """
    Corrects tolerance values of the sub-shapes of the shape <thes> if needed.

    Parameters
    ----------
    theS: TopoDS_Shape
    theMapToAvoid: TopTools_IndexedMapOfShape
    theRunParallel: bool,optional
    	default value is Standard_False

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools_CorrectShapeTolerances(*args)

def BOPTools_AlgoTools_CorrectTolerances(*args) -> "void":
    """
    Provides valid values of tolerances for the shape <thes> <thetolmax> is max value of the tolerance that can be accepted for correction. if real value of the tolerance will be greater than <atolmax>, the correction does not perform.

    Parameters
    ----------
    theS: TopoDS_Shape
    theMapToAvoid: TopTools_IndexedMapOfShape
    theTolMax: float,optional
    	default value is 0.0001
    theRunParallel: bool,optional
    	default value is Standard_False

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools_CorrectTolerances(*args)

def BOPTools_AlgoTools_DTolerance(*args) -> "Standard_Real":
    """
    Additional tolerance (delta tolerance) is used in boolean operations to ensure that the tolerance of new/old entities obtained by intersection of two shapes is slightly bigger than the actual distances to these shapes. it helps to avoid numerical instability which may occur when comparing distances and tolerances.

    Returns
    -------
    float

    """
    return _BOPTools.BOPTools_AlgoTools_DTolerance(*args)

def BOPTools_AlgoTools_Dimension(*args) -> "Standard_Integer":
    """
    Returns dimension of the shape <thes>. if the shape contains elements of different dimension, -1 is returned.

    Parameters
    ----------
    theS: TopoDS_Shape

    Returns
    -------
    int

    """
    return _BOPTools.BOPTools_AlgoTools_Dimension(*args)

def BOPTools_AlgoTools_Dimensions(*args) -> "Standard_Integer &, Standard_Integer &":
    """
    Returns the min and max dimensions of the shape <thes>.

    Parameters
    ----------
    theS: TopoDS_Shape

    Returns
    -------
    theDMin: int
    theDMax: int

    """
    return _BOPTools.BOPTools_AlgoTools_Dimensions(*args)

def BOPTools_AlgoTools_GetEdgeOff(*args) -> "Standard_Boolean":
    """
    Returns true if the face theface contains the edge theedge but with opposite orientation. if the method returns true theedgeoff is the edge founded.

    Parameters
    ----------
    theEdge: TopoDS_Edge
    theFace: TopoDS_Face
    theEdgeOff: TopoDS_Edge

    Returns
    -------
    bool

    """
    return _BOPTools.BOPTools_AlgoTools_GetEdgeOff(*args)

def BOPTools_AlgoTools_GetEdgeOnFace(*args) -> "Standard_Boolean":
    """
    For the face theface gets the edge theedgeonf that is the same as theedge returns true if such edge exists returns false if there is no such edge.

    Parameters
    ----------
    theEdge: TopoDS_Edge
    theFace: TopoDS_Face
    theEdgeOnF: TopoDS_Edge

    Returns
    -------
    bool

    """
    return _BOPTools.BOPTools_AlgoTools_GetEdgeOnFace(*args)

def BOPTools_AlgoTools_GetFaceOff(*args) -> "Standard_Boolean":
    """
    For the face theface and its edge theedge finds the face suitable to produce shell. thelcef - set of faces to search. all faces from thelcef must share edge theedge.

    Parameters
    ----------
    theEdge: TopoDS_Edge
    theFace: TopoDS_Face
    theLCEF: BOPTools_ListOfCoupleOfShape
    theFaceOff: TopoDS_Face
    theContext: IntTools_Context

    Returns
    -------
    bool

    """
    return _BOPTools.BOPTools_AlgoTools_GetFaceOff(*args)

def BOPTools_AlgoTools_IsBlockInOnFace(*args) -> "Standard_Boolean":
    """
    Returns true if paveblock <apb> lays on the face <af>, i.e the <pb> is in or on in 2d of <af>.

    Parameters
    ----------
    aShR: IntTools_Range
    aF: TopoDS_Face
    aE: TopoDS_Edge
    aContext: IntTools_Context

    Returns
    -------
    bool

    """
    return _BOPTools.BOPTools_AlgoTools_IsBlockInOnFace(*args)

def BOPTools_AlgoTools_IsHole(*args) -> "Standard_Boolean":
    """
    Checks if the wire is a hole for the face.

    Parameters
    ----------
    theW: TopoDS_Shape
    theF: TopoDS_Shape

    Returns
    -------
    bool

    """
    return _BOPTools.BOPTools_AlgoTools_IsHole(*args)

def BOPTools_AlgoTools_IsInternalFace(*args) -> "Standard_Boolean":
    """
    Returns true if the face theface is inside of the couple of faces theface1, theface2. the faces theface, theface1, theface2 must share the edge theedge return values: * 0 state is not in * 1 state is in * 2 state can not be found by the method of angles.

    Parameters
    ----------
    theFace: TopoDS_Face
    theEdge: TopoDS_Edge
    theFace1: TopoDS_Face
    theFace2: TopoDS_Face
    theContext: IntTools_Context

    Returns
    -------
    int

    Returns true if the face theface is inside of the appropriate couple of faces (from the set thelf) . the faces of the set thelf and theface must share the edge theedge * 0 state is not in * 1 state is in * 2 state can not be found by the method of angles.

    Parameters
    ----------
    theFace: TopoDS_Face
    theEdge: TopoDS_Edge
    theLF: TopTools_ListOfShape
    theContext: IntTools_Context

    Returns
    -------
    int

    Returns true if the face theface is inside the solid thesolid. themef - map edge/faces for thesolid thetol - value of precision of computation thecontext- cahed geometrical tools.

    Parameters
    ----------
    theFace: TopoDS_Face
    theSolid: TopoDS_Solid
    theMEF: TopTools_IndexedDataMapOfShapeListOfShape
    theTol: float
    theContext: IntTools_Context

    Returns
    -------
    bool

    """
    return _BOPTools.BOPTools_AlgoTools_IsInternalFace(*args)

def BOPTools_AlgoTools_IsInvertedSolid(*args) -> "Standard_Boolean":
    """
    Returns true if the solid <thesolid> is inverted.

    Parameters
    ----------
    theSolid: TopoDS_Solid

    Returns
    -------
    bool

    """
    return _BOPTools.BOPTools_AlgoTools_IsInvertedSolid(*args)

def BOPTools_AlgoTools_IsMicroEdge(*args) -> "Standard_Boolean":
    """
    Checks if it is possible to compute shrunk range for the edge <ae> flag <thechecksplittable> defines whether to take into account the possibility to split the edge or not.

    Parameters
    ----------
    theEdge: TopoDS_Edge
    theContext: IntTools_Context
    theCheckSplittable: bool,optional
    	default value is Standard_True

    Returns
    -------
    bool

    """
    return _BOPTools.BOPTools_AlgoTools_IsMicroEdge(*args)

def BOPTools_AlgoTools_IsOpenShell(*args) -> "Standard_Boolean":
    """
    Returns true if the shell <theshell> is open.

    Parameters
    ----------
    theShell: TopoDS_Shell

    Returns
    -------
    bool

    """
    return _BOPTools.BOPTools_AlgoTools_IsOpenShell(*args)

def BOPTools_AlgoTools_IsSplitToReverse(*args) -> "Standard_Boolean":
    """
    Checks if the direction of the split shape is opposite to the direction of the original shape. the method is an overload for (edge,edge) and (face,face) corresponding methods and checks only these types of shapes. for faces the method checks if normal directions are opposite. for edges the method checks if tangent vectors are opposite. //! in case the directions do not coincide, it returns true, meaning that split shape has to be reversed to match the direction of the original shape. //! if requested (<theerror> is not null), the method returns the status of the operation: - 0 - no error; - error from (edge,edge) or (face,face) corresponding method - 100 - bad types. in case of any error the method always returns false. //! @param thesplit [in] split shape @param theshape [in] original shape @param thecontext [in] cashed geometrical tools @param theerror [out] error status of the operation.

    Parameters
    ----------
    theSplit: TopoDS_Shape
    theShape: TopoDS_Shape
    theContext: IntTools_Context
    theError: int *,optional
    	default value is NULL

    Returns
    -------
    bool

    Checks if the normal direction of the split face is opposite to the normal direction of the original face. the normal directions for both faces are taken in the same point - point inside the split face is projected onto the original face. returns true if the normals do not coincide, meaning the necessity to revert the orientation of the split face to match the direction of the original face. //! if requested (<theerror> is not null), the method returns the status of the operation: - 0 - no error; - 1 - unable to find the point inside split face; - 2 - unable to compute the normal for the split face; - 3 - unable to project the point inside the split face on the original face; - 4 - unable to compute the normal for the original face. in case of any error the method always returns false. //! @param thesplit [in] split face @param theshape [in] original face @param thecontext [in] cashed geometrical tools @param theerror [out] error status of the operation.

    Parameters
    ----------
    theSplit: TopoDS_Face
    theShape: TopoDS_Face
    theContext: IntTools_Context
    theError: int *,optional
    	default value is NULL

    Returns
    -------
    bool

    Checks if the tangent vector of the split edge is opposite to the tangent vector of the original edge. the tangent vectors for both edges are computed in the same point - point inside the split edge is projected onto the original edge. returns true if the tangent vectors do not coincide, meaning the necessity to revert the orientation of the split edge to match the direction of the original edge. //! if requested (<theerror> is not null), the method returns the status of the operation: - 0 - no error; - 1 - degenerated edges are given; - 2 - unable to compute the tangent vector for the split edge; - 3 - unable to project the point inside the split edge on the original edge; - 4 - unable to compute the tangent vector for the original edge; in case of any error the method always returns false. //! @param thesplit [in] split edge @param theshape [in] original edge @param thecontext [in] cashed geometrical tools @param theerror [out] error status of the operation.

    Parameters
    ----------
    theSplit: TopoDS_Edge
    theShape: TopoDS_Edge
    theContext: IntTools_Context
    theError: int *,optional
    	default value is NULL

    Returns
    -------
    bool

    """
    return _BOPTools.BOPTools_AlgoTools_IsSplitToReverse(*args)

def BOPTools_AlgoTools_IsSplitToReverseWithWarn(*args) -> "Standard_Boolean":
    """
    Add-on for the *issplittoreverse()* to check for its errors and in case of any add the *bopalgo_alertunabletoorienttheshape* warning to the report.

    Parameters
    ----------
    theSplit: TopoDS_Shape
    theShape: TopoDS_Shape
    theContext: IntTools_Context
    theReport: Message_Report,optional
    	default value is NULL

    Returns
    -------
    bool

    """
    return _BOPTools.BOPTools_AlgoTools_IsSplitToReverseWithWarn(*args)

def BOPTools_AlgoTools_MakeConnexityBlock(*args) -> "void":
    """
    For the list of faces thels build block thelscb in terms of connexity by edges themapavoid - set of edges to avoid for the treatment.

    Parameters
    ----------
    theLS: TopTools_ListOfShape
    theMapAvoid: TopTools_IndexedMapOfShape
    theLSCB: TopTools_ListOfShape
    theAllocator: NCollection_BaseAllocator

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools_MakeConnexityBlock(*args)

def BOPTools_AlgoTools_MakeConnexityBlocks(*args) -> "void":
    """
    For the compound <thes> builds the blocks (compounds) of elements of type <theelementtype> connected through the shapes of the type <theconnectiontype>. the blocks are stored into the list <thelcb>.

    Parameters
    ----------
    theS: TopoDS_Shape
    theConnectionType: TopAbs_ShapeEnum
    theElementType: TopAbs_ShapeEnum
    theLCB: TopTools_ListOfShape

    Returns
    -------
    None

    For the compound <thes> builds the blocks (compounds) of elements of type <theelementtype> connected through the shapes of the type <theconnectiontype>. the blocks are stored into the list of lists <thelcb>. returns also the connection map <theconnectionmap>, filled during operation.

    Parameters
    ----------
    theS: TopoDS_Shape
    theConnectionType: TopAbs_ShapeEnum
    theElementType: TopAbs_ShapeEnum
    theLCB: TopTools_ListOfListOfShape
    theConnectionMap: TopTools_IndexedDataMapOfShapeListOfShape

    Returns
    -------
    None

    Makes connexity blocks of elements of the given type with the given type of the connecting elements. the blocks are checked on regularity (multi-connectivity) and stored to the list of blocks <thelcb>.

    Parameters
    ----------
    theLS: TopTools_ListOfShape
    theConnectionType: TopAbs_ShapeEnum
    theElementType: TopAbs_ShapeEnum
    theLCB: BOPTools_ListOfConnexityBlock

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools_MakeConnexityBlocks(*args)

def BOPTools_AlgoTools_MakeContainer(*args) -> "void":
    """
    Makes empty container of requested type.

    Parameters
    ----------
    theType: TopAbs_ShapeEnum
    theShape: TopoDS_Shape

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools_MakeContainer(*args)

def BOPTools_AlgoTools_MakeEdge(*args) -> "void":
    """
    Makes the edge based on the given curve with given bounding vertices.

    Parameters
    ----------
    theCurve: IntTools_Curve
    theV1: TopoDS_Vertex
    theT1: float
    theV2: TopoDS_Vertex
    theT2: float
    theTolR3D: float
    theE: TopoDS_Edge

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools_MakeEdge(*args)

def BOPTools_AlgoTools_MakeNewVertex(*args) -> "void":
    """
    Make a vertex using 3d-point <ap1> and 3d-tolerance value <atol>.

    Parameters
    ----------
    aP1: gp_Pnt
    aTol: float
    aNewVertex: TopoDS_Vertex

    Returns
    -------
    None

    Make a vertex using couple of vertices <av1, av2>.

    Parameters
    ----------
    aV1: TopoDS_Vertex
    aV2: TopoDS_Vertex
    aNewVertex: TopoDS_Vertex

    Returns
    -------
    None

    Make a vertex in place of intersection between two edges <ae1, ae2> with parameters <ap1, ap2>.

    Parameters
    ----------
    aE1: TopoDS_Edge
    aP1: float
    aE2: TopoDS_Edge
    aP2: float
    aNewVertex: TopoDS_Vertex

    Returns
    -------
    None

    Make a vertex in place of intersection between the edge <ae1> with parameter <ap1> and the face <af2>.

    Parameters
    ----------
    aE1: TopoDS_Edge
    aP1: float
    aF2: TopoDS_Face
    aNewVertex: TopoDS_Vertex

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools_MakeNewVertex(*args)

def BOPTools_AlgoTools_MakePCurve(*args) -> "void":
    """
    Makes 2d curve of the edge <thee> on the faces <thef1> and <thef2>. <thecontext> - storage for caching the geometrical tools.

    Parameters
    ----------
    theE: TopoDS_Edge
    theF1: TopoDS_Face
    theF2: TopoDS_Face
    theCurve: IntTools_Curve
    thePC1: bool
    thePC2: bool
    theContext: IntTools_Context,optional
    	default value is opencascade::handle<IntTools_Context>()

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools_MakePCurve(*args)

def BOPTools_AlgoTools_MakeSectEdge(*args) -> "void":
    """
    Make the edge from 3d-curve <aic> and two vertices <av1,av2> at parameters <ap1,ap2>.

    Parameters
    ----------
    aIC: IntTools_Curve
    aV1: TopoDS_Vertex
    aP1: float
    aV2: TopoDS_Vertex
    aP2: float
    aNewEdge: TopoDS_Edge

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools_MakeSectEdge(*args)

def BOPTools_AlgoTools_MakeSplitEdge(*args) -> "void":
    """
    Make the edge from base edge <ae1> and two vertices <av1,av2> at parameters <ap1,ap2>.

    Parameters
    ----------
    aE1: TopoDS_Edge
    aV1: TopoDS_Vertex
    aP1: float
    aV2: TopoDS_Vertex
    aP2: float
    aNewEdge: TopoDS_Edge

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools_MakeSplitEdge(*args)

def BOPTools_AlgoTools_MakeVertex(*args) -> "void":
    """
    Makes the vertex in the middle of given vertices with the tolerance covering all tolerance spheres of vertices.

    Parameters
    ----------
    theLV: TopTools_ListOfShape
    theV: TopoDS_Vertex

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools_MakeVertex(*args)

def BOPTools_AlgoTools_OrientEdgesOnWire(*args) -> "void":
    """
    Correctly orients edges on the wire.

    Parameters
    ----------
    theWire: TopoDS_Shape

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools_OrientEdgesOnWire(*args)

def BOPTools_AlgoTools_OrientFacesOnShell(*args) -> "void":
    """
    Correctly orients faces on the shell.

    Parameters
    ----------
    theShell: TopoDS_Shape

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools_OrientFacesOnShell(*args)

def BOPTools_AlgoTools_PointOnEdge(*args) -> "void":
    """
    Compute a 3d-point on the edge <aedge> at parameter <aprm>.

    Parameters
    ----------
    aEdge: TopoDS_Edge
    aPrm: float
    aP: gp_Pnt

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools_PointOnEdge(*args)

def BOPTools_AlgoTools_Sense(*args) -> "Standard_Integer":
    """
    Checks if the normals direction of the given faces computed near the shared edge coincide. returns the status of operation: * 0 - in case of error (shared edge not found or directions are not collinear) * 1 - normal directions coincide; * -1 - normal directions are opposite.

    Parameters
    ----------
    theF1: TopoDS_Face
    theF2: TopoDS_Face
    theContext: IntTools_Context

    Returns
    -------
    int

    """
    return _BOPTools.BOPTools_AlgoTools_Sense(*args)

def BOPTools_AlgoTools_TreatCompound(*args) -> "void":
    """
    Collects in the output list recursively all non-compound sub-shapes of the first level of the given shape thes. the optional map themap is used to avoid the duplicates in the output list, so it will also contain all non-compound sub-shapes.

    Parameters
    ----------
    theS: TopoDS_Shape
    theList: TopTools_ListOfShape
    theMap: TopTools_MapOfShape *,optional
    	default value is NULL

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools_TreatCompound(*args)

def BOPTools_AlgoTools_UpdateVertex(*args) -> "void":
    """
    Update the tolerance value for vertex <av> taking into account the fact that <av> lays on the curve <aic>.

    Parameters
    ----------
    aIC: IntTools_Curve
    aT: float
    aV: TopoDS_Vertex

    Returns
    -------
    None

    Update the tolerance value for vertex <av> taking into account the fact that <av> lays on the edge <ae>.

    Parameters
    ----------
    aE: TopoDS_Edge
    aT: float
    aV: TopoDS_Vertex

    Returns
    -------
    None

    Update the tolerance value for vertex <avn> taking into account the fact that <avn> should cover tolerance zone of <avf>.

    Parameters
    ----------
    aVF: TopoDS_Vertex
    aVN: TopoDS_Vertex

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools_UpdateVertex(*args)

class BOPTools_AlgoTools2D(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BOPTools_AlgoTools2D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BOPTools_AlgoTools2D, name)
    __repr__ = _swig_repr

    def AdjustPCurveOnFace(*args) -> "void":
        """
        Adjust p-curve <thec2d> (3d-curve <thec3d>) on surface of the face <thef>. <thecontext> - storage for caching the geometrical tools.

        Parameters
        ----------
        theF: TopoDS_Face
        theC3D: Geom_Curve
        theC2D: Geom2d_Curve
        theC2DA: Geom2d_Curve
        theContext: IntTools_Context,optional
        	default value is opencascade::handle<IntTools_Context>()

        Returns
        -------
        None

        Adjust p-curve <ac2d> (3d-curve <c3d>) on surface <af> . [at1, at2] - range to adjust <thecontext> - storage for caching the geometrical tools.

        Parameters
        ----------
        theF: TopoDS_Face
        theFirst: float
        theLast: float
        theC2D: Geom2d_Curve
        theC2DA: Geom2d_Curve
        theContext: IntTools_Context,optional
        	default value is opencascade::handle<IntTools_Context>()

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools2D_AdjustPCurveOnFace(*args)

    AdjustPCurveOnFace = staticmethod(AdjustPCurveOnFace)

    def AdjustPCurveOnSurf(*args) -> "void":
        """
        Adjust p-curve <ac2d> (3d-curve <c3d>) on surface <af> . [at1, at2] - range to adjust.

        Parameters
        ----------
        aF: BRepAdaptor_Surface
        aT1: float
        aT2: float
        aC2D: Geom2d_Curve
        aC2DA: Geom2d_Curve

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools2D_AdjustPCurveOnSurf(*args)

    AdjustPCurveOnSurf = staticmethod(AdjustPCurveOnSurf)

    def AttachExistingPCurve(*args) -> "Standard_Integer":
        """
        Attach p-curve from the edge <aeold> on surface <af> to the edge <aenew> returns 0 in case of success.

        Parameters
        ----------
        aEold: TopoDS_Edge
        aEnew: TopoDS_Edge
        aF: TopoDS_Face
        aCtx: IntTools_Context

        Returns
        -------
        int

        """
        return _BOPTools.BOPTools_AlgoTools2D_AttachExistingPCurve(*args)

    AttachExistingPCurve = staticmethod(AttachExistingPCurve)

    def BuildPCurveForEdgeOnFace(*args) -> "void":
        """
        Compute p-curve for the edge <ae> on the face <af>. raises exception standard_constructionerror if projection algorithm fails. <thecontext> - storage for caching the geometrical tools.

        Parameters
        ----------
        aE: TopoDS_Edge
        aF: TopoDS_Face
        theContext: IntTools_Context,optional
        	default value is opencascade::handle<IntTools_Context>()

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools2D_BuildPCurveForEdgeOnFace(*args)

    BuildPCurveForEdgeOnFace = staticmethod(BuildPCurveForEdgeOnFace)

    def CurveOnSurface(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
        """
        Get p-curve <ac> for the edge <ae> on surface <af> . if the p-curve does not exist, build it using make2d(). [atoler] - reached tolerance raises exception standard_constructionerror if algorithm make2d() fails. <thecontext> - storage for caching the geometrical tools.

        Parameters
        ----------
        aE: TopoDS_Edge
        aF: TopoDS_Face
        aC: Geom2d_Curve
        theContext: IntTools_Context,optional
        	default value is opencascade::handle<IntTools_Context>()

        Returns
        -------
        aToler: float

        Get p-curve <ac> for the edge <ae> on surface <af> . if the p-curve does not exist, build it using make2d(). [afirst, alast] - range of the p-curve [atoler] - reached tolerance raises exception standard_constructionerror if algorithm make2d() fails. <thecontext> - storage for caching the geometrical tools.

        Parameters
        ----------
        aE: TopoDS_Edge
        aF: TopoDS_Face
        aC: Geom2d_Curve
        theContext: IntTools_Context,optional
        	default value is opencascade::handle<IntTools_Context>()

        Returns
        -------
        aFirst: float
        aLast: float
        aToler: float

        """
        return _BOPTools.BOPTools_AlgoTools2D_CurveOnSurface(*args)

    CurveOnSurface = staticmethod(CurveOnSurface)

    def EdgeTangent(*args) -> "Standard_Boolean":
        """
        Compute tangent for the edge <ae> [in 3d] at parameter <at>.

        Parameters
        ----------
        anE: TopoDS_Edge
        aT: float
        Tau: gp_Vec

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_AlgoTools2D_EdgeTangent(*args)

    EdgeTangent = staticmethod(EdgeTangent)

    def HasCurveOnSurface(*args) -> "Standard_Boolean":
        """
        Returns true if the edge <ae> has p-curve <ac> on surface <af> . [afirst, alast] - range of the p-curve [atoler] - reached tolerance if the p-curve does not exist, ac.isnull()=true.

        Parameters
        ----------
        aE: TopoDS_Edge
        aF: TopoDS_Face
        aC: Geom2d_Curve

        Returns
        -------
        aFirst: float
        aLast: float
        aToler: float

        Returns true if the edge <ae> has p-curve <ac> on surface <af> . if the p-curve does not exist, ac.isnull()=true.

        Parameters
        ----------
        aE: TopoDS_Edge
        aF: TopoDS_Face

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_AlgoTools2D_HasCurveOnSurface(*args)

    HasCurveOnSurface = staticmethod(HasCurveOnSurface)

    def IntermediatePoint(*args) -> "Standard_Real":
        """
        Compute intermediate value in between [afirst, alast] .

        Parameters
        ----------
        aFirst: float
        aLast: float

        Returns
        -------
        float

        Compute intermediate value of parameter for the edge <ane>.

        Parameters
        ----------
        anE: TopoDS_Edge

        Returns
        -------
        float

        """
        return _BOPTools.BOPTools_AlgoTools2D_IntermediatePoint(*args)

    IntermediatePoint = staticmethod(IntermediatePoint)

    def IsEdgeIsoline(*args) -> "Standard_Boolean &, Standard_Boolean &":
        """
        Checks if curveonsurface of thee on thef matches with isoline of thef surface. sets corresponding values for istheuiso and istheviso variables. attention!!! this method is based on comparation between direction of surface (which thef is based on) iso-lines and the direction of the edge p-curve (on thef) in middle-point of the p-curve. this method should be used carefully (e.g. brep_tool::isclosed(...) together) in order to avoid false classification some p-curves as isoline (e.g. circle on a plane).

        Parameters
        ----------
        theE: TopoDS_Edge
        theF: TopoDS_Face

        Returns
        -------
        isTheUIso: bool
        isTheVIso: bool

        """
        return _BOPTools.BOPTools_AlgoTools2D_IsEdgeIsoline(*args)

    IsEdgeIsoline = staticmethod(IsEdgeIsoline)

    def Make2D(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
        """
        Make p-curve <ac> for the edge <ae> on surface <af> . [afirst, alast] - range of the p-curve [atoler] - reached tolerance raises exception standard_constructionerror if algorithm fails. <thecontext> - storage for caching the geometrical tools.

        Parameters
        ----------
        aE: TopoDS_Edge
        aF: TopoDS_Face
        aC: Geom2d_Curve
        theContext: IntTools_Context,optional
        	default value is opencascade::handle<IntTools_Context>()

        Returns
        -------
        aFirst: float
        aLast: float
        aToler: float

        """
        return _BOPTools.BOPTools_AlgoTools2D_Make2D(*args)

    Make2D = staticmethod(Make2D)

    def MakePCurveOnFace(*args) -> "Standard_Real &":
        """
        Make p-curve <ac> for the 3d-curve <c3d> on surface <af> . [atoler] - reached tolerance raises exception standard_constructionerror if projection algorithm fails. <thecontext> - storage for caching the geometrical tools.

        Parameters
        ----------
        aF: TopoDS_Face
        C3D: Geom_Curve
        aC: Geom2d_Curve
        theContext: IntTools_Context,optional
        	default value is opencascade::handle<IntTools_Context>()

        Returns
        -------
        aToler: float

        Make p-curve <ac> for the 3d-curve <c3d> on surface <af> . [at1, at2] - range to build [atoler] - reached tolerance raises exception standard_constructionerror if projection algorithm fails. <thecontext> - storage for caching the geometrical tools.

        Parameters
        ----------
        aF: TopoDS_Face
        C3D: Geom_Curve
        aT1: float
        aT2: float
        aC: Geom2d_Curve
        theContext: IntTools_Context,optional
        	default value is opencascade::handle<IntTools_Context>()

        Returns
        -------
        aToler: float

        """
        return _BOPTools.BOPTools_AlgoTools2D_MakePCurveOnFace(*args)

    MakePCurveOnFace = staticmethod(MakePCurveOnFace)

    def PointOnSurface(*args) -> "Standard_Real &, Standard_Real &":
        """
        Compute surface parameters <u,v> of the face <af> for the point from the edge <ae> at parameter <at>. if <ae> has't pcurve on surface, algorithm tries to get it by projection and can raise exception standard_constructionerror if projection algorithm fails. <thecontext> - storage for caching the geometrical tools.

        Parameters
        ----------
        aE: TopoDS_Edge
        aF: TopoDS_Face
        aT: float
        theContext: IntTools_Context,optional
        	default value is opencascade::handle<IntTools_Context>()

        Returns
        -------
        U: float
        V: float

        """
        return _BOPTools.BOPTools_AlgoTools2D_PointOnSurface(*args)

    PointOnSurface = staticmethod(PointOnSurface)

    __repr__ = _dumps_object

    @methodnotwrapped
    def MakeCurveOnSurface(self):
    	pass


    def __init__(self):
        this = _BOPTools.new_BOPTools_AlgoTools2D()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPTools.delete_BOPTools_AlgoTools2D
    __del__ = lambda self: None
BOPTools_AlgoTools2D_swigregister = _BOPTools.BOPTools_AlgoTools2D_swigregister
BOPTools_AlgoTools2D_swigregister(BOPTools_AlgoTools2D)

def BOPTools_AlgoTools2D_AdjustPCurveOnFace(*args) -> "void":
    """
    Adjust p-curve <thec2d> (3d-curve <thec3d>) on surface of the face <thef>. <thecontext> - storage for caching the geometrical tools.

    Parameters
    ----------
    theF: TopoDS_Face
    theC3D: Geom_Curve
    theC2D: Geom2d_Curve
    theC2DA: Geom2d_Curve
    theContext: IntTools_Context,optional
    	default value is opencascade::handle<IntTools_Context>()

    Returns
    -------
    None

    Adjust p-curve <ac2d> (3d-curve <c3d>) on surface <af> . [at1, at2] - range to adjust <thecontext> - storage for caching the geometrical tools.

    Parameters
    ----------
    theF: TopoDS_Face
    theFirst: float
    theLast: float
    theC2D: Geom2d_Curve
    theC2DA: Geom2d_Curve
    theContext: IntTools_Context,optional
    	default value is opencascade::handle<IntTools_Context>()

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools2D_AdjustPCurveOnFace(*args)

def BOPTools_AlgoTools2D_AdjustPCurveOnSurf(*args) -> "void":
    """
    Adjust p-curve <ac2d> (3d-curve <c3d>) on surface <af> . [at1, at2] - range to adjust.

    Parameters
    ----------
    aF: BRepAdaptor_Surface
    aT1: float
    aT2: float
    aC2D: Geom2d_Curve
    aC2DA: Geom2d_Curve

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools2D_AdjustPCurveOnSurf(*args)

def BOPTools_AlgoTools2D_AttachExistingPCurve(*args) -> "Standard_Integer":
    """
    Attach p-curve from the edge <aeold> on surface <af> to the edge <aenew> returns 0 in case of success.

    Parameters
    ----------
    aEold: TopoDS_Edge
    aEnew: TopoDS_Edge
    aF: TopoDS_Face
    aCtx: IntTools_Context

    Returns
    -------
    int

    """
    return _BOPTools.BOPTools_AlgoTools2D_AttachExistingPCurve(*args)

def BOPTools_AlgoTools2D_BuildPCurveForEdgeOnFace(*args) -> "void":
    """
    Compute p-curve for the edge <ae> on the face <af>. raises exception standard_constructionerror if projection algorithm fails. <thecontext> - storage for caching the geometrical tools.

    Parameters
    ----------
    aE: TopoDS_Edge
    aF: TopoDS_Face
    theContext: IntTools_Context,optional
    	default value is opencascade::handle<IntTools_Context>()

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools2D_BuildPCurveForEdgeOnFace(*args)

def BOPTools_AlgoTools2D_CurveOnSurface(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
    """
    Get p-curve <ac> for the edge <ae> on surface <af> . if the p-curve does not exist, build it using make2d(). [atoler] - reached tolerance raises exception standard_constructionerror if algorithm make2d() fails. <thecontext> - storage for caching the geometrical tools.

    Parameters
    ----------
    aE: TopoDS_Edge
    aF: TopoDS_Face
    aC: Geom2d_Curve
    theContext: IntTools_Context,optional
    	default value is opencascade::handle<IntTools_Context>()

    Returns
    -------
    aToler: float

    Get p-curve <ac> for the edge <ae> on surface <af> . if the p-curve does not exist, build it using make2d(). [afirst, alast] - range of the p-curve [atoler] - reached tolerance raises exception standard_constructionerror if algorithm make2d() fails. <thecontext> - storage for caching the geometrical tools.

    Parameters
    ----------
    aE: TopoDS_Edge
    aF: TopoDS_Face
    aC: Geom2d_Curve
    theContext: IntTools_Context,optional
    	default value is opencascade::handle<IntTools_Context>()

    Returns
    -------
    aFirst: float
    aLast: float
    aToler: float

    """
    return _BOPTools.BOPTools_AlgoTools2D_CurveOnSurface(*args)

def BOPTools_AlgoTools2D_EdgeTangent(*args) -> "Standard_Boolean":
    """
    Compute tangent for the edge <ae> [in 3d] at parameter <at>.

    Parameters
    ----------
    anE: TopoDS_Edge
    aT: float
    Tau: gp_Vec

    Returns
    -------
    bool

    """
    return _BOPTools.BOPTools_AlgoTools2D_EdgeTangent(*args)

def BOPTools_AlgoTools2D_HasCurveOnSurface(*args) -> "Standard_Boolean":
    """
    Returns true if the edge <ae> has p-curve <ac> on surface <af> . [afirst, alast] - range of the p-curve [atoler] - reached tolerance if the p-curve does not exist, ac.isnull()=true.

    Parameters
    ----------
    aE: TopoDS_Edge
    aF: TopoDS_Face
    aC: Geom2d_Curve

    Returns
    -------
    aFirst: float
    aLast: float
    aToler: float

    Returns true if the edge <ae> has p-curve <ac> on surface <af> . if the p-curve does not exist, ac.isnull()=true.

    Parameters
    ----------
    aE: TopoDS_Edge
    aF: TopoDS_Face

    Returns
    -------
    bool

    """
    return _BOPTools.BOPTools_AlgoTools2D_HasCurveOnSurface(*args)

def BOPTools_AlgoTools2D_IntermediatePoint(*args) -> "Standard_Real":
    """
    Compute intermediate value in between [afirst, alast] .

    Parameters
    ----------
    aFirst: float
    aLast: float

    Returns
    -------
    float

    Compute intermediate value of parameter for the edge <ane>.

    Parameters
    ----------
    anE: TopoDS_Edge

    Returns
    -------
    float

    """
    return _BOPTools.BOPTools_AlgoTools2D_IntermediatePoint(*args)

def BOPTools_AlgoTools2D_IsEdgeIsoline(*args) -> "Standard_Boolean &, Standard_Boolean &":
    """
    Checks if curveonsurface of thee on thef matches with isoline of thef surface. sets corresponding values for istheuiso and istheviso variables. attention!!! this method is based on comparation between direction of surface (which thef is based on) iso-lines and the direction of the edge p-curve (on thef) in middle-point of the p-curve. this method should be used carefully (e.g. brep_tool::isclosed(...) together) in order to avoid false classification some p-curves as isoline (e.g. circle on a plane).

    Parameters
    ----------
    theE: TopoDS_Edge
    theF: TopoDS_Face

    Returns
    -------
    isTheUIso: bool
    isTheVIso: bool

    """
    return _BOPTools.BOPTools_AlgoTools2D_IsEdgeIsoline(*args)

def BOPTools_AlgoTools2D_Make2D(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
    """
    Make p-curve <ac> for the edge <ae> on surface <af> . [afirst, alast] - range of the p-curve [atoler] - reached tolerance raises exception standard_constructionerror if algorithm fails. <thecontext> - storage for caching the geometrical tools.

    Parameters
    ----------
    aE: TopoDS_Edge
    aF: TopoDS_Face
    aC: Geom2d_Curve
    theContext: IntTools_Context,optional
    	default value is opencascade::handle<IntTools_Context>()

    Returns
    -------
    aFirst: float
    aLast: float
    aToler: float

    """
    return _BOPTools.BOPTools_AlgoTools2D_Make2D(*args)

def BOPTools_AlgoTools2D_MakePCurveOnFace(*args) -> "Standard_Real &":
    """
    Make p-curve <ac> for the 3d-curve <c3d> on surface <af> . [atoler] - reached tolerance raises exception standard_constructionerror if projection algorithm fails. <thecontext> - storage for caching the geometrical tools.

    Parameters
    ----------
    aF: TopoDS_Face
    C3D: Geom_Curve
    aC: Geom2d_Curve
    theContext: IntTools_Context,optional
    	default value is opencascade::handle<IntTools_Context>()

    Returns
    -------
    aToler: float

    Make p-curve <ac> for the 3d-curve <c3d> on surface <af> . [at1, at2] - range to build [atoler] - reached tolerance raises exception standard_constructionerror if projection algorithm fails. <thecontext> - storage for caching the geometrical tools.

    Parameters
    ----------
    aF: TopoDS_Face
    C3D: Geom_Curve
    aT1: float
    aT2: float
    aC: Geom2d_Curve
    theContext: IntTools_Context,optional
    	default value is opencascade::handle<IntTools_Context>()

    Returns
    -------
    aToler: float

    """
    return _BOPTools.BOPTools_AlgoTools2D_MakePCurveOnFace(*args)

def BOPTools_AlgoTools2D_PointOnSurface(*args) -> "Standard_Real &, Standard_Real &":
    """
    Compute surface parameters <u,v> of the face <af> for the point from the edge <ae> at parameter <at>. if <ae> has't pcurve on surface, algorithm tries to get it by projection and can raise exception standard_constructionerror if projection algorithm fails. <thecontext> - storage for caching the geometrical tools.

    Parameters
    ----------
    aE: TopoDS_Edge
    aF: TopoDS_Face
    aT: float
    theContext: IntTools_Context,optional
    	default value is opencascade::handle<IntTools_Context>()

    Returns
    -------
    U: float
    V: float

    """
    return _BOPTools.BOPTools_AlgoTools2D_PointOnSurface(*args)

class BOPTools_AlgoTools3D(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BOPTools_AlgoTools3D, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BOPTools_AlgoTools3D, name)
    __repr__ = _swig_repr

    def DoSplitSEAMOnFace(*args) -> "Standard_Boolean":
        """
        Makes the edge <theesplit> seam edge for the face <theface> basing on the surface properties (u and v periods).

        Parameters
        ----------
        theESplit: TopoDS_Edge
        theFace: TopoDS_Face

        Returns
        -------
        bool

        Makes the split edge <theesplit> seam edge for the face <theface> basing on the positions of 2d curves of the original edge <theeorigin>.

        Parameters
        ----------
        theEOrigin: TopoDS_Edge
        theESplit: TopoDS_Edge
        theFace: TopoDS_Face

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_AlgoTools3D_DoSplitSEAMOnFace(*args)

    DoSplitSEAMOnFace = staticmethod(DoSplitSEAMOnFace)

    def GetApproxNormalToFaceOnEdge(*args) -> "Standard_Boolean":
        """
        Computes normal to the face <af> for the 3d-point that belongs to the edge <ae> at parameter <at>. output: apx - the 3d-point where the normal computed ad - the normal; warning: the normal is computed not exactly in the point on the edge, but in point that is near to the edge towards to the face material (so, we'll have approx. normal); the point is computed using pointnearedge function, with the shifting value boptools_algotools3d::minstepin2d(), from the edge, but if this value is too big, the point will be computed using hatcher (pointinface function). returns true in case of success.

        Parameters
        ----------
        aE: TopoDS_Edge
        aF: TopoDS_Face
        aT: float
        aPx: gp_Pnt
        aD: gp_Dir
        theContext: IntTools_Context

        Returns
        -------
        bool

        Computes normal to the face <af> for the 3d-point that belongs to the edge <ae> at parameter <at>. output: apx - the 3d-point where the normal computed ad - the normal; warning: the normal is computed not exactly in the point on the edge, but in point that is near to the edge towards to the face material (so, we'll have approx. normal); the point is computed using pointnearedge function with the shifting value <adt2d> from the edge; no checks on this value will be done. returns true in case of success.

        Parameters
        ----------
        theE: TopoDS_Edge
        theF: TopoDS_Face
        aT: float
        aP: gp_Pnt
        aDNF: gp_Dir
        aDt2D: float

        Returns
        -------
        bool

        Computes normal to the face <af> for the 3d-point that belongs to the edge <ae> at parameter <at>. output: apx - the 3d-point where the normal computed ad - the normal; warning: the normal is computed not exactly in the point on the edge, but in point that is near to the edge towards to the face material (so, we'll have approx. normal); the point is computed using pointnearedge function with the shifting value <adt2d> from the edge, but if this value is too big the point will be computed using hatcher (pointinface function). returns true in case of success.

        Parameters
        ----------
        theE: TopoDS_Edge
        theF: TopoDS_Face
        aT: float
        aDt2D: float
        aP: gp_Pnt
        aDNF: gp_Dir
        theContext: IntTools_Context

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_AlgoTools3D_GetApproxNormalToFaceOnEdge(*args)

    GetApproxNormalToFaceOnEdge = staticmethod(GetApproxNormalToFaceOnEdge)

    def GetNormalToFaceOnEdge(*args) -> "void":
        """
        Computes normal to the face <af> for the point on the edge <ae> at parameter <at>. <thecontext> - storage for caching the geometrical tools.

        Parameters
        ----------
        aE: TopoDS_Edge
        aF: TopoDS_Face
        aT: float
        aD: gp_Dir
        theContext: IntTools_Context,optional
        	default value is opencascade::handle<IntTools_Context>()

        Returns
        -------
        None

        Computes normal to the face <af> for the point on the edge <ae> at arbitrary intermediate parameter. <thecontext> - storage for caching the geometrical tools.

        Parameters
        ----------
        aE: TopoDS_Edge
        aF: TopoDS_Face
        aD: gp_Dir
        theContext: IntTools_Context,optional
        	default value is opencascade::handle<IntTools_Context>()

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools3D_GetNormalToFaceOnEdge(*args)

    GetNormalToFaceOnEdge = staticmethod(GetNormalToFaceOnEdge)

    def GetNormalToSurface(*args) -> "Standard_Boolean":
        """
        Compute normal <ad> to surface <as> in point (u,v) returns true if directions ad1u, ad1v coincide.

        Parameters
        ----------
        aS: Geom_Surface
        U: float
        V: float
        aD: gp_Dir

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_AlgoTools3D_GetNormalToSurface(*args)

    GetNormalToSurface = staticmethod(GetNormalToSurface)

    def IsEmptyShape(*args) -> "Standard_Boolean":
        """
        Returns true if the shape <as> does not contain geometry information (e.g. empty compound).

        Parameters
        ----------
        aS: TopoDS_Shape

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_AlgoTools3D_IsEmptyShape(*args)

    IsEmptyShape = staticmethod(IsEmptyShape)

    def MinStepIn2d(*args) -> "Standard_Real":
        """
        Returns simple step value that is used in 2d-computations = 1.e-5.

        Returns
        -------
        float

        """
        return _BOPTools.BOPTools_AlgoTools3D_MinStepIn2d(*args)

    MinStepIn2d = staticmethod(MinStepIn2d)

    def OrientEdgeOnFace(*args) -> "void":
        """
        Get the edge <aer> from the face <af> that is the same as the edge <ae>.

        Parameters
        ----------
        aE: TopoDS_Edge
        aF: TopoDS_Face
        aER: TopoDS_Edge

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_AlgoTools3D_OrientEdgeOnFace(*args)

    OrientEdgeOnFace = staticmethod(OrientEdgeOnFace)

    def PointInFace(*args) -> "Standard_Integer":
        """
        Computes arbitrary point <thep> inside the face <thef>. <thep2d> - 2d representation of <thep> on the surface of <thef> returns 0 in case of success.

        Parameters
        ----------
        theF: TopoDS_Face
        theP: gp_Pnt
        theP2D: gp_Pnt2d
        theContext: IntTools_Context

        Returns
        -------
        int

        Computes a point <thep> inside the face <thef> using starting point taken by the parameter <thet> from the 2d curve of the edge <thee> on the face <thef> in the direction perpendicular to the tangent vector of the 2d curve of the edge. the point will be distanced on <thedt2d> from the 2d curve. <thep2d> - 2d representation of <thep> on the surface of <thef> returns 0 in case of success.

        Parameters
        ----------
        theF: TopoDS_Face
        theE: TopoDS_Edge
        theT: float
        theDt2D: float
        theP: gp_Pnt
        theP2D: gp_Pnt2d
        theContext: IntTools_Context

        Returns
        -------
        int

        Computes a point <thep> inside the face <thef> using the line <thel> so that 2d point <thep2d>, 2d representation of <thep> on the surface of <thef>, lies on that line. returns 0 in case of success.

        Parameters
        ----------
        theF: TopoDS_Face
        theL: Geom2d_Curve
        theP: gp_Pnt
        theP2D: gp_Pnt2d
        theContext: IntTools_Context
        theDt2D: float,optional
        	default value is 0.0

        Returns
        -------
        int

        """
        return _BOPTools.BOPTools_AlgoTools3D_PointInFace(*args)

    PointInFace = staticmethod(PointInFace)

    def PointNearEdge(*args) -> "Standard_Integer":
        """
        Compute the point <apx>, (<ap2d>) that is near to the edge <ae> at parameter <at> towards to the material of the face <af>. the value of shifting in 2d is <adt2d> if the value of shifting is too big the point will be computed using hatcher (pointinface function). returns error status: 0 - in case of success; 1 - <ae> does not have 2d curve on the face <af>; 2 - the computed point is out of the face.

        Parameters
        ----------
        aE: TopoDS_Edge
        aF: TopoDS_Face
        aT: float
        aDt2D: float
        aP2D: gp_Pnt2d
        aPx: gp_Pnt
        theContext: IntTools_Context

        Returns
        -------
        int

        Compute the point <apx>, (<ap2d>) that is near to the edge <ae> at parameter <at> towards to the material of the face <af>. the value of shifting in 2d is <adt2d>. no checks on this value will be done. returns error status: 0 - in case of success; 1 - <ae> does not have 2d curve on the face <af>.

        Parameters
        ----------
        aE: TopoDS_Edge
        aF: TopoDS_Face
        aT: float
        aDt2D: float
        aP2D: gp_Pnt2d
        aPx: gp_Pnt

        Returns
        -------
        int

        Computes the point <apx>, (<ap2d>) that is near to the edge <ae> at parameter <at> towards to the material of the face <af>. the value of shifting in 2d is dt2d=boptools_algotools3d::minstepin2d() if the value of shifting is too big the point will be computed using hatcher (pointinface function). returns error status: 0 - in case of success; 1 - <ae> does not have 2d curve on the face <af>; 2 - the computed point is out of the face.

        Parameters
        ----------
        aE: TopoDS_Edge
        aF: TopoDS_Face
        aT: float
        aP2D: gp_Pnt2d
        aPx: gp_Pnt
        theContext: IntTools_Context

        Returns
        -------
        int

        Compute the point <apx>, (<ap2d>) that is near to the edge <ae> at arbitrary parameter towards to the material of the face <af>. the value of shifting in 2d is dt2d=boptools_algotools3d::minstepin2d(). if the value of shifting is too big the point will be computed using hatcher (pointinface function). returns error status: 0 - in case of success; 1 - <ae> does not have 2d curve on the face <af>; 2 - the computed point is out of the face.

        Parameters
        ----------
        aE: TopoDS_Edge
        aF: TopoDS_Face
        aP2D: gp_Pnt2d
        aPx: gp_Pnt
        theContext: IntTools_Context

        Returns
        -------
        int

        """
        return _BOPTools.BOPTools_AlgoTools3D_PointNearEdge(*args)

    PointNearEdge = staticmethod(PointNearEdge)

    def SenseFlag(*args) -> "Standard_Integer":
        """
        Returns 1 if scalar product anf1* anf2>0. returns 0 if directions anf1 anf2 coincide returns -1 if scalar product anf1* anf2<0.

        Parameters
        ----------
        aNF1: gp_Dir
        aNF2: gp_Dir

        Returns
        -------
        int

        """
        return _BOPTools.BOPTools_AlgoTools3D_SenseFlag(*args)

    SenseFlag = staticmethod(SenseFlag)

    __repr__ = _dumps_object


    def __init__(self):
        this = _BOPTools.new_BOPTools_AlgoTools3D()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPTools.delete_BOPTools_AlgoTools3D
    __del__ = lambda self: None
BOPTools_AlgoTools3D_swigregister = _BOPTools.BOPTools_AlgoTools3D_swigregister
BOPTools_AlgoTools3D_swigregister(BOPTools_AlgoTools3D)

def BOPTools_AlgoTools3D_DoSplitSEAMOnFace(*args) -> "Standard_Boolean":
    """
    Makes the edge <theesplit> seam edge for the face <theface> basing on the surface properties (u and v periods).

    Parameters
    ----------
    theESplit: TopoDS_Edge
    theFace: TopoDS_Face

    Returns
    -------
    bool

    Makes the split edge <theesplit> seam edge for the face <theface> basing on the positions of 2d curves of the original edge <theeorigin>.

    Parameters
    ----------
    theEOrigin: TopoDS_Edge
    theESplit: TopoDS_Edge
    theFace: TopoDS_Face

    Returns
    -------
    bool

    """
    return _BOPTools.BOPTools_AlgoTools3D_DoSplitSEAMOnFace(*args)

def BOPTools_AlgoTools3D_GetApproxNormalToFaceOnEdge(*args) -> "Standard_Boolean":
    """
    Computes normal to the face <af> for the 3d-point that belongs to the edge <ae> at parameter <at>. output: apx - the 3d-point where the normal computed ad - the normal; warning: the normal is computed not exactly in the point on the edge, but in point that is near to the edge towards to the face material (so, we'll have approx. normal); the point is computed using pointnearedge function, with the shifting value boptools_algotools3d::minstepin2d(), from the edge, but if this value is too big, the point will be computed using hatcher (pointinface function). returns true in case of success.

    Parameters
    ----------
    aE: TopoDS_Edge
    aF: TopoDS_Face
    aT: float
    aPx: gp_Pnt
    aD: gp_Dir
    theContext: IntTools_Context

    Returns
    -------
    bool

    Computes normal to the face <af> for the 3d-point that belongs to the edge <ae> at parameter <at>. output: apx - the 3d-point where the normal computed ad - the normal; warning: the normal is computed not exactly in the point on the edge, but in point that is near to the edge towards to the face material (so, we'll have approx. normal); the point is computed using pointnearedge function with the shifting value <adt2d> from the edge; no checks on this value will be done. returns true in case of success.

    Parameters
    ----------
    theE: TopoDS_Edge
    theF: TopoDS_Face
    aT: float
    aP: gp_Pnt
    aDNF: gp_Dir
    aDt2D: float

    Returns
    -------
    bool

    Computes normal to the face <af> for the 3d-point that belongs to the edge <ae> at parameter <at>. output: apx - the 3d-point where the normal computed ad - the normal; warning: the normal is computed not exactly in the point on the edge, but in point that is near to the edge towards to the face material (so, we'll have approx. normal); the point is computed using pointnearedge function with the shifting value <adt2d> from the edge, but if this value is too big the point will be computed using hatcher (pointinface function). returns true in case of success.

    Parameters
    ----------
    theE: TopoDS_Edge
    theF: TopoDS_Face
    aT: float
    aDt2D: float
    aP: gp_Pnt
    aDNF: gp_Dir
    theContext: IntTools_Context

    Returns
    -------
    bool

    """
    return _BOPTools.BOPTools_AlgoTools3D_GetApproxNormalToFaceOnEdge(*args)

def BOPTools_AlgoTools3D_GetNormalToFaceOnEdge(*args) -> "void":
    """
    Computes normal to the face <af> for the point on the edge <ae> at parameter <at>. <thecontext> - storage for caching the geometrical tools.

    Parameters
    ----------
    aE: TopoDS_Edge
    aF: TopoDS_Face
    aT: float
    aD: gp_Dir
    theContext: IntTools_Context,optional
    	default value is opencascade::handle<IntTools_Context>()

    Returns
    -------
    None

    Computes normal to the face <af> for the point on the edge <ae> at arbitrary intermediate parameter. <thecontext> - storage for caching the geometrical tools.

    Parameters
    ----------
    aE: TopoDS_Edge
    aF: TopoDS_Face
    aD: gp_Dir
    theContext: IntTools_Context,optional
    	default value is opencascade::handle<IntTools_Context>()

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools3D_GetNormalToFaceOnEdge(*args)

def BOPTools_AlgoTools3D_GetNormalToSurface(*args) -> "Standard_Boolean":
    """
    Compute normal <ad> to surface <as> in point (u,v) returns true if directions ad1u, ad1v coincide.

    Parameters
    ----------
    aS: Geom_Surface
    U: float
    V: float
    aD: gp_Dir

    Returns
    -------
    bool

    """
    return _BOPTools.BOPTools_AlgoTools3D_GetNormalToSurface(*args)

def BOPTools_AlgoTools3D_IsEmptyShape(*args) -> "Standard_Boolean":
    """
    Returns true if the shape <as> does not contain geometry information (e.g. empty compound).

    Parameters
    ----------
    aS: TopoDS_Shape

    Returns
    -------
    bool

    """
    return _BOPTools.BOPTools_AlgoTools3D_IsEmptyShape(*args)

def BOPTools_AlgoTools3D_MinStepIn2d(*args) -> "Standard_Real":
    """
    Returns simple step value that is used in 2d-computations = 1.e-5.

    Returns
    -------
    float

    """
    return _BOPTools.BOPTools_AlgoTools3D_MinStepIn2d(*args)

def BOPTools_AlgoTools3D_OrientEdgeOnFace(*args) -> "void":
    """
    Get the edge <aer> from the face <af> that is the same as the edge <ae>.

    Parameters
    ----------
    aE: TopoDS_Edge
    aF: TopoDS_Face
    aER: TopoDS_Edge

    Returns
    -------
    None

    """
    return _BOPTools.BOPTools_AlgoTools3D_OrientEdgeOnFace(*args)

def BOPTools_AlgoTools3D_PointInFace(*args) -> "Standard_Integer":
    """
    Computes arbitrary point <thep> inside the face <thef>. <thep2d> - 2d representation of <thep> on the surface of <thef> returns 0 in case of success.

    Parameters
    ----------
    theF: TopoDS_Face
    theP: gp_Pnt
    theP2D: gp_Pnt2d
    theContext: IntTools_Context

    Returns
    -------
    int

    Computes a point <thep> inside the face <thef> using starting point taken by the parameter <thet> from the 2d curve of the edge <thee> on the face <thef> in the direction perpendicular to the tangent vector of the 2d curve of the edge. the point will be distanced on <thedt2d> from the 2d curve. <thep2d> - 2d representation of <thep> on the surface of <thef> returns 0 in case of success.

    Parameters
    ----------
    theF: TopoDS_Face
    theE: TopoDS_Edge
    theT: float
    theDt2D: float
    theP: gp_Pnt
    theP2D: gp_Pnt2d
    theContext: IntTools_Context

    Returns
    -------
    int

    Computes a point <thep> inside the face <thef> using the line <thel> so that 2d point <thep2d>, 2d representation of <thep> on the surface of <thef>, lies on that line. returns 0 in case of success.

    Parameters
    ----------
    theF: TopoDS_Face
    theL: Geom2d_Curve
    theP: gp_Pnt
    theP2D: gp_Pnt2d
    theContext: IntTools_Context
    theDt2D: float,optional
    	default value is 0.0

    Returns
    -------
    int

    """
    return _BOPTools.BOPTools_AlgoTools3D_PointInFace(*args)

def BOPTools_AlgoTools3D_PointNearEdge(*args) -> "Standard_Integer":
    """
    Compute the point <apx>, (<ap2d>) that is near to the edge <ae> at parameter <at> towards to the material of the face <af>. the value of shifting in 2d is <adt2d> if the value of shifting is too big the point will be computed using hatcher (pointinface function). returns error status: 0 - in case of success; 1 - <ae> does not have 2d curve on the face <af>; 2 - the computed point is out of the face.

    Parameters
    ----------
    aE: TopoDS_Edge
    aF: TopoDS_Face
    aT: float
    aDt2D: float
    aP2D: gp_Pnt2d
    aPx: gp_Pnt
    theContext: IntTools_Context

    Returns
    -------
    int

    Compute the point <apx>, (<ap2d>) that is near to the edge <ae> at parameter <at> towards to the material of the face <af>. the value of shifting in 2d is <adt2d>. no checks on this value will be done. returns error status: 0 - in case of success; 1 - <ae> does not have 2d curve on the face <af>.

    Parameters
    ----------
    aE: TopoDS_Edge
    aF: TopoDS_Face
    aT: float
    aDt2D: float
    aP2D: gp_Pnt2d
    aPx: gp_Pnt

    Returns
    -------
    int

    Computes the point <apx>, (<ap2d>) that is near to the edge <ae> at parameter <at> towards to the material of the face <af>. the value of shifting in 2d is dt2d=boptools_algotools3d::minstepin2d() if the value of shifting is too big the point will be computed using hatcher (pointinface function). returns error status: 0 - in case of success; 1 - <ae> does not have 2d curve on the face <af>; 2 - the computed point is out of the face.

    Parameters
    ----------
    aE: TopoDS_Edge
    aF: TopoDS_Face
    aT: float
    aP2D: gp_Pnt2d
    aPx: gp_Pnt
    theContext: IntTools_Context

    Returns
    -------
    int

    Compute the point <apx>, (<ap2d>) that is near to the edge <ae> at arbitrary parameter towards to the material of the face <af>. the value of shifting in 2d is dt2d=boptools_algotools3d::minstepin2d(). if the value of shifting is too big the point will be computed using hatcher (pointinface function). returns error status: 0 - in case of success; 1 - <ae> does not have 2d curve on the face <af>; 2 - the computed point is out of the face.

    Parameters
    ----------
    aE: TopoDS_Edge
    aF: TopoDS_Face
    aP2D: gp_Pnt2d
    aPx: gp_Pnt
    theContext: IntTools_Context

    Returns
    -------
    int

    """
    return _BOPTools.BOPTools_AlgoTools3D_PointNearEdge(*args)

def BOPTools_AlgoTools3D_SenseFlag(*args) -> "Standard_Integer":
    """
    Returns 1 if scalar product anf1* anf2>0. returns 0 if directions anf1 anf2 coincide returns -1 if scalar product anf1* anf2<0.

    Parameters
    ----------
    aNF1: gp_Dir
    aNF2: gp_Dir

    Returns
    -------
    int

    """
    return _BOPTools.BOPTools_AlgoTools3D_SenseFlag(*args)

class BOPTools_ConnexityBlock(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BOPTools_ConnexityBlock, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BOPTools_ConnexityBlock, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        theAllocator: NCollection_BaseAllocator

        Returns
        -------
        None

        """
        this = _BOPTools.new_BOPTools_ConnexityBlock(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ChangeLoops(self, *args) -> "TopTools_ListOfShape &":
        """
        No available documentation.

        Returns
        -------
        TopTools_ListOfShape

        """
        return _BOPTools.BOPTools_ConnexityBlock_ChangeLoops(self, *args)


    def ChangeShapes(self, *args) -> "TopTools_ListOfShape &":
        """
        No available documentation.

        Returns
        -------
        TopTools_ListOfShape

        """
        return _BOPTools.BOPTools_ConnexityBlock_ChangeShapes(self, *args)


    def IsRegular(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_ConnexityBlock_IsRegular(self, *args)


    def Loops(self, *args) -> "TopTools_ListOfShape const &":
        """
        No available documentation.

        Returns
        -------
        TopTools_ListOfShape

        """
        return _BOPTools.BOPTools_ConnexityBlock_Loops(self, *args)


    def SetRegular(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        theFlag: bool

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_ConnexityBlock_SetRegular(self, *args)


    def Shapes(self, *args) -> "TopTools_ListOfShape const &":
        """
        No available documentation.

        Returns
        -------
        TopTools_ListOfShape

        """
        return _BOPTools.BOPTools_ConnexityBlock_Shapes(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BOPTools.delete_BOPTools_ConnexityBlock
    __del__ = lambda self: None
BOPTools_ConnexityBlock_swigregister = _BOPTools.BOPTools_ConnexityBlock_swigregister
BOPTools_ConnexityBlock_swigregister(BOPTools_ConnexityBlock)

class BOPTools_CoupleOfShape(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BOPTools_CoupleOfShape, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BOPTools_CoupleOfShape, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        """
        this = _BOPTools.new_BOPTools_CoupleOfShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetShape1(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        theShape: TopoDS_Shape

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_CoupleOfShape_SetShape1(self, *args)


    def SetShape2(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        theShape: TopoDS_Shape

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_CoupleOfShape_SetShape2(self, *args)


    def Shape1(self, *args) -> "TopoDS_Shape const":
        """
        No available documentation.

        Returns
        -------
        TopoDS_Shape

        """
        return _BOPTools.BOPTools_CoupleOfShape_Shape1(self, *args)


    def Shape2(self, *args) -> "TopoDS_Shape const":
        """
        No available documentation.

        Returns
        -------
        TopoDS_Shape

        """
        return _BOPTools.BOPTools_CoupleOfShape_Shape2(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BOPTools.delete_BOPTools_CoupleOfShape
    __del__ = lambda self: None
BOPTools_CoupleOfShape_swigregister = _BOPTools.BOPTools_CoupleOfShape_swigregister
BOPTools_CoupleOfShape_swigregister(BOPTools_CoupleOfShape)

class BOPTools_Set(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BOPTools_Set, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BOPTools_Set, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        theAllocator: NCollection_BaseAllocator

        Returns
        -------
        None

        Copy constructor.

        Parameters
        ----------
        theOther: BOPTools_Set

        Returns
        -------
        None

        """
        this = _BOPTools.new_BOPTools_Set(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        theS: TopoDS_Shape
        theType: TopAbs_ShapeEnum

        Returns
        -------
        None

        """
        return _BOPTools.BOPTools_Set_Add(self, *args)


    def Assign(self, *args) -> "BOPTools_Set &":
        """
        No available documentation.

        Parameters
        ----------
        Other: BOPTools_Set

        Returns
        -------
        BOPTools_Set

        """
        return _BOPTools.BOPTools_Set_Assign(self, *args)


    def HashCode(self, *args) -> "Standard_Integer":
        """
        Computes a hash code for this set, in the range [1, theupperbound] @param theupperbound the upper bound of the range a computing hash code must be within returns a computed hash code, in the range [1, theupperbound].

        Parameters
        ----------
        theUpperBound: int

        Returns
        -------
        int

        """
        return _BOPTools.BOPTools_Set_HashCode(self, *args)


    def __hash__(self) -> "Standard_Integer":
        return _BOPTools.BOPTools_Set___hash__(self)

    def IsEqual(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Parameters
        ----------
        aOther: BOPTools_Set

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_Set_IsEqual(self, *args)


    def NbShapes(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _BOPTools.BOPTools_Set_NbShapes(self, *args)


    def Shape(self, *args) -> "TopoDS_Shape const":
        """
        No available documentation.

        Returns
        -------
        TopoDS_Shape

        """
        return _BOPTools.BOPTools_Set_Shape(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _BOPTools.delete_BOPTools_Set
    __del__ = lambda self: None
BOPTools_Set_swigregister = _BOPTools.BOPTools_Set_swigregister
BOPTools_Set_swigregister(BOPTools_Set)

class BOPTools_SetMapHasher(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BOPTools_SetMapHasher, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BOPTools_SetMapHasher, name)
    __repr__ = _swig_repr

    def HashCode(*args) -> "Standard_Integer":
        """
        Computes a hash code for the given set, in the range [1, theupperbound] @param theset the set which hash code is to be computed @param theupperbound the upper bound of the range a computing hash code must be within returns a computed hash code, in the range [1, theupperbound].

        Parameters
        ----------
        theSet: BOPTools_Set
        theUpperBound: int

        Returns
        -------
        int

        """
        return _BOPTools.BOPTools_SetMapHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args) -> "Standard_Boolean":
        """
        No available documentation.

        Parameters
        ----------
        aSet1: BOPTools_Set
        aSet2: BOPTools_Set

        Returns
        -------
        bool

        """
        return _BOPTools.BOPTools_SetMapHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    __repr__ = _dumps_object


    def __init__(self):
        this = _BOPTools.new_BOPTools_SetMapHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BOPTools.delete_BOPTools_SetMapHasher
    __del__ = lambda self: None
BOPTools_SetMapHasher_swigregister = _BOPTools.BOPTools_SetMapHasher_swigregister
BOPTools_SetMapHasher_swigregister(BOPTools_SetMapHasher)

def BOPTools_SetMapHasher_HashCode(*args) -> "Standard_Integer":
    """
    Computes a hash code for the given set, in the range [1, theupperbound] @param theset the set which hash code is to be computed @param theupperbound the upper bound of the range a computing hash code must be within returns a computed hash code, in the range [1, theupperbound].

    Parameters
    ----------
    theSet: BOPTools_Set
    theUpperBound: int

    Returns
    -------
    int

    """
    return _BOPTools.BOPTools_SetMapHasher_HashCode(*args)

def BOPTools_SetMapHasher_IsEqual(*args) -> "Standard_Boolean":
    """
    No available documentation.

    Parameters
    ----------
    aSet1: BOPTools_Set
    aSet2: BOPTools_Set

    Returns
    -------
    bool

    """
    return _BOPTools.BOPTools_SetMapHasher_IsEqual(*args)


@classnotwrapped
class BOPTools_Parallel:
	pass

@classnotwrapped
class BOPTools_BoxSelector:
	pass

@classnotwrapped
class BOPTools_BoxSet:
	pass

@classnotwrapped
class BOPTools_PairSelector:
	pass




# This file is compatible with both classic and new-style classes.


