# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
IFSelect module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_ifselect.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IFSelect')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IFSelect')
    _IFSelect = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IFSelect', [dirname(__file__)])
        except ImportError:
            import _IFSelect
            return _IFSelect
        try:
            _mod = imp.load_module('_IFSelect', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IFSelect = swig_import_helper()
    del swig_import_helper
else:
    import _IFSelect
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IFSelect.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _IFSelect.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _IFSelect.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _IFSelect.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _IFSelect.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _IFSelect.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _IFSelect.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _IFSelect.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _IFSelect.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _IFSelect.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _IFSelect.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _IFSelect.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _IFSelect.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _IFSelect.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _IFSelect.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _IFSelect.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _IFSelect.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _IFSelect.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _IFSelect.process_exception(error, method_name, class_name)
process_exception = _IFSelect.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.Interface
import OCC.Core.TCollection
import OCC.Core.Message
import OCC.Core.OSD
import OCC.Core.TColStd
import OCC.Core.MoniTool
import OCC.Core.TopoDS
import OCC.Core.TopAbs
import OCC.Core.TopLoc
import OCC.Core.gp

from enum import IntEnum
from OCC.Core.Exception import *

IFSelect_FailOnly = _IFSelect.IFSelect_FailOnly
IFSelect_FailAndWarn = _IFSelect.IFSelect_FailAndWarn
IFSelect_RemainForget = _IFSelect.IFSelect_RemainForget
IFSelect_RemainCompute = _IFSelect.IFSelect_RemainCompute
IFSelect_RemainDisplay = _IFSelect.IFSelect_RemainDisplay
IFSelect_RemainUndo = _IFSelect.IFSelect_RemainUndo
IFSelect_Optional = _IFSelect.IFSelect_Optional
IFSelect_Editable = _IFSelect.IFSelect_Editable
IFSelect_EditProtected = _IFSelect.IFSelect_EditProtected
IFSelect_EditComputed = _IFSelect.IFSelect_EditComputed
IFSelect_EditRead = _IFSelect.IFSelect_EditRead
IFSelect_EditDynamic = _IFSelect.IFSelect_EditDynamic
IFSelect_RetVoid = _IFSelect.IFSelect_RetVoid
IFSelect_RetDone = _IFSelect.IFSelect_RetDone
IFSelect_RetError = _IFSelect.IFSelect_RetError
IFSelect_RetFail = _IFSelect.IFSelect_RetFail
IFSelect_RetStop = _IFSelect.IFSelect_RetStop
IFSelect_ItemsByEntity = _IFSelect.IFSelect_ItemsByEntity
IFSelect_CountByItem = _IFSelect.IFSelect_CountByItem
IFSelect_ShortByItem = _IFSelect.IFSelect_ShortByItem
IFSelect_ListByItem = _IFSelect.IFSelect_ListByItem
IFSelect_EntitiesByItem = _IFSelect.IFSelect_EntitiesByItem
IFSelect_CountSummary = _IFSelect.IFSelect_CountSummary
IFSelect_GeneralInfo = _IFSelect.IFSelect_GeneralInfo
IFSelect_Mapping = _IFSelect.IFSelect_Mapping
IFSelect_ResultCount = _IFSelect.IFSelect_ResultCount


class IFSelect_PrintFail(IntEnum):
	IFSelect_FailOnly = 0
	IFSelect_FailAndWarn = 1
IFSelect_FailOnly = IFSelect_PrintFail.IFSelect_FailOnly
IFSelect_FailAndWarn = IFSelect_PrintFail.IFSelect_FailAndWarn

class IFSelect_RemainMode(IntEnum):
	IFSelect_RemainForget = 0
	IFSelect_RemainCompute = 1
	IFSelect_RemainDisplay = 2
	IFSelect_RemainUndo = 3
IFSelect_RemainForget = IFSelect_RemainMode.IFSelect_RemainForget
IFSelect_RemainCompute = IFSelect_RemainMode.IFSelect_RemainCompute
IFSelect_RemainDisplay = IFSelect_RemainMode.IFSelect_RemainDisplay
IFSelect_RemainUndo = IFSelect_RemainMode.IFSelect_RemainUndo

class IFSelect_EditValue(IntEnum):
	IFSelect_Optional = 0
	IFSelect_Editable = 1
	IFSelect_EditProtected = 2
	IFSelect_EditComputed = 3
	IFSelect_EditRead = 4
	IFSelect_EditDynamic = 5
IFSelect_Optional = IFSelect_EditValue.IFSelect_Optional
IFSelect_Editable = IFSelect_EditValue.IFSelect_Editable
IFSelect_EditProtected = IFSelect_EditValue.IFSelect_EditProtected
IFSelect_EditComputed = IFSelect_EditValue.IFSelect_EditComputed
IFSelect_EditRead = IFSelect_EditValue.IFSelect_EditRead
IFSelect_EditDynamic = IFSelect_EditValue.IFSelect_EditDynamic

class IFSelect_ReturnStatus(IntEnum):
	IFSelect_RetVoid = 0
	IFSelect_RetDone = 1
	IFSelect_RetError = 2
	IFSelect_RetFail = 3
	IFSelect_RetStop = 4
IFSelect_RetVoid = IFSelect_ReturnStatus.IFSelect_RetVoid
IFSelect_RetDone = IFSelect_ReturnStatus.IFSelect_RetDone
IFSelect_RetError = IFSelect_ReturnStatus.IFSelect_RetError
IFSelect_RetFail = IFSelect_ReturnStatus.IFSelect_RetFail
IFSelect_RetStop = IFSelect_ReturnStatus.IFSelect_RetStop

class IFSelect_PrintCount(IntEnum):
	IFSelect_ItemsByEntity = 0
	IFSelect_CountByItem = 1
	IFSelect_ShortByItem = 2
	IFSelect_ListByItem = 3
	IFSelect_EntitiesByItem = 4
	IFSelect_CountSummary = 5
	IFSelect_GeneralInfo = 6
	IFSelect_Mapping = 7
	IFSelect_ResultCount = 8
IFSelect_ItemsByEntity = IFSelect_PrintCount.IFSelect_ItemsByEntity
IFSelect_CountByItem = IFSelect_PrintCount.IFSelect_CountByItem
IFSelect_ShortByItem = IFSelect_PrintCount.IFSelect_ShortByItem
IFSelect_ListByItem = IFSelect_PrintCount.IFSelect_ListByItem
IFSelect_EntitiesByItem = IFSelect_PrintCount.IFSelect_EntitiesByItem
IFSelect_CountSummary = IFSelect_PrintCount.IFSelect_CountSummary
IFSelect_GeneralInfo = IFSelect_PrintCount.IFSelect_GeneralInfo
IFSelect_Mapping = IFSelect_PrintCount.IFSelect_Mapping
IFSelect_ResultCount = IFSelect_PrintCount.IFSelect_ResultCount


def Handle_IFSelect_Activator_Create() -> "opencascade::handle< IFSelect_Activator >":
    return _IFSelect.Handle_IFSelect_Activator_Create()
Handle_IFSelect_Activator_Create = _IFSelect.Handle_IFSelect_Activator_Create

def Handle_IFSelect_Activator_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_Activator >":
    return _IFSelect.Handle_IFSelect_Activator_DownCast(t)
Handle_IFSelect_Activator_DownCast = _IFSelect.Handle_IFSelect_Activator_DownCast

def Handle_IFSelect_Activator_IsNull(t: 'opencascade::handle< IFSelect_Activator > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_Activator_IsNull(t)
Handle_IFSelect_Activator_IsNull = _IFSelect.Handle_IFSelect_Activator_IsNull

def Handle_IFSelect_AppliedModifiers_Create() -> "opencascade::handle< IFSelect_AppliedModifiers >":
    return _IFSelect.Handle_IFSelect_AppliedModifiers_Create()
Handle_IFSelect_AppliedModifiers_Create = _IFSelect.Handle_IFSelect_AppliedModifiers_Create

def Handle_IFSelect_AppliedModifiers_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_AppliedModifiers >":
    return _IFSelect.Handle_IFSelect_AppliedModifiers_DownCast(t)
Handle_IFSelect_AppliedModifiers_DownCast = _IFSelect.Handle_IFSelect_AppliedModifiers_DownCast

def Handle_IFSelect_AppliedModifiers_IsNull(t: 'opencascade::handle< IFSelect_AppliedModifiers > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_AppliedModifiers_IsNull(t)
Handle_IFSelect_AppliedModifiers_IsNull = _IFSelect.Handle_IFSelect_AppliedModifiers_IsNull

def Handle_IFSelect_Dispatch_Create() -> "opencascade::handle< IFSelect_Dispatch >":
    return _IFSelect.Handle_IFSelect_Dispatch_Create()
Handle_IFSelect_Dispatch_Create = _IFSelect.Handle_IFSelect_Dispatch_Create

def Handle_IFSelect_Dispatch_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_Dispatch >":
    return _IFSelect.Handle_IFSelect_Dispatch_DownCast(t)
Handle_IFSelect_Dispatch_DownCast = _IFSelect.Handle_IFSelect_Dispatch_DownCast

def Handle_IFSelect_Dispatch_IsNull(t: 'opencascade::handle< IFSelect_Dispatch > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_Dispatch_IsNull(t)
Handle_IFSelect_Dispatch_IsNull = _IFSelect.Handle_IFSelect_Dispatch_IsNull

def Handle_IFSelect_EditForm_Create() -> "opencascade::handle< IFSelect_EditForm >":
    return _IFSelect.Handle_IFSelect_EditForm_Create()
Handle_IFSelect_EditForm_Create = _IFSelect.Handle_IFSelect_EditForm_Create

def Handle_IFSelect_EditForm_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_EditForm >":
    return _IFSelect.Handle_IFSelect_EditForm_DownCast(t)
Handle_IFSelect_EditForm_DownCast = _IFSelect.Handle_IFSelect_EditForm_DownCast

def Handle_IFSelect_EditForm_IsNull(t: 'opencascade::handle< IFSelect_EditForm > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_EditForm_IsNull(t)
Handle_IFSelect_EditForm_IsNull = _IFSelect.Handle_IFSelect_EditForm_IsNull

def Handle_IFSelect_Editor_Create() -> "opencascade::handle< IFSelect_Editor >":
    return _IFSelect.Handle_IFSelect_Editor_Create()
Handle_IFSelect_Editor_Create = _IFSelect.Handle_IFSelect_Editor_Create

def Handle_IFSelect_Editor_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_Editor >":
    return _IFSelect.Handle_IFSelect_Editor_DownCast(t)
Handle_IFSelect_Editor_DownCast = _IFSelect.Handle_IFSelect_Editor_DownCast

def Handle_IFSelect_Editor_IsNull(t: 'opencascade::handle< IFSelect_Editor > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_Editor_IsNull(t)
Handle_IFSelect_Editor_IsNull = _IFSelect.Handle_IFSelect_Editor_IsNull

def Handle_IFSelect_GeneralModifier_Create() -> "opencascade::handle< IFSelect_GeneralModifier >":
    return _IFSelect.Handle_IFSelect_GeneralModifier_Create()
Handle_IFSelect_GeneralModifier_Create = _IFSelect.Handle_IFSelect_GeneralModifier_Create

def Handle_IFSelect_GeneralModifier_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_GeneralModifier >":
    return _IFSelect.Handle_IFSelect_GeneralModifier_DownCast(t)
Handle_IFSelect_GeneralModifier_DownCast = _IFSelect.Handle_IFSelect_GeneralModifier_DownCast

def Handle_IFSelect_GeneralModifier_IsNull(t: 'opencascade::handle< IFSelect_GeneralModifier > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_GeneralModifier_IsNull(t)
Handle_IFSelect_GeneralModifier_IsNull = _IFSelect.Handle_IFSelect_GeneralModifier_IsNull

def Handle_IFSelect_IntParam_Create() -> "opencascade::handle< IFSelect_IntParam >":
    return _IFSelect.Handle_IFSelect_IntParam_Create()
Handle_IFSelect_IntParam_Create = _IFSelect.Handle_IFSelect_IntParam_Create

def Handle_IFSelect_IntParam_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_IntParam >":
    return _IFSelect.Handle_IFSelect_IntParam_DownCast(t)
Handle_IFSelect_IntParam_DownCast = _IFSelect.Handle_IFSelect_IntParam_DownCast

def Handle_IFSelect_IntParam_IsNull(t: 'opencascade::handle< IFSelect_IntParam > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_IntParam_IsNull(t)
Handle_IFSelect_IntParam_IsNull = _IFSelect.Handle_IFSelect_IntParam_IsNull

def Handle_IFSelect_ListEditor_Create() -> "opencascade::handle< IFSelect_ListEditor >":
    return _IFSelect.Handle_IFSelect_ListEditor_Create()
Handle_IFSelect_ListEditor_Create = _IFSelect.Handle_IFSelect_ListEditor_Create

def Handle_IFSelect_ListEditor_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_ListEditor >":
    return _IFSelect.Handle_IFSelect_ListEditor_DownCast(t)
Handle_IFSelect_ListEditor_DownCast = _IFSelect.Handle_IFSelect_ListEditor_DownCast

def Handle_IFSelect_ListEditor_IsNull(t: 'opencascade::handle< IFSelect_ListEditor > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_ListEditor_IsNull(t)
Handle_IFSelect_ListEditor_IsNull = _IFSelect.Handle_IFSelect_ListEditor_IsNull

def Handle_IFSelect_ModelCopier_Create() -> "opencascade::handle< IFSelect_ModelCopier >":
    return _IFSelect.Handle_IFSelect_ModelCopier_Create()
Handle_IFSelect_ModelCopier_Create = _IFSelect.Handle_IFSelect_ModelCopier_Create

def Handle_IFSelect_ModelCopier_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_ModelCopier >":
    return _IFSelect.Handle_IFSelect_ModelCopier_DownCast(t)
Handle_IFSelect_ModelCopier_DownCast = _IFSelect.Handle_IFSelect_ModelCopier_DownCast

def Handle_IFSelect_ModelCopier_IsNull(t: 'opencascade::handle< IFSelect_ModelCopier > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_ModelCopier_IsNull(t)
Handle_IFSelect_ModelCopier_IsNull = _IFSelect.Handle_IFSelect_ModelCopier_IsNull

def Handle_IFSelect_PacketList_Create() -> "opencascade::handle< IFSelect_PacketList >":
    return _IFSelect.Handle_IFSelect_PacketList_Create()
Handle_IFSelect_PacketList_Create = _IFSelect.Handle_IFSelect_PacketList_Create

def Handle_IFSelect_PacketList_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_PacketList >":
    return _IFSelect.Handle_IFSelect_PacketList_DownCast(t)
Handle_IFSelect_PacketList_DownCast = _IFSelect.Handle_IFSelect_PacketList_DownCast

def Handle_IFSelect_PacketList_IsNull(t: 'opencascade::handle< IFSelect_PacketList > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_PacketList_IsNull(t)
Handle_IFSelect_PacketList_IsNull = _IFSelect.Handle_IFSelect_PacketList_IsNull

def Handle_IFSelect_Selection_Create() -> "opencascade::handle< IFSelect_Selection >":
    return _IFSelect.Handle_IFSelect_Selection_Create()
Handle_IFSelect_Selection_Create = _IFSelect.Handle_IFSelect_Selection_Create

def Handle_IFSelect_Selection_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_Selection >":
    return _IFSelect.Handle_IFSelect_Selection_DownCast(t)
Handle_IFSelect_Selection_DownCast = _IFSelect.Handle_IFSelect_Selection_DownCast

def Handle_IFSelect_Selection_IsNull(t: 'opencascade::handle< IFSelect_Selection > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_Selection_IsNull(t)
Handle_IFSelect_Selection_IsNull = _IFSelect.Handle_IFSelect_Selection_IsNull

def Handle_IFSelect_SessionDumper_Create() -> "opencascade::handle< IFSelect_SessionDumper >":
    return _IFSelect.Handle_IFSelect_SessionDumper_Create()
Handle_IFSelect_SessionDumper_Create = _IFSelect.Handle_IFSelect_SessionDumper_Create

def Handle_IFSelect_SessionDumper_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SessionDumper >":
    return _IFSelect.Handle_IFSelect_SessionDumper_DownCast(t)
Handle_IFSelect_SessionDumper_DownCast = _IFSelect.Handle_IFSelect_SessionDumper_DownCast

def Handle_IFSelect_SessionDumper_IsNull(t: 'opencascade::handle< IFSelect_SessionDumper > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SessionDumper_IsNull(t)
Handle_IFSelect_SessionDumper_IsNull = _IFSelect.Handle_IFSelect_SessionDumper_IsNull

def Handle_IFSelect_ShareOut_Create() -> "opencascade::handle< IFSelect_ShareOut >":
    return _IFSelect.Handle_IFSelect_ShareOut_Create()
Handle_IFSelect_ShareOut_Create = _IFSelect.Handle_IFSelect_ShareOut_Create

def Handle_IFSelect_ShareOut_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_ShareOut >":
    return _IFSelect.Handle_IFSelect_ShareOut_DownCast(t)
Handle_IFSelect_ShareOut_DownCast = _IFSelect.Handle_IFSelect_ShareOut_DownCast

def Handle_IFSelect_ShareOut_IsNull(t: 'opencascade::handle< IFSelect_ShareOut > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_ShareOut_IsNull(t)
Handle_IFSelect_ShareOut_IsNull = _IFSelect.Handle_IFSelect_ShareOut_IsNull

def Handle_IFSelect_Signature_Create() -> "opencascade::handle< IFSelect_Signature >":
    return _IFSelect.Handle_IFSelect_Signature_Create()
Handle_IFSelect_Signature_Create = _IFSelect.Handle_IFSelect_Signature_Create

def Handle_IFSelect_Signature_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_Signature >":
    return _IFSelect.Handle_IFSelect_Signature_DownCast(t)
Handle_IFSelect_Signature_DownCast = _IFSelect.Handle_IFSelect_Signature_DownCast

def Handle_IFSelect_Signature_IsNull(t: 'opencascade::handle< IFSelect_Signature > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_Signature_IsNull(t)
Handle_IFSelect_Signature_IsNull = _IFSelect.Handle_IFSelect_Signature_IsNull

def Handle_IFSelect_SignatureList_Create() -> "opencascade::handle< IFSelect_SignatureList >":
    return _IFSelect.Handle_IFSelect_SignatureList_Create()
Handle_IFSelect_SignatureList_Create = _IFSelect.Handle_IFSelect_SignatureList_Create

def Handle_IFSelect_SignatureList_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SignatureList >":
    return _IFSelect.Handle_IFSelect_SignatureList_DownCast(t)
Handle_IFSelect_SignatureList_DownCast = _IFSelect.Handle_IFSelect_SignatureList_DownCast

def Handle_IFSelect_SignatureList_IsNull(t: 'opencascade::handle< IFSelect_SignatureList > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SignatureList_IsNull(t)
Handle_IFSelect_SignatureList_IsNull = _IFSelect.Handle_IFSelect_SignatureList_IsNull

def Handle_IFSelect_Transformer_Create() -> "opencascade::handle< IFSelect_Transformer >":
    return _IFSelect.Handle_IFSelect_Transformer_Create()
Handle_IFSelect_Transformer_Create = _IFSelect.Handle_IFSelect_Transformer_Create

def Handle_IFSelect_Transformer_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_Transformer >":
    return _IFSelect.Handle_IFSelect_Transformer_DownCast(t)
Handle_IFSelect_Transformer_DownCast = _IFSelect.Handle_IFSelect_Transformer_DownCast

def Handle_IFSelect_Transformer_IsNull(t: 'opencascade::handle< IFSelect_Transformer > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_Transformer_IsNull(t)
Handle_IFSelect_Transformer_IsNull = _IFSelect.Handle_IFSelect_Transformer_IsNull

def Handle_IFSelect_WorkLibrary_Create() -> "opencascade::handle< IFSelect_WorkLibrary >":
    return _IFSelect.Handle_IFSelect_WorkLibrary_Create()
Handle_IFSelect_WorkLibrary_Create = _IFSelect.Handle_IFSelect_WorkLibrary_Create

def Handle_IFSelect_WorkLibrary_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_WorkLibrary >":
    return _IFSelect.Handle_IFSelect_WorkLibrary_DownCast(t)
Handle_IFSelect_WorkLibrary_DownCast = _IFSelect.Handle_IFSelect_WorkLibrary_DownCast

def Handle_IFSelect_WorkLibrary_IsNull(t: 'opencascade::handle< IFSelect_WorkLibrary > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_WorkLibrary_IsNull(t)
Handle_IFSelect_WorkLibrary_IsNull = _IFSelect.Handle_IFSelect_WorkLibrary_IsNull

def Handle_IFSelect_WorkSession_Create() -> "opencascade::handle< IFSelect_WorkSession >":
    return _IFSelect.Handle_IFSelect_WorkSession_Create()
Handle_IFSelect_WorkSession_Create = _IFSelect.Handle_IFSelect_WorkSession_Create

def Handle_IFSelect_WorkSession_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_WorkSession >":
    return _IFSelect.Handle_IFSelect_WorkSession_DownCast(t)
Handle_IFSelect_WorkSession_DownCast = _IFSelect.Handle_IFSelect_WorkSession_DownCast

def Handle_IFSelect_WorkSession_IsNull(t: 'opencascade::handle< IFSelect_WorkSession > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_WorkSession_IsNull(t)
Handle_IFSelect_WorkSession_IsNull = _IFSelect.Handle_IFSelect_WorkSession_IsNull

def Handle_IFSelect_Act_Create() -> "opencascade::handle< IFSelect_Act >":
    return _IFSelect.Handle_IFSelect_Act_Create()
Handle_IFSelect_Act_Create = _IFSelect.Handle_IFSelect_Act_Create

def Handle_IFSelect_Act_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_Act >":
    return _IFSelect.Handle_IFSelect_Act_DownCast(t)
Handle_IFSelect_Act_DownCast = _IFSelect.Handle_IFSelect_Act_DownCast

def Handle_IFSelect_Act_IsNull(t: 'opencascade::handle< IFSelect_Act > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_Act_IsNull(t)
Handle_IFSelect_Act_IsNull = _IFSelect.Handle_IFSelect_Act_IsNull

def Handle_IFSelect_BasicDumper_Create() -> "opencascade::handle< IFSelect_BasicDumper >":
    return _IFSelect.Handle_IFSelect_BasicDumper_Create()
Handle_IFSelect_BasicDumper_Create = _IFSelect.Handle_IFSelect_BasicDumper_Create

def Handle_IFSelect_BasicDumper_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_BasicDumper >":
    return _IFSelect.Handle_IFSelect_BasicDumper_DownCast(t)
Handle_IFSelect_BasicDumper_DownCast = _IFSelect.Handle_IFSelect_BasicDumper_DownCast

def Handle_IFSelect_BasicDumper_IsNull(t: 'opencascade::handle< IFSelect_BasicDumper > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_BasicDumper_IsNull(t)
Handle_IFSelect_BasicDumper_IsNull = _IFSelect.Handle_IFSelect_BasicDumper_IsNull

def Handle_IFSelect_CheckCounter_Create() -> "opencascade::handle< IFSelect_CheckCounter >":
    return _IFSelect.Handle_IFSelect_CheckCounter_Create()
Handle_IFSelect_CheckCounter_Create = _IFSelect.Handle_IFSelect_CheckCounter_Create

def Handle_IFSelect_CheckCounter_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_CheckCounter >":
    return _IFSelect.Handle_IFSelect_CheckCounter_DownCast(t)
Handle_IFSelect_CheckCounter_DownCast = _IFSelect.Handle_IFSelect_CheckCounter_DownCast

def Handle_IFSelect_CheckCounter_IsNull(t: 'opencascade::handle< IFSelect_CheckCounter > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_CheckCounter_IsNull(t)
Handle_IFSelect_CheckCounter_IsNull = _IFSelect.Handle_IFSelect_CheckCounter_IsNull

def Handle_IFSelect_DispGlobal_Create() -> "opencascade::handle< IFSelect_DispGlobal >":
    return _IFSelect.Handle_IFSelect_DispGlobal_Create()
Handle_IFSelect_DispGlobal_Create = _IFSelect.Handle_IFSelect_DispGlobal_Create

def Handle_IFSelect_DispGlobal_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_DispGlobal >":
    return _IFSelect.Handle_IFSelect_DispGlobal_DownCast(t)
Handle_IFSelect_DispGlobal_DownCast = _IFSelect.Handle_IFSelect_DispGlobal_DownCast

def Handle_IFSelect_DispGlobal_IsNull(t: 'opencascade::handle< IFSelect_DispGlobal > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_DispGlobal_IsNull(t)
Handle_IFSelect_DispGlobal_IsNull = _IFSelect.Handle_IFSelect_DispGlobal_IsNull

def Handle_IFSelect_DispPerCount_Create() -> "opencascade::handle< IFSelect_DispPerCount >":
    return _IFSelect.Handle_IFSelect_DispPerCount_Create()
Handle_IFSelect_DispPerCount_Create = _IFSelect.Handle_IFSelect_DispPerCount_Create

def Handle_IFSelect_DispPerCount_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_DispPerCount >":
    return _IFSelect.Handle_IFSelect_DispPerCount_DownCast(t)
Handle_IFSelect_DispPerCount_DownCast = _IFSelect.Handle_IFSelect_DispPerCount_DownCast

def Handle_IFSelect_DispPerCount_IsNull(t: 'opencascade::handle< IFSelect_DispPerCount > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_DispPerCount_IsNull(t)
Handle_IFSelect_DispPerCount_IsNull = _IFSelect.Handle_IFSelect_DispPerCount_IsNull

def Handle_IFSelect_DispPerFiles_Create() -> "opencascade::handle< IFSelect_DispPerFiles >":
    return _IFSelect.Handle_IFSelect_DispPerFiles_Create()
Handle_IFSelect_DispPerFiles_Create = _IFSelect.Handle_IFSelect_DispPerFiles_Create

def Handle_IFSelect_DispPerFiles_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_DispPerFiles >":
    return _IFSelect.Handle_IFSelect_DispPerFiles_DownCast(t)
Handle_IFSelect_DispPerFiles_DownCast = _IFSelect.Handle_IFSelect_DispPerFiles_DownCast

def Handle_IFSelect_DispPerFiles_IsNull(t: 'opencascade::handle< IFSelect_DispPerFiles > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_DispPerFiles_IsNull(t)
Handle_IFSelect_DispPerFiles_IsNull = _IFSelect.Handle_IFSelect_DispPerFiles_IsNull

def Handle_IFSelect_DispPerOne_Create() -> "opencascade::handle< IFSelect_DispPerOne >":
    return _IFSelect.Handle_IFSelect_DispPerOne_Create()
Handle_IFSelect_DispPerOne_Create = _IFSelect.Handle_IFSelect_DispPerOne_Create

def Handle_IFSelect_DispPerOne_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_DispPerOne >":
    return _IFSelect.Handle_IFSelect_DispPerOne_DownCast(t)
Handle_IFSelect_DispPerOne_DownCast = _IFSelect.Handle_IFSelect_DispPerOne_DownCast

def Handle_IFSelect_DispPerOne_IsNull(t: 'opencascade::handle< IFSelect_DispPerOne > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_DispPerOne_IsNull(t)
Handle_IFSelect_DispPerOne_IsNull = _IFSelect.Handle_IFSelect_DispPerOne_IsNull

def Handle_IFSelect_DispPerSignature_Create() -> "opencascade::handle< IFSelect_DispPerSignature >":
    return _IFSelect.Handle_IFSelect_DispPerSignature_Create()
Handle_IFSelect_DispPerSignature_Create = _IFSelect.Handle_IFSelect_DispPerSignature_Create

def Handle_IFSelect_DispPerSignature_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_DispPerSignature >":
    return _IFSelect.Handle_IFSelect_DispPerSignature_DownCast(t)
Handle_IFSelect_DispPerSignature_DownCast = _IFSelect.Handle_IFSelect_DispPerSignature_DownCast

def Handle_IFSelect_DispPerSignature_IsNull(t: 'opencascade::handle< IFSelect_DispPerSignature > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_DispPerSignature_IsNull(t)
Handle_IFSelect_DispPerSignature_IsNull = _IFSelect.Handle_IFSelect_DispPerSignature_IsNull

def Handle_IFSelect_Modifier_Create() -> "opencascade::handle< IFSelect_Modifier >":
    return _IFSelect.Handle_IFSelect_Modifier_Create()
Handle_IFSelect_Modifier_Create = _IFSelect.Handle_IFSelect_Modifier_Create

def Handle_IFSelect_Modifier_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_Modifier >":
    return _IFSelect.Handle_IFSelect_Modifier_DownCast(t)
Handle_IFSelect_Modifier_DownCast = _IFSelect.Handle_IFSelect_Modifier_DownCast

def Handle_IFSelect_Modifier_IsNull(t: 'opencascade::handle< IFSelect_Modifier > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_Modifier_IsNull(t)
Handle_IFSelect_Modifier_IsNull = _IFSelect.Handle_IFSelect_Modifier_IsNull

def Handle_IFSelect_ParamEditor_Create() -> "opencascade::handle< IFSelect_ParamEditor >":
    return _IFSelect.Handle_IFSelect_ParamEditor_Create()
Handle_IFSelect_ParamEditor_Create = _IFSelect.Handle_IFSelect_ParamEditor_Create

def Handle_IFSelect_ParamEditor_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_ParamEditor >":
    return _IFSelect.Handle_IFSelect_ParamEditor_DownCast(t)
Handle_IFSelect_ParamEditor_DownCast = _IFSelect.Handle_IFSelect_ParamEditor_DownCast

def Handle_IFSelect_ParamEditor_IsNull(t: 'opencascade::handle< IFSelect_ParamEditor > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_ParamEditor_IsNull(t)
Handle_IFSelect_ParamEditor_IsNull = _IFSelect.Handle_IFSelect_ParamEditor_IsNull

def Handle_IFSelect_SelectBase_Create() -> "opencascade::handle< IFSelect_SelectBase >":
    return _IFSelect.Handle_IFSelect_SelectBase_Create()
Handle_IFSelect_SelectBase_Create = _IFSelect.Handle_IFSelect_SelectBase_Create

def Handle_IFSelect_SelectBase_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectBase >":
    return _IFSelect.Handle_IFSelect_SelectBase_DownCast(t)
Handle_IFSelect_SelectBase_DownCast = _IFSelect.Handle_IFSelect_SelectBase_DownCast

def Handle_IFSelect_SelectBase_IsNull(t: 'opencascade::handle< IFSelect_SelectBase > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectBase_IsNull(t)
Handle_IFSelect_SelectBase_IsNull = _IFSelect.Handle_IFSelect_SelectBase_IsNull

def Handle_IFSelect_SelectCombine_Create() -> "opencascade::handle< IFSelect_SelectCombine >":
    return _IFSelect.Handle_IFSelect_SelectCombine_Create()
Handle_IFSelect_SelectCombine_Create = _IFSelect.Handle_IFSelect_SelectCombine_Create

def Handle_IFSelect_SelectCombine_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectCombine >":
    return _IFSelect.Handle_IFSelect_SelectCombine_DownCast(t)
Handle_IFSelect_SelectCombine_DownCast = _IFSelect.Handle_IFSelect_SelectCombine_DownCast

def Handle_IFSelect_SelectCombine_IsNull(t: 'opencascade::handle< IFSelect_SelectCombine > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectCombine_IsNull(t)
Handle_IFSelect_SelectCombine_IsNull = _IFSelect.Handle_IFSelect_SelectCombine_IsNull

def Handle_IFSelect_SelectControl_Create() -> "opencascade::handle< IFSelect_SelectControl >":
    return _IFSelect.Handle_IFSelect_SelectControl_Create()
Handle_IFSelect_SelectControl_Create = _IFSelect.Handle_IFSelect_SelectControl_Create

def Handle_IFSelect_SelectControl_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectControl >":
    return _IFSelect.Handle_IFSelect_SelectControl_DownCast(t)
Handle_IFSelect_SelectControl_DownCast = _IFSelect.Handle_IFSelect_SelectControl_DownCast

def Handle_IFSelect_SelectControl_IsNull(t: 'opencascade::handle< IFSelect_SelectControl > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectControl_IsNull(t)
Handle_IFSelect_SelectControl_IsNull = _IFSelect.Handle_IFSelect_SelectControl_IsNull

def Handle_IFSelect_SelectDeduct_Create() -> "opencascade::handle< IFSelect_SelectDeduct >":
    return _IFSelect.Handle_IFSelect_SelectDeduct_Create()
Handle_IFSelect_SelectDeduct_Create = _IFSelect.Handle_IFSelect_SelectDeduct_Create

def Handle_IFSelect_SelectDeduct_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectDeduct >":
    return _IFSelect.Handle_IFSelect_SelectDeduct_DownCast(t)
Handle_IFSelect_SelectDeduct_DownCast = _IFSelect.Handle_IFSelect_SelectDeduct_DownCast

def Handle_IFSelect_SelectDeduct_IsNull(t: 'opencascade::handle< IFSelect_SelectDeduct > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectDeduct_IsNull(t)
Handle_IFSelect_SelectDeduct_IsNull = _IFSelect.Handle_IFSelect_SelectDeduct_IsNull

def Handle_IFSelect_SessionPilot_Create() -> "opencascade::handle< IFSelect_SessionPilot >":
    return _IFSelect.Handle_IFSelect_SessionPilot_Create()
Handle_IFSelect_SessionPilot_Create = _IFSelect.Handle_IFSelect_SessionPilot_Create

def Handle_IFSelect_SessionPilot_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SessionPilot >":
    return _IFSelect.Handle_IFSelect_SessionPilot_DownCast(t)
Handle_IFSelect_SessionPilot_DownCast = _IFSelect.Handle_IFSelect_SessionPilot_DownCast

def Handle_IFSelect_SessionPilot_IsNull(t: 'opencascade::handle< IFSelect_SessionPilot > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SessionPilot_IsNull(t)
Handle_IFSelect_SessionPilot_IsNull = _IFSelect.Handle_IFSelect_SessionPilot_IsNull

def Handle_IFSelect_SignCategory_Create() -> "opencascade::handle< IFSelect_SignCategory >":
    return _IFSelect.Handle_IFSelect_SignCategory_Create()
Handle_IFSelect_SignCategory_Create = _IFSelect.Handle_IFSelect_SignCategory_Create

def Handle_IFSelect_SignCategory_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SignCategory >":
    return _IFSelect.Handle_IFSelect_SignCategory_DownCast(t)
Handle_IFSelect_SignCategory_DownCast = _IFSelect.Handle_IFSelect_SignCategory_DownCast

def Handle_IFSelect_SignCategory_IsNull(t: 'opencascade::handle< IFSelect_SignCategory > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SignCategory_IsNull(t)
Handle_IFSelect_SignCategory_IsNull = _IFSelect.Handle_IFSelect_SignCategory_IsNull

def Handle_IFSelect_SignCounter_Create() -> "opencascade::handle< IFSelect_SignCounter >":
    return _IFSelect.Handle_IFSelect_SignCounter_Create()
Handle_IFSelect_SignCounter_Create = _IFSelect.Handle_IFSelect_SignCounter_Create

def Handle_IFSelect_SignCounter_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SignCounter >":
    return _IFSelect.Handle_IFSelect_SignCounter_DownCast(t)
Handle_IFSelect_SignCounter_DownCast = _IFSelect.Handle_IFSelect_SignCounter_DownCast

def Handle_IFSelect_SignCounter_IsNull(t: 'opencascade::handle< IFSelect_SignCounter > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SignCounter_IsNull(t)
Handle_IFSelect_SignCounter_IsNull = _IFSelect.Handle_IFSelect_SignCounter_IsNull

def Handle_IFSelect_SignMultiple_Create() -> "opencascade::handle< IFSelect_SignMultiple >":
    return _IFSelect.Handle_IFSelect_SignMultiple_Create()
Handle_IFSelect_SignMultiple_Create = _IFSelect.Handle_IFSelect_SignMultiple_Create

def Handle_IFSelect_SignMultiple_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SignMultiple >":
    return _IFSelect.Handle_IFSelect_SignMultiple_DownCast(t)
Handle_IFSelect_SignMultiple_DownCast = _IFSelect.Handle_IFSelect_SignMultiple_DownCast

def Handle_IFSelect_SignMultiple_IsNull(t: 'opencascade::handle< IFSelect_SignMultiple > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SignMultiple_IsNull(t)
Handle_IFSelect_SignMultiple_IsNull = _IFSelect.Handle_IFSelect_SignMultiple_IsNull

def Handle_IFSelect_SignType_Create() -> "opencascade::handle< IFSelect_SignType >":
    return _IFSelect.Handle_IFSelect_SignType_Create()
Handle_IFSelect_SignType_Create = _IFSelect.Handle_IFSelect_SignType_Create

def Handle_IFSelect_SignType_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SignType >":
    return _IFSelect.Handle_IFSelect_SignType_DownCast(t)
Handle_IFSelect_SignType_DownCast = _IFSelect.Handle_IFSelect_SignType_DownCast

def Handle_IFSelect_SignType_IsNull(t: 'opencascade::handle< IFSelect_SignType > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SignType_IsNull(t)
Handle_IFSelect_SignType_IsNull = _IFSelect.Handle_IFSelect_SignType_IsNull

def Handle_IFSelect_SignValidity_Create() -> "opencascade::handle< IFSelect_SignValidity >":
    return _IFSelect.Handle_IFSelect_SignValidity_Create()
Handle_IFSelect_SignValidity_Create = _IFSelect.Handle_IFSelect_SignValidity_Create

def Handle_IFSelect_SignValidity_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SignValidity >":
    return _IFSelect.Handle_IFSelect_SignValidity_DownCast(t)
Handle_IFSelect_SignValidity_DownCast = _IFSelect.Handle_IFSelect_SignValidity_DownCast

def Handle_IFSelect_SignValidity_IsNull(t: 'opencascade::handle< IFSelect_SignValidity > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SignValidity_IsNull(t)
Handle_IFSelect_SignValidity_IsNull = _IFSelect.Handle_IFSelect_SignValidity_IsNull

def Handle_IFSelect_TransformStandard_Create() -> "opencascade::handle< IFSelect_TransformStandard >":
    return _IFSelect.Handle_IFSelect_TransformStandard_Create()
Handle_IFSelect_TransformStandard_Create = _IFSelect.Handle_IFSelect_TransformStandard_Create

def Handle_IFSelect_TransformStandard_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_TransformStandard >":
    return _IFSelect.Handle_IFSelect_TransformStandard_DownCast(t)
Handle_IFSelect_TransformStandard_DownCast = _IFSelect.Handle_IFSelect_TransformStandard_DownCast

def Handle_IFSelect_TransformStandard_IsNull(t: 'opencascade::handle< IFSelect_TransformStandard > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_TransformStandard_IsNull(t)
Handle_IFSelect_TransformStandard_IsNull = _IFSelect.Handle_IFSelect_TransformStandard_IsNull

def Handle_IFSelect_GraphCounter_Create() -> "opencascade::handle< IFSelect_GraphCounter >":
    return _IFSelect.Handle_IFSelect_GraphCounter_Create()
Handle_IFSelect_GraphCounter_Create = _IFSelect.Handle_IFSelect_GraphCounter_Create

def Handle_IFSelect_GraphCounter_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_GraphCounter >":
    return _IFSelect.Handle_IFSelect_GraphCounter_DownCast(t)
Handle_IFSelect_GraphCounter_DownCast = _IFSelect.Handle_IFSelect_GraphCounter_DownCast

def Handle_IFSelect_GraphCounter_IsNull(t: 'opencascade::handle< IFSelect_GraphCounter > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_GraphCounter_IsNull(t)
Handle_IFSelect_GraphCounter_IsNull = _IFSelect.Handle_IFSelect_GraphCounter_IsNull

def Handle_IFSelect_ModifEditForm_Create() -> "opencascade::handle< IFSelect_ModifEditForm >":
    return _IFSelect.Handle_IFSelect_ModifEditForm_Create()
Handle_IFSelect_ModifEditForm_Create = _IFSelect.Handle_IFSelect_ModifEditForm_Create

def Handle_IFSelect_ModifEditForm_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_ModifEditForm >":
    return _IFSelect.Handle_IFSelect_ModifEditForm_DownCast(t)
Handle_IFSelect_ModifEditForm_DownCast = _IFSelect.Handle_IFSelect_ModifEditForm_DownCast

def Handle_IFSelect_ModifEditForm_IsNull(t: 'opencascade::handle< IFSelect_ModifEditForm > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_ModifEditForm_IsNull(t)
Handle_IFSelect_ModifEditForm_IsNull = _IFSelect.Handle_IFSelect_ModifEditForm_IsNull

def Handle_IFSelect_ModifReorder_Create() -> "opencascade::handle< IFSelect_ModifReorder >":
    return _IFSelect.Handle_IFSelect_ModifReorder_Create()
Handle_IFSelect_ModifReorder_Create = _IFSelect.Handle_IFSelect_ModifReorder_Create

def Handle_IFSelect_ModifReorder_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_ModifReorder >":
    return _IFSelect.Handle_IFSelect_ModifReorder_DownCast(t)
Handle_IFSelect_ModifReorder_DownCast = _IFSelect.Handle_IFSelect_ModifReorder_DownCast

def Handle_IFSelect_ModifReorder_IsNull(t: 'opencascade::handle< IFSelect_ModifReorder > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_ModifReorder_IsNull(t)
Handle_IFSelect_ModifReorder_IsNull = _IFSelect.Handle_IFSelect_ModifReorder_IsNull

def Handle_IFSelect_SelectAnyList_Create() -> "opencascade::handle< IFSelect_SelectAnyList >":
    return _IFSelect.Handle_IFSelect_SelectAnyList_Create()
Handle_IFSelect_SelectAnyList_Create = _IFSelect.Handle_IFSelect_SelectAnyList_Create

def Handle_IFSelect_SelectAnyList_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectAnyList >":
    return _IFSelect.Handle_IFSelect_SelectAnyList_DownCast(t)
Handle_IFSelect_SelectAnyList_DownCast = _IFSelect.Handle_IFSelect_SelectAnyList_DownCast

def Handle_IFSelect_SelectAnyList_IsNull(t: 'opencascade::handle< IFSelect_SelectAnyList > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectAnyList_IsNull(t)
Handle_IFSelect_SelectAnyList_IsNull = _IFSelect.Handle_IFSelect_SelectAnyList_IsNull

def Handle_IFSelect_SelectDiff_Create() -> "opencascade::handle< IFSelect_SelectDiff >":
    return _IFSelect.Handle_IFSelect_SelectDiff_Create()
Handle_IFSelect_SelectDiff_Create = _IFSelect.Handle_IFSelect_SelectDiff_Create

def Handle_IFSelect_SelectDiff_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectDiff >":
    return _IFSelect.Handle_IFSelect_SelectDiff_DownCast(t)
Handle_IFSelect_SelectDiff_DownCast = _IFSelect.Handle_IFSelect_SelectDiff_DownCast

def Handle_IFSelect_SelectDiff_IsNull(t: 'opencascade::handle< IFSelect_SelectDiff > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectDiff_IsNull(t)
Handle_IFSelect_SelectDiff_IsNull = _IFSelect.Handle_IFSelect_SelectDiff_IsNull

def Handle_IFSelect_SelectEntityNumber_Create() -> "opencascade::handle< IFSelect_SelectEntityNumber >":
    return _IFSelect.Handle_IFSelect_SelectEntityNumber_Create()
Handle_IFSelect_SelectEntityNumber_Create = _IFSelect.Handle_IFSelect_SelectEntityNumber_Create

def Handle_IFSelect_SelectEntityNumber_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectEntityNumber >":
    return _IFSelect.Handle_IFSelect_SelectEntityNumber_DownCast(t)
Handle_IFSelect_SelectEntityNumber_DownCast = _IFSelect.Handle_IFSelect_SelectEntityNumber_DownCast

def Handle_IFSelect_SelectEntityNumber_IsNull(t: 'opencascade::handle< IFSelect_SelectEntityNumber > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectEntityNumber_IsNull(t)
Handle_IFSelect_SelectEntityNumber_IsNull = _IFSelect.Handle_IFSelect_SelectEntityNumber_IsNull

def Handle_IFSelect_SelectExplore_Create() -> "opencascade::handle< IFSelect_SelectExplore >":
    return _IFSelect.Handle_IFSelect_SelectExplore_Create()
Handle_IFSelect_SelectExplore_Create = _IFSelect.Handle_IFSelect_SelectExplore_Create

def Handle_IFSelect_SelectExplore_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectExplore >":
    return _IFSelect.Handle_IFSelect_SelectExplore_DownCast(t)
Handle_IFSelect_SelectExplore_DownCast = _IFSelect.Handle_IFSelect_SelectExplore_DownCast

def Handle_IFSelect_SelectExplore_IsNull(t: 'opencascade::handle< IFSelect_SelectExplore > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectExplore_IsNull(t)
Handle_IFSelect_SelectExplore_IsNull = _IFSelect.Handle_IFSelect_SelectExplore_IsNull

def Handle_IFSelect_SelectExtract_Create() -> "opencascade::handle< IFSelect_SelectExtract >":
    return _IFSelect.Handle_IFSelect_SelectExtract_Create()
Handle_IFSelect_SelectExtract_Create = _IFSelect.Handle_IFSelect_SelectExtract_Create

def Handle_IFSelect_SelectExtract_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectExtract >":
    return _IFSelect.Handle_IFSelect_SelectExtract_DownCast(t)
Handle_IFSelect_SelectExtract_DownCast = _IFSelect.Handle_IFSelect_SelectExtract_DownCast

def Handle_IFSelect_SelectExtract_IsNull(t: 'opencascade::handle< IFSelect_SelectExtract > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectExtract_IsNull(t)
Handle_IFSelect_SelectExtract_IsNull = _IFSelect.Handle_IFSelect_SelectExtract_IsNull

def Handle_IFSelect_SelectIntersection_Create() -> "opencascade::handle< IFSelect_SelectIntersection >":
    return _IFSelect.Handle_IFSelect_SelectIntersection_Create()
Handle_IFSelect_SelectIntersection_Create = _IFSelect.Handle_IFSelect_SelectIntersection_Create

def Handle_IFSelect_SelectIntersection_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectIntersection >":
    return _IFSelect.Handle_IFSelect_SelectIntersection_DownCast(t)
Handle_IFSelect_SelectIntersection_DownCast = _IFSelect.Handle_IFSelect_SelectIntersection_DownCast

def Handle_IFSelect_SelectIntersection_IsNull(t: 'opencascade::handle< IFSelect_SelectIntersection > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectIntersection_IsNull(t)
Handle_IFSelect_SelectIntersection_IsNull = _IFSelect.Handle_IFSelect_SelectIntersection_IsNull

def Handle_IFSelect_SelectModelEntities_Create() -> "opencascade::handle< IFSelect_SelectModelEntities >":
    return _IFSelect.Handle_IFSelect_SelectModelEntities_Create()
Handle_IFSelect_SelectModelEntities_Create = _IFSelect.Handle_IFSelect_SelectModelEntities_Create

def Handle_IFSelect_SelectModelEntities_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectModelEntities >":
    return _IFSelect.Handle_IFSelect_SelectModelEntities_DownCast(t)
Handle_IFSelect_SelectModelEntities_DownCast = _IFSelect.Handle_IFSelect_SelectModelEntities_DownCast

def Handle_IFSelect_SelectModelEntities_IsNull(t: 'opencascade::handle< IFSelect_SelectModelEntities > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectModelEntities_IsNull(t)
Handle_IFSelect_SelectModelEntities_IsNull = _IFSelect.Handle_IFSelect_SelectModelEntities_IsNull

def Handle_IFSelect_SelectModelRoots_Create() -> "opencascade::handle< IFSelect_SelectModelRoots >":
    return _IFSelect.Handle_IFSelect_SelectModelRoots_Create()
Handle_IFSelect_SelectModelRoots_Create = _IFSelect.Handle_IFSelect_SelectModelRoots_Create

def Handle_IFSelect_SelectModelRoots_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectModelRoots >":
    return _IFSelect.Handle_IFSelect_SelectModelRoots_DownCast(t)
Handle_IFSelect_SelectModelRoots_DownCast = _IFSelect.Handle_IFSelect_SelectModelRoots_DownCast

def Handle_IFSelect_SelectModelRoots_IsNull(t: 'opencascade::handle< IFSelect_SelectModelRoots > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectModelRoots_IsNull(t)
Handle_IFSelect_SelectModelRoots_IsNull = _IFSelect.Handle_IFSelect_SelectModelRoots_IsNull

def Handle_IFSelect_SelectPointed_Create() -> "opencascade::handle< IFSelect_SelectPointed >":
    return _IFSelect.Handle_IFSelect_SelectPointed_Create()
Handle_IFSelect_SelectPointed_Create = _IFSelect.Handle_IFSelect_SelectPointed_Create

def Handle_IFSelect_SelectPointed_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectPointed >":
    return _IFSelect.Handle_IFSelect_SelectPointed_DownCast(t)
Handle_IFSelect_SelectPointed_DownCast = _IFSelect.Handle_IFSelect_SelectPointed_DownCast

def Handle_IFSelect_SelectPointed_IsNull(t: 'opencascade::handle< IFSelect_SelectPointed > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectPointed_IsNull(t)
Handle_IFSelect_SelectPointed_IsNull = _IFSelect.Handle_IFSelect_SelectPointed_IsNull

def Handle_IFSelect_SelectShared_Create() -> "opencascade::handle< IFSelect_SelectShared >":
    return _IFSelect.Handle_IFSelect_SelectShared_Create()
Handle_IFSelect_SelectShared_Create = _IFSelect.Handle_IFSelect_SelectShared_Create

def Handle_IFSelect_SelectShared_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectShared >":
    return _IFSelect.Handle_IFSelect_SelectShared_DownCast(t)
Handle_IFSelect_SelectShared_DownCast = _IFSelect.Handle_IFSelect_SelectShared_DownCast

def Handle_IFSelect_SelectShared_IsNull(t: 'opencascade::handle< IFSelect_SelectShared > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectShared_IsNull(t)
Handle_IFSelect_SelectShared_IsNull = _IFSelect.Handle_IFSelect_SelectShared_IsNull

def Handle_IFSelect_SelectSharing_Create() -> "opencascade::handle< IFSelect_SelectSharing >":
    return _IFSelect.Handle_IFSelect_SelectSharing_Create()
Handle_IFSelect_SelectSharing_Create = _IFSelect.Handle_IFSelect_SelectSharing_Create

def Handle_IFSelect_SelectSharing_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectSharing >":
    return _IFSelect.Handle_IFSelect_SelectSharing_DownCast(t)
Handle_IFSelect_SelectSharing_DownCast = _IFSelect.Handle_IFSelect_SelectSharing_DownCast

def Handle_IFSelect_SelectSharing_IsNull(t: 'opencascade::handle< IFSelect_SelectSharing > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectSharing_IsNull(t)
Handle_IFSelect_SelectSharing_IsNull = _IFSelect.Handle_IFSelect_SelectSharing_IsNull

def Handle_IFSelect_SelectSuite_Create() -> "opencascade::handle< IFSelect_SelectSuite >":
    return _IFSelect.Handle_IFSelect_SelectSuite_Create()
Handle_IFSelect_SelectSuite_Create = _IFSelect.Handle_IFSelect_SelectSuite_Create

def Handle_IFSelect_SelectSuite_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectSuite >":
    return _IFSelect.Handle_IFSelect_SelectSuite_DownCast(t)
Handle_IFSelect_SelectSuite_DownCast = _IFSelect.Handle_IFSelect_SelectSuite_DownCast

def Handle_IFSelect_SelectSuite_IsNull(t: 'opencascade::handle< IFSelect_SelectSuite > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectSuite_IsNull(t)
Handle_IFSelect_SelectSuite_IsNull = _IFSelect.Handle_IFSelect_SelectSuite_IsNull

def Handle_IFSelect_SelectUnion_Create() -> "opencascade::handle< IFSelect_SelectUnion >":
    return _IFSelect.Handle_IFSelect_SelectUnion_Create()
Handle_IFSelect_SelectUnion_Create = _IFSelect.Handle_IFSelect_SelectUnion_Create

def Handle_IFSelect_SelectUnion_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectUnion >":
    return _IFSelect.Handle_IFSelect_SelectUnion_DownCast(t)
Handle_IFSelect_SelectUnion_DownCast = _IFSelect.Handle_IFSelect_SelectUnion_DownCast

def Handle_IFSelect_SelectUnion_IsNull(t: 'opencascade::handle< IFSelect_SelectUnion > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectUnion_IsNull(t)
Handle_IFSelect_SelectUnion_IsNull = _IFSelect.Handle_IFSelect_SelectUnion_IsNull

def Handle_IFSelect_SignAncestor_Create() -> "opencascade::handle< IFSelect_SignAncestor >":
    return _IFSelect.Handle_IFSelect_SignAncestor_Create()
Handle_IFSelect_SignAncestor_Create = _IFSelect.Handle_IFSelect_SignAncestor_Create

def Handle_IFSelect_SignAncestor_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SignAncestor >":
    return _IFSelect.Handle_IFSelect_SignAncestor_DownCast(t)
Handle_IFSelect_SignAncestor_DownCast = _IFSelect.Handle_IFSelect_SignAncestor_DownCast

def Handle_IFSelect_SignAncestor_IsNull(t: 'opencascade::handle< IFSelect_SignAncestor > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SignAncestor_IsNull(t)
Handle_IFSelect_SignAncestor_IsNull = _IFSelect.Handle_IFSelect_SignAncestor_IsNull

def Handle_IFSelect_SelectAnyType_Create() -> "opencascade::handle< IFSelect_SelectAnyType >":
    return _IFSelect.Handle_IFSelect_SelectAnyType_Create()
Handle_IFSelect_SelectAnyType_Create = _IFSelect.Handle_IFSelect_SelectAnyType_Create

def Handle_IFSelect_SelectAnyType_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectAnyType >":
    return _IFSelect.Handle_IFSelect_SelectAnyType_DownCast(t)
Handle_IFSelect_SelectAnyType_DownCast = _IFSelect.Handle_IFSelect_SelectAnyType_DownCast

def Handle_IFSelect_SelectAnyType_IsNull(t: 'opencascade::handle< IFSelect_SelectAnyType > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectAnyType_IsNull(t)
Handle_IFSelect_SelectAnyType_IsNull = _IFSelect.Handle_IFSelect_SelectAnyType_IsNull

def Handle_IFSelect_SelectErrorEntities_Create() -> "opencascade::handle< IFSelect_SelectErrorEntities >":
    return _IFSelect.Handle_IFSelect_SelectErrorEntities_Create()
Handle_IFSelect_SelectErrorEntities_Create = _IFSelect.Handle_IFSelect_SelectErrorEntities_Create

def Handle_IFSelect_SelectErrorEntities_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectErrorEntities >":
    return _IFSelect.Handle_IFSelect_SelectErrorEntities_DownCast(t)
Handle_IFSelect_SelectErrorEntities_DownCast = _IFSelect.Handle_IFSelect_SelectErrorEntities_DownCast

def Handle_IFSelect_SelectErrorEntities_IsNull(t: 'opencascade::handle< IFSelect_SelectErrorEntities > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectErrorEntities_IsNull(t)
Handle_IFSelect_SelectErrorEntities_IsNull = _IFSelect.Handle_IFSelect_SelectErrorEntities_IsNull

def Handle_IFSelect_SelectFlag_Create() -> "opencascade::handle< IFSelect_SelectFlag >":
    return _IFSelect.Handle_IFSelect_SelectFlag_Create()
Handle_IFSelect_SelectFlag_Create = _IFSelect.Handle_IFSelect_SelectFlag_Create

def Handle_IFSelect_SelectFlag_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectFlag >":
    return _IFSelect.Handle_IFSelect_SelectFlag_DownCast(t)
Handle_IFSelect_SelectFlag_DownCast = _IFSelect.Handle_IFSelect_SelectFlag_DownCast

def Handle_IFSelect_SelectFlag_IsNull(t: 'opencascade::handle< IFSelect_SelectFlag > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectFlag_IsNull(t)
Handle_IFSelect_SelectFlag_IsNull = _IFSelect.Handle_IFSelect_SelectFlag_IsNull

def Handle_IFSelect_SelectInList_Create() -> "opencascade::handle< IFSelect_SelectInList >":
    return _IFSelect.Handle_IFSelect_SelectInList_Create()
Handle_IFSelect_SelectInList_Create = _IFSelect.Handle_IFSelect_SelectInList_Create

def Handle_IFSelect_SelectInList_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectInList >":
    return _IFSelect.Handle_IFSelect_SelectInList_DownCast(t)
Handle_IFSelect_SelectInList_DownCast = _IFSelect.Handle_IFSelect_SelectInList_DownCast

def Handle_IFSelect_SelectInList_IsNull(t: 'opencascade::handle< IFSelect_SelectInList > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectInList_IsNull(t)
Handle_IFSelect_SelectInList_IsNull = _IFSelect.Handle_IFSelect_SelectInList_IsNull

def Handle_IFSelect_SelectRange_Create() -> "opencascade::handle< IFSelect_SelectRange >":
    return _IFSelect.Handle_IFSelect_SelectRange_Create()
Handle_IFSelect_SelectRange_Create = _IFSelect.Handle_IFSelect_SelectRange_Create

def Handle_IFSelect_SelectRange_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectRange >":
    return _IFSelect.Handle_IFSelect_SelectRange_DownCast(t)
Handle_IFSelect_SelectRange_DownCast = _IFSelect.Handle_IFSelect_SelectRange_DownCast

def Handle_IFSelect_SelectRange_IsNull(t: 'opencascade::handle< IFSelect_SelectRange > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectRange_IsNull(t)
Handle_IFSelect_SelectRange_IsNull = _IFSelect.Handle_IFSelect_SelectRange_IsNull

def Handle_IFSelect_SelectRootComps_Create() -> "opencascade::handle< IFSelect_SelectRootComps >":
    return _IFSelect.Handle_IFSelect_SelectRootComps_Create()
Handle_IFSelect_SelectRootComps_Create = _IFSelect.Handle_IFSelect_SelectRootComps_Create

def Handle_IFSelect_SelectRootComps_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectRootComps >":
    return _IFSelect.Handle_IFSelect_SelectRootComps_DownCast(t)
Handle_IFSelect_SelectRootComps_DownCast = _IFSelect.Handle_IFSelect_SelectRootComps_DownCast

def Handle_IFSelect_SelectRootComps_IsNull(t: 'opencascade::handle< IFSelect_SelectRootComps > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectRootComps_IsNull(t)
Handle_IFSelect_SelectRootComps_IsNull = _IFSelect.Handle_IFSelect_SelectRootComps_IsNull

def Handle_IFSelect_SelectRoots_Create() -> "opencascade::handle< IFSelect_SelectRoots >":
    return _IFSelect.Handle_IFSelect_SelectRoots_Create()
Handle_IFSelect_SelectRoots_Create = _IFSelect.Handle_IFSelect_SelectRoots_Create

def Handle_IFSelect_SelectRoots_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectRoots >":
    return _IFSelect.Handle_IFSelect_SelectRoots_DownCast(t)
Handle_IFSelect_SelectRoots_DownCast = _IFSelect.Handle_IFSelect_SelectRoots_DownCast

def Handle_IFSelect_SelectRoots_IsNull(t: 'opencascade::handle< IFSelect_SelectRoots > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectRoots_IsNull(t)
Handle_IFSelect_SelectRoots_IsNull = _IFSelect.Handle_IFSelect_SelectRoots_IsNull

def Handle_IFSelect_SelectSent_Create() -> "opencascade::handle< IFSelect_SelectSent >":
    return _IFSelect.Handle_IFSelect_SelectSent_Create()
Handle_IFSelect_SelectSent_Create = _IFSelect.Handle_IFSelect_SelectSent_Create

def Handle_IFSelect_SelectSent_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectSent >":
    return _IFSelect.Handle_IFSelect_SelectSent_DownCast(t)
Handle_IFSelect_SelectSent_DownCast = _IFSelect.Handle_IFSelect_SelectSent_DownCast

def Handle_IFSelect_SelectSent_IsNull(t: 'opencascade::handle< IFSelect_SelectSent > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectSent_IsNull(t)
Handle_IFSelect_SelectSent_IsNull = _IFSelect.Handle_IFSelect_SelectSent_IsNull

def Handle_IFSelect_SelectSignature_Create() -> "opencascade::handle< IFSelect_SelectSignature >":
    return _IFSelect.Handle_IFSelect_SelectSignature_Create()
Handle_IFSelect_SelectSignature_Create = _IFSelect.Handle_IFSelect_SelectSignature_Create

def Handle_IFSelect_SelectSignature_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectSignature >":
    return _IFSelect.Handle_IFSelect_SelectSignature_DownCast(t)
Handle_IFSelect_SelectSignature_DownCast = _IFSelect.Handle_IFSelect_SelectSignature_DownCast

def Handle_IFSelect_SelectSignature_IsNull(t: 'opencascade::handle< IFSelect_SelectSignature > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectSignature_IsNull(t)
Handle_IFSelect_SelectSignature_IsNull = _IFSelect.Handle_IFSelect_SelectSignature_IsNull

def Handle_IFSelect_SelectSignedShared_Create() -> "opencascade::handle< IFSelect_SelectSignedShared >":
    return _IFSelect.Handle_IFSelect_SelectSignedShared_Create()
Handle_IFSelect_SelectSignedShared_Create = _IFSelect.Handle_IFSelect_SelectSignedShared_Create

def Handle_IFSelect_SelectSignedShared_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectSignedShared >":
    return _IFSelect.Handle_IFSelect_SelectSignedShared_DownCast(t)
Handle_IFSelect_SelectSignedShared_DownCast = _IFSelect.Handle_IFSelect_SelectSignedShared_DownCast

def Handle_IFSelect_SelectSignedShared_IsNull(t: 'opencascade::handle< IFSelect_SelectSignedShared > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectSignedShared_IsNull(t)
Handle_IFSelect_SelectSignedShared_IsNull = _IFSelect.Handle_IFSelect_SelectSignedShared_IsNull

def Handle_IFSelect_SelectSignedSharing_Create() -> "opencascade::handle< IFSelect_SelectSignedSharing >":
    return _IFSelect.Handle_IFSelect_SelectSignedSharing_Create()
Handle_IFSelect_SelectSignedSharing_Create = _IFSelect.Handle_IFSelect_SelectSignedSharing_Create

def Handle_IFSelect_SelectSignedSharing_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectSignedSharing >":
    return _IFSelect.Handle_IFSelect_SelectSignedSharing_DownCast(t)
Handle_IFSelect_SelectSignedSharing_DownCast = _IFSelect.Handle_IFSelect_SelectSignedSharing_DownCast

def Handle_IFSelect_SelectSignedSharing_IsNull(t: 'opencascade::handle< IFSelect_SelectSignedSharing > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectSignedSharing_IsNull(t)
Handle_IFSelect_SelectSignedSharing_IsNull = _IFSelect.Handle_IFSelect_SelectSignedSharing_IsNull

def Handle_IFSelect_SelectUnknownEntities_Create() -> "opencascade::handle< IFSelect_SelectUnknownEntities >":
    return _IFSelect.Handle_IFSelect_SelectUnknownEntities_Create()
Handle_IFSelect_SelectUnknownEntities_Create = _IFSelect.Handle_IFSelect_SelectUnknownEntities_Create

def Handle_IFSelect_SelectUnknownEntities_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectUnknownEntities >":
    return _IFSelect.Handle_IFSelect_SelectUnknownEntities_DownCast(t)
Handle_IFSelect_SelectUnknownEntities_DownCast = _IFSelect.Handle_IFSelect_SelectUnknownEntities_DownCast

def Handle_IFSelect_SelectUnknownEntities_IsNull(t: 'opencascade::handle< IFSelect_SelectUnknownEntities > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectUnknownEntities_IsNull(t)
Handle_IFSelect_SelectUnknownEntities_IsNull = _IFSelect.Handle_IFSelect_SelectUnknownEntities_IsNull

def Handle_IFSelect_SelectIncorrectEntities_Create() -> "opencascade::handle< IFSelect_SelectIncorrectEntities >":
    return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_Create()
Handle_IFSelect_SelectIncorrectEntities_Create = _IFSelect.Handle_IFSelect_SelectIncorrectEntities_Create

def Handle_IFSelect_SelectIncorrectEntities_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectIncorrectEntities >":
    return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_DownCast(t)
Handle_IFSelect_SelectIncorrectEntities_DownCast = _IFSelect.Handle_IFSelect_SelectIncorrectEntities_DownCast

def Handle_IFSelect_SelectIncorrectEntities_IsNull(t: 'opencascade::handle< IFSelect_SelectIncorrectEntities > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectIncorrectEntities_IsNull(t)
Handle_IFSelect_SelectIncorrectEntities_IsNull = _IFSelect.Handle_IFSelect_SelectIncorrectEntities_IsNull

def Handle_IFSelect_SelectType_Create() -> "opencascade::handle< IFSelect_SelectType >":
    return _IFSelect.Handle_IFSelect_SelectType_Create()
Handle_IFSelect_SelectType_Create = _IFSelect.Handle_IFSelect_SelectType_Create

def Handle_IFSelect_SelectType_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_SelectType >":
    return _IFSelect.Handle_IFSelect_SelectType_DownCast(t)
Handle_IFSelect_SelectType_DownCast = _IFSelect.Handle_IFSelect_SelectType_DownCast

def Handle_IFSelect_SelectType_IsNull(t: 'opencascade::handle< IFSelect_SelectType > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_SelectType_IsNull(t)
Handle_IFSelect_SelectType_IsNull = _IFSelect.Handle_IFSelect_SelectType_IsNull

def Handle_IFSelect_HSeqOfSelection_Create() -> "opencascade::handle< IFSelect_HSeqOfSelection >":
    return _IFSelect.Handle_IFSelect_HSeqOfSelection_Create()
Handle_IFSelect_HSeqOfSelection_Create = _IFSelect.Handle_IFSelect_HSeqOfSelection_Create

def Handle_IFSelect_HSeqOfSelection_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IFSelect_HSeqOfSelection >":
    return _IFSelect.Handle_IFSelect_HSeqOfSelection_DownCast(t)
Handle_IFSelect_HSeqOfSelection_DownCast = _IFSelect.Handle_IFSelect_HSeqOfSelection_DownCast

def Handle_IFSelect_HSeqOfSelection_IsNull(t: 'opencascade::handle< IFSelect_HSeqOfSelection > const &') -> "bool":
    return _IFSelect.Handle_IFSelect_HSeqOfSelection_IsNull(t)
Handle_IFSelect_HSeqOfSelection_IsNull = _IFSelect.Handle_IFSelect_HSeqOfSelection_IsNull
class IFSelect_SequenceOfAppliedModifiers(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SequenceOfAppliedModifiers, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SequenceOfAppliedModifiers, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Sequence< opencascade::handle< IFSelect_AppliedModifiers > >::iterator":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_begin(self)

    def end(self) -> "NCollection_Sequence< opencascade::handle< IFSelect_AppliedModifiers > >::iterator":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_end(self)

    def cbegin(self) -> "NCollection_Sequence< opencascade::handle< IFSelect_AppliedModifiers > >::const_iterator":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_cbegin(self)

    def cend(self) -> "NCollection_Sequence< opencascade::handle< IFSelect_AppliedModifiers > >::const_iterator":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_cend(self)

    def __init__(self, *args):
        this = _IFSelect.new_IFSelect_SequenceOfAppliedModifiers(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self) -> "Standard_Integer":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_Size(self)

    def Length(self) -> "Standard_Integer":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_Length(self)

    def Lower(self) -> "Standard_Integer":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_Upper(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_IsEmpty(self)

    def Reverse(self) -> "void":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_Reverse(self)

    def Exchange(self, I: 'Standard_Integer const', J: 'Standard_Integer const') -> "void":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_Exchange(self, I, J)
    if _newclass:
        delNode = staticmethod(_IFSelect.IFSelect_SequenceOfAppliedModifiers_delNode)
    else:
        delNode = _IFSelect.IFSelect_SequenceOfAppliedModifiers_delNode

    def Clear(self, theAllocator: 'opencascade::handle< NCollection_BaseAllocator > const &'=0) -> "void":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_Clear(self, theAllocator)

    def Assign(self, theOther: 'IFSelect_SequenceOfAppliedModifiers') -> "NCollection_Sequence< opencascade::handle< IFSelect_AppliedModifiers > > &":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_Assign(self, theOther)

    def Set(self, theOther: 'IFSelect_SequenceOfAppliedModifiers') -> "NCollection_Sequence< opencascade::handle< IFSelect_AppliedModifiers > > &":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_Set(self, theOther)

    def Remove(self, *args) -> "void":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_Remove(self, *args)

    def Append(self, *args) -> "void":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_Append(self, *args)

    def Prepend(self, *args) -> "void":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_Prepend(self, *args)

    def InsertBefore(self, *args) -> "void":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_InsertBefore(self, *args)

    def InsertAfter(self, *args) -> "void":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_InsertAfter(self, *args)

    def Split(self, theIndex: 'Standard_Integer const', theSeq: 'IFSelect_SequenceOfAppliedModifiers') -> "void":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_Split(self, theIndex, theSeq)

    def First(self) -> "opencascade::handle< IFSelect_AppliedModifiers > const &":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_First(self)

    def ChangeFirst(self) -> "opencascade::handle< IFSelect_AppliedModifiers > &":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_ChangeFirst(self)

    def Last(self) -> "opencascade::handle< IFSelect_AppliedModifiers > const &":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_Last(self)

    def ChangeLast(self) -> "opencascade::handle< IFSelect_AppliedModifiers > &":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< IFSelect_AppliedModifiers > const &":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< IFSelect_AppliedModifiers > &":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "opencascade::handle< IFSelect_AppliedModifiers > &":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'opencascade::handle< IFSelect_AppliedModifiers > const &') -> "void":
        return _IFSelect.IFSelect_SequenceOfAppliedModifiers_SetValue(self, theIndex, theItem)
    __swig_destroy__ = _IFSelect.delete_IFSelect_SequenceOfAppliedModifiers
    __del__ = lambda self: None

    def __len__(self):
        return self.Size()

IFSelect_SequenceOfAppliedModifiers_swigregister = _IFSelect.IFSelect_SequenceOfAppliedModifiers_swigregister
IFSelect_SequenceOfAppliedModifiers_swigregister(IFSelect_SequenceOfAppliedModifiers)

def IFSelect_SequenceOfAppliedModifiers_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _IFSelect.IFSelect_SequenceOfAppliedModifiers_delNode(theNode, theAl)
IFSelect_SequenceOfAppliedModifiers_delNode = _IFSelect.IFSelect_SequenceOfAppliedModifiers_delNode

class IFSelect_SequenceOfGeneralModifier(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SequenceOfGeneralModifier, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SequenceOfGeneralModifier, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Sequence< opencascade::handle< IFSelect_GeneralModifier > >::iterator":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_begin(self)

    def end(self) -> "NCollection_Sequence< opencascade::handle< IFSelect_GeneralModifier > >::iterator":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_end(self)

    def cbegin(self) -> "NCollection_Sequence< opencascade::handle< IFSelect_GeneralModifier > >::const_iterator":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_cbegin(self)

    def cend(self) -> "NCollection_Sequence< opencascade::handle< IFSelect_GeneralModifier > >::const_iterator":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_cend(self)

    def __init__(self, *args):
        this = _IFSelect.new_IFSelect_SequenceOfGeneralModifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self) -> "Standard_Integer":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_Size(self)

    def Length(self) -> "Standard_Integer":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_Length(self)

    def Lower(self) -> "Standard_Integer":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_Upper(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_IsEmpty(self)

    def Reverse(self) -> "void":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_Reverse(self)

    def Exchange(self, I: 'Standard_Integer const', J: 'Standard_Integer const') -> "void":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_Exchange(self, I, J)
    if _newclass:
        delNode = staticmethod(_IFSelect.IFSelect_SequenceOfGeneralModifier_delNode)
    else:
        delNode = _IFSelect.IFSelect_SequenceOfGeneralModifier_delNode

    def Clear(self, theAllocator: 'opencascade::handle< NCollection_BaseAllocator > const &'=0) -> "void":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_Clear(self, theAllocator)

    def Assign(self, theOther: 'IFSelect_SequenceOfGeneralModifier') -> "NCollection_Sequence< opencascade::handle< IFSelect_GeneralModifier > > &":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_Assign(self, theOther)

    def Set(self, theOther: 'IFSelect_SequenceOfGeneralModifier') -> "NCollection_Sequence< opencascade::handle< IFSelect_GeneralModifier > > &":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_Set(self, theOther)

    def Remove(self, *args) -> "void":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_Remove(self, *args)

    def Append(self, *args) -> "void":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_Append(self, *args)

    def Prepend(self, *args) -> "void":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_Prepend(self, *args)

    def InsertBefore(self, *args) -> "void":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_InsertBefore(self, *args)

    def InsertAfter(self, *args) -> "void":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_InsertAfter(self, *args)

    def Split(self, theIndex: 'Standard_Integer const', theSeq: 'IFSelect_SequenceOfGeneralModifier') -> "void":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_Split(self, theIndex, theSeq)

    def First(self) -> "opencascade::handle< IFSelect_GeneralModifier > const &":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_First(self)

    def ChangeFirst(self) -> "opencascade::handle< IFSelect_GeneralModifier > &":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_ChangeFirst(self)

    def Last(self) -> "opencascade::handle< IFSelect_GeneralModifier > const &":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_Last(self)

    def ChangeLast(self) -> "opencascade::handle< IFSelect_GeneralModifier > &":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< IFSelect_GeneralModifier > const &":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< IFSelect_GeneralModifier > &":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "opencascade::handle< IFSelect_GeneralModifier > &":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'opencascade::handle< IFSelect_GeneralModifier > const &') -> "void":
        return _IFSelect.IFSelect_SequenceOfGeneralModifier_SetValue(self, theIndex, theItem)
    __swig_destroy__ = _IFSelect.delete_IFSelect_SequenceOfGeneralModifier
    __del__ = lambda self: None

    def __len__(self):
        return self.Size()

IFSelect_SequenceOfGeneralModifier_swigregister = _IFSelect.IFSelect_SequenceOfGeneralModifier_swigregister
IFSelect_SequenceOfGeneralModifier_swigregister(IFSelect_SequenceOfGeneralModifier)

def IFSelect_SequenceOfGeneralModifier_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _IFSelect.IFSelect_SequenceOfGeneralModifier_delNode(theNode, theAl)
IFSelect_SequenceOfGeneralModifier_delNode = _IFSelect.IFSelect_SequenceOfGeneralModifier_delNode

class IFSelect_SequenceOfInterfaceModel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SequenceOfInterfaceModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SequenceOfInterfaceModel, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Sequence< opencascade::handle< Interface_InterfaceModel > >::iterator":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_begin(self)

    def end(self) -> "NCollection_Sequence< opencascade::handle< Interface_InterfaceModel > >::iterator":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_end(self)

    def cbegin(self) -> "NCollection_Sequence< opencascade::handle< Interface_InterfaceModel > >::const_iterator":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_cbegin(self)

    def cend(self) -> "NCollection_Sequence< opencascade::handle< Interface_InterfaceModel > >::const_iterator":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_cend(self)

    def __init__(self, *args):
        this = _IFSelect.new_IFSelect_SequenceOfInterfaceModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self) -> "Standard_Integer":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_Size(self)

    def Length(self) -> "Standard_Integer":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_Length(self)

    def Lower(self) -> "Standard_Integer":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_Upper(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_IsEmpty(self)

    def Reverse(self) -> "void":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_Reverse(self)

    def Exchange(self, I: 'Standard_Integer const', J: 'Standard_Integer const') -> "void":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_Exchange(self, I, J)
    if _newclass:
        delNode = staticmethod(_IFSelect.IFSelect_SequenceOfInterfaceModel_delNode)
    else:
        delNode = _IFSelect.IFSelect_SequenceOfInterfaceModel_delNode

    def Clear(self, theAllocator: 'opencascade::handle< NCollection_BaseAllocator > const &'=0) -> "void":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_Clear(self, theAllocator)

    def Assign(self, theOther: 'IFSelect_SequenceOfInterfaceModel') -> "NCollection_Sequence< opencascade::handle< Interface_InterfaceModel > > &":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_Assign(self, theOther)

    def Set(self, theOther: 'IFSelect_SequenceOfInterfaceModel') -> "NCollection_Sequence< opencascade::handle< Interface_InterfaceModel > > &":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_Set(self, theOther)

    def Remove(self, *args) -> "void":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_Remove(self, *args)

    def Append(self, *args) -> "void":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_Append(self, *args)

    def Prepend(self, *args) -> "void":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_Prepend(self, *args)

    def InsertBefore(self, *args) -> "void":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_InsertBefore(self, *args)

    def InsertAfter(self, *args) -> "void":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_InsertAfter(self, *args)

    def Split(self, theIndex: 'Standard_Integer const', theSeq: 'IFSelect_SequenceOfInterfaceModel') -> "void":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_Split(self, theIndex, theSeq)

    def First(self) -> "opencascade::handle< Interface_InterfaceModel > const &":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_First(self)

    def ChangeFirst(self) -> "opencascade::handle< Interface_InterfaceModel > &":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_ChangeFirst(self)

    def Last(self) -> "opencascade::handle< Interface_InterfaceModel > const &":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_Last(self)

    def ChangeLast(self) -> "opencascade::handle< Interface_InterfaceModel > &":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< Interface_InterfaceModel > const &":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< Interface_InterfaceModel > &":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "opencascade::handle< Interface_InterfaceModel > &":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'opencascade::handle< Interface_InterfaceModel > const &') -> "void":
        return _IFSelect.IFSelect_SequenceOfInterfaceModel_SetValue(self, theIndex, theItem)
    __swig_destroy__ = _IFSelect.delete_IFSelect_SequenceOfInterfaceModel
    __del__ = lambda self: None

    def __len__(self):
        return self.Size()

IFSelect_SequenceOfInterfaceModel_swigregister = _IFSelect.IFSelect_SequenceOfInterfaceModel_swigregister
IFSelect_SequenceOfInterfaceModel_swigregister(IFSelect_SequenceOfInterfaceModel)

def IFSelect_SequenceOfInterfaceModel_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _IFSelect.IFSelect_SequenceOfInterfaceModel_delNode(theNode, theAl)
IFSelect_SequenceOfInterfaceModel_delNode = _IFSelect.IFSelect_SequenceOfInterfaceModel_delNode

class IFSelect_TSeqOfDispatch(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_TSeqOfDispatch, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_TSeqOfDispatch, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Sequence< opencascade::handle< IFSelect_Dispatch > >::iterator":
        return _IFSelect.IFSelect_TSeqOfDispatch_begin(self)

    def end(self) -> "NCollection_Sequence< opencascade::handle< IFSelect_Dispatch > >::iterator":
        return _IFSelect.IFSelect_TSeqOfDispatch_end(self)

    def cbegin(self) -> "NCollection_Sequence< opencascade::handle< IFSelect_Dispatch > >::const_iterator":
        return _IFSelect.IFSelect_TSeqOfDispatch_cbegin(self)

    def cend(self) -> "NCollection_Sequence< opencascade::handle< IFSelect_Dispatch > >::const_iterator":
        return _IFSelect.IFSelect_TSeqOfDispatch_cend(self)

    def __init__(self, *args):
        this = _IFSelect.new_IFSelect_TSeqOfDispatch(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self) -> "Standard_Integer":
        return _IFSelect.IFSelect_TSeqOfDispatch_Size(self)

    def Length(self) -> "Standard_Integer":
        return _IFSelect.IFSelect_TSeqOfDispatch_Length(self)

    def Lower(self) -> "Standard_Integer":
        return _IFSelect.IFSelect_TSeqOfDispatch_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _IFSelect.IFSelect_TSeqOfDispatch_Upper(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _IFSelect.IFSelect_TSeqOfDispatch_IsEmpty(self)

    def Reverse(self) -> "void":
        return _IFSelect.IFSelect_TSeqOfDispatch_Reverse(self)

    def Exchange(self, I: 'Standard_Integer const', J: 'Standard_Integer const') -> "void":
        return _IFSelect.IFSelect_TSeqOfDispatch_Exchange(self, I, J)
    if _newclass:
        delNode = staticmethod(_IFSelect.IFSelect_TSeqOfDispatch_delNode)
    else:
        delNode = _IFSelect.IFSelect_TSeqOfDispatch_delNode

    def Clear(self, theAllocator: 'opencascade::handle< NCollection_BaseAllocator > const &'=0) -> "void":
        return _IFSelect.IFSelect_TSeqOfDispatch_Clear(self, theAllocator)

    def Assign(self, theOther: 'IFSelect_TSeqOfDispatch') -> "NCollection_Sequence< opencascade::handle< IFSelect_Dispatch > > &":
        return _IFSelect.IFSelect_TSeqOfDispatch_Assign(self, theOther)

    def Set(self, theOther: 'IFSelect_TSeqOfDispatch') -> "NCollection_Sequence< opencascade::handle< IFSelect_Dispatch > > &":
        return _IFSelect.IFSelect_TSeqOfDispatch_Set(self, theOther)

    def Remove(self, *args) -> "void":
        return _IFSelect.IFSelect_TSeqOfDispatch_Remove(self, *args)

    def Append(self, *args) -> "void":
        return _IFSelect.IFSelect_TSeqOfDispatch_Append(self, *args)

    def Prepend(self, *args) -> "void":
        return _IFSelect.IFSelect_TSeqOfDispatch_Prepend(self, *args)

    def InsertBefore(self, *args) -> "void":
        return _IFSelect.IFSelect_TSeqOfDispatch_InsertBefore(self, *args)

    def InsertAfter(self, *args) -> "void":
        return _IFSelect.IFSelect_TSeqOfDispatch_InsertAfter(self, *args)

    def Split(self, theIndex: 'Standard_Integer const', theSeq: 'IFSelect_TSeqOfDispatch') -> "void":
        return _IFSelect.IFSelect_TSeqOfDispatch_Split(self, theIndex, theSeq)

    def First(self) -> "opencascade::handle< IFSelect_Dispatch > const &":
        return _IFSelect.IFSelect_TSeqOfDispatch_First(self)

    def ChangeFirst(self) -> "opencascade::handle< IFSelect_Dispatch > &":
        return _IFSelect.IFSelect_TSeqOfDispatch_ChangeFirst(self)

    def Last(self) -> "opencascade::handle< IFSelect_Dispatch > const &":
        return _IFSelect.IFSelect_TSeqOfDispatch_Last(self)

    def ChangeLast(self) -> "opencascade::handle< IFSelect_Dispatch > &":
        return _IFSelect.IFSelect_TSeqOfDispatch_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< IFSelect_Dispatch > const &":
        return _IFSelect.IFSelect_TSeqOfDispatch_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< IFSelect_Dispatch > &":
        return _IFSelect.IFSelect_TSeqOfDispatch_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "opencascade::handle< IFSelect_Dispatch > &":
        return _IFSelect.IFSelect_TSeqOfDispatch___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'opencascade::handle< IFSelect_Dispatch > const &') -> "void":
        return _IFSelect.IFSelect_TSeqOfDispatch_SetValue(self, theIndex, theItem)
    __swig_destroy__ = _IFSelect.delete_IFSelect_TSeqOfDispatch
    __del__ = lambda self: None

    def __len__(self):
        return self.Size()

IFSelect_TSeqOfDispatch_swigregister = _IFSelect.IFSelect_TSeqOfDispatch_swigregister
IFSelect_TSeqOfDispatch_swigregister(IFSelect_TSeqOfDispatch)

def IFSelect_TSeqOfDispatch_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _IFSelect.IFSelect_TSeqOfDispatch_delNode(theNode, theAl)
IFSelect_TSeqOfDispatch_delNode = _IFSelect.IFSelect_TSeqOfDispatch_delNode

class IFSelect_TSeqOfSelection(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_TSeqOfSelection, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_TSeqOfSelection, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Sequence< opencascade::handle< IFSelect_Selection > >::iterator":
        return _IFSelect.IFSelect_TSeqOfSelection_begin(self)

    def end(self) -> "NCollection_Sequence< opencascade::handle< IFSelect_Selection > >::iterator":
        return _IFSelect.IFSelect_TSeqOfSelection_end(self)

    def cbegin(self) -> "NCollection_Sequence< opencascade::handle< IFSelect_Selection > >::const_iterator":
        return _IFSelect.IFSelect_TSeqOfSelection_cbegin(self)

    def cend(self) -> "NCollection_Sequence< opencascade::handle< IFSelect_Selection > >::const_iterator":
        return _IFSelect.IFSelect_TSeqOfSelection_cend(self)

    def __init__(self, *args):
        this = _IFSelect.new_IFSelect_TSeqOfSelection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self) -> "Standard_Integer":
        return _IFSelect.IFSelect_TSeqOfSelection_Size(self)

    def Length(self) -> "Standard_Integer":
        return _IFSelect.IFSelect_TSeqOfSelection_Length(self)

    def Lower(self) -> "Standard_Integer":
        return _IFSelect.IFSelect_TSeqOfSelection_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _IFSelect.IFSelect_TSeqOfSelection_Upper(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _IFSelect.IFSelect_TSeqOfSelection_IsEmpty(self)

    def Reverse(self) -> "void":
        return _IFSelect.IFSelect_TSeqOfSelection_Reverse(self)

    def Exchange(self, I: 'Standard_Integer const', J: 'Standard_Integer const') -> "void":
        return _IFSelect.IFSelect_TSeqOfSelection_Exchange(self, I, J)
    if _newclass:
        delNode = staticmethod(_IFSelect.IFSelect_TSeqOfSelection_delNode)
    else:
        delNode = _IFSelect.IFSelect_TSeqOfSelection_delNode

    def Clear(self, theAllocator: 'opencascade::handle< NCollection_BaseAllocator > const &'=0) -> "void":
        return _IFSelect.IFSelect_TSeqOfSelection_Clear(self, theAllocator)

    def Assign(self, theOther: 'IFSelect_TSeqOfSelection') -> "NCollection_Sequence< opencascade::handle< IFSelect_Selection > > &":
        return _IFSelect.IFSelect_TSeqOfSelection_Assign(self, theOther)

    def Set(self, theOther: 'IFSelect_TSeqOfSelection') -> "NCollection_Sequence< opencascade::handle< IFSelect_Selection > > &":
        return _IFSelect.IFSelect_TSeqOfSelection_Set(self, theOther)

    def Remove(self, *args) -> "void":
        return _IFSelect.IFSelect_TSeqOfSelection_Remove(self, *args)

    def Append(self, *args) -> "void":
        return _IFSelect.IFSelect_TSeqOfSelection_Append(self, *args)

    def Prepend(self, *args) -> "void":
        return _IFSelect.IFSelect_TSeqOfSelection_Prepend(self, *args)

    def InsertBefore(self, *args) -> "void":
        return _IFSelect.IFSelect_TSeqOfSelection_InsertBefore(self, *args)

    def InsertAfter(self, *args) -> "void":
        return _IFSelect.IFSelect_TSeqOfSelection_InsertAfter(self, *args)

    def Split(self, theIndex: 'Standard_Integer const', theSeq: 'IFSelect_TSeqOfSelection') -> "void":
        return _IFSelect.IFSelect_TSeqOfSelection_Split(self, theIndex, theSeq)

    def First(self) -> "opencascade::handle< IFSelect_Selection > const &":
        return _IFSelect.IFSelect_TSeqOfSelection_First(self)

    def ChangeFirst(self) -> "opencascade::handle< IFSelect_Selection > &":
        return _IFSelect.IFSelect_TSeqOfSelection_ChangeFirst(self)

    def Last(self) -> "opencascade::handle< IFSelect_Selection > const &":
        return _IFSelect.IFSelect_TSeqOfSelection_Last(self)

    def ChangeLast(self) -> "opencascade::handle< IFSelect_Selection > &":
        return _IFSelect.IFSelect_TSeqOfSelection_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< IFSelect_Selection > const &":
        return _IFSelect.IFSelect_TSeqOfSelection_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< IFSelect_Selection > &":
        return _IFSelect.IFSelect_TSeqOfSelection_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "opencascade::handle< IFSelect_Selection > &":
        return _IFSelect.IFSelect_TSeqOfSelection___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'opencascade::handle< IFSelect_Selection > const &') -> "void":
        return _IFSelect.IFSelect_TSeqOfSelection_SetValue(self, theIndex, theItem)
    __swig_destroy__ = _IFSelect.delete_IFSelect_TSeqOfSelection
    __del__ = lambda self: None

    def __len__(self):
        return self.Size()

IFSelect_TSeqOfSelection_swigregister = _IFSelect.IFSelect_TSeqOfSelection_swigregister
IFSelect_TSeqOfSelection_swigregister(IFSelect_TSeqOfSelection)

def IFSelect_TSeqOfSelection_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _IFSelect.IFSelect_TSeqOfSelection_delNode(theNode, theAl)
IFSelect_TSeqOfSelection_delNode = _IFSelect.IFSelect_TSeqOfSelection_delNode

class ifselect(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ifselect, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ifselect, name)
    __repr__ = _swig_repr

    def RestoreSession(*args) -> "Standard_Boolean":
        """
        Restore the state of a worksession from ifselect, by using a sessionfile from ifselect. returns true if done, false in case of error on writing. <file> gives the name of the file to be used (this avoids to export the class sessionfile).

        Parameters
        ----------
        WS: IFSelect_WorkSession
        file: char *

        Returns
        -------
        bool

        """
        return _IFSelect.ifselect_RestoreSession(*args)

    RestoreSession = staticmethod(RestoreSession)

    def SaveSession(*args) -> "Standard_Boolean":
        """
        Saves the state of a worksession from ifselect, by using a sessionfile from ifselect. returns true if done, false in case of error on writing. <file> gives the name of the file to be produced (this avoids to export the class sessionfile).

        Parameters
        ----------
        WS: IFSelect_WorkSession
        file: char *

        Returns
        -------
        bool

        """
        return _IFSelect.ifselect_SaveSession(*args)

    SaveSession = staticmethod(SaveSession)

    __repr__ = _dumps_object


    def __init__(self):
        this = _IFSelect.new_ifselect()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IFSelect.delete_ifselect
    __del__ = lambda self: None
ifselect_swigregister = _IFSelect.ifselect_swigregister
ifselect_swigregister(ifselect)

def ifselect_RestoreSession(*args) -> "Standard_Boolean":
    """
    Restore the state of a worksession from ifselect, by using a sessionfile from ifselect. returns true if done, false in case of error on writing. <file> gives the name of the file to be used (this avoids to export the class sessionfile).

    Parameters
    ----------
    WS: IFSelect_WorkSession
    file: char *

    Returns
    -------
    bool

    """
    return _IFSelect.ifselect_RestoreSession(*args)

def ifselect_SaveSession(*args) -> "Standard_Boolean":
    """
    Saves the state of a worksession from ifselect, by using a sessionfile from ifselect. returns true if done, false in case of error on writing. <file> gives the name of the file to be produced (this avoids to export the class sessionfile).

    Parameters
    ----------
    WS: IFSelect_WorkSession
    file: char *

    Returns
    -------
    bool

    """
    return _IFSelect.ifselect_SaveSession(*args)

class IFSelect_Activator(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_Activator, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_Activator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        Allows a self-definition by an activator of the commands it processes, call the class method adding (mode 0).

        Parameters
        ----------
        number: int
        command: char *

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_Activator_Add(self, *args)


    def AddSet(self, *args) -> "void":
        """
        Same as add but specifies that this command is candidate for xset (creation of items, xset : named items; mode 1).

        Parameters
        ----------
        number: int
        command: char *

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_Activator_AddSet(self, *args)


    def Adding(*args) -> "void":
        """
        Records, in a dictionary available for all the activators, the command title an activator can process, attached with its number, proper for this activator <mode> allows to distinguish various execution modes 0: default mode; 1 : for xset.

        Parameters
        ----------
        actor: IFSelect_Activator
        number: int
        command: char *
        mode: int

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_Activator_Adding(*args)

    Adding = staticmethod(Adding)

    def Commands(*args) -> "opencascade::handle< TColStd_HSequenceOfAsciiString >":
        """
        Returns, for a root of command title, the list of possible commands. <mode> : -1 (d) for all commands if <commands> is empty -1 + command : about a group , >= 0 see adding by default, it returns the whole list of known commands.

        Parameters
        ----------
        mode: int,optional
        	default value is -1
        command: char *,optional
        	default value is 

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfAsciiString>

        """
        return _IFSelect.IFSelect_Activator_Commands(*args)

    Commands = staticmethod(Commands)

    def Do(self, *args) -> "IFSelect_ReturnStatus":
        """
        Tries to execute a command line. <number> is the number of the command for this activator. it must forecast to record the result of the execution, for need of undo-redo must returns : 0 for a void command (not to be recorded), 1 if execution ok, -1 if command incorrect, -2 if error on execution.

        Parameters
        ----------
        number: int
        pilot: IFSelect_SessionPilot

        Returns
        -------
        IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_Activator_Do(self, *args)


    def File(self, *args) -> "char const *":
        """
        No available documentation.

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_Activator_File(self, *args)


    def Group(self, *args) -> "char const *":
        """
        No available documentation.

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_Activator_Group(self, *args)


    def Help(self, *args) -> "char const *":
        """
        Sends a short help message for a given command identified by it number for this activator (must take one line max).

        Parameters
        ----------
        number: int

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_Activator_Help(self, *args)


    def Mode(*args) -> "Standard_Integer":
        """
        Returns mode recorded for a command. -1 if not found.

        Parameters
        ----------
        command: char *

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_Activator_Mode(*args)

    Mode = staticmethod(Mode)

    def Remove(*args) -> "void":
        """
        Removes a command, if it is recorded (else, does nothing).

        Parameters
        ----------
        command: char *

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_Activator_Remove(*args)

    Remove = staticmethod(Remove)

    def Select(*args) -> "Standard_Integer &":
        """
        Selects, for a command given by its title, an actor with its command number. returns true if found, false else.

        Parameters
        ----------
        command: char *
        actor: IFSelect_Activator

        Returns
        -------
        number: int

        """
        return _IFSelect.IFSelect_Activator_Select(*args)

    Select = staticmethod(Select)

    def SetForGroup(self, *args) -> "void":
        """
        Group and setgroup define a 'group of commands' which correspond to an activator. default is 'xstep' also a file may be attached.

        Parameters
        ----------
        group: char *
        file: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_Activator_SetForGroup(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_Activator_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_Activator
    __del__ = lambda self: None
IFSelect_Activator_swigregister = _IFSelect.IFSelect_Activator_swigregister
IFSelect_Activator_swigregister(IFSelect_Activator)

def IFSelect_Activator_Adding(*args) -> "void":
    """
    Records, in a dictionary available for all the activators, the command title an activator can process, attached with its number, proper for this activator <mode> allows to distinguish various execution modes 0: default mode; 1 : for xset.

    Parameters
    ----------
    actor: IFSelect_Activator
    number: int
    command: char *
    mode: int

    Returns
    -------
    None

    """
    return _IFSelect.IFSelect_Activator_Adding(*args)

def IFSelect_Activator_Commands(*args) -> "opencascade::handle< TColStd_HSequenceOfAsciiString >":
    """
    Returns, for a root of command title, the list of possible commands. <mode> : -1 (d) for all commands if <commands> is empty -1 + command : about a group , >= 0 see adding by default, it returns the whole list of known commands.

    Parameters
    ----------
    mode: int,optional
    	default value is -1
    command: char *,optional
    	default value is 

    Returns
    -------
    opencascade::handle<TColStd_HSequenceOfAsciiString>

    """
    return _IFSelect.IFSelect_Activator_Commands(*args)

def IFSelect_Activator_Mode(*args) -> "Standard_Integer":
    """
    Returns mode recorded for a command. -1 if not found.

    Parameters
    ----------
    command: char *

    Returns
    -------
    int

    """
    return _IFSelect.IFSelect_Activator_Mode(*args)

def IFSelect_Activator_Remove(*args) -> "void":
    """
    Removes a command, if it is recorded (else, does nothing).

    Parameters
    ----------
    command: char *

    Returns
    -------
    None

    """
    return _IFSelect.IFSelect_Activator_Remove(*args)

def IFSelect_Activator_Select(*args) -> "Standard_Integer &":
    """
    Selects, for a command given by its title, an actor with its command number. returns true if found, false else.

    Parameters
    ----------
    command: char *
    actor: IFSelect_Activator

    Returns
    -------
    number: int

    """
    return _IFSelect.IFSelect_Activator_Select(*args)

class IFSelect_AppliedModifiers(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_AppliedModifiers, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_AppliedModifiers, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an appliedmodifiers, ready to record up to <nbmax> modifiers, on a model of <nbent> entities.

        Parameters
        ----------
        nbmax: int
        nbent: int

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_AppliedModifiers(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddModif(self, *args) -> "Standard_Boolean":
        """
        Records a modifier. by default, it is to apply on all a produced file. further calls to addnum will restrict this. returns true if done, false if too many modifiers are already recorded.

        Parameters
        ----------
        modif: IFSelect_GeneralModifier

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_AppliedModifiers_AddModif(self, *args)


    def AddNum(self, *args) -> "Standard_Boolean":
        """
        Adds a number of entity of the output file to be applied on. if a sequence of addnum is called after addmodif, this modifier will be applied on the list of designated entities. else, it will be applied on all the file returns true if done, false if no modifier has yet been added.

        Parameters
        ----------
        nument: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_AppliedModifiers_AddNum(self, *args)


    def Count(self, *args) -> "Standard_Integer":
        """
        Returns the count of recorded modifiers.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_AppliedModifiers_Count(self, *args)


    def IsForAll(self, *args) -> "Standard_Boolean":
        """
        Returns true if the applied modifier queried by last call to item is to be applied to all the produced file. else, <entcount> returned by item gives the count of entity numbers, each one is queried by itemnum.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_AppliedModifiers_IsForAll(self, *args)


    def Item(self, *args) -> "Standard_Boolean":
        """
        Returns the description for applied modifier n0 <num> : the modifier itself, and the count of entities to be applied on. if no specific list of number has been defined, returns the total count of entities of the file if this count is zero, then the modifier applies to all the file (see below). else, the numbers are then queried by calls to itemnum between 1 and <entcount> returns true if ok, false if <num> is out of range.

        Parameters
        ----------
        num: int
        modif: IFSelect_GeneralModifier

        Returns
        -------
        entcount: int

        """
        return _IFSelect.IFSelect_AppliedModifiers_Item(self, *args)


    def ItemList(self, *args) -> "opencascade::handle< TColStd_HSequenceOfInteger >":
        """
        Returns the list of entities to be applied on (see item) as a hsequence (isforall produces the complete list of all the entity numbers of the file.

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfInteger>

        """
        return _IFSelect.IFSelect_AppliedModifiers_ItemList(self, *args)


    def ItemNum(self, *args) -> "Standard_Integer":
        """
        Returns a numero of entity to be applied on, given its rank in the list. if no list is defined (i.e. for all the file), returns <nument> itself, to give all the entities of the file returns 0 if <nument> out of range.

        Parameters
        ----------
        nument: int

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_AppliedModifiers_ItemNum(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_AppliedModifiers_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_AppliedModifiers
    __del__ = lambda self: None
IFSelect_AppliedModifiers_swigregister = _IFSelect.IFSelect_AppliedModifiers_swigregister
IFSelect_AppliedModifiers_swigregister(IFSelect_AppliedModifiers)

class IFSelect_ContextModif(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_ContextModif, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_ContextModif, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Prepares a contextmodif with these informations : - the graph established from original model (target passed directly to modifier) - the copytool which detains the copycontrol, which maps starting (in original) and result (in target) entities - an optional file name (for file output) //! such a contextmodif is considered to be applied on all transferred entities (no filter active).

        Parameters
        ----------
        graph: Interface_Graph
        TC: Interface_CopyTool
        filename: char *,optional
        	default value is 

        Returns
        -------
        None

        Prepares a contextmodif with these informations : - the graph established from original model (target passed directly to modifier) - an optional file name (for file output) here, no copycontrol, hence all entities are considered equal as starting and result //! such a contextmodif is considered to be applied on all transferred entities (no filter active).

        Parameters
        ----------
        graph: Interface_Graph
        filename: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_ContextModif(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddCheck(self, *args) -> "void":
        """
        Adds a check to the checklist. if it is empty, nothing is done if it concerns an entity from the original model (by setentity) to which another check is attached, it is merged to it. else, it is added or merged as to globalcheck.

        Parameters
        ----------
        check: Interface_Check

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ContextModif_AddCheck(self, *args)


    def AddFail(self, *args) -> "void":
        """
        Adds a fail message for an entity from the original model if <start> is not an entity from the original model (e.g. the model itself) this message is added to global check.

        Parameters
        ----------
        start: Standard_Transient
        mess: char *
        orig: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ContextModif_AddFail(self, *args)


    def AddWarning(self, *args) -> "void":
        """
        Adds a warning message for an entity from the original model if <start> is not an entity from the original model (e.g. the model itself) this message is added to global check.

        Parameters
        ----------
        start: Standard_Transient
        mess: char *
        orig: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ContextModif_AddWarning(self, *args)


    def CCheck(self, *args) -> "opencascade::handle< Interface_Check >":
        """
        Returns a check given an entity number (in the original model) by default a global check. creates it the first time. it can then be acknowledged on the spot, in condition that the caller works by reference ('interface_check& check = ...').

        Parameters
        ----------
        num: int,optional
        	default value is 0

        Returns
        -------
        opencascade::handle<Interface_Check>

        Returns a check attached to an entity from the original model it can then be acknowledged on the spot, in condition that the caller works by reference ('interface_check& check = ...').

        Parameters
        ----------
        start: Standard_Transient

        Returns
        -------
        opencascade::handle<Interface_Check>

        """
        return _IFSelect.IFSelect_ContextModif_CCheck(self, *args)


    def CheckList(self, *args) -> "Interface_CheckIterator":
        """
        Returns the complete checklist.

        Returns
        -------
        Interface_CheckIterator

        """
        return _IFSelect.IFSelect_ContextModif_CheckList(self, *args)


    def Control(self, *args) -> "opencascade::handle< Interface_CopyControl >":
        """
        Returns the map for a direct use, if required.

        Returns
        -------
        opencascade::handle<Interface_CopyControl>

        """
        return _IFSelect.IFSelect_ContextModif_Control(self, *args)


    def FileName(self, *args) -> "char const *":
        """
        Returns file name (can be empty).

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_ContextModif_FileName(self, *args)


    def HasFileName(self, *args) -> "Standard_Boolean":
        """
        Returns true if a non empty file name has been defined.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ContextModif_HasFileName(self, *args)


    def IsForAll(self, *args) -> "Standard_Boolean":
        """
        Returns true if no filter is defined : a modifier has to work on all entities of the resulting (target) model.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ContextModif_IsForAll(self, *args)


    def IsForNone(self, *args) -> "Standard_Boolean":
        """
        Returns true if select has determined that a modifier may not be run (filter defined and empty).

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ContextModif_IsForNone(self, *args)


    def IsSelected(self, *args) -> "Standard_Boolean":
        """
        Returns true if a starting item has been transferred and selected.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ContextModif_IsSelected(self, *args)


    def IsTransferred(self, *args) -> "Standard_Boolean":
        """
        Returns true if a starting item has been transferred.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ContextModif_IsTransferred(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """
        Returns true until the iteration has finished.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ContextModif_More(self, *args)


    def Next(self, *args) -> "void":
        """
        Advances the iteration.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ContextModif_Next(self, *args)


    def OriginalGraph(self, *args) -> "Interface_Graph const &":
        """
        Returns the original graph (compared to originalmodel, it gives more query capabilitites).

        Returns
        -------
        Interface_Graph

        """
        return _IFSelect.IFSelect_ContextModif_OriginalGraph(self, *args)


    def OriginalModel(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        Returns the original model.

        Returns
        -------
        opencascade::handle<Interface_InterfaceModel>

        """
        return _IFSelect.IFSelect_ContextModif_OriginalModel(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol >":
        """
        Returns the protocol (null if not set).

        Returns
        -------
        opencascade::handle<Interface_Protocol>

        """
        return _IFSelect.IFSelect_ContextModif_Protocol(self, *args)


    def Select(self, *args) -> "void":
        """
        This method requires contextmodif to be applied with a filter. if a modelmodifier is defined with a selection criterium, the result of this selection is used as a filter : - if none of its items has been transferred, the modification does not apply at all - else, the modifier can query for what entities were selected and what are their results - if this method is not called before working, the modifier has to work on the whole model.

        Parameters
        ----------
        list: Interface_EntityIterator

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ContextModif_Select(self, *args)


    def SelectedCount(self, *args) -> "Standard_Integer":
        """
        Returns the count of selected and transferred items.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_ContextModif_SelectedCount(self, *args)


    def SelectedOriginal(self, *args) -> "Interface_EntityIterator":
        """
        Returns the list of original selected items. see also the iteration.

        Returns
        -------
        Interface_EntityIterator

        """
        return _IFSelect.IFSelect_ContextModif_SelectedOriginal(self, *args)


    def SelectedResult(self, *args) -> "Interface_EntityIterator":
        """
        Returns the list of resulting counterparts of selected items. see also the iteration.

        Returns
        -------
        Interface_EntityIterator

        """
        return _IFSelect.IFSelect_ContextModif_SelectedResult(self, *args)


    def SetProtocol(self, *args) -> "void":
        """
        Allows to transmit a protocol as part of a contextmodif.

        Parameters
        ----------
        proto: Interface_Protocol

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ContextModif_SetProtocol(self, *args)


    def Start(self, *args) -> "void":
        """
        Starts an iteration on selected items. it takes into account isforall/isfornone, by really iterating on all selected items.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ContextModif_Start(self, *args)


    def Trace(self, *args) -> "void":
        """
        Traces the modification of the current entity (see above, valueoriginal and valueresult) for default trace level >= 2. to be called on each indivudual entity really modified <mess> is an optionnal additional message.

        Parameters
        ----------
        mess: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ContextModif_Trace(self, *args)


    def TraceModifier(self, *args) -> "void":
        """
        Traces the application of a modifier. works with default trace file and level. fills the trace if default trace level is at least 1. traces the modifier (its label) and its selection if there is one (its label). to be called after select (because status isforall is printed) worths to trace a global modification. see also trace below.

        Parameters
        ----------
        modif: IFSelect_GeneralModifier

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ContextModif_TraceModifier(self, *args)


    def ValueOriginal(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Returns the current selected item in the original model.

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _IFSelect.IFSelect_ContextModif_ValueOriginal(self, *args)


    def ValueResult(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Returns the result counterpart of current selected item (in the target model).

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _IFSelect.IFSelect_ContextModif_ValueResult(self, *args)


    __repr__ = _dumps_object

    @methodnotwrapped
    def Search(self):
    	pass

    __swig_destroy__ = _IFSelect.delete_IFSelect_ContextModif
    __del__ = lambda self: None
IFSelect_ContextModif_swigregister = _IFSelect.IFSelect_ContextModif_swigregister
IFSelect_ContextModif_swigregister(IFSelect_ContextModif)

class IFSelect_ContextWrite(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_ContextWrite, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_ContextWrite, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Prepares a contextwrite with these informations : - the model which is to be written - the protocol to be used - the filename - an object appliedmodifiers to work. it gives a list of filemodifiers to be ran, and for each one it can give a restricted list of entities (in the model), else all the model is considered.

        Parameters
        ----------
        model: Interface_InterfaceModel
        proto: Interface_Protocol
        applieds: IFSelect_AppliedModifiers
        filename: char *

        Returns
        -------
        None

        Same as above but with an already computed graph.

        Parameters
        ----------
        hgraph: Interface_HGraph
        proto: Interface_Protocol
        applieds: IFSelect_AppliedModifiers
        filename: char *

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_ContextWrite(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddCheck(self, *args) -> "void":
        """
        Adds a check to the checklist. if it is empty, nothing is done if it concerns an entity from the model (by setentity) to which another check is attached, it is merged to it. else, it is added or merged as to globalcheck.

        Parameters
        ----------
        check: Interface_Check

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ContextWrite_AddCheck(self, *args)


    def AddFail(self, *args) -> "void":
        """
        Adds a fail message for an entity from the model if <start> is not an entity from the model (e.g. the model itself) this message is added to global check.

        Parameters
        ----------
        start: Standard_Transient
        mess: char *
        orig: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ContextWrite_AddFail(self, *args)


    def AddWarning(self, *args) -> "void":
        """
        Adds a warning message for an entity from the model if <start> is not an entity from the model (e.g. the model itself) this message is added to global check.

        Parameters
        ----------
        start: Standard_Transient
        mess: char *
        orig: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ContextWrite_AddWarning(self, *args)


    def AppliedModifiers(self, *args) -> "opencascade::handle< IFSelect_AppliedModifiers >":
        """
        Returns the object appliedmodifiers.

        Returns
        -------
        opencascade::handle<IFSelect_AppliedModifiers>

        """
        return _IFSelect.IFSelect_ContextWrite_AppliedModifiers(self, *args)


    def CCheck(self, *args) -> "opencascade::handle< Interface_Check >":
        """
        Returns a check given an entity number (in the model) by default a global check. creates it the first time. it can then be acknowledged on the spot, in condition that the caller works by reference ('interface_check& check = ...').

        Parameters
        ----------
        num: int,optional
        	default value is 0

        Returns
        -------
        opencascade::handle<Interface_Check>

        Returns a check attached to an entity from the model it can then be acknowledged on the spot, in condition that the caller works by reference ('interface_check& check = ...').

        Parameters
        ----------
        start: Standard_Transient

        Returns
        -------
        opencascade::handle<Interface_Check>

        """
        return _IFSelect.IFSelect_ContextWrite_CCheck(self, *args)


    def CheckList(self, *args) -> "Interface_CheckIterator":
        """
        Returns the complete checklist.

        Returns
        -------
        Interface_CheckIterator

        """
        return _IFSelect.IFSelect_ContextWrite_CheckList(self, *args)


    def FileModifier(self, *args) -> "opencascade::handle< IFSelect_GeneralModifier >":
        """
        Returns the currently active file modifier. cast to be done null if not properly set : must be test isnull after casting.

        Returns
        -------
        opencascade::handle<IFSelect_GeneralModifier>

        """
        return _IFSelect.IFSelect_ContextWrite_FileModifier(self, *args)


    def FileName(self, *args) -> "char const *":
        """
        Returns the file name.

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_ContextWrite_FileName(self, *args)


    def Graph(self, *args) -> "Interface_Graph const &":
        """
        Returns the graph, either given when created, else created the first time it is queried.

        Returns
        -------
        Interface_Graph

        """
        return _IFSelect.IFSelect_ContextWrite_Graph(self, *args)


    def IsForAll(self, *args) -> "Standard_Boolean":
        """
        Returns true if the current modifier is to be applied to the whole model. else, a restricted list of selected entities is defined, it can be exploited by the file modifier.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ContextWrite_IsForAll(self, *args)


    def IsForNone(self, *args) -> "Standard_Boolean":
        """
        Returns true if no modifier is currently set.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ContextWrite_IsForNone(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        Returns the model.

        Returns
        -------
        opencascade::handle<Interface_InterfaceModel>

        """
        return _IFSelect.IFSelect_ContextWrite_Model(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """
        Returns true until the iteration has finished.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ContextWrite_More(self, *args)


    def NbEntities(self, *args) -> "Standard_Integer":
        """
        Returns the total count of selected entities.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_ContextWrite_NbEntities(self, *args)


    def NbModifiers(self, *args) -> "Standard_Integer":
        """
        Returns the count of recorded file modifiers.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_ContextWrite_NbModifiers(self, *args)


    def Next(self, *args) -> "void":
        """
        Advances the iteration.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ContextWrite_Next(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol >":
        """
        Returns the protocol;.

        Returns
        -------
        opencascade::handle<Interface_Protocol>

        """
        return _IFSelect.IFSelect_ContextWrite_Protocol(self, *args)


    def SetModifier(self, *args) -> "Standard_Boolean":
        """
        Sets active the file modifier n0 <numod> then, it prepares the list of entities to consider, if any returns false if <numod> out of range.

        Parameters
        ----------
        numod: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ContextWrite_SetModifier(self, *args)


    def Start(self, *args) -> "void":
        """
        Starts an iteration on selected items. it takes into account isforall/isfornone, by really iterating on all selected items.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ContextWrite_Start(self, *args)


    def Value(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Returns the current selected entity in the model.

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _IFSelect.IFSelect_ContextWrite_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_ContextWrite
    __del__ = lambda self: None
IFSelect_ContextWrite_swigregister = _IFSelect.IFSelect_ContextWrite_swigregister
IFSelect_ContextWrite_swigregister(IFSelect_ContextWrite)

class IFSelect_Dispatch(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_Dispatch, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_Dispatch, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def CanHaveRemainder(self, *args) -> "Standard_Boolean":
        """
        Returns true if a dispatch can have a remainder, i.e. if its criterium can let entities apart. it is a potential answer, remainder can be empty at run-time even if answer is true. (to attach a remainderfromdispatch selection is not allowed if answer is true). default answer given here is false (can be redefined).

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_Dispatch_CanHaveRemainder(self, *args)


    def FinalSelection(self, *args) -> "opencascade::handle< IFSelect_Selection >":
        """
        Returns the final selection of a dispatch we 'd like : c++ : return const &.

        Returns
        -------
        opencascade::handle<IFSelect_Selection>

        """
        return _IFSelect.IFSelect_Dispatch_FinalSelection(self, *args)


    def GetEntities(self, *args) -> "Interface_EntityIterator":
        """
        Gets unique root entities from the final selection, given an input graph this the starting step for an evaluation (packets - remainder).

        Parameters
        ----------
        G: Interface_Graph

        Returns
        -------
        Interface_EntityIterator

        """
        return _IFSelect.IFSelect_Dispatch_GetEntities(self, *args)


    def HasRootName(self, *args) -> "Standard_Boolean":
        """
        Returns true if a specific root name has been set (else, the default root name has to be used).

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_Dispatch_HasRootName(self, *args)


    def Label(self, *args) -> "TCollection_AsciiString":
        """
        Returns a text which defines the way a dispatch produces packets (which will become files) from its input.

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_Dispatch_Label(self, *args)


    def LimitedMax(self, *args) -> "Standard_Boolean":
        """
        Returns true if a dispatch generates a count of packets always less than or equal to a maximum value : it can be computed from the total count of entities to be dispatched : <nbent>. if answer is false, no limited maximum is expected for account if answer is true, expected maximum is given in argument <max> default answer given here is false (can be redefined).

        Parameters
        ----------
        nbent: int

        Returns
        -------
        max: int

        """
        return _IFSelect.IFSelect_Dispatch_LimitedMax(self, *args)


    def Packeted(self, *args) -> "Interface_EntityIterator":
        """
        Returns the list of all input entities (see getentities) which are put in a packet. that is, entities listed in getentities but not in remainder (see below). input is given as a graph.

        Parameters
        ----------
        G: Interface_Graph

        Returns
        -------
        Interface_EntityIterator

        """
        return _IFSelect.IFSelect_Dispatch_Packeted(self, *args)


    def Packets(self, *args) -> "void":
        """
        Returns the list of produced packets into argument <pack>. each packet corresponds to a part, the entities listed are the roots given by the selection. input is given as a graph. thus, to create a file from a packet, it suffices to take the entities listed in a part of packets (that is, a packet) without worrying about shared entities this method can raise an exception if data are not coherent.

        Parameters
        ----------
        G: Interface_Graph
        packs: IFGraph_SubPartsIterator

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_Dispatch_Packets(self, *args)


    def Remainder(self, *args) -> "Interface_EntityIterator":
        """
        Returns remainder which is a set of entities. can be empty. default evaluation is empty (has to be redefined if canhaveremainder is redefined to return true).

        Parameters
        ----------
        G: Interface_Graph

        Returns
        -------
        Interface_EntityIterator

        """
        return _IFSelect.IFSelect_Dispatch_Remainder(self, *args)


    def RootName(self, *args) -> "opencascade::handle< TCollection_HAsciiString > const &":
        """
        Returns the root name for files produced by this dispatch it is empty if it has not been set or if it has been reset.

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _IFSelect.IFSelect_Dispatch_RootName(self, *args)


    def Selections(self, *args) -> "IFSelect_SelectionIterator":
        """
        Returns the complete list of source selections (starting from finalselection).

        Returns
        -------
        IFSelect_SelectionIterator

        """
        return _IFSelect.IFSelect_Dispatch_Selections(self, *args)


    def SetFinalSelection(self, *args) -> "void":
        """
        Stores (or changes) the final selection for a dispatch.

        Parameters
        ----------
        sel: IFSelect_Selection

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_Dispatch_SetFinalSelection(self, *args)


    def SetRootName(self, *args) -> "void":
        """
        Sets a root name as an hasciistring to reset it, give a null handle (then, a shareout will have to define the default root name).

        Parameters
        ----------
        name: TCollection_HAsciiString

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_Dispatch_SetRootName(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_Dispatch_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_Dispatch
    __del__ = lambda self: None
IFSelect_Dispatch_swigregister = _IFSelect.IFSelect_Dispatch_swigregister
IFSelect_Dispatch_swigregister(IFSelect_Dispatch)

class IFSelect_EditForm(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_EditForm, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_EditForm, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a complete editform from an editor a specific label can be given.

        Parameters
        ----------
        editor: IFSelect_Editor
        readonly: bool
        undoable: bool
        label: char *,optional
        	default value is 

        Returns
        -------
        None

        Creates an extracted editform from an editor, limited to the values identified in <nums> a specific label can be given.

        Parameters
        ----------
        editor: IFSelect_Editor
        nums: TColStd_SequenceOfInteger
        readonly: bool
        undoable: bool
        label: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_EditForm(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Apply(self, *args) -> "Standard_Boolean":
        """
        Applies modifications to own data calls applydata then clears status according editkeepstatus.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_EditForm_Apply(self, *args)


    def ApplyData(self, *args) -> "Standard_Boolean":
        """
        Applies modifications to data default uses editor. can be redefined.

        Parameters
        ----------
        ent: Standard_Transient
        model: Interface_InterfaceModel

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_EditForm_ApplyData(self, *args)


    def ClearData(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_EditForm_ClearData(self, *args)


    def ClearEdit(self, *args) -> "void":
        """
        Clears modification status : by default all, or one by its numbers (in the editor).

        Parameters
        ----------
        num: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_EditForm_ClearEdit(self, *args)


    def GetEditKeepStatus(self) -> "Standard_Boolean":
        """GetEditKeepStatus(IFSelect_EditForm self) -> Standard_Boolean"""
        return _IFSelect.IFSelect_EditForm_GetEditKeepStatus(self)


    def SetEditKeepStatus(self, value: 'Standard_Boolean') -> "void":
        """SetEditKeepStatus(IFSelect_EditForm self, Standard_Boolean value)"""
        return _IFSelect.IFSelect_EditForm_SetEditKeepStatus(self, value)


    def EditedList(self, *args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """
        Returns the edited value as a list if ismodified is false, returns originalvalue null with ismodified true : means that this value is not defined or has been removed for a single parameter, gives a null handle.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfHAsciiString>

        """
        return _IFSelect.IFSelect_EditForm_EditedList(self, *args)


    def EditedValue(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Returns the edited (i.e. modified) value (string for single) <num> reports to the editform if ismodified is false, returns originalvalue null with ismodified true : means that this value is not defined or has been removed it is for a single parameter. for a list, gives a null handle.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _IFSelect.IFSelect_EditForm_EditedValue(self, *args)


    def Editor(self, *args) -> "opencascade::handle< IFSelect_Editor >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<IFSelect_Editor>

        """
        return _IFSelect.IFSelect_EditForm_Editor(self, *args)


    def Entity(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _IFSelect.IFSelect_EditForm_Entity(self, *args)


    def IsComplete(self, *args) -> "Standard_Boolean":
        """
        Tells if an editform is complete or is an extract from editor.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_EditForm_IsComplete(self, *args)


    def IsLoaded(self, *args) -> "Standard_Boolean":
        """
        Tells if the editform is loaded now.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_EditForm_IsLoaded(self, *args)


    def IsModified(self, *args) -> "Standard_Boolean":
        """
        Tells if a value (of the editform) is modified (directly or through touching by update).

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_EditForm_IsModified(self, *args)


    def IsTouched(self, *args) -> "Standard_Boolean":
        """
        Tells if a value (of the editform) has been touched, i.e. not modified directly but by the modification of another one (by method update from the editor).

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_EditForm_IsTouched(self, *args)


    def Label(self, *args) -> "char const *":
        """
        No available documentation.

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_EditForm_Label(self, *args)


    def ListEditor(self, *args) -> "opencascade::handle< IFSelect_ListEditor >":
        """
        Returns a listeditor to edit the parameter <num> of the editform, if it is a list the editor created it (by listeditor) then loads it (by listvalue) for a single parameter, returns a null handle ...

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<IFSelect_ListEditor>

        """
        return _IFSelect.IFSelect_EditForm_ListEditor(self, *args)


    def LoadData(self, *args) -> "Standard_Boolean":
        """
        Loads modifications to data default uses editor. can be redefined remark that <ent> and/or <model> may be null, according to the kind of editor. shortcuts are available for these cases, but they finally call loaddata (hence, just ignore non-used args).

        Parameters
        ----------
        ent: Standard_Transient
        model: Interface_InterfaceModel

        Returns
        -------
        bool

        Shortcut when both <ent> and <model> are not used (when the editor works on fully static or global data).

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_EditForm_LoadData(self, *args)


    def LoadDefault(self, *args) -> "void":
        """
        For a read-write undoable editform, loads original values from defaults stored in the editor.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_EditForm_LoadDefault(self, *args)


    def LoadEntity(self, *args) -> "Standard_Boolean":
        """
        Shortcut for loaddata when <model> is not used.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_EditForm_LoadEntity(self, *args)


    def LoadList(self, *args) -> "void":
        """
        Loads an original value as a list. called by the editor only.

        Parameters
        ----------
        num: int
        list: TColStd_HSequenceOfHAsciiString

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_EditForm_LoadList(self, *args)


    def LoadModel(self, *args) -> "Standard_Boolean":
        """
        Shortcut for loaddata when only the model is concerned.

        Parameters
        ----------
        model: Interface_InterfaceModel

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_EditForm_LoadModel(self, *args)


    def LoadValue(self, *args) -> "void":
        """
        Loads an original value (single). called by the editor only.

        Parameters
        ----------
        num: int
        val: TCollection_HAsciiString

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_EditForm_LoadValue(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<Interface_InterfaceModel>

        """
        return _IFSelect.IFSelect_EditForm_Model(self, *args)


    def Modify(self, *args) -> "Standard_Boolean":
        """
        Gives a new value for the item <num> of the editform, if it is a single parameter (for a list, just returns false) null means to remove it <enforce> true to overpass protected or computed access mode calls the method update from the editor, which can touch other parameters (see nbtouched) returns true if well recorded, false if this value is not allowed warning : does not apply immediately : will be applied by the method apply.

        Parameters
        ----------
        num: int
        newval: TCollection_HAsciiString
        enforce: bool,optional
        	default value is Standard_False

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_EditForm_Modify(self, *args)


    def ModifyList(self, *args) -> "Standard_Boolean":
        """
        Changes the value of an item of the editform, if it is a list (else, just returns false) the listeditor contains the edited values of the list if no edition was recorded, just returns false calls the method update from the editor, which can touch other parameters (see nbtouched) returns true if well recorded, false if this value is not allowed warning : does not apply immediately : will be applied by the method apply.

        Parameters
        ----------
        num: int
        edited: IFSelect_ListEditor
        enforce: bool,optional
        	default value is Standard_False

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_EditForm_ModifyList(self, *args)


    def ModifyListValue(self, *args) -> "Standard_Boolean":
        """
        As modifylist but the new value is given as such creates a listeditor, loads it, then calls modifylist.

        Parameters
        ----------
        num: int
        list: TColStd_HSequenceOfHAsciiString
        enforce: bool,optional
        	default value is Standard_False

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_EditForm_ModifyListValue(self, *args)


    def NameNumber(self, *args) -> "Standard_Integer":
        """
        Returns the value number in the editor for a given name i.e. the true valuenumber which can be used in various methods of editform if it is not complete, for a recorded (in the editor) but non-loaded name, returns negative value (- number).

        Parameters
        ----------
        name: char *

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_EditForm_NameNumber(self, *args)


    def NameRank(self, *args) -> "Standard_Integer":
        """
        Returns the rank of value in the editform for a given name i.e. if it is not complete, for a recorded (in the editor) but non-loaded name, returns 0.

        Parameters
        ----------
        name: char *

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_EditForm_NameRank(self, *args)


    def NbValues(self, *args) -> "Standard_Integer":
        """
        Returns the count of values <editable> true : count of editable values, i.e. for a complete editform, it is given by the editor else, it is the length of the extraction map <editable> false : all the values from the editor.

        Parameters
        ----------
        editable: bool

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_EditForm_NbValues(self, *args)


    def NumberFromRank(self, *args) -> "Standard_Integer":
        """
        Returns the value number in the editor from a given rank in the editform for a complete editform, both are equal else, it is given by the extraction map returns 0 if <rank> exceeds the count of editable values,.

        Parameters
        ----------
        rank: int

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_EditForm_NumberFromRank(self, *args)


    def OriginalList(self, *args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """
        Returns an original value, as a list <num> is for the editform, not the editor for a single parameter, gives a null handle.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfHAsciiString>

        """
        return _IFSelect.IFSelect_EditForm_OriginalList(self, *args)


    def OriginalValue(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        From an edited value, returns its ... value (original one) null means that this value is not defined <num> is for the editform, not the editor it is for a single parameter. for a list, gives a null handle.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _IFSelect.IFSelect_EditForm_OriginalValue(self, *args)


    def PrintDefsToString(self) -> "std::string":
        """PrintDefsToString(IFSelect_EditForm self) -> std::string"""
        return _IFSelect.IFSelect_EditForm_PrintDefsToString(self)


    def RankFromNumber(self, *args) -> "Standard_Integer":
        """
        Returns the rank in the editform from a given number of value for the editor for a complete editform, both are equal else, it is given by the extraction map returns 0 if <number> is not forecast to be edited, or is out of range.

        Parameters
        ----------
        number: int

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_EditForm_RankFromNumber(self, *args)


    def Recognize(self, *args) -> "Standard_Boolean":
        """
        Tells if this editform can work with its editor and its actual data (entity and model) default uses editor. can be redefined.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_EditForm_Recognize(self, *args)


    def SetData(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        ent: Standard_Transient
        model: Interface_InterfaceModel

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_EditForm_SetData(self, *args)


    def SetEntity(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_EditForm_SetEntity(self, *args)


    def SetModel(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        model: Interface_InterfaceModel

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_EditForm_SetModel(self, *args)


    def Touch(self, *args) -> "Standard_Boolean":
        """
        Gives a new value computed by the editor, if another parameter commands the value of <num> it is generally the case for a computed parameter for instance increments the counter of touched parameters warning : it gives no protection for readonly etc... while it is the internal way of touching parameters does not work (returns false) if <num> is for a list.

        Parameters
        ----------
        num: int
        newval: TCollection_HAsciiString

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_EditForm_Touch(self, *args)


    def TouchList(self, *args) -> "Standard_Boolean":
        """
        Acts as touch but for a list does not work (returns false) if <num> is for a single param.

        Parameters
        ----------
        num: int
        newlist: TColStd_HSequenceOfHAsciiString

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_EditForm_TouchList(self, *args)


    def Undo(self, *args) -> "Standard_Boolean":
        """
        For an undoable editform, applies ... origibal values ! and clears modified ones can be run only once.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_EditForm_Undo(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_EditForm_DownCast(t)


    __repr__ = _dumps_object

    @methodnotwrapped
    def NbTouched(self):
    	pass

    __swig_destroy__ = _IFSelect.delete_IFSelect_EditForm
    __del__ = lambda self: None
IFSelect_EditForm_swigregister = _IFSelect.IFSelect_EditForm_swigregister
IFSelect_EditForm_swigregister(IFSelect_EditForm)

class IFSelect_Editor(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_Editor, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_Editor, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Apply(self, *args) -> "Standard_Boolean":
        """
        Applies modified values of the editform with some data remark: <ent> may be null, this means all <model> is concerned also <model> may be null, if no context applies for <ent> and both <ent> and <model> may be null, for a full static editor.

        Parameters
        ----------
        form: IFSelect_EditForm
        ent: Standard_Transient
        model: Interface_InterfaceModel

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_Editor_Apply(self, *args)


    def EditMode(self, *args) -> "IFSelect_EditValue":
        """
        Returns the edit mode of a value.

        Parameters
        ----------
        num: int

        Returns
        -------
        IFSelect_EditValue

        """
        return _IFSelect.IFSelect_Editor_EditMode(self, *args)


    def Form(self, *args) -> "opencascade::handle< IFSelect_EditForm >":
        """
        Builds and returns an editform, empty (no data yet) can be redefined to return a specific type of editform.

        Parameters
        ----------
        readonly: bool
        undoable: bool,optional
        	default value is Standard_True

        Returns
        -------
        opencascade::handle<IFSelect_EditForm>

        """
        return _IFSelect.IFSelect_Editor_Form(self, *args)


    def IsList(self, *args) -> "Standard_Boolean":
        """
        Tells if a parameter is a list.

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_Editor_IsList(self, *args)


    def Label(self, *args) -> "TCollection_AsciiString":
        """
        Returns the specific label.

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_Editor_Label(self, *args)


    def ListEditor(self, *args) -> "opencascade::handle< IFSelect_ListEditor >":
        """
        Returns a listeditor for a parameter which is a list default returns a basic listeditor for a list, a null handle if <num> is not for a list. can be redefined.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<IFSelect_ListEditor>

        """
        return _IFSelect.IFSelect_Editor_ListEditor(self, *args)


    def ListValue(self, *args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """
        Returns the value of an editform as a list, for a given item if not a list, a null handle should be returned default returns a null handle, because many editors have no list to edit. to be redefined as required.

        Parameters
        ----------
        form: IFSelect_EditForm
        num: int

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfHAsciiString>

        """
        return _IFSelect.IFSelect_Editor_ListValue(self, *args)


    def Load(self, *args) -> "Standard_Boolean":
        """
        Loads original values from some data, to an editform remark: <ent> may be null, this means all <model> is concerned also <model> may be null, if no context applies for <ent> and both <ent> and <model> may be null, for a full static editor.

        Parameters
        ----------
        form: IFSelect_EditForm
        ent: Standard_Transient
        model: Interface_InterfaceModel

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_Editor_Load(self, *args)


    def MaxList(self, *args) -> "Standard_Integer":
        """
        Returns max length allowed for a list = 0 means : list with no limit < 0 means : not a list.

        Parameters
        ----------
        num: int

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_Editor_MaxList(self, *args)


    def MaxNameLength(self, *args) -> "Standard_Integer":
        """
        Returns the maxlength of, according to what : <what> = -1 : length of short names <what> = 0 : length of complete names <what> = 1 : length of values labels.

        Parameters
        ----------
        what: int

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_Editor_MaxNameLength(self, *args)


    def Name(self, *args) -> "char const *":
        """
        Returns the name of a value (complete or short) from its ident short name can be empty.

        Parameters
        ----------
        num: int
        isshort: bool,optional
        	default value is Standard_False

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_Editor_Name(self, *args)


    def NameNumber(self, *args) -> "Standard_Integer":
        """
        Returns the number (ident) of a value, from its name, short or complete. if not found, returns 0.

        Parameters
        ----------
        name: char *

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_Editor_NameNumber(self, *args)


    def NbValues(self, *args) -> "Standard_Integer":
        """
        Returns the count of typed values.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_Editor_NbValues(self, *args)


    def PrintNamesToString(self) -> "std::string":
        """PrintNamesToString(IFSelect_Editor self) -> std::string"""
        return _IFSelect.IFSelect_Editor_PrintNamesToString(self)


    def Recognize(self, *args) -> "Standard_Boolean":
        """
        Tells if this editor can work on this editform and its content (model, entity ?).

        Parameters
        ----------
        form: IFSelect_EditForm

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_Editor_Recognize(self, *args)


    def SetList(self, *args) -> "void":
        """
        Sets a parameter to be a list max < 0 : not for a list (set when starting) max = 0 : list with no length limit (default for setlist) max > 0 : list limited to <max> items.

        Parameters
        ----------
        num: int
        max: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_Editor_SetList(self, *args)


    def SetValue(self, *args) -> "void":
        """
        Sets a typed value for a given ident and short name, with an edit mode.

        Parameters
        ----------
        num: int
        typval: Interface_TypedValue
        shortname: char *,optional
        	default value is 
        accessmode: IFSelect_EditValue,optional
        	default value is IFSelect_Editable

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_Editor_SetValue(self, *args)


    def StringValue(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Returns the value of an editform, for a given item (if not a list. for a list, a null string may be returned).

        Parameters
        ----------
        form: IFSelect_EditForm
        num: int

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _IFSelect.IFSelect_Editor_StringValue(self, *args)


    def TypedValue(self, *args) -> "opencascade::handle< Interface_TypedValue >":
        """
        Returns a typed value from its ident.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<Interface_TypedValue>

        """
        return _IFSelect.IFSelect_Editor_TypedValue(self, *args)


    def Update(self, *args) -> "Standard_Boolean":
        """
        Updates the editform when a parameter is modified i.e. default does nothing, can be redefined, as follows : returns true when done (even if does nothing), false in case of refuse (for instance, if the new value is not suitable) <num> is the rank of the parameter for the editor itself <enforce> true means that protected parameters can be touched //! if a parameter commands the value of other ones, when it is modified, it is necessary to touch them by touch from editform.

        Parameters
        ----------
        form: IFSelect_EditForm
        num: int
        newval: TCollection_HAsciiString
        enforce: bool

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_Editor_Update(self, *args)


    def UpdateList(self, *args) -> "Standard_Boolean":
        """
        Acts as update, but when the value is a list.

        Parameters
        ----------
        form: IFSelect_EditForm
        num: int
        newlist: TColStd_HSequenceOfHAsciiString
        enforce: bool

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_Editor_UpdateList(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_Editor_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_Editor
    __del__ = lambda self: None
IFSelect_Editor_swigregister = _IFSelect.IFSelect_Editor_swigregister
IFSelect_Editor_swigregister(IFSelect_Editor)

class IFSelect_Functions(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_Functions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_Functions, name)
    __repr__ = _swig_repr

    def GiveDispatch(*args) -> "opencascade::handle< IFSelect_Dispatch >":
        """
        Evaluates and returns a dispatch, from data of a worksession if <mode> is false, searches for exact name of dispatch in ws else (d), allows a parameter between brackets : ex.: dispatch_name(parameter) the parameter can be: an integer for disppercount or dispperfiles or the name of a signature for disppersignature returns null handle if not found not well evaluated.

        Parameters
        ----------
        WS: IFSelect_WorkSession
        name: char *
        mode: bool,optional
        	default value is Standard_True

        Returns
        -------
        opencascade::handle<IFSelect_Dispatch>

        """
        return _IFSelect.IFSelect_Functions_GiveDispatch(*args)

    GiveDispatch = staticmethod(GiveDispatch)

    def GiveEntity(*args) -> "opencascade::handle< Standard_Transient >":
        """
        Takes the name of an entity, either as argument, or (if <name> is empty) on keybord, and returns the entity name can be a label or a number (in alphanumeric), it is searched by numberfromlabel from worksession. if <name> doesn't match en entity, a null handle is returned.

        Parameters
        ----------
        WS: IFSelect_WorkSession
        name: char *,optional
        	default value is 

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _IFSelect.IFSelect_Functions_GiveEntity(*args)

    GiveEntity = staticmethod(GiveEntity)

    def GiveEntityNumber(*args) -> "Standard_Integer":
        """
        Same as getentity, but returns the number in the model of the entity. returns 0 for null handle.

        Parameters
        ----------
        WS: IFSelect_WorkSession
        name: char *,optional
        	default value is 

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_Functions_GiveEntityNumber(*args)

    GiveEntityNumber = staticmethod(GiveEntityNumber)

    def GiveList(*args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        Computes a list of entities from a worksession and two idents, first and second, as follows : if <first> is a number or label of an entity : this entity if <first> is the name of a selection in <ws>, and <second> not defined, the standard result of this selection if <first> is for a selection and <second> is defined, the standard result of this selection from the list computed with <second> (an entity or a selection) if <second> is erroneous, it is ignored.

        Parameters
        ----------
        WS: IFSelect_WorkSession
        first: char *,optional
        	default value is 
        second: char *,optional
        	default value is 

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfTransient>

        """
        return _IFSelect.IFSelect_Functions_GiveList(*args)

    GiveList = staticmethod(GiveList)

    def Init(*args) -> "void":
        """
        Defines and loads all basic functions (as actfunc).

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_Functions_Init(*args)

    Init = staticmethod(Init)

    __repr__ = _dumps_object


    def __init__(self):
        this = _IFSelect.new_IFSelect_Functions()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IFSelect.delete_IFSelect_Functions
    __del__ = lambda self: None
IFSelect_Functions_swigregister = _IFSelect.IFSelect_Functions_swigregister
IFSelect_Functions_swigregister(IFSelect_Functions)

def IFSelect_Functions_GiveDispatch(*args) -> "opencascade::handle< IFSelect_Dispatch >":
    """
    Evaluates and returns a dispatch, from data of a worksession if <mode> is false, searches for exact name of dispatch in ws else (d), allows a parameter between brackets : ex.: dispatch_name(parameter) the parameter can be: an integer for disppercount or dispperfiles or the name of a signature for disppersignature returns null handle if not found not well evaluated.

    Parameters
    ----------
    WS: IFSelect_WorkSession
    name: char *
    mode: bool,optional
    	default value is Standard_True

    Returns
    -------
    opencascade::handle<IFSelect_Dispatch>

    """
    return _IFSelect.IFSelect_Functions_GiveDispatch(*args)

def IFSelect_Functions_GiveEntity(*args) -> "opencascade::handle< Standard_Transient >":
    """
    Takes the name of an entity, either as argument, or (if <name> is empty) on keybord, and returns the entity name can be a label or a number (in alphanumeric), it is searched by numberfromlabel from worksession. if <name> doesn't match en entity, a null handle is returned.

    Parameters
    ----------
    WS: IFSelect_WorkSession
    name: char *,optional
    	default value is 

    Returns
    -------
    opencascade::handle<Standard_Transient>

    """
    return _IFSelect.IFSelect_Functions_GiveEntity(*args)

def IFSelect_Functions_GiveEntityNumber(*args) -> "Standard_Integer":
    """
    Same as getentity, but returns the number in the model of the entity. returns 0 for null handle.

    Parameters
    ----------
    WS: IFSelect_WorkSession
    name: char *,optional
    	default value is 

    Returns
    -------
    int

    """
    return _IFSelect.IFSelect_Functions_GiveEntityNumber(*args)

def IFSelect_Functions_GiveList(*args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
    """
    Computes a list of entities from a worksession and two idents, first and second, as follows : if <first> is a number or label of an entity : this entity if <first> is the name of a selection in <ws>, and <second> not defined, the standard result of this selection if <first> is for a selection and <second> is defined, the standard result of this selection from the list computed with <second> (an entity or a selection) if <second> is erroneous, it is ignored.

    Parameters
    ----------
    WS: IFSelect_WorkSession
    first: char *,optional
    	default value is 
    second: char *,optional
    	default value is 

    Returns
    -------
    opencascade::handle<TColStd_HSequenceOfTransient>

    """
    return _IFSelect.IFSelect_Functions_GiveList(*args)

def IFSelect_Functions_Init(*args) -> "void":
    """
    Defines and loads all basic functions (as actfunc).

    Returns
    -------
    None

    """
    return _IFSelect.IFSelect_Functions_Init(*args)

class IFSelect_GeneralModifier(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_GeneralModifier, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_GeneralModifier, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Applies(self, *args) -> "Standard_Boolean":
        """
        Returns true if a model obtained from the dispatch <disp> is to be treated (apart from the selection criterium) if dispatch(me) is null, returns true. else, checks <disp>.

        Parameters
        ----------
        disp: IFSelect_Dispatch

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_GeneralModifier_Applies(self, *args)


    def Dispatch(self, *args) -> "opencascade::handle< IFSelect_Dispatch >":
        """
        Returns the dispatch to be matched, null if not set.

        Returns
        -------
        opencascade::handle<IFSelect_Dispatch>

        """
        return _IFSelect.IFSelect_GeneralModifier_Dispatch(self, *args)


    def HasSelection(self, *args) -> "Standard_Boolean":
        """
        Returns true if a selection is set as an additionnal criterium.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_GeneralModifier_HasSelection(self, *args)


    def Label(self, *args) -> "TCollection_AsciiString":
        """
        Returns a short text which defines the operation performed.

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_GeneralModifier_Label(self, *args)


    def MayChangeGraph(self, *args) -> "Standard_Boolean":
        """
        Returns true if this modifier may change the graph of dependences (aknowledged at creation time).

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_GeneralModifier_MayChangeGraph(self, *args)


    def ResetSelection(self, *args) -> "void":
        """
        Resets the selection : this criterium is not longer active.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_GeneralModifier_ResetSelection(self, *args)


    def Selection(self, *args) -> "opencascade::handle< IFSelect_Selection >":
        """
        Returns the selection, or a null handle if not set.

        Returns
        -------
        opencascade::handle<IFSelect_Selection>

        """
        return _IFSelect.IFSelect_GeneralModifier_Selection(self, *args)


    def SetDispatch(self, *args) -> "void":
        """
        Attaches to a dispatch. if <disp> is null, resets it (to apply the modifier on every dispatch).

        Parameters
        ----------
        disp: IFSelect_Dispatch

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_GeneralModifier_SetDispatch(self, *args)


    def SetSelection(self, *args) -> "void":
        """
        Sets a selection : a model is treated if it contains one or more entities designated by the selection.

        Parameters
        ----------
        sel: IFSelect_Selection

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_GeneralModifier_SetSelection(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_GeneralModifier_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_GeneralModifier
    __del__ = lambda self: None
IFSelect_GeneralModifier_swigregister = _IFSelect.IFSelect_GeneralModifier_swigregister
IFSelect_GeneralModifier_swigregister(IFSelect_GeneralModifier)

class IFSelect_IntParam(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_IntParam, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_IntParam, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an intparam. initial value is set to zer.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_IntParam(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetStaticName(self, *args) -> "void":
        """
        Commands this intparam to be bound to a static hence, value will return the value if this static if it is set else, value works on the locally stored value setvalue also will set the value of the static this works only for a present static of type integer or enum else, it is ignored //! if <statname> is empty, disconnects the intparam from static.

        Parameters
        ----------
        statname: char *

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_IntParam_SetStaticName(self, *args)


    def SetValue(self, *args) -> "void":
        """
        Sets a new integer value for the intparam. if a staticname is defined and the static is set, also sets the value of the static.

        Parameters
        ----------
        val: int

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_IntParam_SetValue(self, *args)


    def Value(self, *args) -> "Standard_Integer":
        """
        Reads integer value of the intparam. if a staticname is defined and the static is set, looks in priority the value of the static.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_IntParam_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_IntParam_DownCast(t)


    __repr__ = _dumps_object

    @methodnotwrapped
    def StaticName(self):
    	pass

    __swig_destroy__ = _IFSelect.delete_IFSelect_IntParam
    __del__ = lambda self: None
IFSelect_IntParam_swigregister = _IFSelect.IFSelect_IntParam_swigregister
IFSelect_IntParam_swigregister(IFSelect_IntParam)

class IFSelect_ListEditor(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_ListEditor, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_ListEditor, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a listeditor with absolutely no constraint.

        Returns
        -------
        None

        Creates a listeditor, for which items of the list to edit are defined by <def>, and <max> describes max length : 0 (d) means no limit value > 0 means : no more the <max> items are allowed.

        Parameters
        ----------
        def: Interface_TypedValue
        max: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_ListEditor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddValue(self, *args) -> "Standard_Boolean":
        """
        Adds a new item. by default appends (at the end of the list) can insert before a given rank <num>, if positive returns true when done. false if maxlength may be overpassed or if <val> does not satisfy the definition.

        Parameters
        ----------
        val: TCollection_HAsciiString
        atnum: int,optional
        	default value is 0

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ListEditor_AddValue(self, *args)


    def ClearEdit(self, *args) -> "void":
        """
        Clears all editions already recorded.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ListEditor_ClearEdit(self, *args)


    def EditedValues(self, *args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """
        Returns the result of the edition.

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfHAsciiString>

        """
        return _IFSelect.IFSelect_ListEditor_EditedValues(self, *args)


    def IsAdded(self, *args) -> "Standard_Boolean":
        """
        Tells if a value (in edited list) has been added (new one).

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ListEditor_IsAdded(self, *args)


    def IsChanged(self, *args) -> "Standard_Boolean":
        """
        Tells if a value (in edited list) has been changed, i.e. either modified-value, or added.

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ListEditor_IsChanged(self, *args)


    def IsModified(self, *args) -> "Standard_Boolean":
        """
        Tells if a value (in edited list) has been modified-value (not added).

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ListEditor_IsModified(self, *args)


    def IsTouched(self, *args) -> "Standard_Boolean":
        """
        Tells if at least one edition (setvalue-addvalue-remove) has been recorded.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ListEditor_IsTouched(self, *args)


    def LoadEdited(self, *args) -> "Standard_Boolean":
        """
        Loads a new list to replace the older one, in once ! by default (can be redefined) checks the length of the list and the value of each item according to the def items are all recorded as modified //! if no def has been given at creation time, no check is done returns true when done, false if checks have failed ... a specialisation may also lock it by returning always false ...

        Parameters
        ----------
        list: TColStd_HSequenceOfHAsciiString

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ListEditor_LoadEdited(self, *args)


    def LoadModel(self, *args) -> "void":
        """
        Loads a model. it is used to check items of type entity(ident).

        Parameters
        ----------
        model: Interface_InterfaceModel

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ListEditor_LoadModel(self, *args)


    def LoadValues(self, *args) -> "void":
        """
        Loads the original values for the list remark : if its length is mor then maxlength, editions remain allowed, except add.

        Parameters
        ----------
        vals: TColStd_HSequenceOfHAsciiString

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ListEditor_LoadValues(self, *args)


    def NbValues(self, *args) -> "Standard_Integer":
        """
        Returns count of values, edited (d) or original.

        Parameters
        ----------
        edited: bool,optional
        	default value is Standard_True

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_ListEditor_NbValues(self, *args)


    def OriginalValues(self, *args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """
        Returns the value from which the edition started.

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfHAsciiString>

        """
        return _IFSelect.IFSelect_ListEditor_OriginalValues(self, *args)


    def Remove(self, *args) -> "Standard_Boolean":
        """
        Removes items from the list by default removes one item. else, count given by <howmany> remove from rank <num> included. by default, from the end returns true when done, false (and does not work) if case of out of range of if <howmany> is greater than current length.

        Parameters
        ----------
        num: int,optional
        	default value is 0
        howmany: int,optional
        	default value is 1

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ListEditor_Remove(self, *args)


    def SetTouched(self, *args) -> "void":
        """
        Declares this listeditor to have been touched (whatever action).

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ListEditor_SetTouched(self, *args)


    def SetValue(self, *args) -> "Standard_Boolean":
        """
        Sets a new value for the item <num> (in edited list) <val> may be a null handle, then the value will be cleared but not removed returns true when done. false if <num> is out of range or if <val> does not satisfy the definition.

        Parameters
        ----------
        num: int
        val: TCollection_HAsciiString

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ListEditor_SetValue(self, *args)


    def Value(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Returns a value given its rank. edited (d) or original a null string means the value is cleared but not removed.

        Parameters
        ----------
        num: int
        edited: bool,optional
        	default value is Standard_True

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _IFSelect.IFSelect_ListEditor_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_ListEditor_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_ListEditor
    __del__ = lambda self: None
IFSelect_ListEditor_swigregister = _IFSelect.IFSelect_ListEditor_swigregister
IFSelect_ListEditor_swigregister(IFSelect_ListEditor)

class IFSelect_ModelCopier(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_ModelCopier, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_ModelCopier, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an empty modelcopier.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_ModelCopier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddFile(self, *args) -> "Standard_Boolean":
        """
        Records a new file to be sent, as a couple (name as asciistring, content as interfacemodel) returns true if done, false if <filename> is already attached to another file.

        Parameters
        ----------
        filename: TCollection_AsciiString
        content: Interface_InterfaceModel

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ModelCopier_AddFile(self, *args)


    def AddSentFile(self, *args) -> "void":
        """
        Adds the name of a just sent file, if beginsentfiles has commanded recording; else does nothing it is called by methods sendcopied sending.

        Parameters
        ----------
        filename: char *

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ModelCopier_AddSentFile(self, *args)


    def AppliedModifiers(self, *args) -> "opencascade::handle< IFSelect_AppliedModifiers >":
        """
        Returns the list of file modifiers to be applied on a file when it will be sent, as computed by copiedmodel : if it is a null handle, no file modifier has to be applied.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<IFSelect_AppliedModifiers>

        """
        return _IFSelect.IFSelect_ModelCopier_AppliedModifiers(self, *args)


    def BeginSentFiles(self, *args) -> "void":
        """
        Begins a sequence of recording the really sent files <sho> : the default file numbering is cleared if <record> is false, clears the list and stops recording if <record> is true, clears the list and commands recording creation time corresponds to 'stop recording'.

        Parameters
        ----------
        sho: IFSelect_ShareOut
        record: bool

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ModelCopier_BeginSentFiles(self, *args)


    def ClearAppliedModifiers(self, *args) -> "Standard_Boolean":
        """
        Clears the list of file modifiers to be applied on a file.

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ModelCopier_ClearAppliedModifiers(self, *args)


    def ClearFile(self, *args) -> "Standard_Boolean":
        """
        Clears the name attached to a file which was formerly defined by a call to addfile. this clearing can be undone by a call to namefile (with same <num>) returns true if done, false else : if <num> is out of range.

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ModelCopier_ClearFile(self, *args)


    def ClearResult(self, *args) -> "void":
        """
        Clears the list of produced models.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ModelCopier_ClearResult(self, *args)


    def CopiedRemaining(self, *args) -> "void":
        """
        Produces a model copied from the remaining list as <newmod> <newmod> is a null handle if this list is empty <wl> performs the copy by using <tc> <tc> is assumed to have been defined with the starting model same as defined by <g>.

        Parameters
        ----------
        G: Interface_Graph
        WL: IFSelect_WorkLibrary
        TC: Interface_CopyTool
        newmod: Interface_InterfaceModel

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ModelCopier_CopiedRemaining(self, *args)


    def Copy(self, *args) -> "Interface_CheckIterator":
        """
        Performs the copy operations, which include the modifications defined by the list of modifiers. memorizes the result, as a list of interfacemodels with the corresponding filenames they can then be sent, by the method send, or queried copy calls internal method copying. returns the produced checklist.

        Parameters
        ----------
        eval: IFSelect_ShareOutResult
        WL: IFSelect_WorkLibrary
        protocol: Interface_Protocol

        Returns
        -------
        Interface_CheckIterator

        """
        return _IFSelect.IFSelect_ModelCopier_Copy(self, *args)


    def FileModel(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        Returns the content of a file before sending, under the form of an interfacemodel, given its rank.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<Interface_InterfaceModel>

        """
        return _IFSelect.IFSelect_ModelCopier_FileModel(self, *args)


    def FileName(self, *args) -> "TCollection_AsciiString":
        """
        Returns the file name for a file given its rank it is empty after a call to clearfile on same <num>.

        Parameters
        ----------
        num: int

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_ModelCopier_FileName(self, *args)


    def NameFile(self, *args) -> "Standard_Boolean":
        """
        Changes the name attached to a file which was formerly defined by a call to addfile returns true if done, false else : if <num> out of range or if the new <filename> is already attached to another file remark : giving an empty file name is equivalent to clearfile.

        Parameters
        ----------
        num: int
        filename: TCollection_AsciiString

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ModelCopier_NameFile(self, *args)


    def NbFiles(self, *args) -> "Standard_Integer":
        """
        Returns the count of files produced, i.e. the count of models memorized (produced by the mmethod copy) with their file names.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_ModelCopier_NbFiles(self, *args)


    def Send(self, *args) -> "Interface_CheckIterator":
        """
        Performs the copy operations (which include the modifications) and sends the result on files, without memorizing it. (the memorized result is ignored : neither queried not filled).

        Parameters
        ----------
        eval: IFSelect_ShareOutResult
        WL: IFSelect_WorkLibrary
        protocol: Interface_Protocol

        Returns
        -------
        Interface_CheckIterator

        """
        return _IFSelect.IFSelect_ModelCopier_Send(self, *args)


    def SendAll(self, *args) -> "Interface_CheckIterator":
        """
        Sends a model (defined in <g>) into one file, without managing remaining data, already sent files, etc. applies the model and file modifiers. returns true if well done, false else.

        Parameters
        ----------
        filename: char *
        G: Interface_Graph
        WL: IFSelect_WorkLibrary
        protocol: Interface_Protocol

        Returns
        -------
        Interface_CheckIterator

        """
        return _IFSelect.IFSelect_ModelCopier_SendAll(self, *args)


    def SendCopied(self, *args) -> "Interface_CheckIterator":
        """
        Sends the formerly defined results (see method copy) to files, then clears it remark : a null file name cause file to be not produced.

        Parameters
        ----------
        WL: IFSelect_WorkLibrary
        protocol: Interface_Protocol

        Returns
        -------
        Interface_CheckIterator

        """
        return _IFSelect.IFSelect_ModelCopier_SendCopied(self, *args)


    def SendSelected(self, *args) -> "Interface_CheckIterator":
        """
        Sends a part of a model into one file. model is gotten from <g>, the part is defined in <iter>. remaining data are managed and can be later be worked on. returns true if well done, false else.

        Parameters
        ----------
        filename: char *
        G: Interface_Graph
        WL: IFSelect_WorkLibrary
        protocol: Interface_Protocol
        iter: Interface_EntityIterator

        Returns
        -------
        Interface_CheckIterator

        """
        return _IFSelect.IFSelect_ModelCopier_SendSelected(self, *args)


    def SentFiles(self, *args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """
        Returns the list of recorded names of sent files. can be empty (if no file has been sent). returns a null handle if beginsentfiles has stopped recording.

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfHAsciiString>

        """
        return _IFSelect.IFSelect_ModelCopier_SentFiles(self, *args)


    def SetAppliedModifiers(self, *args) -> "Standard_Boolean":
        """
        Sets a list of file modifiers to be applied on a file.

        Parameters
        ----------
        num: int
        applied: IFSelect_AppliedModifiers

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ModelCopier_SetAppliedModifiers(self, *args)


    def SetRemaining(self, *args) -> "Standard_Boolean":
        """
        Updates graph status for remaining data, for each entity : - entities just sent to file or copied (by copiedremaining) have their status set to 1 - the other keep their former status (1 for send/copied, 0 for remaining) these status are computed by copying/sending/copiedremaining then, setremaining updates graph status, and mustr be called just after one of these method has been called returns true if done, false if remaining info if not in phase which the graph (not same counts of items).

        Parameters
        ----------
        CG: Interface_Graph

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ModelCopier_SetRemaining(self, *args)


    def SetShareOut(self, *args) -> "void":
        """
        Sets the shareout, which is used to define modifiers to apply.

        Parameters
        ----------
        sho: IFSelect_ShareOut

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ModelCopier_SetShareOut(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_ModelCopier_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_ModelCopier
    __del__ = lambda self: None
IFSelect_ModelCopier_swigregister = _IFSelect.IFSelect_ModelCopier_swigregister
IFSelect_ModelCopier_swigregister(IFSelect_ModelCopier)

class IFSelect_PacketList(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_PacketList, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_PacketList, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a packlist, empty, ready to receive entities from a given model.

        Parameters
        ----------
        model: Interface_InterfaceModel

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_PacketList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args) -> "void":
        """
        Adds an entity from the model into the current packet for add.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_PacketList_Add(self, *args)


    def AddList(self, *args) -> "void":
        """
        Adds an list of entities into the current packet for add.

        Parameters
        ----------
        list: TColStd_HSequenceOfTransient

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_PacketList_AddList(self, *args)


    def AddPacket(self, *args) -> "void":
        """
        Declares a new packet, ready to be filled the entities to be added will be added to this packet.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_PacketList_AddPacket(self, *args)


    def Duplicated(self, *args) -> "Interface_EntityIterator":
        """
        Returns a list of entities duplicated : <count> times, if <andmore> is false, or <count> or more times, if <andmore> is true hence, count=2 & andmore=true gives all duplicated entities count=1 gives non-duplicated entities (in only one packet) count=0 gives remaining entities (in no packet at all).

        Parameters
        ----------
        count: int
        andmore: bool

        Returns
        -------
        Interface_EntityIterator

        """
        return _IFSelect.IFSelect_PacketList_Duplicated(self, *args)


    def Entities(self, *args) -> "Interface_EntityIterator":
        """
        Returns the content of a packet given its rank null handle if <numpack> is out of range.

        Parameters
        ----------
        numpack: int

        Returns
        -------
        Interface_EntityIterator

        """
        return _IFSelect.IFSelect_PacketList_Entities(self, *args)


    def HighestDuplicationCount(self, *args) -> "Standard_Integer":
        """
        Returns the highest number of packets which know a same entity for no duplication, should be one.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_PacketList_HighestDuplicationCount(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        Returns the model of reference.

        Returns
        -------
        opencascade::handle<Interface_InterfaceModel>

        """
        return _IFSelect.IFSelect_PacketList_Model(self, *args)


    def Name(self, *args) -> "char const *":
        """
        Returns the recorded name for a packet list.

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_PacketList_Name(self, *args)


    def NbDuplicated(self, *args) -> "Standard_Integer":
        """
        Returns the count of entities duplicated : <count> times, if <andmore> is false, or <count> or more times, if <andmore> is true see duplicated for more details.

        Parameters
        ----------
        count: int
        andmore: bool

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_PacketList_NbDuplicated(self, *args)


    def NbEntities(self, *args) -> "Standard_Integer":
        """
        Returns the count of entities in a packet given its rank, or 0.

        Parameters
        ----------
        numpack: int

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_PacketList_NbEntities(self, *args)


    def NbPackets(self, *args) -> "Standard_Integer":
        """
        Returns the count of non-empty packets.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_PacketList_NbPackets(self, *args)


    def SetName(self, *args) -> "void":
        """
        Sets a name to a packet list : this makes easier a general routine to print it. default is 'packets'.

        Parameters
        ----------
        name: char *

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_PacketList_SetName(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_PacketList_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_PacketList
    __del__ = lambda self: None
IFSelect_PacketList_swigregister = _IFSelect.IFSelect_PacketList_swigregister
IFSelect_PacketList_swigregister(IFSelect_PacketList)

class IFSelect_Selection(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_Selection, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_Selection, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def CompleteResult(self, *args) -> "Interface_EntityIterator":
        """
        Returns the list of entities involved by a selection, i.e. uniqueresult plus the shared entities (directly or not).

        Parameters
        ----------
        G: Interface_Graph

        Returns
        -------
        Interface_EntityIterator

        """
        return _IFSelect.IFSelect_Selection_CompleteResult(self, *args)


    def FillIterator(self, *args) -> "void":
        """
        Puts in an iterator the selections from which 'me' depends (there can be zero, or one, or a list). specific to each class of selection.

        Parameters
        ----------
        iter: IFSelect_SelectionIterator

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_Selection_FillIterator(self, *args)


    def Label(self, *args) -> "TCollection_AsciiString":
        """
        Returns a text which defines the criterium applied by a selection (can be used to be printed, displayed ...) specific to each class.

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_Selection_Label(self, *args)


    def RootResult(self, *args) -> "Interface_EntityIterator":
        """
        Returns the list of selected entities, computed from input given as a graph. specific to each class of selection note that uniqueness of each entity is not required here this method can raise an exception as necessary.

        Parameters
        ----------
        G: Interface_Graph

        Returns
        -------
        Interface_EntityIterator

        """
        return _IFSelect.IFSelect_Selection_RootResult(self, *args)


    def UniqueResult(self, *args) -> "Interface_EntityIterator":
        """
        Returns the list of selected entities, each of them beeing unique. default definition works from rootresult. according hasuniqueresult, uniqueresult returns directly rootresult, or build a unique result from it with a graph.

        Parameters
        ----------
        G: Interface_Graph

        Returns
        -------
        Interface_EntityIterator

        """
        return _IFSelect.IFSelect_Selection_UniqueResult(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_Selection_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_Selection
    __del__ = lambda self: None
IFSelect_Selection_swigregister = _IFSelect.IFSelect_Selection_swigregister
IFSelect_Selection_swigregister(IFSelect_Selection)

class IFSelect_SelectionIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectionIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectionIterator, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an empty iterator, ready to be filled.

        Returns
        -------
        None

        Creates an iterator from a selection : it lists the selections from which <sel> depends (given by its method filliterator).

        Parameters
        ----------
        sel: IFSelect_Selection

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectionIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddFromIter(self, *args) -> "void":
        """
        Adds to an iterator the content of another one (each selection is present only once in the result).

        Parameters
        ----------
        iter: IFSelect_SelectionIterator

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectionIterator_AddFromIter(self, *args)


    def AddItem(self, *args) -> "void":
        """
        Adds a selection to an iterator (if not yet noted).

        Parameters
        ----------
        sel: IFSelect_Selection

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectionIterator_AddItem(self, *args)


    def AddList(self, *args) -> "void":
        """
        Adds a list of selections to an iterator (this list comes from the description of a selection or a dispatch, etc...).

        Parameters
        ----------
        list: IFSelect_TSeqOfSelection

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectionIterator_AddList(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """
        Returns true if there are more selections to get.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectionIterator_More(self, *args)


    def Next(self, *args) -> "void":
        """
        Sets iterator to the next item.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectionIterator_Next(self, *args)


    def Value(self, *args) -> "opencascade::handle< IFSelect_Selection > const &":
        """
        Returns the current selction beeing iterated error if count of selection has been passed.

        Returns
        -------
        opencascade::handle<IFSelect_Selection>

        """
        return _IFSelect.IFSelect_SelectionIterator_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectionIterator
    __del__ = lambda self: None
IFSelect_SelectionIterator_swigregister = _IFSelect.IFSelect_SelectionIterator_swigregister
IFSelect_SelectionIterator_swigregister(IFSelect_SelectionIterator)

class IFSelect_SessionDumper(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SessionDumper, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SessionDumper, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def First(*args) -> "opencascade::handle< IFSelect_SessionDumper >":
        """
        Returns the first item of the library of dumper. the next ones are then obtained by next on the returned items.

        Returns
        -------
        opencascade::handle<IFSelect_SessionDumper>

        """
        return _IFSelect.IFSelect_SessionDumper_First(*args)

    First = staticmethod(First)

    def Next(self, *args) -> "opencascade::handle< IFSelect_SessionDumper >":
        """
        Returns the next sesiondumper in the library. returns a null handle at the end.

        Returns
        -------
        opencascade::handle<IFSelect_SessionDumper>

        """
        return _IFSelect.IFSelect_SessionDumper_Next(self, *args)


    def ReadOwn(self, *args) -> "Standard_Boolean":
        """
        Recognizes a type (given as <type>) then creates an item of this type with the own parameter, as required. returns true if it has recognized the type (in this case, it is assumed to have created the item, returned as <item>), false else : in that case, sessionfile will try another sessiondumper in the library. readown can use these methods from sessionfile to access own parameters : nbownparams, isvoid, istext, textvalue, itemvalue.

        Parameters
        ----------
        file: IFSelect_SessionFile
        type: TCollection_AsciiString
        item: Standard_Transient

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SessionDumper_ReadOwn(self, *args)


    def WriteOwn(self, *args) -> "Standard_Boolean":
        """
        Writes the own parameters of a given item, if it forecast to manage its type. returns true if it has recognized the type of the item (in this case, it is assumed to have written the own parameters if there are some), false else : in that case, sessionfile will try another sessiondumper in the library. writeown can use these methods from sessionfile : sendvoid, senditem, sendtext, and if necessary, worksession.

        Parameters
        ----------
        file: IFSelect_SessionFile
        item: Standard_Transient

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SessionDumper_WriteOwn(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SessionDumper_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SessionDumper
    __del__ = lambda self: None
IFSelect_SessionDumper_swigregister = _IFSelect.IFSelect_SessionDumper_swigregister
IFSelect_SessionDumper_swigregister(IFSelect_SessionDumper)

def IFSelect_SessionDumper_First(*args) -> "opencascade::handle< IFSelect_SessionDumper >":
    """
    Returns the first item of the library of dumper. the next ones are then obtained by next on the returned items.

    Returns
    -------
    opencascade::handle<IFSelect_SessionDumper>

    """
    return _IFSelect.IFSelect_SessionDumper_First(*args)

class IFSelect_SessionFile(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SessionFile, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SessionFile, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a sessionfile, ready to read files in order to load them into a given worksession. the following read operations must then be called. it is also possible to perform a write, which produces a complete file of all the content of the worksession.

        Parameters
        ----------
        WS: IFSelect_WorkSession

        Returns
        -------
        None

        Creates a sessionfile which writes the content of a worksession to a file (directly calls write) then, isdone aknowledges on the result of the operation. but such a sessionfile may not read a file to a worksession.

        Parameters
        ----------
        WS: IFSelect_WorkSession
        filename: char *

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SessionFile(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddItem(self, *args) -> "void":
        """
        Adds an item to the worksession, taken as name the first item of the read line. if this name is not a name but a number or if this name is already recorded in the worksession, it adds the item but with no name. then the name is recorded in order to be used by the method itemvalue <active> commands to make <item> active or not in the session.

        Parameters
        ----------
        item: Standard_Transient
        active: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SessionFile_AddItem(self, *args)


    def AddLine(self, *args) -> "void":
        """
        Adds a line to the list of recorded lines.

        Parameters
        ----------
        line: char *

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SessionFile_AddLine(self, *args)


    def ClearLines(self, *args) -> "void":
        """
        Clears the lines recorded whatever for writing or for reading.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SessionFile_ClearLines(self, *args)


    def Destroy(self, *args) -> "void":
        """
        Specific destructor (closes the file if not yet done).

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SessionFile_Destroy(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the last read or write operation has been corectly performed. else returns false.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SessionFile_IsDone(self, *args)


    def IsText(self, *args) -> "Standard_Boolean":
        """
        Returns true if a parameter, in the own list (see nbownparams) is a text (between '...'). else it is an item (parameter, selection, dispatch ...), which can be void.

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SessionFile_IsText(self, *args)


    def IsVoid(self, *args) -> "Standard_Boolean":
        """
        Returns true if a parameter, given its rank in the own list (see nbownparams), is void. returns also true if <num> is out of range (undefined parameters).

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SessionFile_IsVoid(self, *args)


    def ItemValue(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Returns a parameter as an item. returns a null handle if the parameter is a text, or if it is defined as void.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _IFSelect.IFSelect_SessionFile_ItemValue(self, *args)


    def Line(self, *args) -> "TCollection_AsciiString const &":
        """
        Returns a line given its rank in the list of recorded lines.

        Parameters
        ----------
        num: int

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SessionFile_Line(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """
        Returns the count of recorded lines.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SessionFile_NbLines(self, *args)


    def NbParams(self, *args) -> "Standard_Integer":
        """
        During a read operation, sessionfile processes sequencially the items to read. for each one, it gives access to the list of its parameters : they were defined by calls to sendvoid/sendparam/sendtext during writing the file. nbparams returns the count of parameters for the line currently read.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SessionFile_NbParams(self, *args)


    def NewItem(self, *args) -> "void":
        """
        At beginning of writing an item, writes its basics : - either its name in the session if it has one - or its relative number of item in the file, else (preceeded by a '_') - then, its dynamic type (in the sense of cdl : pk_class) this basic description can be followed by the parameters which are used in the definition of the item.

        Parameters
        ----------
        ident: int
        par: Standard_Transient

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SessionFile_NewItem(self, *args)


    def ParamValue(self, *args) -> "TCollection_AsciiString const &":
        """
        Returns a parameter (alphanumeric item of a line) as it has been read.

        Parameters
        ----------
        num: int

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SessionFile_ParamValue(self, *args)


    def Read(self, *args) -> "Standard_Integer":
        """
        Performs a read operation from a file to a worksession i.e. calls readfile, then readsession and readend returned value is : 0 for ok, -1 file could not be opened, >0 error during read (see writesession) isdone can be called too (will return true for ok).

        Parameters
        ----------
        filename: char *

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SessionFile_Read(self, *args)


    def ReadEnd(self, *args) -> "Standard_Integer":
        """
        Reads the end of a file (its last line). returns 0 if ok, status >0 in case of error (not a suitable end line).

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SessionFile_ReadEnd(self, *args)


    def ReadFile(self, *args) -> "Standard_Boolean":
        """
        Reads the recorded lines from a file named <name>, after having cleared the list (stops if recognizefile fails) returns false (with no clearing) if the file could not be read.

        Parameters
        ----------
        name: char *

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SessionFile_ReadFile(self, *args)


    def ReadLine(self, *args) -> "Standard_Boolean":
        """
        Reads a line and splits it into a set of alphanumeric items, which can then be queried by nbparams/paramvalue ...

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SessionFile_ReadLine(self, *args)


    def ReadOwn(self, *args) -> "Standard_Boolean":
        """
        Tries to read an item, by calling the library of dumpers sets the list of parameters of the line to be read from the first own one.

        Parameters
        ----------
        item: Standard_Transient

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SessionFile_ReadOwn(self, *args)


    def ReadSession(self, *args) -> "Standard_Integer":
        """
        Performs a read operation from a file to a worksession, i.e. reads the list of line (which must have already been loaded, by readfile or by calls to addline) important remark : this excludes the reading of the last line, which is performed by readend returns 0 for ok, >0 status for read error (not a suitable file, or worksession given as immutable at creation time) isdone can be called too (will return true for ok).

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SessionFile_ReadSession(self, *args)


    def RecognizeFile(self, *args) -> "Standard_Boolean":
        """
        Recognizes the header line. returns true if ok, false else.

        Parameters
        ----------
        headerline: char *

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SessionFile_RecognizeFile(self, *args)


    def RemoveLastLine(self, *args) -> "void":
        """
        Removes the last line. can be called recursively. does nothing if the list is empty.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SessionFile_RemoveLastLine(self, *args)


    def SendItem(self, *args) -> "void":
        """
        During a write action, commands to send the identification of a parameter : if it is null (undefined) it is send as void ($) if it is named in the worksession, its name is sent preceeded by ':', else a relative ident number is sent preceeded by '#' (relative to the present write, i.e. starting at one, without skip, and counted part from named items).

        Parameters
        ----------
        par: Standard_Transient

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SessionFile_SendItem(self, *args)


    def SendText(self, *args) -> "void":
        """
        During a write action, commands to send a text without interpretation. it will be sent as well.

        Parameters
        ----------
        text: char *

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SessionFile_SendText(self, *args)


    def SendVoid(self, *args) -> "void":
        """
        During a write action, commands to send a void parameter i.e. a parameter which is present but undefined its form will be the dollar sign : $.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SessionFile_SendVoid(self, *args)


    def SetLastGeneral(self, *args) -> "void":
        """
        Sets the rank of last general parameter to a new value. it is followed by the fist own parameter of the item. used by sessionfile after reading general parameters.

        Parameters
        ----------
        lastgen: int

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SessionFile_SetLastGeneral(self, *args)


    def SetOwn(self, *args) -> "void":
        """
        Sets parameters to be sent as own if <mode> is true (their name or number or void mark or text value is preceeded by a column sign ':') else they are sent normally hence, the own parameter are clearly identified in the file.

        Parameters
        ----------
        mode: bool

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SessionFile_SetOwn(self, *args)


    def SplitLine(self, *args) -> "void":
        """
        Internal routine which processes a line into words and prepares its exploration.

        Parameters
        ----------
        line: char *

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SessionFile_SplitLine(self, *args)


    def TextValue(self, *args) -> "TCollection_AsciiString":
        """
        Returns the content of a text parameter (without the quotes). returns an empty string if the parameter is not a text.

        Parameters
        ----------
        num: int

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SessionFile_TextValue(self, *args)


    def WorkSession(self, *args) -> "opencascade::handle< IFSelect_WorkSession >":
        """
        Returns the worksession on which a sessionfile works. remark that it is returned as immutable.

        Returns
        -------
        opencascade::handle<IFSelect_WorkSession>

        """
        return _IFSelect.IFSelect_SessionFile_WorkSession(self, *args)


    def Write(self, *args) -> "Standard_Integer":
        """
        Performs a write operation from a worksession to a file i.e. calls writesession then writeend, and writefile returned value is : 0 for ok, -1 file could not be created, >0 error during write (see writesession) isdone can be called too (will return true for ok).

        Parameters
        ----------
        filename: char *

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SessionFile_Write(self, *args)


    def WriteEnd(self, *args) -> "Standard_Integer":
        """
        Writes the trailing line. it is separate from writesession, in order to allow to redefine writesession without touching writeend (writesession defines the body of the file) writeend fills the list of lines. returns a status of error, 0 if ok, >0 else.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SessionFile_WriteEnd(self, *args)


    def WriteFile(self, *args) -> "Standard_Boolean":
        """
        Writes the recorded lines to a file named <name> then clears the list of lines. returns false (with no clearing) if the file could not be created.

        Parameters
        ----------
        name: char *

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SessionFile_WriteFile(self, *args)


    def WriteLine(self, *args) -> "void":
        """
        Writes a line to the file. if <follow> is given, it is added at the following of the line. a newline must be added for the end.

        Parameters
        ----------
        line: char *
        follow: Standard_Character,optional
        	default value is 0

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SessionFile_WriteLine(self, *args)


    def WriteOwn(self, *args) -> "Standard_Boolean":
        """
        Writes the parameters own to each type of item. uses the library of sessiondumpers returns true if done, false if <item> could not be treated (hence it remains written with no own parameter).

        Parameters
        ----------
        item: Standard_Transient

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SessionFile_WriteOwn(self, *args)


    def WriteSession(self, *args) -> "Standard_Integer":
        """
        Prepares the write operation from a worksession (ifselect) to a file, i.e. fills the list of lines (the file itself remains to be written; or nblines/line may be called) important remark : this excludes the reading of the last line, which is performed by writeend returns 0 if ok, status > 0 in case of error.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SessionFile_WriteSession(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SessionFile
    __del__ = lambda self: None
IFSelect_SessionFile_swigregister = _IFSelect.IFSelect_SessionFile_swigregister
IFSelect_SessionFile_swigregister(IFSelect_SessionFile)

class IFSelect_ShareOut(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_ShareOut, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_ShareOut, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an empty shareout.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_ShareOut(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddDispatch(self, *args) -> "void":
        """
        Adds a dispatch to the list.

        Parameters
        ----------
        disp: IFSelect_Dispatch

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ShareOut_AddDispatch(self, *args)


    def AddModif(self, *args) -> "void":
        """
        Adds a modifier to the list of modifiers : model modifiers if <formodel> is true, file modifiers else (internal).

        Parameters
        ----------
        modifier: IFSelect_GeneralModifier
        formodel: bool
        atnum: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ShareOut_AddModif(self, *args)


    def AddModifier(self, *args) -> "void":
        """
        Sets a modifier to be applied on all dispatches to be run if <modifier> is a modelmodifier, adds it to the list of model modifiers; else to the list of file modifiers by default (atnum = 0) at the end of the list, else at <atnum> each modifier is used, after each copy of a packet of entities into a model : its criteria are checked and if they are ok, the method perform of this modifier is run.

        Parameters
        ----------
        modifier: IFSelect_GeneralModifier
        atnum: int

        Returns
        -------
        None

        Sets a modifier to be applied on the dispatch <dispnum> if <modifier> is a modelmodifier, adds it to the list of model modifiers; else to the list of file modifiers this is the same list as for all dispatches, but the modifier is qualified to be applied to one dispatch only then, <atnum> refers to the entire list by default (atnum = 0) at the end of the list, else at <atnum> remark : if the modifier was already in the list and if <atnum> = 0, the modifier is not moved, but only qualified for a dispatch.

        Parameters
        ----------
        modifier: IFSelect_GeneralModifier
        dispnum: int
        atnum: int

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ShareOut_AddModifier(self, *args)


    def ChangeModifierRank(self, *args) -> "Standard_Boolean":
        """
        Changes the rank of a modifier in the list : model modifiers if <formodel> is true, file modifiers else from <before> to <after> returns true if done, false else (before or after out of range).

        Parameters
        ----------
        formodel: bool
        befor: int
        after: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ShareOut_ChangeModifierRank(self, *args)


    def Clear(self, *args) -> "void":
        """
        Removes in one operation all the dispatches with their idents also clears all informations about names, and all results but naming informations which are : - kept if <onlydisp> is true. - cleared if <onlydisp> is false (complete clearing) if <onlydisp> is true, that's all. else, clears also modifiers.

        Parameters
        ----------
        onlydisp: bool

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ShareOut_Clear(self, *args)


    def ClearResult(self, *args) -> "void":
        """
        Clears all data produced (apart from dispatches, etc...) if <alsoname> is true, all is cleared. else, informations about produced names are kept (to maintain unicity of naming across clearings).

        Parameters
        ----------
        alsoname: bool

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ShareOut_ClearResult(self, *args)


    def DefaultRootName(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Returns the default root name. can be empty.

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _IFSelect.IFSelect_ShareOut_DefaultRootName(self, *args)


    def Dispatch(self, *args) -> "opencascade::handle< IFSelect_Dispatch > const &":
        """
        Returns a dispatch, given its rank in the list.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<IFSelect_Dispatch>

        """
        return _IFSelect.IFSelect_ShareOut_Dispatch(self, *args)


    def DispatchRank(self, *args) -> "Standard_Integer":
        """
        Returns the rank of a dispatch, given its value (handle). returns 0 if the dispatch is unknown in the shareout.

        Parameters
        ----------
        disp: IFSelect_Dispatch

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_ShareOut_DispatchRank(self, *args)


    def Extension(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Returns the general extension. can be empty (not recommanded).

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _IFSelect.IFSelect_ShareOut_Extension(self, *args)


    def FileName(self, *args) -> "TCollection_AsciiString":
        """
        Computes the complete file name for a packet of a dispatch, given dispatch number (rank), packet number, and count of packets generated by this dispatch (0 if unknown) //! file name is made of following strings, concatenated : general prefix, root name for dispatch, packet suffix, and general extension. if no root name is specified for a dispatch, defaultrootname is considered (and pnum is not used, but <thenbdefs> is incremented and used error if no root is defined for this <idnum>.

        Parameters
        ----------
        dnum: int
        pnum: int
        nbpack: int,optional
        	default value is 0

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_ShareOut_FileName(self, *args)


    def GeneralModifier(self, *args) -> "opencascade::handle< IFSelect_GeneralModifier >":
        """
        Returns a modifier of the list, given its rank : model modifiers if <formodel> is true, file modifiers else.

        Parameters
        ----------
        formodel: bool
        num: int

        Returns
        -------
        opencascade::handle<IFSelect_GeneralModifier>

        """
        return _IFSelect.IFSelect_ShareOut_GeneralModifier(self, *args)


    def HasRootName(self, *args) -> "Standard_Boolean":
        """
        Returns true if the dispatch of rank <num> has an attached root name. false else, or if num is out of range.

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ShareOut_HasRootName(self, *args)


    def LastRun(self, *args) -> "Standard_Integer":
        """
        Returns the rank of last run item (clearresult resets it to 0).

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_ShareOut_LastRun(self, *args)


    def ModelModifier(self, *args) -> "opencascade::handle< IFSelect_Modifier >":
        """
        Returns a modifier of the list of model modifiers, duely casted.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<IFSelect_Modifier>

        """
        return _IFSelect.IFSelect_ShareOut_ModelModifier(self, *args)


    def ModifierRank(self, *args) -> "Standard_Integer":
        """
        Gives the rank of a modifier in the list, 0 if not in the list model modifiers if <modifier> is kind of modelmodifer, file modifiers else.

        Parameters
        ----------
        modifier: IFSelect_GeneralModifier

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_ShareOut_ModifierRank(self, *args)


    def NbDispatches(self, *args) -> "Standard_Integer":
        """
        Returns the count of dispatches.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_ShareOut_NbDispatches(self, *args)


    def NbModifiers(self, *args) -> "Standard_Integer":
        """
        Returns count of modifiers (which apply to complete models) : model modifiers if <formodel> is true, file modifiers else.

        Parameters
        ----------
        formodel: bool

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_ShareOut_NbModifiers(self, *args)


    def Prefix(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Returns the general prefix. can be empty.

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _IFSelect.IFSelect_ShareOut_Prefix(self, *args)


    def RemoveDispatch(self, *args) -> "Standard_Boolean":
        """
        Removes a dispatch, given its rank in the list returns true if done, false if rank is not between (lastrun + 1) and (nbdispatches).

        Parameters
        ----------
        rank: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ShareOut_RemoveDispatch(self, *args)


    def RemoveItem(self, *args) -> "Standard_Boolean":
        """
        Removes an item, which can be, either a dispatch (removed from the list of dispatches), or a generalmodifier (removed from the list of model modifiers or from the list of file modifiers according to its type). returns true if done, false if has not been found or if it is neither a dispatch, nor a modifier.

        Parameters
        ----------
        item: Standard_Transient

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ShareOut_RemoveItem(self, *args)


    def RemoveModifier(self, *args) -> "Standard_Boolean":
        """
        Removes a modifier, given it rank in the list : model modifiers if <formodel> is true, file modifiers else returns true if done, false if <num> is out of range.

        Parameters
        ----------
        formodel: bool
        num: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ShareOut_RemoveModifier(self, *args)


    def RootName(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Returns the root bound to a dispatch, given its rank returns a null handle if not defined.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _IFSelect.IFSelect_ShareOut_RootName(self, *args)


    def RootNumber(self, *args) -> "Standard_Integer":
        """
        Returns an integer value about a given root name : - positive : it's the rank of the dispatch which has this name - null : this root name is unknown - negative (-1) : this root name is the default root name.

        Parameters
        ----------
        name: TCollection_HAsciiString

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_ShareOut_RootNumber(self, *args)


    def SetDefaultRootName(self, *args) -> "Standard_Boolean":
        """
        Defines or changes the default root name to a new value (which is used for dispatches which have no attached root name). if this method is not called, defaultrootname remains empty returns true if ok, false if this name is already attached, for a dispatch or for default.

        Parameters
        ----------
        defrt: TCollection_HAsciiString

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ShareOut_SetDefaultRootName(self, *args)


    def SetExtension(self, *args) -> "void":
        """
        Defines or changes the general extension (which is appended to complete file name generated). if this method is not call, extension remains empty.

        Parameters
        ----------
        ext: TCollection_HAsciiString

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ShareOut_SetExtension(self, *args)


    def SetLastRun(self, *args) -> "void":
        """
        Records a new alue for the rank of last run item.

        Parameters
        ----------
        last: int

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ShareOut_SetLastRun(self, *args)


    def SetPrefix(self, *args) -> "void":
        """
        Defines or changes the general prefix (which is prepended to complete file name generated). if this method is not call, prefix remains empty.

        Parameters
        ----------
        pref: TCollection_HAsciiString

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ShareOut_SetPrefix(self, *args)


    def SetRootName(self, *args) -> "Standard_Boolean":
        """
        Attaches a root name to a dispatch given its rank, as an hasciistring (standard form). a null handle resets this name. returns true if ok, false if this name is already attached, for a dispatch or for default, or <num> out of range.

        Parameters
        ----------
        num: int
        name: TCollection_HAsciiString

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ShareOut_SetRootName(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_ShareOut_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_ShareOut
    __del__ = lambda self: None
IFSelect_ShareOut_swigregister = _IFSelect.IFSelect_ShareOut_swigregister
IFSelect_ShareOut_swigregister(IFSelect_ShareOut)

class IFSelect_ShareOutResult(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_ShareOutResult, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_ShareOutResult, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a shareoutresult from a shareout, to work on a model (without any more precision; uses active protocol).

        Parameters
        ----------
        sho: IFSelect_ShareOut
        mod: Interface_InterfaceModel

        Returns
        -------
        None

        Creates a shareoutresult from a shareout, to work on a graph already computed, which defines the input model and can specialize some entities.

        Parameters
        ----------
        sho: IFSelect_ShareOut
        G: Interface_Graph

        Returns
        -------
        None

        Creates a shareoutresult from a unique dispatch, to work on a model. as if it was a shareout with only one dispatch (without any more precision; uses active protocol) allows to compute the effect of a single dispatch.

        Parameters
        ----------
        disp: IFSelect_Dispatch
        mod: Interface_InterfaceModel

        Returns
        -------
        None

        Creates a shareoutresult from a unique dispatch, to work on a graph. as if it was a shareout with only one dispatch allows to compute the effect of a single dispatch.

        Parameters
        ----------
        disp: IFSelect_Dispatch
        G: Interface_Graph

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_ShareOutResult(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Dispatch(self, *args) -> "opencascade::handle< IFSelect_Dispatch >":
        """
        Returns the current dispatch.

        Returns
        -------
        opencascade::handle<IFSelect_Dispatch>

        """
        return _IFSelect.IFSelect_ShareOutResult_Dispatch(self, *args)


    def DispatchRank(self, *args) -> "Standard_Integer":
        """
        Returns the rank of the current dispatch in the shareout returns zero if there is none (iteration finished).

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_ShareOutResult_DispatchRank(self, *args)


    def Evaluate(self, *args) -> "void":
        """
        Evaluates the result of a shareout : determines entities to be forgotten by the shareout, entities to be transferred several times (duplicated), prepares an iteration on the packets to be produced called the first time anyone question is asked, or after a call to reset. works by calling the method prepare.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ShareOutResult_Evaluate(self, *args)


    def FileName(self, *args) -> "TCollection_AsciiString":
        """
        Returns the file name which corresponds to current packet (computed by shareout) if current packet has no associated name (see shareout), the returned value is null.

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_ShareOutResult_FileName(self, *args)


    def Graph(self, *args) -> "Interface_Graph const &":
        """
        Returns the graph used to create theshareoutresult.

        Returns
        -------
        Interface_Graph

        """
        return _IFSelect.IFSelect_ShareOutResult_Graph(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """
        Returns true if there is more packets in the current dispatch, else if there is more dispatch in the shareout.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_ShareOutResult_More(self, *args)


    def NbPackets(self, *args) -> "Standard_Integer":
        """
        Returns the total count of produced non empty packets (in out : calls evaluate as necessary).

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_ShareOutResult_NbPackets(self, *args)


    def Next(self, *args) -> "void":
        """
        Passes to the next packet in the current dispatch, or if there is none, to the next dispatch in the shareout.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ShareOutResult_Next(self, *args)


    def NextDispatch(self, *args) -> "void":
        """
        Passes to the next dispatch, regardless about remaining packets.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ShareOutResult_NextDispatch(self, *args)


    def PacketContent(self, *args) -> "Interface_EntityIterator":
        """
        Returns the complete content of the current packet (i.e. with shared entities, which will also be put in the file).

        Returns
        -------
        Interface_EntityIterator

        """
        return _IFSelect.IFSelect_ShareOutResult_PacketContent(self, *args)


    def PacketRoot(self, *args) -> "Interface_EntityIterator":
        """
        Returns the list of roots of the current packet (never empty) (i.e. the entities to be themselves asked for transfer) error if there is none (iteration finished).

        Returns
        -------
        Interface_EntityIterator

        """
        return _IFSelect.IFSelect_ShareOutResult_PacketRoot(self, *args)


    def Packets(self, *args) -> "opencascade::handle< IFSelect_PacketList >":
        """
        Returns the list of recorded packets, under two modes : - <complete> = false, the strict definition of packets, i.e. for each one, the root entities, to be explicitely sent - <complete> = true (default), the completely evaluated list, i.e. which really gives the destination of each entity : this mode allows to evaluate duplications remark that to send packets, iteration remains preferable (file names are managed).

        Parameters
        ----------
        complete: bool,optional
        	default value is Standard_True

        Returns
        -------
        opencascade::handle<IFSelect_PacketList>

        """
        return _IFSelect.IFSelect_ShareOutResult_Packets(self, *args)


    def PacketsInDispatch(self, *args) -> "void":
        """
        Returns number (rank) of current packet in current dispatch, and total count of packets in current dispatch, as arguments.

        Parameters
        ----------

        Returns
        -------
        numpack: int
        nbpacks: int

        """
        return _IFSelect.IFSelect_ShareOutResult_PacketsInDispatch(self, *args)


    def Prepare(self, *args) -> "void":
        """
        Prepares the iteration on the packets this method is called by evaluate, but can be called anytime the iteration consists in taking each dispatch of the shareout beginning by the first one, compute its packets, then iterate on these packets. once all these packets are iterated, the iteration passes to the next dispatch, or stops. for a creation from a unique dispatch, same but with only this dispatch. each packet can be listed, or really transferred (producing a derived model, from which a file can be generated) //! prepare sets the iteration to the first dispatch, first packet.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ShareOutResult_Prepare(self, *args)


    def Reset(self, *args) -> "void":
        """
        Erases computed data, in order to command a new evaluation.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ShareOutResult_Reset(self, *args)


    def ShareOut(self, *args) -> "opencascade::handle< IFSelect_ShareOut >":
        """
        Returns the shareout used to create the shareoutresult if creation from a dispatch, returns a null handle.

        Returns
        -------
        opencascade::handle<IFSelect_ShareOut>

        """
        return _IFSelect.IFSelect_ShareOutResult_ShareOut(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_ShareOutResult
    __del__ = lambda self: None
IFSelect_ShareOutResult_swigregister = _IFSelect.IFSelect_ShareOutResult_swigregister
IFSelect_ShareOutResult_swigregister(IFSelect_ShareOutResult)

class IFSelect_Signature(OCC.Core.Interface.Interface_SignType):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Interface.Interface_SignType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_Signature, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Interface.Interface_SignType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_Signature, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AddCase(self, *args) -> "void":
        """
        Adds a possible case to be called when creating, if the list of possible cases for value is known when starting for instance, for cdl types, rather do not fill this, but for a specific enumeration (such as a status), can be used.

        Parameters
        ----------
        acase: char *

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_Signature_AddCase(self, *args)


    def CaseList(self, *args) -> "opencascade::handle< TColStd_HSequenceOfAsciiString >":
        """
        Returns the predefined list of possible cases, filled by addcase null handle if no predefined list (hence, to be counted) useful to filter on really possible vase, for instance, or for a help.

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfAsciiString>

        """
        return _IFSelect.IFSelect_Signature_CaseList(self, *args)


    def IntValue(*args) -> "char const *":
        """
        This procedure converts an integer to a cstring it is a convenient way when the value of a signature has the form of a simple integer value the value is to be used immediately (one buffer only, no copy).

        Parameters
        ----------
        val: int

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_Signature_IntValue(*args)

    IntValue = staticmethod(IntValue)

    def IsIntCase(self, *args) -> "Standard_Boolean":
        """
        Tells if this signature gives integer values and returns values from setintcase if true.

        Parameters
        ----------

        Returns
        -------
        hasmin: bool
        valmin: int
        hasmax: bool
        valmax: int

        """
        return _IFSelect.IFSelect_Signature_IsIntCase(self, *args)


    def Label(self, *args) -> "TCollection_AsciiString":
        """
        The label of a signature uses its name as follow : 'signature : <name>'.

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_Signature_Label(self, *args)


    def MatchValue(*args) -> "Standard_Boolean":
        """
        Default procedure to tell if a value <val> matches a text with a criterium <exact>. <exact> = true requires equality, else only contained (no reg-exp).

        Parameters
        ----------
        val: char *
        text: TCollection_AsciiString
        exact: bool

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_Signature_MatchValue(*args)

    MatchValue = staticmethod(MatchValue)

    def Matches(self, *args) -> "Standard_Boolean":
        """
        Tells if the value for <ent> in <model> matches a text, with a criterium <exact>. the default definition calls matchvalue can be redefined.

        Parameters
        ----------
        ent: Standard_Transient
        model: Interface_InterfaceModel
        text: TCollection_AsciiString
        exact: bool

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_Signature_Matches(self, *args)


    def SetIntCase(self, *args) -> "void":
        """
        Sets the information data to tell 'integer cases' with possible min and max values to be called when creating.

        Parameters
        ----------
        hasmin: bool
        valmin: int
        hasmax: bool
        valmax: int

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_Signature_SetIntCase(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_Signature_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_Signature
    __del__ = lambda self: None
IFSelect_Signature_swigregister = _IFSelect.IFSelect_Signature_swigregister
IFSelect_Signature_swigregister(IFSelect_Signature)

def IFSelect_Signature_IntValue(*args) -> "char const *":
    """
    This procedure converts an integer to a cstring it is a convenient way when the value of a signature has the form of a simple integer value the value is to be used immediately (one buffer only, no copy).

    Parameters
    ----------
    val: int

    Returns
    -------
    char *

    """
    return _IFSelect.IFSelect_Signature_IntValue(*args)

def IFSelect_Signature_MatchValue(*args) -> "Standard_Boolean":
    """
    Default procedure to tell if a value <val> matches a text with a criterium <exact>. <exact> = true requires equality, else only contained (no reg-exp).

    Parameters
    ----------
    val: char *
    text: TCollection_AsciiString
    exact: bool

    Returns
    -------
    bool

    """
    return _IFSelect.IFSelect_Signature_MatchValue(*args)

class IFSelect_SignatureList(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SignatureList, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SignatureList, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a signaturelist. if <withlist> is true, entities will be not only counted per signature, but also listed.

        Parameters
        ----------
        withlist: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SignatureList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args) -> "void":
        """
        Adds an entity with its signature, i.e. : - counts an item more for <sign> - if record-list status is set, records the entity accepts a null entity (the signature is then for the global model). but if the string is empty, counts a null item. //! if signonly mode is set, this work is replaced by just setting lastvalue.

        Parameters
        ----------
        ent: Standard_Transient
        sign: char *

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SignatureList_Add(self, *args)


    def Clear(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SignatureList_Clear(self, *args)


    def Entities(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        Returns the list of entities attached to a signature it is empty if <sign> has not been recorded it is a null handle if the list of entities is not known.

        Parameters
        ----------
        sign: char *

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfTransient>

        """
        return _IFSelect.IFSelect_SignatureList_Entities(self, *args)


    def HasEntities(self, *args) -> "Standard_Boolean":
        """
        Returns true if the list of entities is aknowledged, else the method entities will always return a null handle.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SignatureList_HasEntities(self, *args)


    def Init(self, *args) -> "void":
        """
        Aknowledges the list in once. name identifies the signature.

        Parameters
        ----------
        name: char *
        count: NCollection_IndexedDataMap<TCollection_AsciiString, int>
        list: Standard_Transient
        nbnuls: int

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SignatureList_Init(self, *args)


    def LastValue(self, *args) -> "char const *":
        """
        Returns the last value recorded by add (only if signmode set) cleared by clear or init.

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_SignatureList_LastValue(self, *args)


    def List(self, *args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """
        Returns the list of signatures, as a sequence of strings (but without their respective counts). it is ordered. by default, for all the signatures. if <root> is given non empty, for the signatures which begin by <root>.

        Parameters
        ----------
        root: char *,optional
        	default value is 

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfHAsciiString>

        """
        return _IFSelect.IFSelect_SignatureList_List(self, *args)


    def GetModeSignOnly(self) -> "Standard_Boolean":
        """GetModeSignOnly(IFSelect_SignatureList self) -> Standard_Boolean"""
        return _IFSelect.IFSelect_SignatureList_GetModeSignOnly(self)


    def SetModeSignOnly(self, value: 'Standard_Boolean') -> "void":
        """SetModeSignOnly(IFSelect_SignatureList self, Standard_Boolean value)"""
        return _IFSelect.IFSelect_SignatureList_SetModeSignOnly(self, value)


    def Name(self, *args) -> "char const *":
        """
        Returns the recorded name. remark : default is '...' (no setname called).

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_SignatureList_Name(self, *args)


    def NbNulls(self, *args) -> "Standard_Integer":
        """
        Returns the count of null entities.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SignatureList_NbNulls(self, *args)


    def NbTimes(self, *args) -> "Standard_Integer":
        """
        Returns the number of times a signature was counted, 0 if it has not been recorded at all.

        Parameters
        ----------
        sign: char *

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SignatureList_NbTimes(self, *args)


    def PrintCountToString(self) -> "std::string":
        """PrintCountToString(IFSelect_SignatureList self) -> std::string"""
        return _IFSelect.IFSelect_SignatureList_PrintCountToString(self)


    def PrintSumToString(self) -> "std::string":
        """PrintSumToString(IFSelect_SignatureList self) -> std::string"""
        return _IFSelect.IFSelect_SignatureList_PrintSumToString(self)


    def SetList(self, *args) -> "void":
        """
        Changes the record-list status. the list is not cleared but its use changes.

        Parameters
        ----------
        withlist: bool

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SignatureList_SetList(self, *args)


    def SetName(self, *args) -> "void":
        """
        Defines a name for a signaturelist (used to print it).

        Parameters
        ----------
        name: char *

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SignatureList_SetName(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SignatureList_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SignatureList
    __del__ = lambda self: None
IFSelect_SignatureList_swigregister = _IFSelect.IFSelect_SignatureList_swigregister
IFSelect_SignatureList_swigregister(IFSelect_SignatureList)

class IFSelect_Transformer(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_Transformer, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_Transformer, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ChangeProtocol(self, *args) -> "Standard_Boolean":
        """
        This methods allows to declare that the protocol applied to the new model has changed. it applies to the last call to perform. //! returns true if the protocol has changed, false else. the provided default keeps the starting protocol. this method should be redefined as required by the effect of perform.

        Parameters
        ----------
        newproto: Interface_Protocol

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_Transformer_ChangeProtocol(self, *args)


    def Label(self, *args) -> "TCollection_AsciiString":
        """
        Returns a text which defines the way a transformer works (to identify the transformation it performs).

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_Transformer_Label(self, *args)


    def Perform(self, *args) -> "Standard_Boolean":
        """
        Performs a transformation (defined by each sub-class) : <g> gives the input data (especially the starting model) and can be used for queries (by selections, etc...) <protocol> allows to work with general services as necessary (it applies to input data) if the change corresponds to a conversion to a new protocol, see also the method changeprotocol <checks> stores produced checks messages if any <newmod> gives the result of the transformation : - if it is null (i.e. has not been affected), the transformation has been made on the spot, it is assumed to cause no change to the graph of dependances - if it equates the starting model, it has been transformed on the spot (possibiliy some entities were replaced inside it) - if it is new, it corresponds to a new data set which replaces the starting one //! <self> is mutable to allow results for changeprotocol to be memorized if needed, and to store informations useful for the method updated //! returns true if done, false if an error occured : in this case, if a new data set has been produced, the transformation is ignored, else data may be corrupted.

        Parameters
        ----------
        G: Interface_Graph
        protocol: Interface_Protocol
        checks: Interface_CheckIterator
        newmod: Interface_InterfaceModel

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_Transformer_Perform(self, *args)


    def Updated(self, *args) -> "Standard_Boolean":
        """
        This method allows to know what happened to a starting entity after the last perform. if <entfrom> (from starting model) has one and only one known item which corresponds in the new produced model, this method must return true and fill the argument <entto>. else, it returns false.

        Parameters
        ----------
        entfrom: Standard_Transient
        entto: Standard_Transient

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_Transformer_Updated(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_Transformer_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_Transformer
    __del__ = lambda self: None
IFSelect_Transformer_swigregister = _IFSelect.IFSelect_Transformer_swigregister
IFSelect_Transformer_swigregister(IFSelect_Transformer)

class IFSelect_WorkLibrary(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_WorkLibrary, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_WorkLibrary, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def CopyModel(self, *args) -> "Standard_Boolean":
        """
        Performs the copy of entities from an original model to a new one. it must also copy headers if any. returns true when done. the provided default works by copying the individual entities designated in the list, by using the general service class copytool. it can be redefined for a norm which, either implements copy by another way (do not forget to bind each copied result with its original entity in tc) and returns true, or does not know how to copy and returns false.

        Parameters
        ----------
        original: Interface_InterfaceModel
        newmodel: Interface_InterfaceModel
        list: Interface_EntityIterator
        TC: Interface_CopyTool

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkLibrary_CopyModel(self, *args)


    def DumpHelp(self, *args) -> "char const *":
        """
        Returns the help line recorded for <level>, or an empty string.

        Parameters
        ----------
        level: int

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_WorkLibrary_DumpHelp(self, *args)


    def DumpLevels(self, *args) -> "void":
        """
        Returns the recorded default and maximum dump levels if none was recorded, max is returned negative, def as zero.

        Parameters
        ----------

        Returns
        -------
        def: int
        max: int

        """
        return _IFSelect.IFSelect_WorkLibrary_DumpLevels(self, *args)


    def ReadFile(self, *args) -> "Standard_Integer":
        """
        Gives the way to read a file and transfer it to a model <mod> is the resulting model, which has to be created by this method. in case of error, <mod> must be returned null return value is a status with free values. simply, 0 is for 'execution ok' the protocol can be used to work (e.g. create the model, read and recognize the entities).

        Parameters
        ----------
        name: char *
        model: Interface_InterfaceModel
        protocol: Interface_Protocol

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkLibrary_ReadFile(self, *args)


    def ReadStream(self, *args) -> "Standard_Integer":
        """
        Interface to read a data from the specified stream. @param model is the resulting model, which has to be created by this method. in case of error, model must be returned null return value is a status: 0 - ok, 1 - read failure, -1 - stream failure. default implementation returns 1 (error).

        Parameters
        ----------
        theName: char *
        theIStream: std::istream
        model: Interface_InterfaceModel
        protocol: Interface_Protocol

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkLibrary_ReadStream(self, *args)


    def SetDumpHelp(self, *args) -> "void":
        """
        Records a short line of help for a level (0 - max).

        Parameters
        ----------
        level: int
        help: char *

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkLibrary_SetDumpHelp(self, *args)


    def SetDumpLevels(self, *args) -> "void":
        """
        Records a default level and a maximum value for level level for dumpentity can go between 0 and <max> default value will be <def>.

        Parameters
        ----------
        def: int
        max: int

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkLibrary_SetDumpLevels(self, *args)


    def WriteFile(self, *args) -> "Standard_Boolean":
        """
        Gives the way to write a file from a model. <ctx> contains all necessary informations : the model, the protocol, the file name, and the list of file modifiers to be applied, also with restricted list of selected entities for each one, if required. in return, it brings the produced check-list //! the worklibrary has to query <applied> to get then run the contextwrite by looping like this (example) : for (numap = 1; numap <= ctx.nbmodifiers(); numap ++) { ctx.setmodifier (numap); cast ctx.filemodifier() to specific type -> variable filemod if (!filemod.isnull()) filemod->perform (ctx,writer); filemod then works with ctx. it can, either act on the model itself (for instance on its header), or iterate on selected entities (start/next/more/value) it can call addfail or addwarning, as necessary }.

        Parameters
        ----------
        ctx: IFSelect_ContextWrite

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkLibrary_WriteFile(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_WorkLibrary_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_WorkLibrary
    __del__ = lambda self: None
IFSelect_WorkLibrary_swigregister = _IFSelect.IFSelect_WorkLibrary_swigregister
IFSelect_WorkLibrary_swigregister(IFSelect_WorkLibrary)

class IFSelect_WorkSession(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_WorkSession, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_WorkSession, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a work session it provides default, empty shareout and modelcopier, which can be replaced (if required, should be done just after creation).

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_WorkSession(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddItem(self, *args) -> "Standard_Integer":
        """
        Adds an item and returns its attached ident. does nothing if <item> is already recorded (and returns its attached ident) <active> if true commands call to setactive (see below) remark : the determined ident is used if <item> is a dispatch, to fill the shareout.

        Parameters
        ----------
        item: Standard_Transient
        active: bool,optional
        	default value is Standard_True

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_AddItem(self, *args)


    def AddNamedItem(self, *args) -> "Standard_Integer":
        """
        Adds an item with an attached name. if the name is already known in the worksession, the older item losts it returns ident if done, 0 else, i.e. if <item> is null if <name> is empty, works as additem (i.e. with no name) if <item> is already known but with no attached name, this method tries to attached a name to it <active> if true commands call to setactive (see below).

        Parameters
        ----------
        name: char *
        item: Standard_Transient
        active: bool,optional
        	default value is Standard_True

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_AddNamedItem(self, *args)


    def AppliedDispatches(self, *args) -> "opencascade::handle< TColStd_HSequenceOfInteger >":
        """
        Returns the ordered list of dispatches stored by the shareout.

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfInteger>

        """
        return _IFSelect.IFSelect_WorkSession_AppliedDispatches(self, *args)


    def BeginSentFiles(self, *args) -> "void":
        """
        Commands file sending to clear the list of already sent files, commands to record a new one if <record> is true this list is managed by the modelcopier when sendsplit is called it allows a global exploitation of the set of sent files.

        Parameters
        ----------
        record: bool

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_BeginSentFiles(self, *args)


    def CategoryName(self, *args) -> "char const *":
        """
        Returns the category name determined for an entity it is computed by the class category remark : an unknown entity gives an empty string.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_WorkSession_CategoryName(self, *args)


    def CategoryNumber(self, *args) -> "Standard_Integer":
        """
        Returns the category number determined for an entity it is computed by the class category an unknown entity (number 0) gives a value -1.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_CategoryNumber(self, *args)


    def ChangeModifierRank(self, *args) -> "Standard_Boolean":
        """
        Changes the rank of a modifier in the session : model modifiers if <formodel> is true, file modifiers else the modifier n0 <before> is put to n0 <after> return true if done, false if <before> or <after> out of range.

        Parameters
        ----------
        formodel: bool
        before: int
        after: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_ChangeModifierRank(self, *args)


    def CheckOne(self, *args) -> "Interface_CheckIterator":
        """
        Returns a check for a single entity, under the form of a checkiterator (this gives only one form for the user) if <ent> is null or equates the current model, it gives the global check, else the check for the given entity <complete> as for modelchecklist.

        Parameters
        ----------
        ent: Standard_Transient
        complete: bool,optional
        	default value is Standard_True

        Returns
        -------
        Interface_CheckIterator

        """
        return _IFSelect.IFSelect_WorkSession_CheckOne(self, *args)


    def ClearData(self, *args) -> "void":
        """
        Clears recorded data (not the items) according mode : 1 : all data : model, graph, checklist, + cleardata 4 2 : graph and checklist (they will then be recomputed later) 3 : checklist (it will be recomputed by computecheck) 4 : just content of selectpointed and counters plus 0 : does nothing but called by setmodel cleardata is virtual, hence it can be redefined to clear other data of a specialised work session.

        Parameters
        ----------
        mode: int

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_ClearData(self, *args)


    def ClearFile(self, *args) -> "void":
        """
        Erases all stored data from the file evaluation (i.e. all former naming informations are lost).

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_ClearFile(self, *args)


    def ClearFinalModifiers(self, *args) -> "void":
        """
        Removes all the modifiers active in the modelcopier : they become inactive and they are removed from the session.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_ClearFinalModifiers(self, *args)


    def ClearItems(self, *args) -> "void":
        """
        Clears all the recorded items : selections, dispatches, modifiers, and strings & intparams, with their idents & names. remark that if a model has been loaded, it is not cleared.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_ClearItems(self, *args)


    def ClearShareOut(self, *args) -> "void":
        """
        Clears the list of dispatches recorded by the shareout if <only> disp is true, tha's all. else, clears also the lists of modifiers recorded by the shareout.

        Parameters
        ----------
        onlydisp: bool

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_ClearShareOut(self, *args)


    def CombineAdd(self, *args) -> "Standard_Integer":
        """
        Adds an input selection to a selectcombine (union or inters.). returns new count of inputs for this selectcombine if done or 0 if <sel> is not kind of selectcombine, or if <seladd> or <sel> is not in the worksession by default, adding is done at the end of the list else, it is an insertion to rank <atnum> (usefull for un-redo).

        Parameters
        ----------
        selcomb: IFSelect_Selection
        seladd: IFSelect_Selection
        atnum: int,optional
        	default value is 0

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_CombineAdd(self, *args)


    def CombineRemove(self, *args) -> "Standard_Boolean":
        """
        Removes an input selection from a selectcombine (union or intersection). returns true if done, false if <selcomb> is not kind of selectcombine or <selrem> is not source of <selcomb>.

        Parameters
        ----------
        selcomb: IFSelect_Selection
        selrem: IFSelect_Selection

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_CombineRemove(self, *args)


    def ComputeCheck(self, *args) -> "Standard_Boolean":
        """
        Computes the checklist for the model currently loaded it can then be used for displays, querries ... returns true if ok, false else (i.e. no protocol set, or model absent). if <enforce> is false, works only if not already done or if a new model has been loaded from last call. remark : computation is enforced by every call to setmodel or runtransformer.

        Parameters
        ----------
        enforce: bool,optional
        	default value is Standard_False

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_ComputeCheck(self, *args)


    def ComputeCounter(self, *args) -> "Standard_Boolean":
        """
        Computes the content of a signcounter when it is defined with a selection, then returns true returns false if the signcounter is not defined with a selection, or if its selection mode is inhibited <forced> to work around optimisations.

        Parameters
        ----------
        counter: IFSelect_SignCounter
        forced: bool,optional
        	default value is Standard_False

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_ComputeCounter(self, *args)


    def ComputeCounterFromList(self, *args) -> "Standard_Boolean":
        """
        Computes the content of a signcounter from an input list if <list> is null, uses internal definition of the counter : a selection, else the whole model (recomputation forced) if <clear> is true (d), starts from scratch else, cumulates computations.

        Parameters
        ----------
        counter: IFSelect_SignCounter
        list: TColStd_HSequenceOfTransient
        clear: bool,optional
        	default value is Standard_True

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_ComputeCounterFromList(self, *args)


    def ComputeGraph(self, *args) -> "Standard_Boolean":
        """
        Computes the graph used for selections, displays ... if a hgraph is already set, with same model as given by method model, does nothing. else, computes a new graph. if <enforce> is given true, computes a new graph anyway. remark that a call to cleargraph will cause computegraph to really compute a new graph returns true if graph is ok, false else (i.e. if no protocol is set, or if model is absent or empty).

        Parameters
        ----------
        enforce: bool,optional
        	default value is Standard_False

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_ComputeGraph(self, *args)


    def DefaultFileRoot(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Returns the defined default file root. it is used for dispatches which have no specific root attached. null handle if not defined.

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _IFSelect.IFSelect_WorkSession_DefaultFileRoot(self, *args)


    def Dispatch(self, *args) -> "opencascade::handle< IFSelect_Dispatch >":
        """
        Returns a dispatch, given its ident in the session null result if <id> is not suitable for a dispatch (undefined, or defined for another kind of variable).

        Parameters
        ----------
        id: int

        Returns
        -------
        opencascade::handle<IFSelect_Dispatch>

        """
        return _IFSelect.IFSelect_WorkSession_Dispatch(self, *args)


    def DispatchRank(self, *args) -> "Standard_Integer":
        """
        Returns the rank of a dispatch in the shareout, or 0 if <disp> is not in the shareout or not in the worksession.

        Parameters
        ----------
        disp: IFSelect_Dispatch

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_DispatchRank(self, *args)


    def DumpSelection(self, *args) -> "void":
        """
        Lists a selection and its sources (see selectioniterator), given its rank in the list.

        Parameters
        ----------
        sel: IFSelect_Selection

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_DumpSelection(self, *args)


    def DumpShare(self, *args) -> "void":
        """
        Dumps contents of the shareout (on 'cout').

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_DumpShare(self, *args)


    def EntityLabel(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Returns the label for <ent>, as the model does if <ent> is not in the model or if no model is loaded, a null handle is returned.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _IFSelect.IFSelect_WorkSession_EntityLabel(self, *args)


    def EntityName(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Returns the name of an entity this name is computed by the general service name returns a null handle if fails.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _IFSelect.IFSelect_WorkSession_EntityName(self, *args)


    def ErrorHandle(self, *args) -> "Standard_Boolean":
        """
        Returns the error handler status.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_ErrorHandle(self, *args)


    def EvalSelection(self, *args) -> "Interface_EntityIterator":
        """
        Evaluates the effect of a selection applied on the input model returned result remains empty if no input model has been set.

        Parameters
        ----------
        sel: IFSelect_Selection

        Returns
        -------
        Interface_EntityIterator

        """
        return _IFSelect.IFSelect_WorkSession_EvalSelection(self, *args)


    def EvalSplit(self, *args) -> "opencascade::handle< IFSelect_PacketList >":
        """
        Returns an evaluation of the whole shareout definition : i.e. how the entities of the starting model are forecast to be sent to various files : list of packets according the dispatches, effective lists of roots for each packet (which determine the content of the corresponding file); plus evaluation of which entities are : forgotten (sent into no file), duplicated (sent into more than one file), sent into a given file. see the class packetlist for more details.

        Returns
        -------
        opencascade::handle<IFSelect_PacketList>

        """
        return _IFSelect.IFSelect_WorkSession_EvalSplit(self, *args)


    def EvaluateComplete(self, *args) -> "void":
        """
        Displays the effect of applying the shareout on the input model. <mode> = 0 (default) : displays only roots for each packet, <mode> = 1 : displays all entities for each packet, plus duplicated entities <mode> = 2 : same as <mode> = 1, plus displays forgotten entities (which are in no packet at all).

        Parameters
        ----------
        mode: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_EvaluateComplete(self, *args)


    def EvaluateDispatch(self, *args) -> "void":
        """
        Displays the result of applying a dispatch on the input model (also shows remainder if there is) <mode> = 0 (default), displays nothing else <mode> = 1 : displays also duplicated entities (because of this dispatch) <mode> = 2 : displays the entities of the starting model which are not taken by this dispatch (forgotten entities) <mode> = 3 : displays both duplicated and forgotten entities remark : evaluatecomplete displays these data evaluated for for all the dispatches, if there are several.

        Parameters
        ----------
        disp: IFSelect_Dispatch
        mode: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_EvaluateDispatch(self, *args)


    def EvaluateFile(self, *args) -> "void":
        """
        Performs and stores a file evaluation. the results are a list of produced models and a list of names (strings), in parallel fills lastrunchecklist.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_EvaluateFile(self, *args)


    def EvaluateSelection(self, *args) -> "void":
        """
        Displays the list of entities selected by a selection (i.e. the result of evalselection).

        Parameters
        ----------
        sel: IFSelect_Selection

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_EvaluateSelection(self, *args)


    def FileExtension(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Returns the defined file extension. null handle if not defined.

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _IFSelect.IFSelect_WorkSession_FileExtension(self, *args)


    def FileModel(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        Returns a model, given its rank in the evaluation list.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<Interface_InterfaceModel>

        """
        return _IFSelect.IFSelect_WorkSession_FileModel(self, *args)


    def FileName(self, *args) -> "TCollection_AsciiString":
        """
        Returns the name of a file corresponding to a produced model, given its rank in the evaluation list.

        Parameters
        ----------
        num: int

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_WorkSession_FileName(self, *args)


    def FilePrefix(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Returns the defined file prefix. null handle if not defined.

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _IFSelect.IFSelect_WorkSession_FilePrefix(self, *args)


    def FileRoot(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Returns the file root defined for a dispatch. null if no root name is defined for it (hence, no file will be produced).

        Parameters
        ----------
        disp: IFSelect_Dispatch

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _IFSelect.IFSelect_WorkSession_FileRoot(self, *args)


    def FinalModifierIdents(self, *args) -> "opencascade::handle< TColStd_HSequenceOfInteger >":
        """
        Fills a sequence with a list of idents, those attached to the modifiers applied to final sending. model modifiers if <formodel> is true, file modifiers else this list is given in the order in which they will be applied (which takes into account the changes to modifier ranks).

        Parameters
        ----------
        formodel: bool

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfInteger>

        """
        return _IFSelect.IFSelect_WorkSession_FinalModifierIdents(self, *args)


    def GeneralModifier(self, *args) -> "opencascade::handle< IFSelect_GeneralModifier >":
        """
        Returns a modifier, given its ident in the session null result if <id> is not suitable for a modifier (undefined, or defined for another kind of variable).

        Parameters
        ----------
        id: int

        Returns
        -------
        opencascade::handle<IFSelect_GeneralModifier>

        """
        return _IFSelect.IFSelect_WorkSession_GeneralModifier(self, *args)


    def GetModeStat(self, *args) -> "Standard_Boolean":
        """
        Return value of mode defining of filling selection during loading.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_GetModeStat(self, *args)


    def GiveFileComplete(self, *args) -> "char const *":
        """
        Completes a file name as required, with prefix and extension (if defined; for a non-defined item, completes nothing).

        Parameters
        ----------
        file: char *

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_WorkSession_GiveFileComplete(self, *args)


    def GiveFileRoot(self, *args) -> "char const *":
        """
        Extracts file root name from a given complete file name (uses osd_path).

        Parameters
        ----------
        file: char *

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_WorkSession_GiveFileRoot(self, *args)


    def GiveList(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        Determines a list of entities from an object : <obj> already hsequenceoftransient : returned itself <obj> selection : its result of evaluation is returned <obj> an entity of the model : a hsequence which contains it else, an empty hsequence <obj> the model it self : all its content (not only the roots).

        Parameters
        ----------
        obj: Standard_Transient

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfTransient>

        Computes a list of entities from two alphanums, first and second, as follows : if <first> is a number or label of an entity : this entity if <first> is a list of numbers/labels : the list of entities if <first> is the name of a selection in <ws>, and <second> not defined, the standard result of this selection else, let's consider 'first second' : this whole phrase is splitted by blanks, as follows (recursive call) : - the leftest term is the final selection - the other terms define the result of the selection - and so on (the 'leftest minus one' is a selection, of which the input is given by the remaining ...).

        Parameters
        ----------
        first: char *
        second: char *,optional
        	default value is 

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfTransient>

        """
        return _IFSelect.IFSelect_WorkSession_GiveList(self, *args)


    def GiveListCombined(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        Combines two lists and returns the result, according to mode : <mode> < 0 : entities in <l1> and not in <l2> <mode> = 0 : entities in <l1> and in <l2> <mode> > 0 : entities in <l1> or in <l2>.

        Parameters
        ----------
        l1: TColStd_HSequenceOfTransient
        l2: TColStd_HSequenceOfTransient
        mode: int

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfTransient>

        """
        return _IFSelect.IFSelect_WorkSession_GiveListCombined(self, *args)


    def GiveListFromList(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        Computes a list of entities from the model as follows <first> beeing a selection or a combination of selections, <ent> beeing an entity or a list of entities (as a hsequenceoftransient) : the standard result of this selection applied to this list if <ent> is null, the standard definition of the selection is used (which contains a default input selection) if <selname> is erroneous, a null handle is returned //! remark : selname is processed as <first second> of preceeding givelist.

        Parameters
        ----------
        selname: char *
        ent: Standard_Transient

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfTransient>

        """
        return _IFSelect.IFSelect_WorkSession_GiveListFromList(self, *args)


    def GiveSelection(self, *args) -> "opencascade::handle< IFSelect_Selection >":
        """
        Returns a selection from a name : - the name of a selection : this selection - the name of a signature + criteria between (..) : a new selection from this signature - an entity or a list of entities : a new selectpointed else, returns a null handle.

        Parameters
        ----------
        selname: char *

        Returns
        -------
        opencascade::handle<IFSelect_Selection>

        """
        return _IFSelect.IFSelect_WorkSession_GiveSelection(self, *args)


    def Graph(self, *args) -> "Interface_Graph const &":
        """
        Returns the computed graph, for read only.

        Returns
        -------
        Interface_Graph

        """
        return _IFSelect.IFSelect_WorkSession_Graph(self, *args)


    def HGraph(self, *args) -> "opencascade::handle< Interface_HGraph >":
        """
        Returns the computed graph as hgraph (null handle if not set).

        Returns
        -------
        opencascade::handle<Interface_HGraph>

        """
        return _IFSelect.IFSelect_WorkSession_HGraph(self, *args)


    def HasModel(self, *args) -> "Standard_Boolean":
        """
        Returns true is a model has been set.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_HasModel(self, *args)


    def HasName(self, *args) -> "Standard_Boolean":
        """
        Returns true if an item of the worksession has an attached name.

        Parameters
        ----------
        item: Standard_Transient

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_HasName(self, *args)


    def IntParam(self, *args) -> "opencascade::handle< IFSelect_IntParam >":
        """
        Returns an intparam, given its ident in the session null result if <id> is not suitable for an intparam (undefined, or defined for another kind of variable).

        Parameters
        ----------
        id: int

        Returns
        -------
        opencascade::handle<IFSelect_IntParam>

        """
        return _IFSelect.IFSelect_WorkSession_IntParam(self, *args)


    def IntValue(self, *args) -> "Standard_Integer":
        """
        Returns integer value of an intparam.

        Parameters
        ----------
        it: IFSelect_IntParam

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_IntValue(self, *args)


    def IsLoaded(self, *args) -> "Standard_Boolean":
        """
        Returns true if a model is defined and really loaded (not empty), a protocol is set and a graph has been computed. in this case, the worksession can start to work.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_IsLoaded(self, *args)


    def IsReversedSelectExtract(self, *args) -> "Standard_Boolean":
        """
        Returns true if <sel> a reversed selectextract, false else.

        Parameters
        ----------
        sel: IFSelect_Selection

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_IsReversedSelectExtract(self, *args)


    def Item(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Returns an item, given its ident. returns a null handle if no item corresponds to this ident.

        Parameters
        ----------
        id: int

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _IFSelect.IFSelect_WorkSession_Item(self, *args)


    def ItemIdent(self, *args) -> "Standard_Integer":
        """
        Returns the ident attached to an item in the worksession, or zero if it is unknown.

        Parameters
        ----------
        item: Standard_Transient

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_ItemIdent(self, *args)


    def ItemIdents(self, *args) -> "opencascade::handle< TColStd_HSequenceOfInteger >":
        """
        Fills a sequence with the list of idents attached to the items of which type complies with (iskind) <type> (alphabetic order) remark : <type> = type(standard_transient) gives all the idents which are suitable in the worksession.

        Parameters
        ----------
        type: Standard_Type

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfInteger>

        """
        return _IFSelect.IFSelect_WorkSession_ItemIdents(self, *args)


    def ItemLabel(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Returns a label which illustrates the content of an item, given its ident. this label is : - for a text parameter, 'text:<text value>' - for an integer parameter, 'integer:<integer value>' - for a selection, a dispatch or a modifier, its label (see these classes) - for any other kind of variable, its cdl type.

        Parameters
        ----------
        id: int

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _IFSelect.IFSelect_WorkSession_ItemLabel(self, *args)


    def ItemNames(self, *args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """
        Fills a sequence with the list of the names attached to items of which type complies with (iskind) <type> (alphabetic order) remark : <type> = type(standard_transient) gives all the names.

        Parameters
        ----------
        type: Standard_Type

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfHAsciiString>

        """
        return _IFSelect.IFSelect_WorkSession_ItemNames(self, *args)


    def ItemNamesForLabel(self, *args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """
        Fills a sequence with the names of the control items, of which the label matches <label> (contain it) : see nextidentforlabel search mode is fixed to 'contained' if <label> is empty, returns all names.

        Parameters
        ----------
        label: char *

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfHAsciiString>

        """
        return _IFSelect.IFSelect_WorkSession_ItemNamesForLabel(self, *args)


    def ItemSelection(self, *args) -> "opencascade::handle< IFSelect_Selection >":
        """
        Returns the selection of a dispatch or a generalmodifier. returns a null handle if none is defined or <item> not good type.

        Parameters
        ----------
        item: Standard_Transient

        Returns
        -------
        opencascade::handle<IFSelect_Selection>

        """
        return _IFSelect.IFSelect_WorkSession_ItemSelection(self, *args)


    def LastRunCheckList(self, *args) -> "Interface_CheckIterator":
        """
        Returns the check list produced by the last execution of either : evaluatefile(for split), sendsplit, sendall, sendselected, runtransformer-runmodifier cleared by setmodel or cleardata(1) the field is protected, hence a specialized worksession may fill it.

        Returns
        -------
        Interface_CheckIterator

        """
        return _IFSelect.IFSelect_WorkSession_LastRunCheckList(self, *args)


    def ListFinalModifiers(self, *args) -> "void":
        """
        Lists the modifiers of the session (for each one, displays its label). listing is done following ranks (modifiers are invoked following their ranks) model modifiers if <formodel> is true, file modifiers else.

        Parameters
        ----------
        formodel: bool

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_ListFinalModifiers(self, *args)


    def ListItems(self, *args) -> "void":
        """
        Lists the labels of all items of the worksession if <label> is defined, lists labels which contain it.

        Parameters
        ----------
        label: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_ListItems(self, *args)


    def LoadedFile(self, *args) -> "char const *":
        """
        Returns the filename used to load current model empty if unknown.

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_WorkSession_LoadedFile(self, *args)


    def MaxIdent(self, *args) -> "Standard_Integer":
        """
        Returns the maximum value for an item identifier. it can be greater to the count of known items, because some can have been removed.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_MaxIdent(self, *args)


    def MaxSendingCount(self, *args) -> "Standard_Integer":
        """
        Returns the greater count of different files in which any of the starting entities could be sent. before any file output, this count is 0. ideal count is 1. more than 1 means that duplications occur.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_MaxSendingCount(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel > const &":
        """
        Returns the model of the work session (null handle if none) should be c++ : return const &.

        Returns
        -------
        opencascade::handle<Interface_InterfaceModel>

        """
        return _IFSelect.IFSelect_WorkSession_Model(self, *args)


    def ModelCheckList(self, *args) -> "Interface_CheckIterator":
        """
        Returns the check list for the model currently loaded : <complete> = true : complete (syntactic & semantic messages), computed if not yet done <complete> = false : only syntactic (check file form).

        Parameters
        ----------
        complete: bool,optional
        	default value is Standard_True

        Returns
        -------
        Interface_CheckIterator

        """
        return _IFSelect.IFSelect_WorkSession_ModelCheckList(self, *args)


    def ModelCopier(self, *args) -> "opencascade::handle< IFSelect_ModelCopier > const &":
        """
        Gives access to the complete modelcopier.

        Returns
        -------
        opencascade::handle<IFSelect_ModelCopier>

        """
        return _IFSelect.IFSelect_WorkSession_ModelCopier(self, *args)


    def ModelModifier(self, *args) -> "opencascade::handle< IFSelect_Modifier >":
        """
        Returns a model modifier, given its ident in the session, i.e. typed as a modifier (not simply a generalmodifier) null result if <id> is not suitable for a modifier (undefined, or defined for another kind of variable).

        Parameters
        ----------
        id: int

        Returns
        -------
        opencascade::handle<IFSelect_Modifier>

        """
        return _IFSelect.IFSelect_WorkSession_ModelModifier(self, *args)


    def ModifierRank(self, *args) -> "Standard_Integer":
        """
        Returns the rank of a modifier given its ident. model or file modifier according its type (modelmodifier or not) remember that modifiers are applied sequencially following their rank : first model modifiers then file modifiers rank is given by rank of call to additem and can be changed by changemodifierrank.

        Parameters
        ----------
        item: IFSelect_GeneralModifier

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_ModifierRank(self, *args)


    def Name(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Returns the name attached to an item as a variable of this worksession. if <item> is null or not recorded, returns an empty string.

        Parameters
        ----------
        item: Standard_Transient

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _IFSelect.IFSelect_WorkSession_Name(self, *args)


    def NameIdent(self, *args) -> "Standard_Integer":
        """
        Returns the ident attached to a name, 0 if name not recorded.

        Parameters
        ----------
        name: char *

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_NameIdent(self, *args)


    def NamedItem(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Returns the item which corresponds to a variable, given its name (whatever the type of this item). returns a null handle if this name is not recorded.

        Parameters
        ----------
        name: char *

        Returns
        -------
        opencascade::handle<Standard_Transient>

        Same as above, but <name> is given through a handle especially usefull with methods selectionnames, etc...

        Parameters
        ----------
        name: TCollection_HAsciiString

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _IFSelect.IFSelect_WorkSession_NamedItem(self, *args)


    def NbFiles(self, *args) -> "Standard_Integer":
        """
        Returns the count of produced models.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_NbFiles(self, *args)


    def NbFinalModifiers(self, *args) -> "Standard_Integer":
        """
        Returns the count of modifiers applied to final sending model modifiers if <formodel> is true, file modifiers else (i.e. modifiers which apply once the models have been filled).

        Parameters
        ----------
        formodel: bool

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_NbFinalModifiers(self, *args)


    def NbSources(self, *args) -> "Standard_Integer":
        """
        Returns the count of input selections known for a selection, or 0 if <sel> not in the worksession. this count is one for a selectdeduct / selectextract kind, two for selectcontrol kind, variable for a selectcombine (union/intersection), zero else.

        Parameters
        ----------
        sel: IFSelect_Selection

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_NbSources(self, *args)


    def NbStartingEntities(self, *args) -> "Standard_Integer":
        """
        Returns the count of entities stored in the model, or 0.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_NbStartingEntities(self, *args)


    def NewIntParam(self, *args) -> "opencascade::handle< IFSelect_IntParam >":
        """
        Creates a new intparam. a name can be set (optional) returns the created intparam, or a null handle in case of failure (see additem/addnameditem).

        Parameters
        ----------
        name: char *,optional
        	default value is 

        Returns
        -------
        opencascade::handle<IFSelect_IntParam>

        """
        return _IFSelect.IFSelect_WorkSession_NewIntParam(self, *args)


    def NewParamFromStatic(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Creates a parameter as being bound to a static if the static is integer, this creates an intparam bound to it by its name. else this creates a string which is the value of the static. returns a null handle if <statname> is unknown as a static.

        Parameters
        ----------
        statname: char *
        name: char *,optional
        	default value is 

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _IFSelect.IFSelect_WorkSession_NewParamFromStatic(self, *args)


    def NewSelectPointed(self, *args) -> "opencascade::handle< IFSelect_Selection >":
        """
        Creates a new selection, of type selectpointed, its content starts with <list>. a name must be given (can be empty).

        Parameters
        ----------
        list: TColStd_HSequenceOfTransient
        name: char *

        Returns
        -------
        opencascade::handle<IFSelect_Selection>

        """
        return _IFSelect.IFSelect_WorkSession_NewSelectPointed(self, *args)


    def NewTextParam(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Creates a new (empty) textparam. a name can be set (optional) returns the created textparam (as an hasciistring), or a null handle in case of failure (see additem/addnameditem).

        Parameters
        ----------
        name: char *,optional
        	default value is 

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _IFSelect.IFSelect_WorkSession_NewTextParam(self, *args)


    def NewTransformStandard(self, *args) -> "opencascade::handle< IFSelect_Transformer >":
        """
        Creates and returns a transformstandard, empty, with its copy option (true = copy, false = on the spot) and an optional name. to a transformstandard, the method setappliedmodifier applies.

        Parameters
        ----------
        copy: bool
        name: char *,optional
        	default value is 

        Returns
        -------
        opencascade::handle<IFSelect_Transformer>

        """
        return _IFSelect.IFSelect_WorkSession_NewTransformStandard(self, *args)


    def NextIdentForLabel(self, *args) -> "Standard_Integer":
        """
        For query by label with possible iterations searches the ident of which item has a label which matches a given one, the search starts from an initial ident. returns the first found ident which follows <id>, or zero //! the search must start with <id> = 0, it returns the next ident which matches. to iterate, call again this method which this returned value as <id>. once an ident has been returned, the item can be obtained by the method item //! <mode> precises the required matching mode : - 0 (default) : <label> must match exactly with the item label - 1 : <label> must match the exact beginning (the end is free) - 2 : <label> must be at least once wherever in the item label - other values are ignored.

        Parameters
        ----------
        label: char *
        id: int
        mode: int,optional
        	default value is 0

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_NextIdentForLabel(self, *args)


    def NumberFromLabel(self, *args) -> "Standard_Integer":
        """
        From a given label in model, returns the corresponding number starts from first entity by default, may start after a given number : this number may be given negative, its absolute value is then considered. hence a loop on numberfromlabel may be programmed (stop test is : returned value positive or null) //! returns 0 if not found, < 0 if more than one found (first found in negative). if <val> just gives an integer value, returns it.

        Parameters
        ----------
        val: char *
        afternum: int,optional
        	default value is 0

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_NumberFromLabel(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol > const &":
        """
        Returns the protocol. null handle if not yet set should be c++ : return const &.

        Returns
        -------
        opencascade::handle<Interface_Protocol>

        """
        return _IFSelect.IFSelect_WorkSession_Protocol(self, *args)


    def QueryCheckList(self, *args) -> "void":
        """
        Loads data from a check iterator to query status on it.

        Parameters
        ----------
        chl: Interface_CheckIterator

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_QueryCheckList(self, *args)


    def QueryCheckStatus(self, *args) -> "Standard_Integer":
        """
        Determines check status for an entity regarding last call to querychecklist : -1 : <ent> unknown in the model, ignored 0 : no check at all, immediate or inherited thru graph 1 : immediate warning (no fail), no inherited check 2 : immediate fail, no inherited check +10 : idem but some inherited warning (no fail) +20 : idem but some inherited fail.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_QueryCheckStatus(self, *args)


    def QueryParent(self, *args) -> "Standard_Integer":
        """
        Determines if <entdad> is parent of <entson> (in the graph), returns : -1 if no; 0 if <entdad> = <entson> 1 if immediate parent, > 1 if parent, gives count of steps.

        Parameters
        ----------
        entdad: Standard_Transient
        entson: Standard_Transient

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_QueryParent(self, *args)


    def ReadFile(self, *args) -> "IFSelect_ReturnStatus":
        """
        Reads a file with the worklibrary (sets model and loadedfile) returns a integer status which can be : retdone if ok, retvoid if no protocol not defined, reterror for file not found, retfail if fail during read.

        Parameters
        ----------
        filename: char *

        Returns
        -------
        IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_WorkSession_ReadFile(self, *args)


    def ReadStream(self, *args) -> "IFSelect_ReturnStatus":
        """
        Reads a file from stream with the worklibrary (sets model and loadedfile) returns a integer status which can be : retdone if ok, retvoid if no protocol not defined, reterror for file not found, retfail if fail during read.

        Parameters
        ----------
        theName: char *
        theIStream: std::istream

        Returns
        -------
        IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_WorkSession_ReadStream(self, *args)


    def RemoveItem(self, *args) -> "Standard_Boolean":
        """
        Removes an item given its ident. returns false if <id> is attached to no item in the worksession. for a named item, also removes its name.

        Parameters
        ----------
        item: Standard_Transient

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_RemoveItem(self, *args)


    def RemoveName(self, *args) -> "Standard_Boolean":
        """
        Removes a name without removing the item returns true if done, false else (name not recorded).

        Parameters
        ----------
        name: char *

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_RemoveName(self, *args)


    def RemoveNamedItem(self, *args) -> "Standard_Boolean":
        """
        Removes an item from the session, given its name returns true if done, false else (name not recorded) (applies only on item which are named).

        Parameters
        ----------
        name: char *

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_RemoveNamedItem(self, *args)


    def ResetAppliedModifier(self, *args) -> "Standard_Boolean":
        """
        Resets a generalmodifier to be applied returns true if done, false if <modif> was not applied.

        Parameters
        ----------
        modif: IFSelect_GeneralModifier

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_ResetAppliedModifier(self, *args)


    def ResetItemSelection(self, *args) -> "Standard_Boolean":
        """
        Resets input selection which was set by setitemselection same conditions as for setitemselection returns true if done, false if <item> is not in the worksession.

        Parameters
        ----------
        item: Standard_Transient

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_ResetItemSelection(self, *args)


    def RunModifier(self, *args) -> "Standard_Integer":
        """
        Runs a modifier on starting model. it can modify entities, or add new ones. but the model or the protocol is unchanged. the modifier is applied on each entity of the model. see also runmodifierselected fills lastrunchecklist //! <copy> : if true, a new data set is produced which brings the modifications (model + its entities) if false, data are modified on the spot //! it works through a transformstandard defined with <modif> returned status as runtransformer : 0 nothing done, >0 ok, <0 problem, but only between -3 and 3 (protocol unchanged) remark : <copy> true will give <effect> = 3 or -3.

        Parameters
        ----------
        modif: IFSelect_Modifier
        copy: bool

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_RunModifier(self, *args)


    def RunModifierSelected(self, *args) -> "Standard_Integer":
        """
        Acts as runmodifier, but the modifier is applied on the list determined by a selection, rather than on the whole model if the selection is a null handle, the whole model is taken.

        Parameters
        ----------
        modif: IFSelect_Modifier
        sel: IFSelect_Selection
        copy: bool

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_RunModifierSelected(self, *args)


    def RunTransformer(self, *args) -> "Standard_Integer":
        """
        Runs a transformer on starting model, which can then be edited or replaced by a new one. the protocol can also be changed. fills lastrunchecklist //! returned status is 0 if nothing done (<transf> or model undefined), positive if ok, negative else : 0 : nothing done 1 : ok, edition on the spot with no change to the graph of dependances (purely local) 2 : ok, model edited on the spot (graph recomputed, may have changed), protocol unchanged 3 : ok, new model produced, same protocol 4 : ok, model edited on the spot (graph recomputed), but protocol has changed 5 : ok, new model produced, protocol has changed -1 : error on the spot (slight changes), data may be corrupted (remark : corruption should not be profound) -2 : error on edition the spot, data may be corrupted (checking them is recommanded) -3 : error with a new data set, transformation ignored -4 : ok as 4, but graph of dependances count not be recomputed (the former one is kept) : check the protocol.

        Parameters
        ----------
        transf: IFSelect_Transformer

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_RunTransformer(self, *args)


    def Selection(self, *args) -> "opencascade::handle< IFSelect_Selection >":
        """
        Returns a selection, given its ident in the session null result if <id> is not suitable for a selection (undefined, or defined for another kind of variable).

        Parameters
        ----------
        id: int

        Returns
        -------
        opencascade::handle<IFSelect_Selection>

        """
        return _IFSelect.IFSelect_WorkSession_Selection(self, *args)


    def SelectionResult(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        Returns the result of a selection, computed by evalselection (see above) under the form of a hsequence (hence, it can be used by a frontal-engine logic). it can be empty returns a null handle if <sel> is not in the worksession.

        Parameters
        ----------
        sel: IFSelect_Selection

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfTransient>

        """
        return _IFSelect.IFSelect_WorkSession_SelectionResult(self, *args)


    def SelectionResultFromList(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        Returns the result of a selection, by forcing its input with a given list <list> (unless <list> is null). rules : <list> applies only for a selectdeduct kind selection : its input is considered : if it is a selectdeduct kind selection, its input is considered, etc... until an input is not a deduct/extract : its result is replaced by <list> and all the chain of deductions is applied.

        Parameters
        ----------
        sel: IFSelect_Selection
        list: TColStd_HSequenceOfTransient

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfTransient>

        """
        return _IFSelect.IFSelect_WorkSession_SelectionResultFromList(self, *args)


    def SendAll(self, *args) -> "IFSelect_ReturnStatus":
        """
        Sends the starting model into one file, without splitting, managing remaining data or anything else. <computegraph> true commands the graph to be recomputed before sending : required when a model is filled in several steps //! the model and file modifiers recorded to be applied on sending files are. returns a status of execution : done if ok, void if no data available, error if errors occured (work library is not defined), errors during translation fail if exception during translation is raised stop if no disk space or disk, file is write protected fills lastrunchecklist.

        Parameters
        ----------
        filename: char *
        computegraph: bool,optional
        	default value is Standard_False

        Returns
        -------
        IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_WorkSession_SendAll(self, *args)


    def SendSelected(self, *args) -> "IFSelect_ReturnStatus":
        """
        Sends a part of the starting model into one file, without splitting. but remaining data are managed. <computegraph> true commands the graph to be recomputed before sending : required when a model is filled in several steps //! the model and file modifiers recorded to be applied on sending files are. returns a status : done if ok, fail if error during send, error : worklibrary not defined, void : selection list empty fills lastrunchecklist.

        Parameters
        ----------
        filename: char *
        sel: IFSelect_Selection
        computegraph: bool,optional
        	default value is Standard_False

        Returns
        -------
        IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_WorkSession_SendSelected(self, *args)


    def SendSplit(self, *args) -> "Standard_Boolean":
        """
        Performs creation of derived files from the input model takes its data (sub-models and names), from result evaluatefile if active, else by dynamic evaluation (not stored) after sendsplit, result of evaluatefile is cleared fills lastrunchecklist //! works with the worklibrary which acts on specific type of model and can work with file modifiers (managed by the model copier) and a modelcopier, which can work with model modifiers returns false if, either worklibrary has failed on at least one sub-file, or the work session is badly conditionned (no model defined, or filenaming not in phase with shareout).

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_SendSplit(self, *args)


    def SentFiles(self, *args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """
        Returns the list of recorded sent files, or a null handle is recording has not been enabled.

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfHAsciiString>

        """
        return _IFSelect.IFSelect_WorkSession_SentFiles(self, *args)


    def SentList(self, *args) -> "Interface_EntityIterator":
        """
        Returns the list of entities sent in files, accourding the count of files each one has been sent (these counts are reset by setmodel or setremaining(forget) ) stored in graph status <count> = -1 (default) is for entities sent at least once <count> = 0 is for the remaining list (entities not yet sent) <count> = 1 is for entities sent in one and only one file (the ideal case) remaining data are computed on each sending/copying output files (see methods evaluatefile and sendsplit) graph status is 0 for remaining entity, <count> for sent into <count> files this status is set to 0 (not yet sent) for all by setmodel and by setremaining(mode=forget,display).

        Parameters
        ----------
        count: int,optional
        	default value is -1

        Returns
        -------
        Interface_EntityIterator

        """
        return _IFSelect.IFSelect_WorkSession_SentList(self, *args)


    def SetActive(self, *args) -> "Standard_Boolean":
        """
        Following the type of <item> : - dispatch : adds or removes it in the shareout & filenaming - generalmodifier : adds or removes it for final sending (i.e. in the modelcopier) returns true if it did something, false else (state unchanged).

        Parameters
        ----------
        item: Standard_Transient
        mode: bool

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_SetActive(self, *args)


    def SetAppliedModifier(self, *args) -> "Standard_Boolean":
        """
        Sets a generalmodifier to be applied to an item : - item = shareout : applies for final sending (all dispatches) - item is a dispatch : applies for this dispatch only returns true if done, false if <modif> or <item> not in <self>.

        Parameters
        ----------
        modif: IFSelect_GeneralModifier
        item: Standard_Transient

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_SetAppliedModifier(self, *args)


    def SetControl(self, *args) -> "Standard_Boolean":
        """
        Sets an input selection, main if <formain> is true, second else (as <sc>) to a selectcontrol (as <sel>). returns true if done, false if <sel> is not a selectcontrol, or <sc> or <sel> is not in the worksession.

        Parameters
        ----------
        sel: IFSelect_Selection
        sc: IFSelect_Selection
        formain: bool,optional
        	default value is Standard_True

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_SetControl(self, *args)


    def SetDefaultFileRoot(self, *args) -> "Standard_Boolean":
        """
        Defines a default file root name. clears it is <name> = '' returns true if ok, false if <name> already set for a dispatch.

        Parameters
        ----------
        name: char *

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_SetDefaultFileRoot(self, *args)


    def SetErrorHandle(self, *args) -> "void":
        """
        Changes the error handler status (by default, it is not set).

        Parameters
        ----------
        toHandle: bool

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_SetErrorHandle(self, *args)


    def SetFileExtension(self, *args) -> "void":
        """
        Defines a file extension.

        Parameters
        ----------
        name: char *

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_SetFileExtension(self, *args)


    def SetFilePrefix(self, *args) -> "void":
        """
        Defines a file prefix.

        Parameters
        ----------
        name: char *

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_SetFilePrefix(self, *args)


    def SetFileRoot(self, *args) -> "Standard_Boolean":
        """
        Defines a root for a dispatch if <name> is empty, clears root name this has as effect to inhibit the production of file by <disp> returns false if <disp> is not in the worksession or if a root name is already defined for it.

        Parameters
        ----------
        disp: IFSelect_Dispatch
        name: char *

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_SetFileRoot(self, *args)


    def SetInputSelection(self, *args) -> "Standard_Boolean":
        """
        Sets an input selection (as <input>) to a selectextract or a selectdeduct (as <sel>). returns true if done, false if <sel> is neither a selectextract nor a selectdeduct, or not in the worksession.

        Parameters
        ----------
        sel: IFSelect_Selection
        input: IFSelect_Selection

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_SetInputSelection(self, *args)


    def SetIntValue(self, *args) -> "Standard_Boolean":
        """
        Changes the integer value of an intparam returns true if done, false if <it> is not in the worksession.

        Parameters
        ----------
        it: IFSelect_IntParam
        val: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_SetIntValue(self, *args)


    def SetItemSelection(self, *args) -> "Standard_Boolean":
        """
        Sets a selection as input for an item, according its type : if <item> is a dispatch : as final selection if <item> is a generalmodifier (i.e. any kind of modifier) : as selection used to filter entities to modify <sel> null causes this selection to be nullified returns false if <item> is not of a suitable type, or <item> or <sel> is not in the worksession.

        Parameters
        ----------
        item: Standard_Transient
        sel: IFSelect_Selection

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_SetItemSelection(self, *args)


    def SetLibrary(self, *args) -> "void":
        """
        Sets a worklibrary, which will be used to read and write files.

        Parameters
        ----------
        theLib: IFSelect_WorkLibrary

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_SetLibrary(self, *args)


    def SetLoadedFile(self, *args) -> "void":
        """
        Stores the filename used for read for setting the model it is cleared by setmodel and cleardata(1).

        Parameters
        ----------
        theFileName: char *

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_SetLoadedFile(self, *args)


    def SetModeStat(self, *args) -> "void":
        """
        Set value of mode responsible for precence of selections after loading if mode set to true that different selections will be accessible after loading else selections will be not accessible after loading( for economy memory in applicatios).

        Parameters
        ----------
        theMode: bool

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_SetModeStat(self, *args)


    def SetModel(self, *args) -> "void":
        """
        Sets a model as input : this will be the model from which the shareout will work if <clearpointed> is true (default) all selectpointed items are cleared, else they must be managed by the caller remark : setmodel clears the graph, recomputes it if a protocol is set and if the model is not empty, of course.

        Parameters
        ----------
        model: Interface_InterfaceModel
        clearpointed: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_SetModel(self, *args)


    def SetModelContent(self, *args) -> "Standard_Boolean":
        """
        Defines a new content from the former one if <keep> is true, it is given by entities selected by selection <sel> (and all shared entities) else, it is given by all the former content but entities selected by the selection <sel> (and properly shared ones) returns true if done. returns false if the selected list (from <sel>) is empty, hence nothing is done.

        Parameters
        ----------
        sel: IFSelect_Selection
        keep: bool

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_SetModelContent(self, *args)


    def SetModelCopier(self, *args) -> "void":
        """
        Sets a new modelcopier. fills items which its content.

        Parameters
        ----------
        copier: IFSelect_ModelCopier

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_SetModelCopier(self, *args)


    def SetParams(self, *args) -> "void":
        """
        Sets a list of parameters, i.e. typedvalue, to be handled through an editor the two lists are parallel, if <params> is longer than <uses>, surnumeral parameters are for general use //! editforms are created to handle these parameters (list, edit) on the basis of a parameditor xst-params-edit //! a use number dispatches the parameter to a given editform editforms are defined as follows name use means xst-params all all parameters (complete list) xst-params-general 1 generals xst-params-load 2 loadfile (no transfer) xst-params-send 3 sendfile (write, no transfer) xst-params-split 4 split xst-param-read 5 transfer on reading xst-param-write 6 transfer on writing.

        Parameters
        ----------
        params: Standard_Transient
        uselist: NCollection_Vector<int>

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_SetParams(self, *args)


    def SetProtocol(self, *args) -> "void":
        """
        Sets a protocol, which will be used to determine graphs, to read and to write files.

        Parameters
        ----------
        protocol: Interface_Protocol

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_SetProtocol(self, *args)


    def SetRemaining(self, *args) -> "Standard_Boolean":
        """
        Processes remaining data (after having sent files), mode : forget : forget remaining info (i.e. clear all 'sent' status) compute : compute and keep remaining (does nothing if : remaining is empty or if no files has been sent) display : display entities recorded as remaining undo : restore former state of data (after remaining(1) ) returns true if ok, false else (i.e. mode = 2 and remaining list is either empty or takes all the entities, or mode = 3 and no former computation of remaining data was done).

        Parameters
        ----------
        mode: IFSelect_RemainMode

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_SetRemaining(self, *args)


    def SetSelectPointed(self, *args) -> "Standard_Boolean":
        """
        Changes the content of a selection of type selectpointed according <mode> : 0 set <list> as new content (clear former) 1 : adds <list> to actual content -1 : removes <list> from actual content returns true if done, false if <sel> is not a selectpointed.

        Parameters
        ----------
        sel: IFSelect_Selection
        list: TColStd_HSequenceOfTransient
        mode: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_SetSelectPointed(self, *args)


    def SetShareOut(self, *args) -> "void":
        """
        Sets a new shareout. fills items which its content warning : data from the former shareout are lost.

        Parameters
        ----------
        shareout: IFSelect_ShareOut

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_SetShareOut(self, *args)


    def SetSignType(self, *args) -> "void":
        """
        Sets a specific signature to be the signtype, i.e. the signature which will determine typename from the model (basic function). it is recorded in the gtool this signature is also set as 'xst-sign-type' (reserved name).

        Parameters
        ----------
        signtype: IFSelect_Signature

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_SetSignType(self, *args)


    def SetTextValue(self, *args) -> "Standard_Boolean":
        """
        Changes the text value of a textparam (an hasciistring) returns true if done, false if <it> is not in the worksession.

        Parameters
        ----------
        par: TCollection_HAsciiString
        val: char *

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_SetTextValue(self, *args)


    def ShareOut(self, *args) -> "opencascade::handle< IFSelect_ShareOut > const &":
        """
        Returns the shareout defined at creation time.

        Returns
        -------
        opencascade::handle<IFSelect_ShareOut>

        """
        return _IFSelect.IFSelect_WorkSession_ShareOut(self, *args)


    def Shareds(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        Returns the list of entities shared by <ent> (can be empty) returns a null handle if <ent> is unknown.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfTransient>

        """
        return _IFSelect.IFSelect_WorkSession_Shareds(self, *args)


    def Sharings(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        Returns the list of entities sharing <ent> (can be empty) returns a null handle if <ent> is unknown.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfTransient>

        """
        return _IFSelect.IFSelect_WorkSession_Sharings(self, *args)


    def SignCounter(self, *args) -> "opencascade::handle< IFSelect_SignCounter >":
        """
        Returns a signcounter from its ident in the session null result if <id> is not suitable for a signcounter (undefined, or defined for another kind of variable).

        Parameters
        ----------
        id: int

        Returns
        -------
        opencascade::handle<IFSelect_SignCounter>

        """
        return _IFSelect.IFSelect_WorkSession_SignCounter(self, *args)


    def SignType(self, *args) -> "opencascade::handle< IFSelect_Signature >":
        """
        Returns the current signtype.

        Returns
        -------
        opencascade::handle<IFSelect_Signature>

        """
        return _IFSelect.IFSelect_WorkSession_SignType(self, *args)


    def SignValue(self, *args) -> "char const *":
        """
        Returns the value computed by a signature for an entity returns an empty string if the entity does not belong to the loaded model.

        Parameters
        ----------
        sign: IFSelect_Signature
        ent: Standard_Transient

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_WorkSession_SignValue(self, *args)


    def Signature(self, *args) -> "opencascade::handle< IFSelect_Signature >":
        """
        Returns a signature, given its ident in the session null result if <id> is not suitable for a signature (undefined, or defined for another kind of variable).

        Parameters
        ----------
        id: int

        Returns
        -------
        opencascade::handle<IFSelect_Signature>

        """
        return _IFSelect.IFSelect_WorkSession_Signature(self, *args)


    def Source(self, *args) -> "opencascade::handle< IFSelect_Selection >":
        """
        Returns the <num>th input selection of a selection (see nbsources). returns a null handle if <sel> is not in the worksession or if <num> is out of the range <1-nbsources> to obtain more details, see the method sources.

        Parameters
        ----------
        sel: IFSelect_Selection
        num: int,optional
        	default value is 1

        Returns
        -------
        opencascade::handle<IFSelect_Selection>

        """
        return _IFSelect.IFSelect_WorkSession_Source(self, *args)


    def Sources(self, *args) -> "IFSelect_SelectionIterator":
        """
        Returns the selections which are source of selection, given its rank in the list of selections (see selectioniterator) returned value is empty if <num> is out of range or if <sel> is not in the worksession.

        Parameters
        ----------
        sel: IFSelect_Selection

        Returns
        -------
        IFSelect_SelectionIterator

        """
        return _IFSelect.IFSelect_WorkSession_Sources(self, *args)


    def StartingEntity(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Returns an entity stored in the model of the worksession (null handle is no model or num out of range).

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _IFSelect.IFSelect_WorkSession_StartingEntity(self, *args)


    def StartingNumber(self, *args) -> "Standard_Integer":
        """
        Returns the number of an entity in the model (0 if no model set or <ent> not in the model).

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_WorkSession_StartingNumber(self, *args)


    def TextParam(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Returns a textparam, given its ident in the session null result if <id> is not suitable for a textparam (undefined, or defined for another kind of variable).

        Parameters
        ----------
        id: int

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _IFSelect.IFSelect_WorkSession_TextParam(self, *args)


    def TextValue(self, *args) -> "TCollection_AsciiString":
        """
        Returns text value of a textparam (a string) or an empty string if <it> is not in the worksession.

        Parameters
        ----------
        par: TCollection_HAsciiString

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_WorkSession_TextValue(self, *args)


    def ToggleSelectExtract(self, *args) -> "Standard_Boolean":
        """
        Toggles the sense (direct <-> reversed) of a selectextract returns true if done, false if <sel> is not a selectextract or is not in the worksession.

        Parameters
        ----------
        sel: IFSelect_Selection

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_WorkSession_ToggleSelectExtract(self, *args)


    def TraceDumpEntity(self, *args) -> "void":
        """
        Dumps an entity from the current model as inherited dumpentity on currently defined default trace file (<level> interpreted according to the norm, see worklibrary).

        Parameters
        ----------
        ent: Standard_Transient
        level: int

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_TraceDumpEntity(self, *args)


    def TraceDumpModel(self, *args) -> "void":
        """
        Dumps the current model (as inherited dumpmodel), on currently defined default trace file (default is standard output).

        Parameters
        ----------
        mode: int

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_TraceDumpModel(self, *args)


    def TraceStatics(self, *args) -> "void":
        """
        Traces the statics attached to a given use number if <use> is given positive (normal), the trace is embedded with a header and a trailer if <use> is negative, just values are printed (this allows to make compositions) remark : use number 5 commands use -2 to be traced remark : use numbers 4 and 6 command use -3 to be traced.

        Parameters
        ----------
        use: int
        mode: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_WorkSession_TraceStatics(self, *args)


    def Transformer(self, *args) -> "opencascade::handle< IFSelect_Transformer >":
        """
        Returns a transformer, given its ident in the session null result if <id> is not suitable for a transformer (undefined, or defined for another kind of variable).

        Parameters
        ----------
        id: int

        Returns
        -------
        opencascade::handle<IFSelect_Transformer>

        """
        return _IFSelect.IFSelect_WorkSession_Transformer(self, *args)


    def UsesAppliedModifier(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Returns the item on which a generalmodifier is applied : the shareout, or a given dispatch returns a null handle if <modif> is not applied.

        Parameters
        ----------
        modif: IFSelect_GeneralModifier

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _IFSelect.IFSelect_WorkSession_UsesAppliedModifier(self, *args)


    def ValidityName(self, *args) -> "char const *":
        """
        Returns the validity name determined for an entity it is computed by the class signvalidity remark : an unknown entity gives an empty string.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_WorkSession_ValidityName(self, *args)


    def WorkLibrary(self, *args) -> "opencascade::handle< IFSelect_WorkLibrary > const &":
        """
        Returns the worklibrary. null handle if not yet set should be c++ : return const &.

        Returns
        -------
        opencascade::handle<IFSelect_WorkLibrary>

        """
        return _IFSelect.IFSelect_WorkSession_WorkLibrary(self, *args)


    def WriteFile(self, *args) -> "IFSelect_ReturnStatus":
        """
        Writes the current interface model globally to a file, and returns a write status which can be : done ok, fail file could not be written, error no norm is selected remark : it is a simple, one-file writing, other operations are available (such as splitting ...) which calls sendall.

        Parameters
        ----------
        filename: char *

        Returns
        -------
        IFSelect_ReturnStatus

        Writes a sub-part of the current interface model to a file, as defined by a selection <sel>, recomputes the graph, and returns a write status which can be : done ok, fail file could not be written, error no norm is selected remark : it is a simple, one-file writing, other operations are available (such as splitting ...) which calls sendselected.

        Parameters
        ----------
        filename: char *
        sel: IFSelect_Selection

        Returns
        -------
        IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_WorkSession_WriteFile(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_WorkSession_DownCast(t)


    __repr__ = _dumps_object

    @methodnotwrapped
    def theerrhand(self):
    	pass

    __swig_destroy__ = _IFSelect.delete_IFSelect_WorkSession
    __del__ = lambda self: None
IFSelect_WorkSession_swigregister = _IFSelect.IFSelect_WorkSession_swigregister
IFSelect_WorkSession_swigregister(IFSelect_WorkSession)

class IFSelect_Act(IFSelect_Activator):
    __swig_setmethods__ = {}
    for _s in [IFSelect_Activator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_Act, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_Activator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_Act, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an act with a name, help and a function mode (add or addset) is given when recording.

        Parameters
        ----------
        name: char *
        help: char *
        func: IFSelect_ActFunc

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_Act(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddFSet(*args) -> "void":
        """
        Adds a function with its name and help : creates an act then records it as function for xset (i.e. to create control item).

        Parameters
        ----------
        name: char *
        help: char *
        func: IFSelect_ActFunc

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_Act_AddFSet(*args)

    AddFSet = staticmethod(AddFSet)

    def AddFunc(*args) -> "void":
        """
        Adds a function with its name and help : creates an act then records it as normal function.

        Parameters
        ----------
        name: char *
        help: char *
        func: IFSelect_ActFunc

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_Act_AddFunc(*args)

    AddFunc = staticmethod(AddFunc)

    def SetGroup(*args) -> "void":
        """
        Changes the default group name for the following acts group empty means to come back to default from activator also a file name can be precised (to query by getsource).

        Parameters
        ----------
        group: char *
        file: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_Act_SetGroup(*args)

    SetGroup = staticmethod(SetGroup)


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_Act_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_Act
    __del__ = lambda self: None
IFSelect_Act_swigregister = _IFSelect.IFSelect_Act_swigregister
IFSelect_Act_swigregister(IFSelect_Act)

def IFSelect_Act_AddFSet(*args) -> "void":
    """
    Adds a function with its name and help : creates an act then records it as function for xset (i.e. to create control item).

    Parameters
    ----------
    name: char *
    help: char *
    func: IFSelect_ActFunc

    Returns
    -------
    None

    """
    return _IFSelect.IFSelect_Act_AddFSet(*args)

def IFSelect_Act_AddFunc(*args) -> "void":
    """
    Adds a function with its name and help : creates an act then records it as normal function.

    Parameters
    ----------
    name: char *
    help: char *
    func: IFSelect_ActFunc

    Returns
    -------
    None

    """
    return _IFSelect.IFSelect_Act_AddFunc(*args)

def IFSelect_Act_SetGroup(*args) -> "void":
    """
    Changes the default group name for the following acts group empty means to come back to default from activator also a file name can be precised (to query by getsource).

    Parameters
    ----------
    group: char *
    file: char *,optional
    	default value is 

    Returns
    -------
    None

    """
    return _IFSelect.IFSelect_Act_SetGroup(*args)

class IFSelect_BasicDumper(IFSelect_SessionDumper):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SessionDumper]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_BasicDumper, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SessionDumper]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_BasicDumper, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a basicdumper and puts it into the library of dumper.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_BasicDumper(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_BasicDumper_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_BasicDumper
    __del__ = lambda self: None
IFSelect_BasicDumper_swigregister = _IFSelect.IFSelect_BasicDumper_swigregister
IFSelect_BasicDumper_swigregister(IFSelect_BasicDumper)

class IFSelect_CheckCounter(IFSelect_SignatureList):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SignatureList]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_CheckCounter, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SignatureList]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_CheckCounter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a checkcounter, empty ready to work.

        Parameters
        ----------
        withlist: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_CheckCounter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Analyse(self, *args) -> "void":
        """
        Analyses a checkiterator according a model (which detains the entities for which the checkiterator has messages), i.e. counts messages for entities if <original> is true, does not consider final messages but those before interpretation (such as inserting variables : integers, reals, strings) if <failsonly> is true, only fails are considered remark : global messages are recorded with a null entity.

        Parameters
        ----------
        list: Interface_CheckIterator
        model: Interface_InterfaceModel
        original: bool,optional
        	default value is Standard_False
        failsonly: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_CheckCounter_Analyse(self, *args)


    def SetSignature(self, *args) -> "void":
        """
        Sets a specific signature else, the current signtype (in the model) is used.

        Parameters
        ----------
        sign: MoniTool_SignText

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_CheckCounter_SetSignature(self, *args)


    def Signature(self, *args) -> "opencascade::handle< MoniTool_SignText >":
        """
        Returns the signature;.

        Returns
        -------
        opencascade::handle<MoniTool_SignText>

        """
        return _IFSelect.IFSelect_CheckCounter_Signature(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_CheckCounter_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_CheckCounter
    __del__ = lambda self: None
IFSelect_CheckCounter_swigregister = _IFSelect.IFSelect_CheckCounter_swigregister
IFSelect_CheckCounter_swigregister(IFSelect_CheckCounter)

class IFSelect_DispGlobal(IFSelect_Dispatch):
    __swig_setmethods__ = {}
    for _s in [IFSelect_Dispatch]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_DispGlobal, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_Dispatch]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_DispGlobal, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a dispglobal.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_DispGlobal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_DispGlobal_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_DispGlobal
    __del__ = lambda self: None
IFSelect_DispGlobal_swigregister = _IFSelect.IFSelect_DispGlobal_swigregister
IFSelect_DispGlobal_swigregister(IFSelect_DispGlobal)

class IFSelect_DispPerCount(IFSelect_Dispatch):
    __swig_setmethods__ = {}
    for _s in [IFSelect_Dispatch]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_DispPerCount, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_Dispatch]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_DispPerCount, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a disppercount with no count (default value 1).

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_DispPerCount(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Count(self, *args) -> "opencascade::handle< IFSelect_IntParam >":
        """
        Returns the count parameter used for splitting.

        Returns
        -------
        opencascade::handle<IFSelect_IntParam>

        """
        return _IFSelect.IFSelect_DispPerCount_Count(self, *args)


    def CountValue(self, *args) -> "Standard_Integer":
        """
        Returns the effective value of the count parameter (if count parameter not set or value not positive, returns 1).

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_DispPerCount_CountValue(self, *args)


    def SetCount(self, *args) -> "void":
        """
        Sets a new parameter for count.

        Parameters
        ----------
        count: IFSelect_IntParam

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_DispPerCount_SetCount(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_DispPerCount_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_DispPerCount
    __del__ = lambda self: None
IFSelect_DispPerCount_swigregister = _IFSelect.IFSelect_DispPerCount_swigregister
IFSelect_DispPerCount_swigregister(IFSelect_DispPerCount)

class IFSelect_DispPerFiles(IFSelect_Dispatch):
    __swig_setmethods__ = {}
    for _s in [IFSelect_Dispatch]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_DispPerFiles, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_Dispatch]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_DispPerFiles, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a dispperfiles with no count (default value 1 file).

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_DispPerFiles(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Count(self, *args) -> "opencascade::handle< IFSelect_IntParam >":
        """
        Returns the count parameter used for splitting.

        Returns
        -------
        opencascade::handle<IFSelect_IntParam>

        """
        return _IFSelect.IFSelect_DispPerFiles_Count(self, *args)


    def CountValue(self, *args) -> "Standard_Integer":
        """
        Returns the effective value of the count parameter (if count parameter not set or value not positive, returns 1).

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_DispPerFiles_CountValue(self, *args)


    def SetCount(self, *args) -> "void":
        """
        Sets a new parameter for count.

        Parameters
        ----------
        count: IFSelect_IntParam

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_DispPerFiles_SetCount(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_DispPerFiles_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_DispPerFiles
    __del__ = lambda self: None
IFSelect_DispPerFiles_swigregister = _IFSelect.IFSelect_DispPerFiles_swigregister
IFSelect_DispPerFiles_swigregister(IFSelect_DispPerFiles)

class IFSelect_DispPerOne(IFSelect_Dispatch):
    __swig_setmethods__ = {}
    for _s in [IFSelect_Dispatch]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_DispPerOne, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_Dispatch]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_DispPerOne, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a dispperone.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_DispPerOne(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_DispPerOne_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_DispPerOne
    __del__ = lambda self: None
IFSelect_DispPerOne_swigregister = _IFSelect.IFSelect_DispPerOne_swigregister
IFSelect_DispPerOne_swigregister(IFSelect_DispPerOne)

class IFSelect_DispPerSignature(IFSelect_Dispatch):
    __swig_setmethods__ = {}
    for _s in [IFSelect_Dispatch]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_DispPerSignature, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_Dispatch]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_DispPerSignature, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a disppersignature with no signcounter (by default, produces only one packet).

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_DispPerSignature(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetSignCounter(self, *args) -> "void":
        """
        Sets a signcounter for sort remark : it is set to record lists of entities, not only counts.

        Parameters
        ----------
        sign: IFSelect_SignCounter

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_DispPerSignature_SetSignCounter(self, *args)


    def SignCounter(self, *args) -> "opencascade::handle< IFSelect_SignCounter >":
        """
        Returns the signcounter used for splitting.

        Returns
        -------
        opencascade::handle<IFSelect_SignCounter>

        """
        return _IFSelect.IFSelect_DispPerSignature_SignCounter(self, *args)


    def SignName(self, *args) -> "char const *":
        """
        Returns the name of the signcounter, which caracterises the sorting criterium for this dispatch.

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_DispPerSignature_SignName(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_DispPerSignature_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_DispPerSignature
    __del__ = lambda self: None
IFSelect_DispPerSignature_swigregister = _IFSelect.IFSelect_DispPerSignature_swigregister
IFSelect_DispPerSignature_swigregister(IFSelect_DispPerSignature)

class IFSelect_Modifier(IFSelect_GeneralModifier):
    __swig_setmethods__ = {}
    for _s in [IFSelect_GeneralModifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_Modifier, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_GeneralModifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_Modifier, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Perform(self, *args) -> "void":
        """
        This deferred method defines the action specific to each class of modifier. it is called by a modelcopier, once the model generated and filled. modelcopier has already checked the criteria (dispatch, model rank, selection) before calling it. //! <ctx> detains informations about original data and selection. the result of copying, on which modifications are to be done, is <target>. <tc> allows to run additional copies as required //! in case of error, use methods ccheck from the contextmodif to aknowledge an entity check or a global check with messages.

        Parameters
        ----------
        ctx: IFSelect_ContextModif
        target: Interface_InterfaceModel
        protocol: Interface_Protocol
        TC: Interface_CopyTool

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_Modifier_Perform(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_Modifier_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_Modifier
    __del__ = lambda self: None
IFSelect_Modifier_swigregister = _IFSelect.IFSelect_Modifier_swigregister
IFSelect_Modifier_swigregister(IFSelect_Modifier)

class IFSelect_ParamEditor(IFSelect_Editor):
    __swig_setmethods__ = {}
    for _s in [IFSelect_Editor]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_ParamEditor, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_Editor]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_ParamEditor, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a parameditor, empty, with a maximum count of params (default is 100) and a label, by default it will be 'param editor'.

        Parameters
        ----------
        nbmax: int,optional
        	default value is 100
        label: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_ParamEditor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddConstantText(self, *args) -> "void":
        """
        Adds a constant text, it will be read only by default, its long name equates its shortname.

        Parameters
        ----------
        val: char *
        shortname: char *
        completename: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ParamEditor_AddConstantText(self, *args)


    def AddValue(self, *args) -> "void":
        """
        Adds a typedvalue by default, its short name equates its complete name, it can be explicited.

        Parameters
        ----------
        val: Interface_TypedValue
        shortname: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_ParamEditor_AddValue(self, *args)


    def StaticEditor(*args) -> "opencascade::handle< IFSelect_ParamEditor >":
        """
        Returns a parameditor to work on the static parameters of which names are listed in <list> null handle if <list> is null or empty.

        Parameters
        ----------
        list: TColStd_HSequenceOfHAsciiString
        label: char *,optional
        	default value is 

        Returns
        -------
        opencascade::handle<IFSelect_ParamEditor>

        """
        return _IFSelect.IFSelect_ParamEditor_StaticEditor(*args)

    StaticEditor = staticmethod(StaticEditor)


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_ParamEditor_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_ParamEditor
    __del__ = lambda self: None
IFSelect_ParamEditor_swigregister = _IFSelect.IFSelect_ParamEditor_swigregister
IFSelect_ParamEditor_swigregister(IFSelect_ParamEditor)

def IFSelect_ParamEditor_StaticEditor(*args) -> "opencascade::handle< IFSelect_ParamEditor >":
    """
    Returns a parameditor to work on the static parameters of which names are listed in <list> null handle if <list> is null or empty.

    Parameters
    ----------
    list: TColStd_HSequenceOfHAsciiString
    label: char *,optional
    	default value is 

    Returns
    -------
    opencascade::handle<IFSelect_ParamEditor>

    """
    return _IFSelect.IFSelect_ParamEditor_StaticEditor(*args)

class IFSelect_SelectBase(IFSelect_Selection):
    __swig_setmethods__ = {}
    for _s in [IFSelect_Selection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectBase, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_Selection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectBase_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectBase
    __del__ = lambda self: None
IFSelect_SelectBase_swigregister = _IFSelect.IFSelect_SelectBase_swigregister
IFSelect_SelectBase_swigregister(IFSelect_SelectBase)

class IFSelect_SelectCombine(IFSelect_Selection):
    __swig_setmethods__ = {}
    for _s in [IFSelect_Selection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectCombine, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_Selection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectCombine, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Add(self, *args) -> "void":
        """
        Adds a selection to the filling list by default, adds it to the end of the list a positive rank less then nbinputs gives an insertion rank (insertbefore : the new <atnum>th item of the list is <sel>).

        Parameters
        ----------
        sel: IFSelect_Selection
        atnum: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectCombine_Add(self, *args)


    def Input(self, *args) -> "opencascade::handle< IFSelect_Selection >":
        """
        Returns an input selection, given its rank in the list.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<IFSelect_Selection>

        """
        return _IFSelect.IFSelect_SelectCombine_Input(self, *args)


    def InputRank(self, *args) -> "Standard_Integer":
        """
        Returns the rank of an input selection, 0 if not in the list. most generally, its value is meaningless, except for testing the presence of an input selection : - == 0 if <sel> is not an input for <self> - > 0 if <sel> is an input for <self>.

        Parameters
        ----------
        sel: IFSelect_Selection

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SelectCombine_InputRank(self, *args)


    def NbInputs(self, *args) -> "Standard_Integer":
        """
        Returns the count of input selections.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SelectCombine_NbInputs(self, *args)


    def Remove(self, *args) -> "Standard_Boolean":
        """
        Removes an input selection. returns true if done, false, if <sel> is not an input for <self>.

        Parameters
        ----------
        sel: IFSelect_Selection

        Returns
        -------
        bool

        Removes an input selection, given its rank in the list returns true if done, false if <num> is out of range.

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectCombine_Remove(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectCombine_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectCombine
    __del__ = lambda self: None
IFSelect_SelectCombine_swigregister = _IFSelect.IFSelect_SelectCombine_swigregister
IFSelect_SelectCombine_swigregister(IFSelect_SelectCombine)

class IFSelect_SelectControl(IFSelect_Selection):
    __swig_setmethods__ = {}
    for _s in [IFSelect_Selection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectControl, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_Selection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectControl, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def HasSecondInput(self, *args) -> "Standard_Boolean":
        """
        Returns true if a control input is defined thus, result can be computed differently if there is a control input or if there is none.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectControl_HasSecondInput(self, *args)


    def MainInput(self, *args) -> "opencascade::handle< IFSelect_Selection >":
        """
        Returns the main input selection.

        Returns
        -------
        opencascade::handle<IFSelect_Selection>

        """
        return _IFSelect.IFSelect_SelectControl_MainInput(self, *args)


    def SecondInput(self, *args) -> "opencascade::handle< IFSelect_Selection >":
        """
        Returns the control input selection, or a null handle.

        Returns
        -------
        opencascade::handle<IFSelect_Selection>

        """
        return _IFSelect.IFSelect_SelectControl_SecondInput(self, *args)


    def SetMainInput(self, *args) -> "void":
        """
        Sets a selection to be the main input.

        Parameters
        ----------
        sel: IFSelect_Selection

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectControl_SetMainInput(self, *args)


    def SetSecondInput(self, *args) -> "void":
        """
        Sets a selection to be the control input.

        Parameters
        ----------
        sel: IFSelect_Selection

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectControl_SetSecondInput(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectControl_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectControl
    __del__ = lambda self: None
IFSelect_SelectControl_swigregister = _IFSelect.IFSelect_SelectControl_swigregister
IFSelect_SelectControl_swigregister(IFSelect_SelectControl)

class IFSelect_SelectDeduct(IFSelect_Selection):
    __swig_setmethods__ = {}
    for _s in [IFSelect_Selection]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectDeduct, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_Selection]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectDeduct, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Alternate(self, *args) -> "opencascade::handle< IFSelect_SelectPointed > &":
        """
        Returns the alternate definition it is returned modifiable, hence an already defined selectpointed can be used but if it was not yet defined, it is created the first time //! it is exploited by inputresult.

        Returns
        -------
        opencascade::handle<IFSelect_SelectPointed>

        """
        return _IFSelect.IFSelect_SelectDeduct_Alternate(self, *args)


    def HasAlternate(self, *args) -> "Standard_Boolean":
        """
        Tells if an alternate list has been set, i.e. : the alternate definition is present and set.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectDeduct_HasAlternate(self, *args)


    def HasInput(self, *args) -> "Standard_Boolean":
        """
        Returns true if the input selection is defined, false else.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectDeduct_HasInput(self, *args)


    def Input(self, *args) -> "opencascade::handle< IFSelect_Selection >":
        """
        Returns the input selection.

        Returns
        -------
        opencascade::handle<IFSelect_Selection>

        """
        return _IFSelect.IFSelect_SelectDeduct_Input(self, *args)


    def InputResult(self, *args) -> "Interface_EntityIterator":
        """
        Returns the result determined by input selection, as unique if input selection is not defined, returns an empty list. //! if alternate is set, inputresult takes its definition instead of calling the input selection, then clears it.

        Parameters
        ----------
        G: Interface_Graph

        Returns
        -------
        Interface_EntityIterator

        """
        return _IFSelect.IFSelect_SelectDeduct_InputResult(self, *args)


    def SetInput(self, *args) -> "void":
        """
        Defines or changes the input selection.

        Parameters
        ----------
        sel: IFSelect_Selection

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectDeduct_SetInput(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectDeduct_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectDeduct
    __del__ = lambda self: None
IFSelect_SelectDeduct_swigregister = _IFSelect.IFSelect_SelectDeduct_swigregister
IFSelect_SelectDeduct_swigregister(IFSelect_SelectDeduct)

class IFSelect_SessionPilot(IFSelect_Activator):
    __swig_setmethods__ = {}
    for _s in [IFSelect_Activator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SessionPilot, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_Activator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SessionPilot, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an empty sessionpilot, with a prompt which will be displayed on querying commands. if not precised (''), this prompt is set to 'test-xstep>'.

        Parameters
        ----------
        prompt: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SessionPilot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Arg(self, *args) -> "char const *":
        """
        Returns a word given its rank, as a cstring. as for word, begins at 0 (the command name), etc...

        Parameters
        ----------
        num: int

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_SessionPilot_Arg(self, *args)


    def Clear(self, *args) -> "void":
        """
        Clears the recorded informations (commands, objects).

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SessionPilot_Clear(self, *args)


    def Command(self, *args) -> "TCollection_AsciiString const &":
        """
        Returns a recorded command, given its rank (from 1).

        Parameters
        ----------
        num: int

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SessionPilot_Command(self, *args)


    def CommandLine(self, *args) -> "TCollection_AsciiString const &":
        """
        Returns the command line to be interpreted.

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SessionPilot_CommandLine(self, *args)


    def CommandPart(self, *args) -> "char const *":
        """
        Returns the part of the command line which begins at argument <numarg> between 0 and nbwords-1 (by default, all the line) empty string if out of range.

        Parameters
        ----------
        numarg: int,optional
        	default value is 0

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_SessionPilot_CommandPart(self, *args)


    def Execute(self, *args) -> "IFSelect_ReturnStatus":
        """
        Sets the command then tries to execute it. return value : same as for perform.

        Parameters
        ----------
        command: TCollection_AsciiString

        Returns
        -------
        IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_SessionPilot_Execute(self, *args)


    def ExecuteAlias(self, *args) -> "IFSelect_ReturnStatus":
        """
        Executes the commands, except that the command name (word 0) is aliased. the rest of the command line is unchanged if <alias> is empty, executes with no change //! error status is returned if the alias is unknown as command.

        Parameters
        ----------
        aliasname: TCollection_AsciiString

        Returns
        -------
        IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_SessionPilot_ExecuteAlias(self, *args)


    def ExecuteCounter(self, *args) -> "IFSelect_ReturnStatus":
        """
        Executes a counter in a general way if <numword> is greater than count of command words, it counts all the model. else it considers the word <numword> as the identifier of a selection <mode> gives the mode of printing results, default is countbyitem.

        Parameters
        ----------
        counter: IFSelect_SignCounter
        numword: int
        mode: IFSelect_PrintCount,optional
        	default value is IFSelect_CountByItem

        Returns
        -------
        IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_SessionPilot_ExecuteCounter(self, *args)


    def Library(self, *args) -> "opencascade::handle< IFSelect_WorkLibrary >":
        """
        Returns the worklibrary (null if not set). worklibrary is used to read and write files, according to the norm.

        Returns
        -------
        opencascade::handle<IFSelect_WorkLibrary>

        """
        return _IFSelect.IFSelect_SessionPilot_Library(self, *args)


    def NbCommands(self, *args) -> "Standard_Integer":
        """
        Returns the count of recorded commands.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SessionPilot_NbCommands(self, *args)


    def NbWords(self, *args) -> "Standard_Integer":
        """
        Returns the count of words of the command line, separated by blanks : 0 if empty, one if a command without args, else it gives the count of args minus one. warning : limited to 10 (command title + 9 args).

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SessionPilot_NbWords(self, *args)


    def Number(self, *args) -> "Standard_Integer":
        """
        Interprets a string value as an entity number : if it gives an integer, returns its value else, considers it as entitylabel (preferably case sensitive) in case of failure, returns 0.

        Parameters
        ----------
        val: char *

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SessionPilot_Number(self, *args)


    def Perform(self, *args) -> "IFSelect_ReturnStatus":
        """
        Executes the command, itself (for built-in commands, which have priority) or by using the list of activators. the value returned is : retvoid if nothing done (void command) retdone if execution ok, retend if end of session, reterror if command unknown or incorrect, retfail if error on execution if execution is ok and recordmode is set, this command line is recorded to the list (see below).

        Returns
        -------
        IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_SessionPilot_Perform(self, *args)


    def ReadScript(self, *args) -> "IFSelect_ReturnStatus":
        """
        Reads commands from a script file, named <file>. by default (file = ''), reads from standard input with a prompt else (reading from a file), the read commands are displayed onto standard output. allows nested reads. reading is stopped either by command x or exit, or by reaching end of file return value follows the rules of do : retend for normal end, retfail if script could not be opened.

        Parameters
        ----------
        file: char *,optional
        	default value is 

        Returns
        -------
        IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_SessionPilot_ReadScript(self, *args)


    def RecordItem(self, *args) -> "IFSelect_ReturnStatus":
        """
        Allows to associate a transient value with the last execution as a partial result returns retdone if item is not null, retfail if item is null remark : it is nullified for each perform.

        Parameters
        ----------
        item: Standard_Transient

        Returns
        -------
        IFSelect_ReturnStatus

        """
        return _IFSelect.IFSelect_SessionPilot_RecordItem(self, *args)


    def RecordMode(self, *args) -> "Standard_Boolean":
        """
        Returns the record mode for commands. default is false.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SessionPilot_RecordMode(self, *args)


    def RecordedItem(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Returns the transient object which was recorded with the current line command. if none was, returns a null handle.

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _IFSelect.IFSelect_SessionPilot_RecordedItem(self, *args)


    def RemoveWord(self, *args) -> "Standard_Boolean":
        """
        Removes a word given its rank. returns true if done, false if <num> is out of range.

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SessionPilot_RemoveWord(self, *args)


    def Session(self, *args) -> "opencascade::handle< IFSelect_WorkSession >":
        """
        Returns the worksession which is worked on.

        Returns
        -------
        opencascade::handle<IFSelect_WorkSession>

        """
        return _IFSelect.IFSelect_SessionPilot_Session(self, *args)


    def SetCommandLine(self, *args) -> "void":
        """
        Sets the value of the command line to be interpreted also prepares the interpretation (splitting by blanks).

        Parameters
        ----------
        command: TCollection_AsciiString

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SessionPilot_SetCommandLine(self, *args)


    def SetLibrary(self, *args) -> "void":
        """
        Sets a worklibrary.

        Parameters
        ----------
        WL: IFSelect_WorkLibrary

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SessionPilot_SetLibrary(self, *args)


    def SetRecordMode(self, *args) -> "void":
        """
        Changes the recordmode.

        Parameters
        ----------
        mode: bool

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SessionPilot_SetRecordMode(self, *args)


    def SetSession(self, *args) -> "void":
        """
        Sets a worksession to be worked on.

        Parameters
        ----------
        WS: IFSelect_WorkSession

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SessionPilot_SetSession(self, *args)


    def Word(self, *args) -> "TCollection_AsciiString const &":
        """
        Returns a word given its rank in the command line. begins at 0 which is the command title, 1 is the 1st arg., etc...

        Parameters
        ----------
        num: int

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SessionPilot_Word(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SessionPilot_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SessionPilot
    __del__ = lambda self: None
IFSelect_SessionPilot_swigregister = _IFSelect.IFSelect_SessionPilot_swigregister
IFSelect_SessionPilot_swigregister(IFSelect_SessionPilot)

class IFSelect_SignCategory(IFSelect_Signature):
    __swig_setmethods__ = {}
    for _s in [IFSelect_Signature]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SignCategory, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_Signature]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SignCategory, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Returns a signcategory.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SignCategory(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SignCategory_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SignCategory
    __del__ = lambda self: None
IFSelect_SignCategory_swigregister = _IFSelect.IFSelect_SignCategory_swigregister
IFSelect_SignCategory_swigregister(IFSelect_SignCategory)

class IFSelect_SignCounter(IFSelect_SignatureList):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SignatureList]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SignCounter, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SignatureList]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SignCounter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a signcounter, without proper signature if <withmap> is true (default), added entities are counted only if they are not yet recorded in the map map control can be set off if the input garantees uniqueness of data <withlist> is transmitted to signaturelist (option to list entities, not only to count them).

        Parameters
        ----------
        withmap: bool,optional
        	default value is Standard_True
        withlist: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        Creates a signcounter, with a predefined signature other arguments as for create without signature.

        Parameters
        ----------
        matcher: IFSelect_Signature
        withmap: bool,optional
        	default value is Standard_True
        withlist: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SignCounter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddEntity(self, *args) -> "Standard_Boolean":
        """
        Adds an entity by considering its signature, which is given by call to method addsign returns true if added, false if already in the map (and map control status set).

        Parameters
        ----------
        ent: Standard_Transient
        model: Interface_InterfaceModel

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SignCounter_AddEntity(self, *args)


    def AddFromSelection(self, *args) -> "void":
        """
        Adds the result determined by a selection from a graph remark : does not impact at all data from setselection & co.

        Parameters
        ----------
        sel: IFSelect_Selection
        G: Interface_Graph

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SignCounter_AddFromSelection(self, *args)


    def AddList(self, *args) -> "void":
        """
        Adds a list of entities by adding each of the items.

        Parameters
        ----------
        list: TColStd_HSequenceOfTransient
        model: Interface_InterfaceModel

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SignCounter_AddList(self, *args)


    def AddModel(self, *args) -> "void":
        """
        Adds all the entities contained in a model.

        Parameters
        ----------
        model: Interface_InterfaceModel

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SignCounter_AddModel(self, *args)


    def AddSign(self, *args) -> "void":
        """
        Adds an entity (already filtered by map) with its signature. this signature can be computed with the containing model. its value is provided by the object signature given at start, if no signature is defined, it does nothing. //! can be redefined (in this case, see also sign).

        Parameters
        ----------
        ent: Standard_Transient
        model: Interface_InterfaceModel

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SignCounter_AddSign(self, *args)


    def AddWithGraph(self, *args) -> "void":
        """
        Adds a list of entities in the context given by the graph default just call basic addlist can be redefined to get a signature computed with the graph.

        Parameters
        ----------
        list: TColStd_HSequenceOfTransient
        graph: Interface_Graph

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SignCounter_AddWithGraph(self, *args)


    def ComputeSelected(self, *args) -> "Standard_Boolean":
        """
        Computes from the selection result, if selection is active (mode 2). if selection is not defined (mode 0) or is inhibited (mode 1) does nothing. returns true if computation is done (or optimised), false else this method is called by computecounter from worksession //! if <forced> is true, recomputes systematically else (d), if the counter was not cleared and if the former computed result started from the same total size of graph and same count of selected entities : computation is not redone unless <forced> is given as true.

        Parameters
        ----------
        G: Interface_Graph
        forced: bool,optional
        	default value is Standard_False

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SignCounter_ComputeSelected(self, *args)


    def ComputedSign(self, *args) -> "char const *":
        """
        Applies addwithgraph on one entity, and returns the signature value which has been recorded to do this, add is called with signonly mode true during the call, the returned value is lastvalue.

        Parameters
        ----------
        ent: Standard_Transient
        G: Interface_Graph

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_SignCounter_ComputedSign(self, *args)


    def SelMode(self, *args) -> "Standard_Integer":
        """
        Returns the mode of working with the selection.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SignCounter_SelMode(self, *args)


    def Selection(self, *args) -> "opencascade::handle< IFSelect_Selection >":
        """
        Returns the selection, or a null handle.

        Returns
        -------
        opencascade::handle<IFSelect_Selection>

        """
        return _IFSelect.IFSelect_SignCounter_Selection(self, *args)


    def SetMap(self, *args) -> "void":
        """
        Changes the control status. the map is not cleared, simply its use changes.

        Parameters
        ----------
        withmap: bool

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SignCounter_SetMap(self, *args)


    def SetSelMode(self, *args) -> "void":
        """
        Changes the mode of working with the selection : -1 just clears optimisation data and nothing else 0 clears it 1 inhibits it for computing (but no clearing) 2 sets it active for computing default at creation is 0, after setselection (not null) is 2.

        Parameters
        ----------
        selmode: int

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SignCounter_SetSelMode(self, *args)


    def SetSelection(self, *args) -> "void":
        """
        Sets a selection as input : this causes content to be cleared then the selection to be ready to compute (but not immediatly).

        Parameters
        ----------
        sel: IFSelect_Selection

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SignCounter_SetSelection(self, *args)


    def Sign(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Determines and returns the value of the signature for an entity as an hasciistring. this method works exactly as addsign, which is optimized //! can be redefined, accorded with addsign.

        Parameters
        ----------
        ent: Standard_Transient
        model: Interface_InterfaceModel

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _IFSelect.IFSelect_SignCounter_Sign(self, *args)


    def Signature(self, *args) -> "opencascade::handle< IFSelect_Signature >":
        """
        Returns the signature used to count entities. it can be null.

        Returns
        -------
        opencascade::handle<IFSelect_Signature>

        """
        return _IFSelect.IFSelect_SignCounter_Signature(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SignCounter_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SignCounter
    __del__ = lambda self: None
IFSelect_SignCounter_swigregister = _IFSelect.IFSelect_SignCounter_swigregister
IFSelect_SignCounter_swigregister(IFSelect_SignCounter)

class IFSelect_SignMultiple(IFSelect_Signature):
    __swig_setmethods__ = {}
    for _s in [IFSelect_Signature]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SignMultiple, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_Signature]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SignMultiple, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an empty signmultiple with a name this name should take expected tabulations into account.

        Parameters
        ----------
        name: char *

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SignMultiple(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args) -> "void":
        """
        Adds a signature. width, if given, gives the tabulation if <maxi> is true, it is a forced tabulation (overlength is replaced by a final dot) if <maxi> is false, just 3 blanks follow an overlength.

        Parameters
        ----------
        subsign: IFSelect_Signature
        width: int,optional
        	default value is 0
        maxi: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SignMultiple_Add(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SignMultiple_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SignMultiple
    __del__ = lambda self: None
IFSelect_SignMultiple_swigregister = _IFSelect.IFSelect_SignMultiple_swigregister
IFSelect_SignMultiple_swigregister(IFSelect_SignMultiple)

class IFSelect_SignType(IFSelect_Signature):
    __swig_setmethods__ = {}
    for _s in [IFSelect_Signature]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SignType, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_Signature]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SignType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Returns a signtype <nopk> false (d) : complete dynamic type (name = dynamic type) <nopk> true : class type without pk (name = class type).

        Parameters
        ----------
        nopk: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SignType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SignType_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SignType
    __del__ = lambda self: None
IFSelect_SignType_swigregister = _IFSelect.IFSelect_SignType_swigregister
IFSelect_SignType_swigregister(IFSelect_SignType)

class IFSelect_SignValidity(IFSelect_Signature):
    __swig_setmethods__ = {}
    for _s in [IFSelect_Signature]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SignValidity, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_Signature]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SignValidity, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Returns a signvalidity.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SignValidity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CVal(*args) -> "char const *":
        """
        Returns the signature for a transient object, as a validity deducted from data (reports) stored in the model. class method, can be called by any one.

        Parameters
        ----------
        ent: Standard_Transient
        model: Interface_InterfaceModel

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_SignValidity_CVal(*args)

    CVal = staticmethod(CVal)


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SignValidity_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SignValidity
    __del__ = lambda self: None
IFSelect_SignValidity_swigregister = _IFSelect.IFSelect_SignValidity_swigregister
IFSelect_SignValidity_swigregister(IFSelect_SignValidity)

def IFSelect_SignValidity_CVal(*args) -> "char const *":
    """
    Returns the signature for a transient object, as a validity deducted from data (reports) stored in the model. class method, can be called by any one.

    Parameters
    ----------
    ent: Standard_Transient
    model: Interface_InterfaceModel

    Returns
    -------
    char *

    """
    return _IFSelect.IFSelect_SignValidity_CVal(*args)

class IFSelect_TransformStandard(IFSelect_Transformer):
    __swig_setmethods__ = {}
    for _s in [IFSelect_Transformer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_TransformStandard, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_Transformer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_TransformStandard, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a transformstandard, option standardcopy, no modifier.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_TransformStandard(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddModifier(self, *args) -> "Standard_Boolean":
        """
        Adds a modifier to the list : - <atnum> = 0 (default) : at the end of the list - <atnum> > 0 : at rank <atnum> returns true if done, false if <atnum> is out of range.

        Parameters
        ----------
        modif: IFSelect_Modifier
        atnum: int,optional
        	default value is 0

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_TransformStandard_AddModifier(self, *args)


    def ApplyModifiers(self, *args) -> "Standard_Boolean":
        """
        Applies the modifiers sequencially. for each one, prepares required data (if a selection is associated as a filter). for the option onthespot, it determines if the graph may be changed and updates <newmod> if required if a modifier causes an error (check 'hasfailed'), applymodifier stops : the following modifiers are ignored.

        Parameters
        ----------
        G: Interface_Graph
        protocol: Interface_Protocol
        TC: Interface_CopyTool
        checks: Interface_CheckIterator
        newmod: Interface_InterfaceModel

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_TransformStandard_ApplyModifiers(self, *args)


    def Copy(self, *args) -> "void":
        """
        This the first operation. it calls standardcopy or onthespot according the option.

        Parameters
        ----------
        G: Interface_Graph
        TC: Interface_CopyTool
        newmod: Interface_InterfaceModel

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_TransformStandard_Copy(self, *args)


    def CopyOption(self, *args) -> "Standard_Boolean":
        """
        Returns the copy option.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_TransformStandard_CopyOption(self, *args)


    def Modifier(self, *args) -> "opencascade::handle< IFSelect_Modifier >":
        """
        Returns a modifier given its rank in the list.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<IFSelect_Modifier>

        """
        return _IFSelect.IFSelect_TransformStandard_Modifier(self, *args)


    def ModifierRank(self, *args) -> "Standard_Integer":
        """
        Returns the rank of a modifier in the list, 0 if unknown.

        Parameters
        ----------
        modif: IFSelect_Modifier

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_TransformStandard_ModifierRank(self, *args)


    def NbModifiers(self, *args) -> "Standard_Integer":
        """
        Returns the count of recorded modifiers.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_TransformStandard_NbModifiers(self, *args)


    def OnTheSpot(self, *args) -> "void":
        """
        This is the onthespot action : each entity is bound with ... itself. the produced model is the same as the starting one.

        Parameters
        ----------
        G: Interface_Graph
        TC: Interface_CopyTool
        newmod: Interface_InterfaceModel

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_TransformStandard_OnTheSpot(self, *args)


    def RemoveModifier(self, *args) -> "Standard_Boolean":
        """
        Removes a modifier from the list returns true if done, false if <modif> not in the list.

        Parameters
        ----------
        modif: IFSelect_Modifier

        Returns
        -------
        bool

        Removes a modifier from the list, given its rank returns true if done, false if <num> is out of range.

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_TransformStandard_RemoveModifier(self, *args)


    def Selection(self, *args) -> "opencascade::handle< IFSelect_Selection >":
        """
        Returns the selection, null by default.

        Returns
        -------
        opencascade::handle<IFSelect_Selection>

        """
        return _IFSelect.IFSelect_TransformStandard_Selection(self, *args)


    def SetCopyOption(self, *args) -> "void":
        """
        Sets the copy option to a new value : - true for standardcopy - false for onthespot.

        Parameters
        ----------
        option: bool

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_TransformStandard_SetCopyOption(self, *args)


    def SetSelection(self, *args) -> "void":
        """
        Sets a selection (or unsets if null) this selection then defines the list of entities on which the modifiers will be applied if it is set, it has priority on selections of modifiers else, for each modifier its selection is evaluated by default, all the model is taken.

        Parameters
        ----------
        sel: IFSelect_Selection

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_TransformStandard_SetSelection(self, *args)


    def StandardCopy(self, *args) -> "void":
        """
        This is the standard action of copy : its takes into account only the remaining entities (noted by graph status positive) and their proper dependances of course. produces a new model.

        Parameters
        ----------
        G: Interface_Graph
        TC: Interface_CopyTool
        newmod: Interface_InterfaceModel

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_TransformStandard_StandardCopy(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_TransformStandard_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_TransformStandard
    __del__ = lambda self: None
IFSelect_TransformStandard_swigregister = _IFSelect.IFSelect_TransformStandard_swigregister
IFSelect_TransformStandard_swigregister(IFSelect_TransformStandard)

class IFSelect_GraphCounter(IFSelect_SignCounter):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SignCounter]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_GraphCounter, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SignCounter]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_GraphCounter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a graphcounter, without applied selection.

        Parameters
        ----------
        withmap: bool,optional
        	default value is Standard_True
        withlist: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_GraphCounter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Applied(self, *args) -> "opencascade::handle< IFSelect_SelectDeduct >":
        """
        Returns the applied selection.

        Returns
        -------
        opencascade::handle<IFSelect_SelectDeduct>

        """
        return _IFSelect.IFSelect_GraphCounter_Applied(self, *args)


    def SetApplied(self, *args) -> "void":
        """
        Sets a new applied selection.

        Parameters
        ----------
        sel: IFSelect_SelectDeduct

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_GraphCounter_SetApplied(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_GraphCounter_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_GraphCounter
    __del__ = lambda self: None
IFSelect_GraphCounter_swigregister = _IFSelect.IFSelect_GraphCounter_swigregister
IFSelect_GraphCounter_swigregister(IFSelect_GraphCounter)

class IFSelect_ModifEditForm(IFSelect_Modifier):
    __swig_setmethods__ = {}
    for _s in [IFSelect_Modifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_ModifEditForm, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_Modifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_ModifEditForm, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a modifeditform. it may not change the graph.

        Parameters
        ----------
        editform: IFSelect_EditForm

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_ModifEditForm(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def EditForm(self, *args) -> "opencascade::handle< IFSelect_EditForm >":
        """
        Returns the editform.

        Returns
        -------
        opencascade::handle<IFSelect_EditForm>

        """
        return _IFSelect.IFSelect_ModifEditForm_EditForm(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_ModifEditForm_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_ModifEditForm
    __del__ = lambda self: None
IFSelect_ModifEditForm_swigregister = _IFSelect.IFSelect_ModifEditForm_swigregister
IFSelect_ModifEditForm_swigregister(IFSelect_ModifEditForm)

class IFSelect_ModifReorder(IFSelect_Modifier):
    __swig_setmethods__ = {}
    for _s in [IFSelect_Modifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_ModifReorder, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_Modifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_ModifReorder, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a modifreorder. it may change the graph (it does !) if <rootlast> is true (d), roots are set at the end of packets else, they are set at beginning (as done by addwithrefs).

        Parameters
        ----------
        rootlast: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_ModifReorder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_ModifReorder_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_ModifReorder
    __del__ = lambda self: None
IFSelect_ModifReorder_swigregister = _IFSelect.IFSelect_ModifReorder_swigregister
IFSelect_ModifReorder_swigregister(IFSelect_ModifReorder)

class IFSelect_SelectAnyList(IFSelect_SelectDeduct):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectDeduct]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectAnyList, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectDeduct]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectAnyList, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def FillResult(self, *args) -> "void":
        """
        Puts into <res>, the sub-entities of the list, from n1 to n2 included. remark that adequation with entity's type and length of list has already been made at this stage called by rootresult.

        Parameters
        ----------
        n1: int
        n2: int
        ent: Standard_Transient
        res: Interface_EntityIterator

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectAnyList_FillResult(self, *args)


    def HasLower(self, *args) -> "Standard_Boolean":
        """
        Returns true if a lower limit is defined.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectAnyList_HasLower(self, *args)


    def HasUpper(self, *args) -> "Standard_Boolean":
        """
        Returns true if a lower limit is defined.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectAnyList_HasUpper(self, *args)


    def KeepInputEntity(self, *args) -> "void":
        """
        Keeps input entity, as having required type. it works by keeping in <iter>, only suitable entities (selecttype can be used). called by rootresult (which waits for one entity max).

        Parameters
        ----------
        iter: Interface_EntityIterator

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectAnyList_KeepInputEntity(self, *args)


    def ListLabel(self, *args) -> "TCollection_AsciiString":
        """
        Returns the specific label for the list, which is included as a part of label.

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectAnyList_ListLabel(self, *args)


    def Lower(self, *args) -> "opencascade::handle< IFSelect_IntParam >":
        """
        Returns lower limit (if there is; else, value is senseless).

        Returns
        -------
        opencascade::handle<IFSelect_IntParam>

        """
        return _IFSelect.IFSelect_SelectAnyList_Lower(self, *args)


    def LowerValue(self, *args) -> "Standard_Integer":
        """
        Returns integer value of lower limit (0 if none).

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SelectAnyList_LowerValue(self, *args)


    def NbItems(self, *args) -> "Standard_Integer":
        """
        Returns count of items in the list in the entity <ent> if <ent> has not required type, returned value must be zero.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SelectAnyList_NbItems(self, *args)


    def SetFrom(self, *args) -> "void":
        """
        Sets a lower limit but no upper limit.

        Parameters
        ----------
        rankfrom: IFSelect_IntParam

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectAnyList_SetFrom(self, *args)


    def SetOne(self, *args) -> "void":
        """
        Sets a unique number (only one entity will be sorted as true).

        Parameters
        ----------
        rank: IFSelect_IntParam

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectAnyList_SetOne(self, *args)


    def SetRange(self, *args) -> "void":
        """
        Sets a range for numbers, with a lower and a upper limits.

        Parameters
        ----------
        rankfrom: IFSelect_IntParam
        rankto: IFSelect_IntParam

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectAnyList_SetRange(self, *args)


    def SetUntil(self, *args) -> "void":
        """
        Sets an upper limit but no lower limit (equivalent to lower 1).

        Parameters
        ----------
        rankto: IFSelect_IntParam

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectAnyList_SetUntil(self, *args)


    def Upper(self, *args) -> "opencascade::handle< IFSelect_IntParam >":
        """
        Returns upper limit (if there is; else, value is senseless).

        Returns
        -------
        opencascade::handle<IFSelect_IntParam>

        """
        return _IFSelect.IFSelect_SelectAnyList_Upper(self, *args)


    def UpperValue(self, *args) -> "Standard_Integer":
        """
        Returns integer value of upper limit (0 if none).

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SelectAnyList_UpperValue(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectAnyList_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectAnyList
    __del__ = lambda self: None
IFSelect_SelectAnyList_swigregister = _IFSelect.IFSelect_SelectAnyList_swigregister
IFSelect_SelectAnyList_swigregister(IFSelect_SelectAnyList)

class IFSelect_SelectDiff(IFSelect_SelectControl):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectControl]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectDiff, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectControl]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectDiff, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an empty selectdiff.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectDiff(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectDiff_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectDiff
    __del__ = lambda self: None
IFSelect_SelectDiff_swigregister = _IFSelect.IFSelect_SelectDiff_swigregister
IFSelect_SelectDiff_swigregister(IFSelect_SelectDiff)

class IFSelect_SelectEntityNumber(IFSelect_SelectBase):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectEntityNumber, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectEntityNumber, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a selectentitynumber, initially with no specified number.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectEntityNumber(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Number(self, *args) -> "opencascade::handle< IFSelect_IntParam >":
        """
        Returns specified number (as a parameter).

        Returns
        -------
        opencascade::handle<IFSelect_IntParam>

        """
        return _IFSelect.IFSelect_SelectEntityNumber_Number(self, *args)


    def SetNumber(self, *args) -> "void":
        """
        Sets entity number to be taken (initially, none is set : 0).

        Parameters
        ----------
        num: IFSelect_IntParam

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectEntityNumber_SetNumber(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectEntityNumber_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectEntityNumber
    __del__ = lambda self: None
IFSelect_SelectEntityNumber_swigregister = _IFSelect.IFSelect_SelectEntityNumber_swigregister
IFSelect_SelectEntityNumber_swigregister(IFSelect_SelectEntityNumber)

class IFSelect_SelectExplore(IFSelect_SelectDeduct):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectDeduct]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectExplore, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectDeduct]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectExplore, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Explore(self, *args) -> "Standard_Boolean":
        """
        Analyses and, if required, explores an entity, as follows : the explored list starts as empty, it has to be filled by this method. if it returns false, <ent> is rejected for result (this is to be used only as safety) if it returns true and <explored> remains empty, <ent> is taken itself for result, not explored if it returns true and <explored> is not empty, the content of this list is considered : if maximum level is attained, it is taken for result else (or no max), each of its entity will be itself explored.

        Parameters
        ----------
        level: int
        ent: Standard_Transient
        G: Interface_Graph
        explored: Interface_EntityIterator

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectExplore_Explore(self, *args)


    def ExploreLabel(self, *args) -> "TCollection_AsciiString":
        """
        Returns a text defining the way of exploration.

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectExplore_ExploreLabel(self, *args)


    def Level(self, *args) -> "Standard_Integer":
        """
        Returns the required exploring level.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SelectExplore_Level(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectExplore_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectExplore
    __del__ = lambda self: None
IFSelect_SelectExplore_swigregister = _IFSelect.IFSelect_SelectExplore_swigregister
IFSelect_SelectExplore_swigregister(IFSelect_SelectExplore)

class IFSelect_SelectExtract(IFSelect_SelectDeduct):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectDeduct]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectExtract, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectDeduct]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectExtract, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ExtractLabel(self, *args) -> "TCollection_AsciiString":
        """
        Returns a text defining the criterium for extraction.

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectExtract_ExtractLabel(self, *args)


    def IsDirect(self, *args) -> "Standard_Boolean":
        """
        Returns true if sort criterium is direct, false if reverse.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectExtract_IsDirect(self, *args)


    def SetDirect(self, *args) -> "void":
        """
        Sets sort criterium sense to a new value (true : direct , false : reverse).

        Parameters
        ----------
        direct: bool

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectExtract_SetDirect(self, *args)


    def Sort(self, *args) -> "Standard_Boolean":
        """
        Returns true for an entity if it satisfies the sort criterium it receives : - <rank>, the rank of the entity in the iteration, - <ent> , the entity itself, and - <model>, the starting model hence, the entity to check is 'model->value(num)' (but an interfacemodel allows other checks) this method is specific to each class of selectextract.

        Parameters
        ----------
        rank: int
        ent: Standard_Transient
        model: Interface_InterfaceModel

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectExtract_Sort(self, *args)


    def SortInGraph(self, *args) -> "Standard_Boolean":
        """
        Works as sort but works on the graph default directly calls sort, but it can be redefined if sortingraph is redefined, sort should be defined even if not called (to avoid deferred methods in a final class).

        Parameters
        ----------
        rank: int
        ent: Standard_Transient
        G: Interface_Graph

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectExtract_SortInGraph(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectExtract_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectExtract
    __del__ = lambda self: None
IFSelect_SelectExtract_swigregister = _IFSelect.IFSelect_SelectExtract_swigregister
IFSelect_SelectExtract_swigregister(IFSelect_SelectExtract)

class IFSelect_SelectIntersection(IFSelect_SelectCombine):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectCombine]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectIntersection, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectCombine]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectIntersection, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an empty selectintersection.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectIntersection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectIntersection_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectIntersection
    __del__ = lambda self: None
IFSelect_SelectIntersection_swigregister = _IFSelect.IFSelect_SelectIntersection_swigregister
IFSelect_SelectIntersection_swigregister(IFSelect_SelectIntersection)

class IFSelect_SelectModelEntities(IFSelect_SelectBase):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectModelEntities, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectModelEntities, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a selectmodelroot.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectModelEntities(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectModelEntities_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectModelEntities
    __del__ = lambda self: None
IFSelect_SelectModelEntities_swigregister = _IFSelect.IFSelect_SelectModelEntities_swigregister
IFSelect_SelectModelEntities_swigregister(IFSelect_SelectModelEntities)

class IFSelect_SelectModelRoots(IFSelect_SelectBase):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectModelRoots, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectModelRoots, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a selectmodelroot.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectModelRoots(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectModelRoots_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectModelRoots
    __del__ = lambda self: None
IFSelect_SelectModelRoots_swigregister = _IFSelect.IFSelect_SelectModelRoots_swigregister
IFSelect_SelectModelRoots_swigregister(IFSelect_SelectModelRoots)

class IFSelect_SelectPointed(IFSelect_SelectBase):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectPointed, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectPointed, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a selectpointed.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectPointed(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args) -> "Standard_Boolean":
        """
        Adds an item. returns true if done, false if <item> is already in the selected list.

        Parameters
        ----------
        item: Standard_Transient

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectPointed_Add(self, *args)


    def AddList(self, *args) -> "Standard_Boolean":
        """
        Adds all the items defined in a list. returns true if at least one item has been added, false else.

        Parameters
        ----------
        list: TColStd_HSequenceOfTransient

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectPointed_AddList(self, *args)


    def Clear(self, *args) -> "void":
        """
        Clears the list of selected items also says the list is unset all add* methods and setlist say the list is set.

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectPointed_Clear(self, *args)


    def IsSet(self, *args) -> "Standard_Boolean":
        """
        Tells if the list has been set. even if empty.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectPointed_IsSet(self, *args)


    def Item(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Returns an item given its rank, or a null handle.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _IFSelect.IFSelect_SelectPointed_Item(self, *args)


    def NbItems(self, *args) -> "Standard_Integer":
        """
        Returns the count of selected items.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SelectPointed_NbItems(self, *args)


    def Rank(self, *args) -> "Standard_Integer":
        """
        Returns the rank of an item in the selected list, or 0.

        Parameters
        ----------
        item: Standard_Transient

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SelectPointed_Rank(self, *args)


    def Remove(self, *args) -> "Standard_Boolean":
        """
        Removes an item. returns true if done, false if <item> was not in the selected list.

        Parameters
        ----------
        item: Standard_Transient

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectPointed_Remove(self, *args)


    def RemoveList(self, *args) -> "Standard_Boolean":
        """
        Removes all the items defined in a list. returns true if at least one item has been removed, false else.

        Parameters
        ----------
        list: TColStd_HSequenceOfTransient

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectPointed_RemoveList(self, *args)


    def SetEntity(self, *args) -> "void":
        """
        As setlist but with only one entity if <ent> is null, the list is said as being set but is empty.

        Parameters
        ----------
        item: Standard_Transient

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectPointed_SetEntity(self, *args)


    def SetList(self, *args) -> "void":
        """
        Sets a given list to define the list of selected items <list> can be empty or null : in this case, the list is said as being set, but it is empty //! to use it as an alternate input, one shot : - setlist or setentity to define the input list - rootresult to get it - then clear to drop it.

        Parameters
        ----------
        list: TColStd_HSequenceOfTransient

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectPointed_SetList(self, *args)


    def Toggle(self, *args) -> "Standard_Boolean":
        """
        Toggles status of an item : adds it if not pointed or removes it if already pointed. returns the new status (pointed or not).

        Parameters
        ----------
        item: Standard_Transient

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectPointed_Toggle(self, *args)


    def ToggleList(self, *args) -> "Standard_Boolean":
        """
        Toggles status of all the items defined in a list : adds it if not pointed or removes it if already pointed.

        Parameters
        ----------
        list: TColStd_HSequenceOfTransient

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectPointed_ToggleList(self, *args)


    def Update(self, *args) -> "void":
        """
        Rebuilds the selected list. any selected entity which has a bound result is replaced by this result, else it is removed.

        Parameters
        ----------
        control: Interface_CopyControl

        Returns
        -------
        None

        Rebuilds the selected list, by querying a transformer (same principle as from a copycontrol).

        Parameters
        ----------
        trf: IFSelect_Transformer

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectPointed_Update(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectPointed_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectPointed
    __del__ = lambda self: None
IFSelect_SelectPointed_swigregister = _IFSelect.IFSelect_SelectPointed_swigregister
IFSelect_SelectPointed_swigregister(IFSelect_SelectPointed)

class IFSelect_SelectShared(IFSelect_SelectDeduct):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectDeduct]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectShared, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectDeduct]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectShared, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a selectshared;.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectShared(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectShared_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectShared
    __del__ = lambda self: None
IFSelect_SelectShared_swigregister = _IFSelect.IFSelect_SelectShared_swigregister
IFSelect_SelectShared_swigregister(IFSelect_SelectShared)

class IFSelect_SelectSharing(IFSelect_SelectDeduct):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectDeduct]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectSharing, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectDeduct]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectSharing, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a selectsharing;.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectSharing(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectSharing_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectSharing
    __del__ = lambda self: None
IFSelect_SelectSharing_swigregister = _IFSelect.IFSelect_SelectSharing_swigregister
IFSelect_SelectSharing_swigregister(IFSelect_SelectSharing)

class IFSelect_SelectSuite(IFSelect_SelectDeduct):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectDeduct]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectSuite, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectDeduct]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectSuite, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an empty selectsuite.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectSuite(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddInput(self, *args) -> "Standard_Boolean":
        """
        Adds an input selection. i.e. : if <item> is a selectdeduct, adds it as previous, not as input else, sets it as input returns true when done returns false and refuses to work if input is already defined.

        Parameters
        ----------
        item: IFSelect_Selection

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectSuite_AddInput(self, *args)


    def AddNext(self, *args) -> "void":
        """
        Adds a new last item (prepends to the list) if <item> is null, does nothing.

        Parameters
        ----------
        item: IFSelect_SelectDeduct

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectSuite_AddNext(self, *args)


    def AddPrevious(self, *args) -> "void":
        """
        Adds a new first item (prepends to the list). the input is not touched if <item> is null, does nothing.

        Parameters
        ----------
        item: IFSelect_SelectDeduct

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectSuite_AddPrevious(self, *args)


    def Item(self, *args) -> "opencascade::handle< IFSelect_SelectDeduct >":
        """
        Returns an item from its rank in the list (the input is always apart).

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<IFSelect_SelectDeduct>

        """
        return _IFSelect.IFSelect_SelectSuite_Item(self, *args)


    def NbItems(self, *args) -> "Standard_Integer":
        """
        Returns the count of items.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SelectSuite_NbItems(self, *args)


    def SetLabel(self, *args) -> "void":
        """
        Sets a value for the label.

        Parameters
        ----------
        lab: char *

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectSuite_SetLabel(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectSuite_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectSuite
    __del__ = lambda self: None
IFSelect_SelectSuite_swigregister = _IFSelect.IFSelect_SelectSuite_swigregister
IFSelect_SelectSuite_swigregister(IFSelect_SelectSuite)

class IFSelect_SelectUnion(IFSelect_SelectCombine):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectCombine]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectUnion, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectCombine]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectUnion, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an empty selectunion.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectUnion(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectUnion_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectUnion
    __del__ = lambda self: None
IFSelect_SelectUnion_swigregister = _IFSelect.IFSelect_SelectUnion_swigregister
IFSelect_SelectUnion_swigregister(IFSelect_SelectUnion)

class IFSelect_SignAncestor(IFSelect_SignType):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SignType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SignAncestor, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SignType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SignAncestor, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        nopk: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SignAncestor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SignAncestor_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SignAncestor
    __del__ = lambda self: None
IFSelect_SignAncestor_swigregister = _IFSelect.IFSelect_SignAncestor_swigregister
IFSelect_SignAncestor_swigregister(IFSelect_SignAncestor)

class IFSelect_SelectAnyType(IFSelect_SelectExtract):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectExtract]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectAnyType, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectExtract]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectAnyType, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TypeForMatch(self, *args) -> "opencascade::handle< Standard_Type >":
        """
        Returns the type which has to be matched for select.

        Returns
        -------
        opencascade::handle<Standard_Type>

        """
        return _IFSelect.IFSelect_SelectAnyType_TypeForMatch(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectAnyType_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectAnyType
    __del__ = lambda self: None
IFSelect_SelectAnyType_swigregister = _IFSelect.IFSelect_SelectAnyType_swigregister
IFSelect_SelectAnyType_swigregister(IFSelect_SelectAnyType)

class IFSelect_SelectErrorEntities(IFSelect_SelectExtract):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectExtract]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectErrorEntities, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectExtract]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectErrorEntities, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a selecterrorentities.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectErrorEntities(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectErrorEntities_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectErrorEntities
    __del__ = lambda self: None
IFSelect_SelectErrorEntities_swigregister = _IFSelect.IFSelect_SelectErrorEntities_swigregister
IFSelect_SelectErrorEntities_swigregister(IFSelect_SelectErrorEntities)

class IFSelect_SelectFlag(IFSelect_SelectExtract):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectExtract]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectFlag, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectExtract]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectFlag, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a select flag, to query a flag designated by its name.

        Parameters
        ----------
        flagname: char *

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectFlag(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def FlagName(self, *args) -> "char const *":
        """
        Returns the name of the flag.

        Returns
        -------
        char *

        """
        return _IFSelect.IFSelect_SelectFlag_FlagName(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectFlag_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectFlag
    __del__ = lambda self: None
IFSelect_SelectFlag_swigregister = _IFSelect.IFSelect_SelectFlag_swigregister
IFSelect_SelectFlag_swigregister(IFSelect_SelectFlag)

class IFSelect_SelectInList(IFSelect_SelectAnyList):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectAnyList]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectInList, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectAnyList]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectInList, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ListedEntity(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Returns an entity, given its rank in the list.

        Parameters
        ----------
        num: int
        ent: Standard_Transient

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _IFSelect.IFSelect_SelectInList_ListedEntity(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectInList_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectInList
    __del__ = lambda self: None
IFSelect_SelectInList_swigregister = _IFSelect.IFSelect_SelectInList_swigregister
IFSelect_SelectInList_swigregister(IFSelect_SelectInList)

class IFSelect_SelectRange(IFSelect_SelectExtract):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectExtract]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectRange, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectExtract]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectRange, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a selectrange. default is take all the input list.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectRange(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def HasLower(self, *args) -> "Standard_Boolean":
        """
        Returns true if a lower limit is defined.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectRange_HasLower(self, *args)


    def HasUpper(self, *args) -> "Standard_Boolean":
        """
        Returns true if a lower limit is defined.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectRange_HasUpper(self, *args)


    def Lower(self, *args) -> "opencascade::handle< IFSelect_IntParam >":
        """
        Returns lower limit (if there is; else, value is senseless).

        Returns
        -------
        opencascade::handle<IFSelect_IntParam>

        """
        return _IFSelect.IFSelect_SelectRange_Lower(self, *args)


    def LowerValue(self, *args) -> "Standard_Integer":
        """
        Returns value of lower limit (0 if none is defined).

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SelectRange_LowerValue(self, *args)


    def SetFrom(self, *args) -> "void":
        """
        Sets a lower limit but no upper limit.

        Parameters
        ----------
        rankfrom: IFSelect_IntParam

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectRange_SetFrom(self, *args)


    def SetOne(self, *args) -> "void":
        """
        Sets a unique number (only one entity will be sorted as true).

        Parameters
        ----------
        rank: IFSelect_IntParam

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectRange_SetOne(self, *args)


    def SetRange(self, *args) -> "void":
        """
        Sets a range for numbers, with a lower and a upper limits error if rankto is lower then rankfrom.

        Parameters
        ----------
        rankfrom: IFSelect_IntParam
        rankto: IFSelect_IntParam

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectRange_SetRange(self, *args)


    def SetUntil(self, *args) -> "void":
        """
        Sets an upper limit but no lower limit (equivalent to lower 1).

        Parameters
        ----------
        rankto: IFSelect_IntParam

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectRange_SetUntil(self, *args)


    def Upper(self, *args) -> "opencascade::handle< IFSelect_IntParam >":
        """
        Returns upper limit (if there is; else, value is senseless).

        Returns
        -------
        opencascade::handle<IFSelect_IntParam>

        """
        return _IFSelect.IFSelect_SelectRange_Upper(self, *args)


    def UpperValue(self, *args) -> "Standard_Integer":
        """
        Returns value of upper limit (0 if none is defined).

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SelectRange_UpperValue(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectRange_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectRange
    __del__ = lambda self: None
IFSelect_SelectRange_swigregister = _IFSelect.IFSelect_SelectRange_swigregister
IFSelect_SelectRange_swigregister(IFSelect_SelectRange)

class IFSelect_SelectRootComps(IFSelect_SelectExtract):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectExtract]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectRootComps, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectExtract]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectRootComps, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a selectrootcomps.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectRootComps(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectRootComps_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectRootComps
    __del__ = lambda self: None
IFSelect_SelectRootComps_swigregister = _IFSelect.IFSelect_SelectRootComps_swigregister
IFSelect_SelectRootComps_swigregister(IFSelect_SelectRootComps)

class IFSelect_SelectRoots(IFSelect_SelectExtract):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectExtract]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectRoots, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectExtract]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectRoots, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a selectroots.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectRoots(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectRoots_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectRoots
    __del__ = lambda self: None
IFSelect_SelectRoots_swigregister = _IFSelect.IFSelect_SelectRoots_swigregister
IFSelect_SelectRoots_swigregister(IFSelect_SelectRoots)

class IFSelect_SelectSent(IFSelect_SelectExtract):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectExtract]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectSent, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectExtract]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectSent, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a selectsent : sentcount = 0 -> remaining (non-sent) entities sentcount = 1, atleast = true (d) -> sent (at least once) sentcount = 2, atleast = true -> duplicated (sent least twice) etc... sentcount = 1, atleast = false -> sent just once (non-dupl.d) sentcount = 2, atleast = false -> sent just twice etc...

        Parameters
        ----------
        sentcount: int,optional
        	default value is 1
        atleast: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectSent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AtLeast(self, *args) -> "Standard_Boolean":
        """
        Returns the <atleast> status, true for sending at least the sending count, false for sending exactly the sending count remark : if sentcount is 0, atleast is ignored.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectSent_AtLeast(self, *args)


    def SentCount(self, *args) -> "Standard_Integer":
        """
        Returns the queried count of sending.

        Returns
        -------
        int

        """
        return _IFSelect.IFSelect_SelectSent_SentCount(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectSent_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectSent
    __del__ = lambda self: None
IFSelect_SelectSent_swigregister = _IFSelect.IFSelect_SelectSent_swigregister
IFSelect_SelectSent_swigregister(IFSelect_SelectSent)

class IFSelect_SelectSignature(IFSelect_SelectExtract):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectExtract]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectSignature, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectExtract]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectSignature, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a selectsignature with its signature and its text to match. <exact> if true requires exact match, if false requires <signtext> to be contained in the signature of the entity (default is 'exact').

        Parameters
        ----------
        matcher: IFSelect_Signature
        signtext: char *
        exact: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        As above with an asciistring.

        Parameters
        ----------
        matcher: IFSelect_Signature
        signtext: TCollection_AsciiString
        exact: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        Creates a selectsignature with a counter, more precisely a selectsignature. which is used here to just give a signature value (by signonly mode) matching is the default provided by the class signature.

        Parameters
        ----------
        matcher: IFSelect_SignCounter
        signtext: char *
        exact: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectSignature(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Counter(self, *args) -> "opencascade::handle< IFSelect_SignCounter >":
        """
        Returns the used signcounter. can be used as alternative for signature.

        Returns
        -------
        opencascade::handle<IFSelect_SignCounter>

        """
        return _IFSelect.IFSelect_SelectSignature_Counter(self, *args)


    def IsExact(self, *args) -> "Standard_Boolean":
        """
        Returns true if match must be exact.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectSignature_IsExact(self, *args)


    def Signature(self, *args) -> "opencascade::handle< IFSelect_Signature >":
        """
        Returns the used signature, then it is possible to access it, modify it as required. can be null, hence see counter.

        Returns
        -------
        opencascade::handle<IFSelect_Signature>

        """
        return _IFSelect.IFSelect_SelectSignature_Signature(self, *args)


    def SignatureText(self, *args) -> "TCollection_AsciiString const &":
        """
        Returns text used to sort entity on its signature or signcounter.

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectSignature_SignatureText(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectSignature_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectSignature
    __del__ = lambda self: None
IFSelect_SelectSignature_swigregister = _IFSelect.IFSelect_SelectSignature_swigregister
IFSelect_SelectSignature_swigregister(IFSelect_SelectSignature)

class IFSelect_SelectSignedShared(IFSelect_SelectExplore):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectExplore]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectSignedShared, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectExplore]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectSignedShared, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a selectsignedshared, defaulted for any level with a given signature and text to match.

        Parameters
        ----------
        matcher: IFSelect_Signature
        signtext: char *
        exact: bool,optional
        	default value is Standard_True
        level: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectSignedShared(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsExact(self, *args) -> "Standard_Boolean":
        """
        Returns true if match must be exact.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectSignedShared_IsExact(self, *args)


    def Signature(self, *args) -> "opencascade::handle< IFSelect_Signature >":
        """
        Returns the used signature, then it is possible to access it, modify it as required.

        Returns
        -------
        opencascade::handle<IFSelect_Signature>

        """
        return _IFSelect.IFSelect_SelectSignedShared_Signature(self, *args)


    def SignatureText(self, *args) -> "TCollection_AsciiString const &":
        """
        Returns text used to sort entity on its signature.

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectSignedShared_SignatureText(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectSignedShared_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectSignedShared
    __del__ = lambda self: None
IFSelect_SelectSignedShared_swigregister = _IFSelect.IFSelect_SelectSignedShared_swigregister
IFSelect_SelectSignedShared_swigregister(IFSelect_SelectSignedShared)

class IFSelect_SelectSignedSharing(IFSelect_SelectExplore):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectExplore]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectSignedSharing, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectExplore]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectSignedSharing, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a selectsignedsharing, defaulted for any level with a given signature and text to match.

        Parameters
        ----------
        matcher: IFSelect_Signature
        signtext: char *
        exact: bool,optional
        	default value is Standard_True
        level: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectSignedSharing(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsExact(self, *args) -> "Standard_Boolean":
        """
        Returns true if match must be exact.

        Returns
        -------
        bool

        """
        return _IFSelect.IFSelect_SelectSignedSharing_IsExact(self, *args)


    def Signature(self, *args) -> "opencascade::handle< IFSelect_Signature >":
        """
        Returns the used signature, then it is possible to access it, modify it as required.

        Returns
        -------
        opencascade::handle<IFSelect_Signature>

        """
        return _IFSelect.IFSelect_SelectSignedSharing_Signature(self, *args)


    def SignatureText(self, *args) -> "TCollection_AsciiString const &":
        """
        Returns text used to sort entity on its signature.

        Returns
        -------
        TCollection_AsciiString

        """
        return _IFSelect.IFSelect_SelectSignedSharing_SignatureText(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectSignedSharing_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectSignedSharing
    __del__ = lambda self: None
IFSelect_SelectSignedSharing_swigregister = _IFSelect.IFSelect_SelectSignedSharing_swigregister
IFSelect_SelectSignedSharing_swigregister(IFSelect_SelectSignedSharing)

class IFSelect_SelectUnknownEntities(IFSelect_SelectExtract):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectExtract]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectUnknownEntities, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectExtract]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectUnknownEntities, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a selectunknownentities.

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectUnknownEntities(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectUnknownEntities_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectUnknownEntities
    __del__ = lambda self: None
IFSelect_SelectUnknownEntities_swigregister = _IFSelect.IFSelect_SelectUnknownEntities_swigregister
IFSelect_SelectUnknownEntities_swigregister(IFSelect_SelectUnknownEntities)

class IFSelect_SelectIncorrectEntities(IFSelect_SelectFlag):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectFlag]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectIncorrectEntities, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectFlag]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectIncorrectEntities, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a selectincorrectentities i.e. a selectflag('incorrect').

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectIncorrectEntities(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectIncorrectEntities_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectIncorrectEntities
    __del__ = lambda self: None
IFSelect_SelectIncorrectEntities_swigregister = _IFSelect.IFSelect_SelectIncorrectEntities_swigregister
IFSelect_SelectIncorrectEntities_swigregister(IFSelect_SelectIncorrectEntities)

class IFSelect_SelectType(IFSelect_SelectAnyType):
    __swig_setmethods__ = {}
    for _s in [IFSelect_SelectAnyType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_SelectType, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_SelectAnyType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_SelectType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a selecttype. default is no filter.

        Returns
        -------
        None

        Creates a selecttype for a given type.

        Parameters
        ----------
        atype: Standard_Type

        Returns
        -------
        None

        """
        this = _IFSelect.new_IFSelect_SelectType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetType(self, *args) -> "void":
        """
        Sets a type for filter.

        Parameters
        ----------
        atype: Standard_Type

        Returns
        -------
        None

        """
        return _IFSelect.IFSelect_SelectType_SetType(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_SelectType_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IFSelect.delete_IFSelect_SelectType
    __del__ = lambda self: None
IFSelect_SelectType_swigregister = _IFSelect.IFSelect_SelectType_swigregister
IFSelect_SelectType_swigregister(IFSelect_SelectType)

class IFSelect_HSeqOfSelection(IFSelect_TSeqOfSelection, OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [IFSelect_TSeqOfSelection, OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFSelect_HSeqOfSelection, name, value)
    __swig_getmethods__ = {}
    for _s in [IFSelect_TSeqOfSelection, OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IFSelect_HSeqOfSelection, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _IFSelect.new_IFSelect_HSeqOfSelection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Sequence(self) -> "IFSelect_TSeqOfSelection const &":
        return _IFSelect.IFSelect_HSeqOfSelection_Sequence(self)

    def Append(self, *args) -> "void":
        return _IFSelect.IFSelect_HSeqOfSelection_Append(self, *args)

    def ChangeSequence(self) -> "IFSelect_TSeqOfSelection &":
        return _IFSelect.IFSelect_HSeqOfSelection_ChangeSequence(self)


    @staticmethod
    def DownCast(t):
      return Handle_IFSelect_HSeqOfSelection_DownCast(t)

    __swig_destroy__ = _IFSelect.delete_IFSelect_HSeqOfSelection
    __del__ = lambda self: None
IFSelect_HSeqOfSelection_swigregister = _IFSelect.IFSelect_HSeqOfSelection_swigregister
IFSelect_HSeqOfSelection_swigregister(IFSelect_HSeqOfSelection)



# This file is compatible with both classic and new-style classes.


