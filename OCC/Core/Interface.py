# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
Interface module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_interface.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Interface')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Interface')
    _Interface = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Interface', [dirname(__file__)])
        except ImportError:
            import _Interface
            return _Interface
        try:
            _mod = imp.load_module('_Interface', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Interface = swig_import_helper()
    del swig_import_helper
else:
    import _Interface
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Interface.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _Interface.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _Interface.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _Interface.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _Interface.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _Interface.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _Interface.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _Interface.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _Interface.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _Interface.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _Interface.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _Interface.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _Interface.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _Interface.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _Interface.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _Interface.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _Interface.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Interface.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _Interface.process_exception(error, method_name, class_name)
process_exception = _Interface.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TCollection
import OCC.Core.Message
import OCC.Core.OSD
import OCC.Core.TColStd
import OCC.Core.MoniTool
import OCC.Core.TopoDS
import OCC.Core.TopAbs
import OCC.Core.TopLoc
import OCC.Core.gp

from enum import IntEnum
from OCC.Core.Exception import *

Interface_ParamMisc = _Interface.Interface_ParamMisc
Interface_ParamInteger = _Interface.Interface_ParamInteger
Interface_ParamReal = _Interface.Interface_ParamReal
Interface_ParamIdent = _Interface.Interface_ParamIdent
Interface_ParamVoid = _Interface.Interface_ParamVoid
Interface_ParamText = _Interface.Interface_ParamText
Interface_ParamEnum = _Interface.Interface_ParamEnum
Interface_ParamLogical = _Interface.Interface_ParamLogical
Interface_ParamSub = _Interface.Interface_ParamSub
Interface_ParamHexa = _Interface.Interface_ParamHexa
Interface_ParamBinary = _Interface.Interface_ParamBinary
Interface_StateOK = _Interface.Interface_StateOK
Interface_LoadWarning = _Interface.Interface_LoadWarning
Interface_LoadFail = _Interface.Interface_LoadFail
Interface_DataWarning = _Interface.Interface_DataWarning
Interface_DataFail = _Interface.Interface_DataFail
Interface_StateUnloaded = _Interface.Interface_StateUnloaded
Interface_StateUnknown = _Interface.Interface_StateUnknown
Interface_CheckOK = _Interface.Interface_CheckOK
Interface_CheckWarning = _Interface.Interface_CheckWarning
Interface_CheckFail = _Interface.Interface_CheckFail
Interface_CheckAny = _Interface.Interface_CheckAny
Interface_CheckMessage = _Interface.Interface_CheckMessage
Interface_CheckNoFail = _Interface.Interface_CheckNoFail


class Interface_ParamType(IntEnum):
	Interface_ParamMisc = 0
	Interface_ParamInteger = 1
	Interface_ParamReal = 2
	Interface_ParamIdent = 3
	Interface_ParamVoid = 4
	Interface_ParamText = 5
	Interface_ParamEnum = 6
	Interface_ParamLogical = 7
	Interface_ParamSub = 8
	Interface_ParamHexa = 9
	Interface_ParamBinary = 10
Interface_ParamMisc = Interface_ParamType.Interface_ParamMisc
Interface_ParamInteger = Interface_ParamType.Interface_ParamInteger
Interface_ParamReal = Interface_ParamType.Interface_ParamReal
Interface_ParamIdent = Interface_ParamType.Interface_ParamIdent
Interface_ParamVoid = Interface_ParamType.Interface_ParamVoid
Interface_ParamText = Interface_ParamType.Interface_ParamText
Interface_ParamEnum = Interface_ParamType.Interface_ParamEnum
Interface_ParamLogical = Interface_ParamType.Interface_ParamLogical
Interface_ParamSub = Interface_ParamType.Interface_ParamSub
Interface_ParamHexa = Interface_ParamType.Interface_ParamHexa
Interface_ParamBinary = Interface_ParamType.Interface_ParamBinary

class Interface_DataState(IntEnum):
	Interface_StateOK = 0
	Interface_LoadWarning = 1
	Interface_LoadFail = 2
	Interface_DataWarning = 3
	Interface_DataFail = 4
	Interface_StateUnloaded = 5
	Interface_StateUnknown = 6
Interface_StateOK = Interface_DataState.Interface_StateOK
Interface_LoadWarning = Interface_DataState.Interface_LoadWarning
Interface_LoadFail = Interface_DataState.Interface_LoadFail
Interface_DataWarning = Interface_DataState.Interface_DataWarning
Interface_DataFail = Interface_DataState.Interface_DataFail
Interface_StateUnloaded = Interface_DataState.Interface_StateUnloaded
Interface_StateUnknown = Interface_DataState.Interface_StateUnknown

class Interface_CheckStatus(IntEnum):
	Interface_CheckOK = 0
	Interface_CheckWarning = 1
	Interface_CheckFail = 2
	Interface_CheckAny = 3
	Interface_CheckMessage = 4
	Interface_CheckNoFail = 5
Interface_CheckOK = Interface_CheckStatus.Interface_CheckOK
Interface_CheckWarning = Interface_CheckStatus.Interface_CheckWarning
Interface_CheckFail = Interface_CheckStatus.Interface_CheckFail
Interface_CheckAny = Interface_CheckStatus.Interface_CheckAny
Interface_CheckMessage = Interface_CheckStatus.Interface_CheckMessage
Interface_CheckNoFail = Interface_CheckStatus.Interface_CheckNoFail


def Handle_Interface_Check_Create() -> "opencascade::handle< Interface_Check >":
    return _Interface.Handle_Interface_Check_Create()
Handle_Interface_Check_Create = _Interface.Handle_Interface_Check_Create

def Handle_Interface_Check_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_Check >":
    return _Interface.Handle_Interface_Check_DownCast(t)
Handle_Interface_Check_DownCast = _Interface.Handle_Interface_Check_DownCast

def Handle_Interface_Check_IsNull(t: 'opencascade::handle< Interface_Check > const &') -> "bool":
    return _Interface.Handle_Interface_Check_IsNull(t)
Handle_Interface_Check_IsNull = _Interface.Handle_Interface_Check_IsNull

def Handle_Interface_CopyControl_Create() -> "opencascade::handle< Interface_CopyControl >":
    return _Interface.Handle_Interface_CopyControl_Create()
Handle_Interface_CopyControl_Create = _Interface.Handle_Interface_CopyControl_Create

def Handle_Interface_CopyControl_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_CopyControl >":
    return _Interface.Handle_Interface_CopyControl_DownCast(t)
Handle_Interface_CopyControl_DownCast = _Interface.Handle_Interface_CopyControl_DownCast

def Handle_Interface_CopyControl_IsNull(t: 'opencascade::handle< Interface_CopyControl > const &') -> "bool":
    return _Interface.Handle_Interface_CopyControl_IsNull(t)
Handle_Interface_CopyControl_IsNull = _Interface.Handle_Interface_CopyControl_IsNull

def Handle_Interface_EntityCluster_Create() -> "opencascade::handle< Interface_EntityCluster >":
    return _Interface.Handle_Interface_EntityCluster_Create()
Handle_Interface_EntityCluster_Create = _Interface.Handle_Interface_EntityCluster_Create

def Handle_Interface_EntityCluster_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_EntityCluster >":
    return _Interface.Handle_Interface_EntityCluster_DownCast(t)
Handle_Interface_EntityCluster_DownCast = _Interface.Handle_Interface_EntityCluster_DownCast

def Handle_Interface_EntityCluster_IsNull(t: 'opencascade::handle< Interface_EntityCluster > const &') -> "bool":
    return _Interface.Handle_Interface_EntityCluster_IsNull(t)
Handle_Interface_EntityCluster_IsNull = _Interface.Handle_Interface_EntityCluster_IsNull

def Handle_Interface_FileReaderData_Create() -> "opencascade::handle< Interface_FileReaderData >":
    return _Interface.Handle_Interface_FileReaderData_Create()
Handle_Interface_FileReaderData_Create = _Interface.Handle_Interface_FileReaderData_Create

def Handle_Interface_FileReaderData_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_FileReaderData >":
    return _Interface.Handle_Interface_FileReaderData_DownCast(t)
Handle_Interface_FileReaderData_DownCast = _Interface.Handle_Interface_FileReaderData_DownCast

def Handle_Interface_FileReaderData_IsNull(t: 'opencascade::handle< Interface_FileReaderData > const &') -> "bool":
    return _Interface.Handle_Interface_FileReaderData_IsNull(t)
Handle_Interface_FileReaderData_IsNull = _Interface.Handle_Interface_FileReaderData_IsNull

def Handle_Interface_GTool_Create() -> "opencascade::handle< Interface_GTool >":
    return _Interface.Handle_Interface_GTool_Create()
Handle_Interface_GTool_Create = _Interface.Handle_Interface_GTool_Create

def Handle_Interface_GTool_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_GTool >":
    return _Interface.Handle_Interface_GTool_DownCast(t)
Handle_Interface_GTool_DownCast = _Interface.Handle_Interface_GTool_DownCast

def Handle_Interface_GTool_IsNull(t: 'opencascade::handle< Interface_GTool > const &') -> "bool":
    return _Interface.Handle_Interface_GTool_IsNull(t)
Handle_Interface_GTool_IsNull = _Interface.Handle_Interface_GTool_IsNull

def Handle_Interface_GeneralModule_Create() -> "opencascade::handle< Interface_GeneralModule >":
    return _Interface.Handle_Interface_GeneralModule_Create()
Handle_Interface_GeneralModule_Create = _Interface.Handle_Interface_GeneralModule_Create

def Handle_Interface_GeneralModule_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_GeneralModule >":
    return _Interface.Handle_Interface_GeneralModule_DownCast(t)
Handle_Interface_GeneralModule_DownCast = _Interface.Handle_Interface_GeneralModule_DownCast

def Handle_Interface_GeneralModule_IsNull(t: 'opencascade::handle< Interface_GeneralModule > const &') -> "bool":
    return _Interface.Handle_Interface_GeneralModule_IsNull(t)
Handle_Interface_GeneralModule_IsNull = _Interface.Handle_Interface_GeneralModule_IsNull

def Handle_Interface_GlobalNodeOfGeneralLib_Create() -> "opencascade::handle< Interface_GlobalNodeOfGeneralLib >":
    return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_Create()
Handle_Interface_GlobalNodeOfGeneralLib_Create = _Interface.Handle_Interface_GlobalNodeOfGeneralLib_Create

def Handle_Interface_GlobalNodeOfGeneralLib_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_GlobalNodeOfGeneralLib >":
    return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_DownCast(t)
Handle_Interface_GlobalNodeOfGeneralLib_DownCast = _Interface.Handle_Interface_GlobalNodeOfGeneralLib_DownCast

def Handle_Interface_GlobalNodeOfGeneralLib_IsNull(t: 'opencascade::handle< Interface_GlobalNodeOfGeneralLib > const &') -> "bool":
    return _Interface.Handle_Interface_GlobalNodeOfGeneralLib_IsNull(t)
Handle_Interface_GlobalNodeOfGeneralLib_IsNull = _Interface.Handle_Interface_GlobalNodeOfGeneralLib_IsNull

def Handle_Interface_GlobalNodeOfReaderLib_Create() -> "opencascade::handle< Interface_GlobalNodeOfReaderLib >":
    return _Interface.Handle_Interface_GlobalNodeOfReaderLib_Create()
Handle_Interface_GlobalNodeOfReaderLib_Create = _Interface.Handle_Interface_GlobalNodeOfReaderLib_Create

def Handle_Interface_GlobalNodeOfReaderLib_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_GlobalNodeOfReaderLib >":
    return _Interface.Handle_Interface_GlobalNodeOfReaderLib_DownCast(t)
Handle_Interface_GlobalNodeOfReaderLib_DownCast = _Interface.Handle_Interface_GlobalNodeOfReaderLib_DownCast

def Handle_Interface_GlobalNodeOfReaderLib_IsNull(t: 'opencascade::handle< Interface_GlobalNodeOfReaderLib > const &') -> "bool":
    return _Interface.Handle_Interface_GlobalNodeOfReaderLib_IsNull(t)
Handle_Interface_GlobalNodeOfReaderLib_IsNull = _Interface.Handle_Interface_GlobalNodeOfReaderLib_IsNull

def Handle_Interface_HGraph_Create() -> "opencascade::handle< Interface_HGraph >":
    return _Interface.Handle_Interface_HGraph_Create()
Handle_Interface_HGraph_Create = _Interface.Handle_Interface_HGraph_Create

def Handle_Interface_HGraph_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_HGraph >":
    return _Interface.Handle_Interface_HGraph_DownCast(t)
Handle_Interface_HGraph_DownCast = _Interface.Handle_Interface_HGraph_DownCast

def Handle_Interface_HGraph_IsNull(t: 'opencascade::handle< Interface_HGraph > const &') -> "bool":
    return _Interface.Handle_Interface_HGraph_IsNull(t)
Handle_Interface_HGraph_IsNull = _Interface.Handle_Interface_HGraph_IsNull

def Handle_Interface_IntVal_Create() -> "opencascade::handle< Interface_IntVal >":
    return _Interface.Handle_Interface_IntVal_Create()
Handle_Interface_IntVal_Create = _Interface.Handle_Interface_IntVal_Create

def Handle_Interface_IntVal_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_IntVal >":
    return _Interface.Handle_Interface_IntVal_DownCast(t)
Handle_Interface_IntVal_DownCast = _Interface.Handle_Interface_IntVal_DownCast

def Handle_Interface_IntVal_IsNull(t: 'opencascade::handle< Interface_IntVal > const &') -> "bool":
    return _Interface.Handle_Interface_IntVal_IsNull(t)
Handle_Interface_IntVal_IsNull = _Interface.Handle_Interface_IntVal_IsNull

def Handle_Interface_InterfaceModel_Create() -> "opencascade::handle< Interface_InterfaceModel >":
    return _Interface.Handle_Interface_InterfaceModel_Create()
Handle_Interface_InterfaceModel_Create = _Interface.Handle_Interface_InterfaceModel_Create

def Handle_Interface_InterfaceModel_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_InterfaceModel >":
    return _Interface.Handle_Interface_InterfaceModel_DownCast(t)
Handle_Interface_InterfaceModel_DownCast = _Interface.Handle_Interface_InterfaceModel_DownCast

def Handle_Interface_InterfaceModel_IsNull(t: 'opencascade::handle< Interface_InterfaceModel > const &') -> "bool":
    return _Interface.Handle_Interface_InterfaceModel_IsNull(t)
Handle_Interface_InterfaceModel_IsNull = _Interface.Handle_Interface_InterfaceModel_IsNull

def Handle_Interface_NodeOfGeneralLib_Create() -> "opencascade::handle< Interface_NodeOfGeneralLib >":
    return _Interface.Handle_Interface_NodeOfGeneralLib_Create()
Handle_Interface_NodeOfGeneralLib_Create = _Interface.Handle_Interface_NodeOfGeneralLib_Create

def Handle_Interface_NodeOfGeneralLib_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_NodeOfGeneralLib >":
    return _Interface.Handle_Interface_NodeOfGeneralLib_DownCast(t)
Handle_Interface_NodeOfGeneralLib_DownCast = _Interface.Handle_Interface_NodeOfGeneralLib_DownCast

def Handle_Interface_NodeOfGeneralLib_IsNull(t: 'opencascade::handle< Interface_NodeOfGeneralLib > const &') -> "bool":
    return _Interface.Handle_Interface_NodeOfGeneralLib_IsNull(t)
Handle_Interface_NodeOfGeneralLib_IsNull = _Interface.Handle_Interface_NodeOfGeneralLib_IsNull

def Handle_Interface_NodeOfReaderLib_Create() -> "opencascade::handle< Interface_NodeOfReaderLib >":
    return _Interface.Handle_Interface_NodeOfReaderLib_Create()
Handle_Interface_NodeOfReaderLib_Create = _Interface.Handle_Interface_NodeOfReaderLib_Create

def Handle_Interface_NodeOfReaderLib_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_NodeOfReaderLib >":
    return _Interface.Handle_Interface_NodeOfReaderLib_DownCast(t)
Handle_Interface_NodeOfReaderLib_DownCast = _Interface.Handle_Interface_NodeOfReaderLib_DownCast

def Handle_Interface_NodeOfReaderLib_IsNull(t: 'opencascade::handle< Interface_NodeOfReaderLib > const &') -> "bool":
    return _Interface.Handle_Interface_NodeOfReaderLib_IsNull(t)
Handle_Interface_NodeOfReaderLib_IsNull = _Interface.Handle_Interface_NodeOfReaderLib_IsNull

def Handle_Interface_ParamList_Create() -> "opencascade::handle< Interface_ParamList >":
    return _Interface.Handle_Interface_ParamList_Create()
Handle_Interface_ParamList_Create = _Interface.Handle_Interface_ParamList_Create

def Handle_Interface_ParamList_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_ParamList >":
    return _Interface.Handle_Interface_ParamList_DownCast(t)
Handle_Interface_ParamList_DownCast = _Interface.Handle_Interface_ParamList_DownCast

def Handle_Interface_ParamList_IsNull(t: 'opencascade::handle< Interface_ParamList > const &') -> "bool":
    return _Interface.Handle_Interface_ParamList_IsNull(t)
Handle_Interface_ParamList_IsNull = _Interface.Handle_Interface_ParamList_IsNull

def Handle_Interface_ParamSet_Create() -> "opencascade::handle< Interface_ParamSet >":
    return _Interface.Handle_Interface_ParamSet_Create()
Handle_Interface_ParamSet_Create = _Interface.Handle_Interface_ParamSet_Create

def Handle_Interface_ParamSet_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_ParamSet >":
    return _Interface.Handle_Interface_ParamSet_DownCast(t)
Handle_Interface_ParamSet_DownCast = _Interface.Handle_Interface_ParamSet_DownCast

def Handle_Interface_ParamSet_IsNull(t: 'opencascade::handle< Interface_ParamSet > const &') -> "bool":
    return _Interface.Handle_Interface_ParamSet_IsNull(t)
Handle_Interface_ParamSet_IsNull = _Interface.Handle_Interface_ParamSet_IsNull

def Handle_Interface_Protocol_Create() -> "opencascade::handle< Interface_Protocol >":
    return _Interface.Handle_Interface_Protocol_Create()
Handle_Interface_Protocol_Create = _Interface.Handle_Interface_Protocol_Create

def Handle_Interface_Protocol_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_Protocol >":
    return _Interface.Handle_Interface_Protocol_DownCast(t)
Handle_Interface_Protocol_DownCast = _Interface.Handle_Interface_Protocol_DownCast

def Handle_Interface_Protocol_IsNull(t: 'opencascade::handle< Interface_Protocol > const &') -> "bool":
    return _Interface.Handle_Interface_Protocol_IsNull(t)
Handle_Interface_Protocol_IsNull = _Interface.Handle_Interface_Protocol_IsNull

def Handle_Interface_ReaderModule_Create() -> "opencascade::handle< Interface_ReaderModule >":
    return _Interface.Handle_Interface_ReaderModule_Create()
Handle_Interface_ReaderModule_Create = _Interface.Handle_Interface_ReaderModule_Create

def Handle_Interface_ReaderModule_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_ReaderModule >":
    return _Interface.Handle_Interface_ReaderModule_DownCast(t)
Handle_Interface_ReaderModule_DownCast = _Interface.Handle_Interface_ReaderModule_DownCast

def Handle_Interface_ReaderModule_IsNull(t: 'opencascade::handle< Interface_ReaderModule > const &') -> "bool":
    return _Interface.Handle_Interface_ReaderModule_IsNull(t)
Handle_Interface_ReaderModule_IsNull = _Interface.Handle_Interface_ReaderModule_IsNull

def Handle_Interface_ReportEntity_Create() -> "opencascade::handle< Interface_ReportEntity >":
    return _Interface.Handle_Interface_ReportEntity_Create()
Handle_Interface_ReportEntity_Create = _Interface.Handle_Interface_ReportEntity_Create

def Handle_Interface_ReportEntity_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_ReportEntity >":
    return _Interface.Handle_Interface_ReportEntity_DownCast(t)
Handle_Interface_ReportEntity_DownCast = _Interface.Handle_Interface_ReportEntity_DownCast

def Handle_Interface_ReportEntity_IsNull(t: 'opencascade::handle< Interface_ReportEntity > const &') -> "bool":
    return _Interface.Handle_Interface_ReportEntity_IsNull(t)
Handle_Interface_ReportEntity_IsNull = _Interface.Handle_Interface_ReportEntity_IsNull

def Handle_Interface_SignLabel_Create() -> "opencascade::handle< Interface_SignLabel >":
    return _Interface.Handle_Interface_SignLabel_Create()
Handle_Interface_SignLabel_Create = _Interface.Handle_Interface_SignLabel_Create

def Handle_Interface_SignLabel_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_SignLabel >":
    return _Interface.Handle_Interface_SignLabel_DownCast(t)
Handle_Interface_SignLabel_DownCast = _Interface.Handle_Interface_SignLabel_DownCast

def Handle_Interface_SignLabel_IsNull(t: 'opencascade::handle< Interface_SignLabel > const &') -> "bool":
    return _Interface.Handle_Interface_SignLabel_IsNull(t)
Handle_Interface_SignLabel_IsNull = _Interface.Handle_Interface_SignLabel_IsNull

def Handle_Interface_SignType_Create() -> "opencascade::handle< Interface_SignType >":
    return _Interface.Handle_Interface_SignType_Create()
Handle_Interface_SignType_Create = _Interface.Handle_Interface_SignType_Create

def Handle_Interface_SignType_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_SignType >":
    return _Interface.Handle_Interface_SignType_DownCast(t)
Handle_Interface_SignType_DownCast = _Interface.Handle_Interface_SignType_DownCast

def Handle_Interface_SignType_IsNull(t: 'opencascade::handle< Interface_SignType > const &') -> "bool":
    return _Interface.Handle_Interface_SignType_IsNull(t)
Handle_Interface_SignType_IsNull = _Interface.Handle_Interface_SignType_IsNull

def Handle_Interface_TypedValue_Create() -> "opencascade::handle< Interface_TypedValue >":
    return _Interface.Handle_Interface_TypedValue_Create()
Handle_Interface_TypedValue_Create = _Interface.Handle_Interface_TypedValue_Create

def Handle_Interface_TypedValue_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_TypedValue >":
    return _Interface.Handle_Interface_TypedValue_DownCast(t)
Handle_Interface_TypedValue_DownCast = _Interface.Handle_Interface_TypedValue_DownCast

def Handle_Interface_TypedValue_IsNull(t: 'opencascade::handle< Interface_TypedValue > const &') -> "bool":
    return _Interface.Handle_Interface_TypedValue_IsNull(t)
Handle_Interface_TypedValue_IsNull = _Interface.Handle_Interface_TypedValue_IsNull

def Handle_Interface_UndefinedContent_Create() -> "opencascade::handle< Interface_UndefinedContent >":
    return _Interface.Handle_Interface_UndefinedContent_Create()
Handle_Interface_UndefinedContent_Create = _Interface.Handle_Interface_UndefinedContent_Create

def Handle_Interface_UndefinedContent_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_UndefinedContent >":
    return _Interface.Handle_Interface_UndefinedContent_DownCast(t)
Handle_Interface_UndefinedContent_DownCast = _Interface.Handle_Interface_UndefinedContent_DownCast

def Handle_Interface_UndefinedContent_IsNull(t: 'opencascade::handle< Interface_UndefinedContent > const &') -> "bool":
    return _Interface.Handle_Interface_UndefinedContent_IsNull(t)
Handle_Interface_UndefinedContent_IsNull = _Interface.Handle_Interface_UndefinedContent_IsNull

def Handle_Interface_CopyMap_Create() -> "opencascade::handle< Interface_CopyMap >":
    return _Interface.Handle_Interface_CopyMap_Create()
Handle_Interface_CopyMap_Create = _Interface.Handle_Interface_CopyMap_Create

def Handle_Interface_CopyMap_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_CopyMap >":
    return _Interface.Handle_Interface_CopyMap_DownCast(t)
Handle_Interface_CopyMap_DownCast = _Interface.Handle_Interface_CopyMap_DownCast

def Handle_Interface_CopyMap_IsNull(t: 'opencascade::handle< Interface_CopyMap > const &') -> "bool":
    return _Interface.Handle_Interface_CopyMap_IsNull(t)
Handle_Interface_CopyMap_IsNull = _Interface.Handle_Interface_CopyMap_IsNull

def Handle_Interface_Static_Create() -> "opencascade::handle< Interface_Static >":
    return _Interface.Handle_Interface_Static_Create()
Handle_Interface_Static_Create = _Interface.Handle_Interface_Static_Create

def Handle_Interface_Static_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_Static >":
    return _Interface.Handle_Interface_Static_DownCast(t)
Handle_Interface_Static_DownCast = _Interface.Handle_Interface_Static_DownCast

def Handle_Interface_Static_IsNull(t: 'opencascade::handle< Interface_Static > const &') -> "bool":
    return _Interface.Handle_Interface_Static_IsNull(t)
Handle_Interface_Static_IsNull = _Interface.Handle_Interface_Static_IsNull

def Handle_Interface_HArray1OfHAsciiString_Create() -> "opencascade::handle< Interface_HArray1OfHAsciiString >":
    return _Interface.Handle_Interface_HArray1OfHAsciiString_Create()
Handle_Interface_HArray1OfHAsciiString_Create = _Interface.Handle_Interface_HArray1OfHAsciiString_Create

def Handle_Interface_HArray1OfHAsciiString_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_HArray1OfHAsciiString >":
    return _Interface.Handle_Interface_HArray1OfHAsciiString_DownCast(t)
Handle_Interface_HArray1OfHAsciiString_DownCast = _Interface.Handle_Interface_HArray1OfHAsciiString_DownCast

def Handle_Interface_HArray1OfHAsciiString_IsNull(t: 'opencascade::handle< Interface_HArray1OfHAsciiString > const &') -> "bool":
    return _Interface.Handle_Interface_HArray1OfHAsciiString_IsNull(t)
Handle_Interface_HArray1OfHAsciiString_IsNull = _Interface.Handle_Interface_HArray1OfHAsciiString_IsNull

def Handle_Interface_HSequenceOfCheck_Create() -> "opencascade::handle< Interface_HSequenceOfCheck >":
    return _Interface.Handle_Interface_HSequenceOfCheck_Create()
Handle_Interface_HSequenceOfCheck_Create = _Interface.Handle_Interface_HSequenceOfCheck_Create

def Handle_Interface_HSequenceOfCheck_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< Interface_HSequenceOfCheck >":
    return _Interface.Handle_Interface_HSequenceOfCheck_DownCast(t)
Handle_Interface_HSequenceOfCheck_DownCast = _Interface.Handle_Interface_HSequenceOfCheck_DownCast

def Handle_Interface_HSequenceOfCheck_IsNull(t: 'opencascade::handle< Interface_HSequenceOfCheck > const &') -> "bool":
    return _Interface.Handle_Interface_HSequenceOfCheck_IsNull(t)
Handle_Interface_HSequenceOfCheck_IsNull = _Interface.Handle_Interface_HSequenceOfCheck_IsNull
class Interface_Array1OfFileParameter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_Array1OfFileParameter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_Array1OfFileParameter, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Array1< Interface_FileParameter >::iterator":
        return _Interface.Interface_Array1OfFileParameter_begin(self)

    def end(self) -> "NCollection_Array1< Interface_FileParameter >::iterator":
        return _Interface.Interface_Array1OfFileParameter_end(self)

    def cbegin(self) -> "NCollection_Array1< Interface_FileParameter >::const_iterator":
        return _Interface.Interface_Array1OfFileParameter_cbegin(self)

    def cend(self) -> "NCollection_Array1< Interface_FileParameter >::const_iterator":
        return _Interface.Interface_Array1OfFileParameter_cend(self)

    def __init__(self, *args):
        this = _Interface.new_Interface_Array1OfFileParameter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, theValue: 'Interface_FileParameter') -> "void":
        return _Interface.Interface_Array1OfFileParameter_Init(self, theValue)

    def Size(self) -> "Standard_Integer":
        return _Interface.Interface_Array1OfFileParameter_Size(self)

    def Length(self) -> "Standard_Integer":
        return _Interface.Interface_Array1OfFileParameter_Length(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _Interface.Interface_Array1OfFileParameter_IsEmpty(self)

    def Lower(self) -> "Standard_Integer":
        return _Interface.Interface_Array1OfFileParameter_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _Interface.Interface_Array1OfFileParameter_Upper(self)

    def IsDeletable(self) -> "Standard_Boolean":
        return _Interface.Interface_Array1OfFileParameter_IsDeletable(self)

    def IsAllocated(self) -> "Standard_Boolean":
        return _Interface.Interface_Array1OfFileParameter_IsAllocated(self)

    def Assign(self, theOther: 'Interface_Array1OfFileParameter') -> "NCollection_Array1< Interface_FileParameter > &":
        return _Interface.Interface_Array1OfFileParameter_Assign(self, theOther)

    def Move(self, theOther: 'Interface_Array1OfFileParameter') -> "NCollection_Array1< Interface_FileParameter > &":
        return _Interface.Interface_Array1OfFileParameter_Move(self, theOther)

    def Set(self, *args) -> "NCollection_Array1< Interface_FileParameter > &":
        return _Interface.Interface_Array1OfFileParameter_Set(self, *args)

    def First(self) -> "Interface_FileParameter const &":
        return _Interface.Interface_Array1OfFileParameter_First(self)

    def ChangeFirst(self) -> "Interface_FileParameter &":
        return _Interface.Interface_Array1OfFileParameter_ChangeFirst(self)

    def Last(self) -> "Interface_FileParameter const &":
        return _Interface.Interface_Array1OfFileParameter_Last(self)

    def ChangeLast(self) -> "Interface_FileParameter &":
        return _Interface.Interface_Array1OfFileParameter_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "Interface_FileParameter const &":
        return _Interface.Interface_Array1OfFileParameter_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "Interface_FileParameter &":
        return _Interface.Interface_Array1OfFileParameter_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "Interface_FileParameter &":
        return _Interface.Interface_Array1OfFileParameter___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'Interface_FileParameter') -> "void":
        return _Interface.Interface_Array1OfFileParameter_SetValue(self, theIndex, theItem)

    def Resize(self, theLower: 'Standard_Integer const', theUpper: 'Standard_Integer const', theToCopyData: 'Standard_Boolean const') -> "void":
        return _Interface.Interface_Array1OfFileParameter_Resize(self, theLower, theUpper, theToCopyData)
    __swig_destroy__ = _Interface.delete_Interface_Array1OfFileParameter
    __del__ = lambda self: None

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next

Interface_Array1OfFileParameter_swigregister = _Interface.Interface_Array1OfFileParameter_swigregister
Interface_Array1OfFileParameter_swigregister(Interface_Array1OfFileParameter)

class Interface_Array1OfHAsciiString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_Array1OfHAsciiString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_Array1OfHAsciiString, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Array1< opencascade::handle< TCollection_HAsciiString > >::iterator":
        return _Interface.Interface_Array1OfHAsciiString_begin(self)

    def end(self) -> "NCollection_Array1< opencascade::handle< TCollection_HAsciiString > >::iterator":
        return _Interface.Interface_Array1OfHAsciiString_end(self)

    def cbegin(self) -> "NCollection_Array1< opencascade::handle< TCollection_HAsciiString > >::const_iterator":
        return _Interface.Interface_Array1OfHAsciiString_cbegin(self)

    def cend(self) -> "NCollection_Array1< opencascade::handle< TCollection_HAsciiString > >::const_iterator":
        return _Interface.Interface_Array1OfHAsciiString_cend(self)

    def __init__(self, *args):
        this = _Interface.new_Interface_Array1OfHAsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, theValue: 'opencascade::handle< TCollection_HAsciiString > const &') -> "void":
        return _Interface.Interface_Array1OfHAsciiString_Init(self, theValue)

    def Size(self) -> "Standard_Integer":
        return _Interface.Interface_Array1OfHAsciiString_Size(self)

    def Length(self) -> "Standard_Integer":
        return _Interface.Interface_Array1OfHAsciiString_Length(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _Interface.Interface_Array1OfHAsciiString_IsEmpty(self)

    def Lower(self) -> "Standard_Integer":
        return _Interface.Interface_Array1OfHAsciiString_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _Interface.Interface_Array1OfHAsciiString_Upper(self)

    def IsDeletable(self) -> "Standard_Boolean":
        return _Interface.Interface_Array1OfHAsciiString_IsDeletable(self)

    def IsAllocated(self) -> "Standard_Boolean":
        return _Interface.Interface_Array1OfHAsciiString_IsAllocated(self)

    def Assign(self, theOther: 'Interface_Array1OfHAsciiString') -> "NCollection_Array1< opencascade::handle< TCollection_HAsciiString > > &":
        return _Interface.Interface_Array1OfHAsciiString_Assign(self, theOther)

    def Move(self, theOther: 'Interface_Array1OfHAsciiString') -> "NCollection_Array1< opencascade::handle< TCollection_HAsciiString > > &":
        return _Interface.Interface_Array1OfHAsciiString_Move(self, theOther)

    def Set(self, *args) -> "NCollection_Array1< opencascade::handle< TCollection_HAsciiString > > &":
        return _Interface.Interface_Array1OfHAsciiString_Set(self, *args)

    def First(self) -> "opencascade::handle< TCollection_HAsciiString > const &":
        return _Interface.Interface_Array1OfHAsciiString_First(self)

    def ChangeFirst(self) -> "opencascade::handle< TCollection_HAsciiString > &":
        return _Interface.Interface_Array1OfHAsciiString_ChangeFirst(self)

    def Last(self) -> "opencascade::handle< TCollection_HAsciiString > const &":
        return _Interface.Interface_Array1OfHAsciiString_Last(self)

    def ChangeLast(self) -> "opencascade::handle< TCollection_HAsciiString > &":
        return _Interface.Interface_Array1OfHAsciiString_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< TCollection_HAsciiString > const &":
        return _Interface.Interface_Array1OfHAsciiString_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< TCollection_HAsciiString > &":
        return _Interface.Interface_Array1OfHAsciiString_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "opencascade::handle< TCollection_HAsciiString > &":
        return _Interface.Interface_Array1OfHAsciiString___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'opencascade::handle< TCollection_HAsciiString > const &') -> "void":
        return _Interface.Interface_Array1OfHAsciiString_SetValue(self, theIndex, theItem)

    def Resize(self, theLower: 'Standard_Integer const', theUpper: 'Standard_Integer const', theToCopyData: 'Standard_Boolean const') -> "void":
        return _Interface.Interface_Array1OfHAsciiString_Resize(self, theLower, theUpper, theToCopyData)
    __swig_destroy__ = _Interface.delete_Interface_Array1OfHAsciiString
    __del__ = lambda self: None

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next

Interface_Array1OfHAsciiString_swigregister = _Interface.Interface_Array1OfHAsciiString_swigregister
Interface_Array1OfHAsciiString_swigregister(Interface_Array1OfHAsciiString)

class Interface_DataMapOfTransientInteger(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_DataMapOfTransientInteger, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_DataMapOfTransientInteger, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_DataMap< opencascade::handle< Standard_Transient >,int,NCollection_DefaultHasher< opencascade::handle< Standard_Transient > > >::iterator":
        return _Interface.Interface_DataMapOfTransientInteger_begin(self)

    def end(self) -> "NCollection_DataMap< opencascade::handle< Standard_Transient >,int,NCollection_DefaultHasher< opencascade::handle< Standard_Transient > > >::iterator":
        return _Interface.Interface_DataMapOfTransientInteger_end(self)

    def cbegin(self) -> "NCollection_DataMap< opencascade::handle< Standard_Transient >,int,NCollection_DefaultHasher< opencascade::handle< Standard_Transient > > >::const_iterator":
        return _Interface.Interface_DataMapOfTransientInteger_cbegin(self)

    def cend(self) -> "NCollection_DataMap< opencascade::handle< Standard_Transient >,int,NCollection_DefaultHasher< opencascade::handle< Standard_Transient > > >::const_iterator":
        return _Interface.Interface_DataMapOfTransientInteger_cend(self)

    def __init__(self, *args):
        this = _Interface.new_Interface_DataMapOfTransientInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, theOther: 'Interface_DataMapOfTransientInteger') -> "void":
        return _Interface.Interface_DataMapOfTransientInteger_Exchange(self, theOther)

    def Assign(self, theOther: 'Interface_DataMapOfTransientInteger') -> "NCollection_DataMap< opencascade::handle< Standard_Transient >,Standard_Integer,TColStd_MapTransientHasher > &":
        return _Interface.Interface_DataMapOfTransientInteger_Assign(self, theOther)

    def Set(self, theOther: 'Interface_DataMapOfTransientInteger') -> "NCollection_DataMap< opencascade::handle< Standard_Transient >,Standard_Integer,TColStd_MapTransientHasher > &":
        return _Interface.Interface_DataMapOfTransientInteger_Set(self, theOther)

    def ReSize(self, N: 'Standard_Integer const') -> "void":
        return _Interface.Interface_DataMapOfTransientInteger_ReSize(self, N)

    def Bind(self, theKey: 'opencascade::handle< Standard_Transient > const &', theItem: 'int const &') -> "Standard_Boolean":
        return _Interface.Interface_DataMapOfTransientInteger_Bind(self, theKey, theItem)

    def Bound(self, theKey: 'opencascade::handle< Standard_Transient > const &', theItem: 'int const &') -> "int *":
        return _Interface.Interface_DataMapOfTransientInteger_Bound(self, theKey, theItem)

    def IsBound(self, theKey: 'opencascade::handle< Standard_Transient > const &') -> "Standard_Boolean":
        return _Interface.Interface_DataMapOfTransientInteger_IsBound(self, theKey)

    def UnBind(self, theKey: 'opencascade::handle< Standard_Transient > const &') -> "Standard_Boolean":
        return _Interface.Interface_DataMapOfTransientInteger_UnBind(self, theKey)

    def Seek(self, theKey: 'opencascade::handle< Standard_Transient > const &') -> "int const *":
        return _Interface.Interface_DataMapOfTransientInteger_Seek(self, theKey)

    def Find(self, *args) -> "Standard_Boolean":
        return _Interface.Interface_DataMapOfTransientInteger_Find(self, *args)

    def ChangeSeek(self, theKey: 'opencascade::handle< Standard_Transient > const &') -> "int *":
        return _Interface.Interface_DataMapOfTransientInteger_ChangeSeek(self, theKey)

    def ChangeFind(self, theKey: 'opencascade::handle< Standard_Transient > const &') -> "int &":
        return _Interface.Interface_DataMapOfTransientInteger_ChangeFind(self, theKey)

    def __call__(self, *args) -> "int &":
        return _Interface.Interface_DataMapOfTransientInteger___call__(self, *args)

    def Clear(self, *args) -> "void":
        return _Interface.Interface_DataMapOfTransientInteger_Clear(self, *args)
    __swig_destroy__ = _Interface.delete_Interface_DataMapOfTransientInteger
    __del__ = lambda self: None

    def Size(self) -> "Standard_Integer":
        return _Interface.Interface_DataMapOfTransientInteger_Size(self)
Interface_DataMapOfTransientInteger_swigregister = _Interface.Interface_DataMapOfTransientInteger_swigregister
Interface_DataMapOfTransientInteger_swigregister(Interface_DataMapOfTransientInteger)

class Interface_IndexedMapOfAsciiString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_IndexedMapOfAsciiString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_IndexedMapOfAsciiString, name)
    __repr__ = _swig_repr

    def cbegin(self) -> "NCollection_IndexedMap< TCollection_AsciiString,Interface_MapAsciiStringHasher >::const_iterator":
        return _Interface.Interface_IndexedMapOfAsciiString_cbegin(self)

    def cend(self) -> "NCollection_IndexedMap< TCollection_AsciiString,Interface_MapAsciiStringHasher >::const_iterator":
        return _Interface.Interface_IndexedMapOfAsciiString_cend(self)

    def __init__(self, *args):
        this = _Interface.new_Interface_IndexedMapOfAsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, theOther: 'Interface_IndexedMapOfAsciiString') -> "void":
        return _Interface.Interface_IndexedMapOfAsciiString_Exchange(self, theOther)

    def Assign(self, theOther: 'Interface_IndexedMapOfAsciiString') -> "NCollection_IndexedMap< TCollection_AsciiString,Interface_MapAsciiStringHasher > &":
        return _Interface.Interface_IndexedMapOfAsciiString_Assign(self, theOther)

    def Set(self, theOther: 'Interface_IndexedMapOfAsciiString') -> "NCollection_IndexedMap< TCollection_AsciiString,Interface_MapAsciiStringHasher > &":
        return _Interface.Interface_IndexedMapOfAsciiString_Set(self, theOther)

    def ReSize(self, theExtent: 'Standard_Integer const') -> "void":
        return _Interface.Interface_IndexedMapOfAsciiString_ReSize(self, theExtent)

    def Add(self, theKey1: 'TCollection_AsciiString') -> "Standard_Integer":
        return _Interface.Interface_IndexedMapOfAsciiString_Add(self, theKey1)

    def Contains(self, theKey1: 'TCollection_AsciiString') -> "Standard_Boolean":
        return _Interface.Interface_IndexedMapOfAsciiString_Contains(self, theKey1)

    def Substitute(self, theIndex: 'Standard_Integer const', theKey1: 'TCollection_AsciiString') -> "void":
        return _Interface.Interface_IndexedMapOfAsciiString_Substitute(self, theIndex, theKey1)

    def Swap(self, theIndex1: 'Standard_Integer const', theIndex2: 'Standard_Integer const') -> "void":
        return _Interface.Interface_IndexedMapOfAsciiString_Swap(self, theIndex1, theIndex2)

    def RemoveLast(self) -> "void":
        return _Interface.Interface_IndexedMapOfAsciiString_RemoveLast(self)

    def RemoveFromIndex(self, theIndex: 'Standard_Integer const') -> "void":
        return _Interface.Interface_IndexedMapOfAsciiString_RemoveFromIndex(self, theIndex)

    def RemoveKey(self, theKey1: 'TCollection_AsciiString') -> "Standard_Boolean":
        return _Interface.Interface_IndexedMapOfAsciiString_RemoveKey(self, theKey1)

    def FindKey(self, theIndex: 'Standard_Integer const') -> "TCollection_AsciiString const &":
        return _Interface.Interface_IndexedMapOfAsciiString_FindKey(self, theIndex)

    def __call__(self, theIndex: 'Standard_Integer const') -> "TCollection_AsciiString const &":
        return _Interface.Interface_IndexedMapOfAsciiString___call__(self, theIndex)

    def FindIndex(self, theKey1: 'TCollection_AsciiString') -> "Standard_Integer":
        return _Interface.Interface_IndexedMapOfAsciiString_FindIndex(self, theKey1)

    def Clear(self, *args) -> "void":
        return _Interface.Interface_IndexedMapOfAsciiString_Clear(self, *args)
    __swig_destroy__ = _Interface.delete_Interface_IndexedMapOfAsciiString
    __del__ = lambda self: None

    def Size(self) -> "Standard_Integer":
        return _Interface.Interface_IndexedMapOfAsciiString_Size(self)
Interface_IndexedMapOfAsciiString_swigregister = _Interface.Interface_IndexedMapOfAsciiString_swigregister
Interface_IndexedMapOfAsciiString_swigregister(Interface_IndexedMapOfAsciiString)

class Interface_SequenceOfCheck(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_SequenceOfCheck, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_SequenceOfCheck, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Sequence< opencascade::handle< Interface_Check > >::iterator":
        return _Interface.Interface_SequenceOfCheck_begin(self)

    def end(self) -> "NCollection_Sequence< opencascade::handle< Interface_Check > >::iterator":
        return _Interface.Interface_SequenceOfCheck_end(self)

    def cbegin(self) -> "NCollection_Sequence< opencascade::handle< Interface_Check > >::const_iterator":
        return _Interface.Interface_SequenceOfCheck_cbegin(self)

    def cend(self) -> "NCollection_Sequence< opencascade::handle< Interface_Check > >::const_iterator":
        return _Interface.Interface_SequenceOfCheck_cend(self)

    def __init__(self, *args):
        this = _Interface.new_Interface_SequenceOfCheck(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self) -> "Standard_Integer":
        return _Interface.Interface_SequenceOfCheck_Size(self)

    def Length(self) -> "Standard_Integer":
        return _Interface.Interface_SequenceOfCheck_Length(self)

    def Lower(self) -> "Standard_Integer":
        return _Interface.Interface_SequenceOfCheck_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _Interface.Interface_SequenceOfCheck_Upper(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _Interface.Interface_SequenceOfCheck_IsEmpty(self)

    def Reverse(self) -> "void":
        return _Interface.Interface_SequenceOfCheck_Reverse(self)

    def Exchange(self, I: 'Standard_Integer const', J: 'Standard_Integer const') -> "void":
        return _Interface.Interface_SequenceOfCheck_Exchange(self, I, J)
    if _newclass:
        delNode = staticmethod(_Interface.Interface_SequenceOfCheck_delNode)
    else:
        delNode = _Interface.Interface_SequenceOfCheck_delNode

    def Clear(self, theAllocator: 'opencascade::handle< NCollection_BaseAllocator > const &'=0) -> "void":
        return _Interface.Interface_SequenceOfCheck_Clear(self, theAllocator)

    def Assign(self, theOther: 'Interface_SequenceOfCheck') -> "NCollection_Sequence< opencascade::handle< Interface_Check > > &":
        return _Interface.Interface_SequenceOfCheck_Assign(self, theOther)

    def Set(self, theOther: 'Interface_SequenceOfCheck') -> "NCollection_Sequence< opencascade::handle< Interface_Check > > &":
        return _Interface.Interface_SequenceOfCheck_Set(self, theOther)

    def Remove(self, *args) -> "void":
        return _Interface.Interface_SequenceOfCheck_Remove(self, *args)

    def Append(self, *args) -> "void":
        return _Interface.Interface_SequenceOfCheck_Append(self, *args)

    def Prepend(self, *args) -> "void":
        return _Interface.Interface_SequenceOfCheck_Prepend(self, *args)

    def InsertBefore(self, *args) -> "void":
        return _Interface.Interface_SequenceOfCheck_InsertBefore(self, *args)

    def InsertAfter(self, *args) -> "void":
        return _Interface.Interface_SequenceOfCheck_InsertAfter(self, *args)

    def Split(self, theIndex: 'Standard_Integer const', theSeq: 'Interface_SequenceOfCheck') -> "void":
        return _Interface.Interface_SequenceOfCheck_Split(self, theIndex, theSeq)

    def First(self) -> "opencascade::handle< Interface_Check > const &":
        return _Interface.Interface_SequenceOfCheck_First(self)

    def ChangeFirst(self) -> "opencascade::handle< Interface_Check > &":
        return _Interface.Interface_SequenceOfCheck_ChangeFirst(self)

    def Last(self) -> "opencascade::handle< Interface_Check > const &":
        return _Interface.Interface_SequenceOfCheck_Last(self)

    def ChangeLast(self) -> "opencascade::handle< Interface_Check > &":
        return _Interface.Interface_SequenceOfCheck_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< Interface_Check > const &":
        return _Interface.Interface_SequenceOfCheck_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< Interface_Check > &":
        return _Interface.Interface_SequenceOfCheck_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "opencascade::handle< Interface_Check > &":
        return _Interface.Interface_SequenceOfCheck___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'opencascade::handle< Interface_Check > const &') -> "void":
        return _Interface.Interface_SequenceOfCheck_SetValue(self, theIndex, theItem)
    __swig_destroy__ = _Interface.delete_Interface_SequenceOfCheck
    __del__ = lambda self: None

    def __len__(self):
        return self.Size()

Interface_SequenceOfCheck_swigregister = _Interface.Interface_SequenceOfCheck_swigregister
Interface_SequenceOfCheck_swigregister(Interface_SequenceOfCheck)

def Interface_SequenceOfCheck_delNode(theNode: 'NCollection_SeqNode *', theAl: 'opencascade::handle< NCollection_BaseAllocator > &') -> "void":
    return _Interface.Interface_SequenceOfCheck_delNode(theNode, theAl)
Interface_SequenceOfCheck_delNode = _Interface.Interface_SequenceOfCheck_delNode

class Interface_VectorOfFileParameter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_VectorOfFileParameter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_VectorOfFileParameter, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Vector< Interface_FileParameter >::iterator":
        return _Interface.Interface_VectorOfFileParameter_begin(self)

    def end(self) -> "NCollection_Vector< Interface_FileParameter >::iterator":
        return _Interface.Interface_VectorOfFileParameter_end(self)

    def cbegin(self) -> "NCollection_Vector< Interface_FileParameter >::const_iterator":
        return _Interface.Interface_VectorOfFileParameter_cbegin(self)

    def cend(self) -> "NCollection_Vector< Interface_FileParameter >::const_iterator":
        return _Interface.Interface_VectorOfFileParameter_cend(self)

    def __init__(self, *args):
        this = _Interface.new_Interface_VectorOfFileParameter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Interface.delete_Interface_VectorOfFileParameter
    __del__ = lambda self: None

    def Length(self) -> "Standard_Integer":
        return _Interface.Interface_VectorOfFileParameter_Length(self)

    def Size(self) -> "Standard_Integer":
        return _Interface.Interface_VectorOfFileParameter_Size(self)

    def Lower(self) -> "Standard_Integer":
        return _Interface.Interface_VectorOfFileParameter_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _Interface.Interface_VectorOfFileParameter_Upper(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _Interface.Interface_VectorOfFileParameter_IsEmpty(self)

    def Assign(self, *args) -> "void":
        return _Interface.Interface_VectorOfFileParameter_Assign(self, *args)

    def Set(self, theOther: 'Interface_VectorOfFileParameter') -> "NCollection_Vector< Interface_FileParameter > &":
        return _Interface.Interface_VectorOfFileParameter_Set(self, theOther)

    def Append(self, theValue: 'Interface_FileParameter') -> "Interface_FileParameter &":
        return _Interface.Interface_VectorOfFileParameter_Append(self, theValue)

    def Appended(self) -> "Interface_FileParameter &":
        return _Interface.Interface_VectorOfFileParameter_Appended(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "Interface_FileParameter const &":
        return _Interface.Interface_VectorOfFileParameter_Value(self, theIndex)

    def First(self) -> "Interface_FileParameter const &":
        return _Interface.Interface_VectorOfFileParameter_First(self)

    def ChangeFirst(self) -> "Interface_FileParameter &":
        return _Interface.Interface_VectorOfFileParameter_ChangeFirst(self)

    def Last(self) -> "Interface_FileParameter const &":
        return _Interface.Interface_VectorOfFileParameter_Last(self)

    def ChangeLast(self) -> "Interface_FileParameter &":
        return _Interface.Interface_VectorOfFileParameter_ChangeLast(self)

    def __call__(self, *args) -> "Interface_FileParameter &":
        return _Interface.Interface_VectorOfFileParameter___call__(self, *args)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "Interface_FileParameter &":
        return _Interface.Interface_VectorOfFileParameter_ChangeValue(self, theIndex)

    def SetValue(self, theIndex: 'Standard_Integer const', theValue: 'Interface_FileParameter') -> "Interface_FileParameter &":
        return _Interface.Interface_VectorOfFileParameter_SetValue(self, theIndex, theValue)
Interface_VectorOfFileParameter_swigregister = _Interface.Interface_VectorOfFileParameter_swigregister
Interface_VectorOfFileParameter_swigregister(Interface_VectorOfFileParameter)

class Interface_BitMap(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_BitMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_BitMap, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a empty bitmap.

        Returns
        -------
        None

        Creates a bitmap for <nbitems> items one flag is defined, n0 0 <resflags> prepares allocation for <resflags> more flags flags values start at false.

        Parameters
        ----------
        nbitems: int
        resflags: int,optional
        	default value is 0

        Returns
        -------
        None

        Creates a bitmap from another one if <copied> is true, copies data else, data are not copied, only the header object is.

        Parameters
        ----------
        other: Interface_BitMap
        copied: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_BitMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddFlag(self, *args) -> "Standard_Integer":
        """
        Adds a flag, a name can be attached to it returns its flag number makes required reservation.

        Parameters
        ----------
        name: char *,optional
        	default value is 

        Returns
        -------
        int

        """
        return _Interface.Interface_BitMap_AddFlag(self, *args)


    def AddSomeFlags(self, *args) -> "Standard_Integer":
        """
        Adds several flags (<more>) with no name returns the number of last added flag.

        Parameters
        ----------
        more: int

        Returns
        -------
        int

        """
        return _Interface.Interface_BitMap_AddSomeFlags(self, *args)


    def CFalse(self, *args) -> "Standard_Boolean":
        """
        Returns the former value for a flag and sets it to false (before : value returned; after : false).

        Parameters
        ----------
        item: int
        flag: int,optional
        	default value is 0

        Returns
        -------
        bool

        """
        return _Interface.Interface_BitMap_CFalse(self, *args)


    def CTrue(self, *args) -> "Standard_Boolean":
        """
        Returns the former value for a flag and sets it to true (before : value returned; after : true).

        Parameters
        ----------
        item: int
        flag: int,optional
        	default value is 0

        Returns
        -------
        bool

        """
        return _Interface.Interface_BitMap_CTrue(self, *args)


    def Clear(self, *args) -> "void":
        """
        Clear all field of bit map.

        Returns
        -------
        None

        """
        return _Interface.Interface_BitMap_Clear(self, *args)


    def FlagName(self, *args) -> "char const *":
        """
        Returns the name recorded for a flag, or an empty string.

        Parameters
        ----------
        num: int

        Returns
        -------
        char *

        """
        return _Interface.Interface_BitMap_FlagName(self, *args)


    def FlagNumber(self, *args) -> "Standard_Integer":
        """
        Returns the number or a flag given its name, or zero.

        Parameters
        ----------
        name: char *

        Returns
        -------
        int

        """
        return _Interface.Interface_BitMap_FlagNumber(self, *args)


    def Init(self, *args) -> "void":
        """
        Initialises all the values of flag number <flag> to a given value <val>.

        Parameters
        ----------
        val: bool
        flag: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        return _Interface.Interface_BitMap_Init(self, *args)


    def Initialize(self, *args) -> "void":
        """
        Initialize empty bit by <nbitems> items one flag is defined, n0 0 <resflags> prepares allocation for <resflags> more flags flags values start at false.

        Parameters
        ----------
        nbitems: int
        resflags: int,optional
        	default value is 0

        Returns
        -------
        None

        Initialize a bitmap from another one.

        Parameters
        ----------
        other: Interface_BitMap
        copied: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        return _Interface.Interface_BitMap_Initialize(self, *args)


    def Length(self, *args) -> "Standard_Integer":
        """
        Returns the count of items (i.e. the length of the bitmap).

        Returns
        -------
        int

        """
        return _Interface.Interface_BitMap_Length(self, *args)


    def NbFlags(self, *args) -> "Standard_Integer":
        """
        Returns the count of flags (flag 0 not included).

        Returns
        -------
        int

        """
        return _Interface.Interface_BitMap_NbFlags(self, *args)


    def RemoveFlag(self, *args) -> "Standard_Boolean":
        """
        Removes a flag given its number. returns true if done, false if num is out of range.

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _Interface.Interface_BitMap_RemoveFlag(self, *args)


    def Reservate(self, *args) -> "void":
        """
        Reservates for a count of more flags.

        Parameters
        ----------
        moreflags: int

        Returns
        -------
        None

        """
        return _Interface.Interface_BitMap_Reservate(self, *args)


    def SetFalse(self, *args) -> "void":
        """
        Sets a flag to false.

        Parameters
        ----------
        item: int
        flag: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        return _Interface.Interface_BitMap_SetFalse(self, *args)


    def SetFlagName(self, *args) -> "Standard_Boolean":
        """
        Sets a name for a flag, given its number name can be empty (to erase the name of a flag) returns true if done, false if : num is out of range, or name non-empty already set to another flag.

        Parameters
        ----------
        num: int
        name: char *

        Returns
        -------
        bool

        """
        return _Interface.Interface_BitMap_SetFlagName(self, *args)


    def SetLength(self, *args) -> "void":
        """
        Sets for a new count of items, which can be either less or greater than the former one for new items, their flags start at false.

        Parameters
        ----------
        nbitems: int

        Returns
        -------
        None

        """
        return _Interface.Interface_BitMap_SetLength(self, *args)


    def SetTrue(self, *args) -> "void":
        """
        Sets a flag to true.

        Parameters
        ----------
        item: int
        flag: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        return _Interface.Interface_BitMap_SetTrue(self, *args)


    def SetValue(self, *args) -> "void":
        """
        Sets a new value for a flag.

        Parameters
        ----------
        item: int
        val: bool
        flag: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        return _Interface.Interface_BitMap_SetValue(self, *args)


    def Value(self, *args) -> "Standard_Boolean":
        """
        Returns the value (true/false) of a flag, from : - the number of the item - the flag number, by default 0.

        Parameters
        ----------
        item: int
        flag: int,optional
        	default value is 0

        Returns
        -------
        bool

        """
        return _Interface.Interface_BitMap_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_BitMap
    __del__ = lambda self: None
Interface_BitMap_swigregister = _Interface.Interface_BitMap_swigregister
Interface_BitMap_swigregister(Interface_BitMap)

class Interface_Category(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_Category, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_Category, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a category, with no protocol yet.

        Returns
        -------
        None

        Creates a category with a given protocol.

        Parameters
        ----------
        theProtocol: Interface_Protocol

        Returns
        -------
        None

        Creates a category with a given gtool.

        Parameters
        ----------
        theGTool: Interface_GTool

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_Category(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddCategory(*args) -> "Standard_Integer":
        """
        Records a new category defined by its names, produces a number new if not yet recorded.

        Parameters
        ----------
        theName: char *

        Returns
        -------
        int

        """
        return _Interface.Interface_Category_AddCategory(*args)

    AddCategory = staticmethod(AddCategory)

    def CatNum(self, *args) -> "Standard_Integer":
        """
        Determines the category number for an entity in its context, by using general service categorynumber.

        Parameters
        ----------
        theEnt: Standard_Transient
        theShares: Interface_ShareTool

        Returns
        -------
        int

        """
        return _Interface.Interface_Category_CatNum(self, *args)


    def ClearNums(self, *args) -> "void":
        """
        Clears the recorded list of category numbers for a model.

        Returns
        -------
        None

        """
        return _Interface.Interface_Category_ClearNums(self, *args)


    def Compute(self, *args) -> "void":
        """
        Computes the category number for each entity and records it, in an array (ent.number -> category number) hence, it can be queried by the method num. the model itself is not recorded, this method is intended to be used in a wider context (which detains also a graph, etc).

        Parameters
        ----------
        theModel: Interface_InterfaceModel
        theShares: Interface_ShareTool

        Returns
        -------
        None

        """
        return _Interface.Interface_Category_Compute(self, *args)


    def Init(*args) -> "void":
        """
        Default initialisation (protected against several calls : passes only once).

        Returns
        -------
        None

        """
        return _Interface.Interface_Category_Init(*args)

    Init = staticmethod(Init)

    def Name(*args) -> "char const *":
        """
        Returns the name of a category, according to its number.

        Parameters
        ----------
        theNum: int

        Returns
        -------
        char *

        """
        return _Interface.Interface_Category_Name(*args)

    Name = staticmethod(Name)

    def NbCategories(*args) -> "Standard_Integer":
        """
        Returns the count of recorded categories.

        Returns
        -------
        int

        """
        return _Interface.Interface_Category_NbCategories(*args)

    NbCategories = staticmethod(NbCategories)

    def Num(self, *args) -> "Standard_Integer":
        """
        Returns the category number recorded for an entity number returns 0 if out of range.

        Parameters
        ----------
        theNumEnt: int

        Returns
        -------
        int

        """
        return _Interface.Interface_Category_Num(self, *args)


    def Number(*args) -> "Standard_Integer":
        """
        Returns the number of a category, according to its name.

        Parameters
        ----------
        theName: char *

        Returns
        -------
        int

        """
        return _Interface.Interface_Category_Number(*args)

    Number = staticmethod(Number)

    def SetProtocol(self, *args) -> "void":
        """
        Sets/changes protocol.

        Parameters
        ----------
        theProtocol: Interface_Protocol

        Returns
        -------
        None

        """
        return _Interface.Interface_Category_SetProtocol(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_Category
    __del__ = lambda self: None
Interface_Category_swigregister = _Interface.Interface_Category_swigregister
Interface_Category_swigregister(Interface_Category)

def Interface_Category_AddCategory(*args) -> "Standard_Integer":
    """
    Records a new category defined by its names, produces a number new if not yet recorded.

    Parameters
    ----------
    theName: char *

    Returns
    -------
    int

    """
    return _Interface.Interface_Category_AddCategory(*args)

def Interface_Category_Init(*args) -> "void":
    """
    Default initialisation (protected against several calls : passes only once).

    Returns
    -------
    None

    """
    return _Interface.Interface_Category_Init(*args)

def Interface_Category_Name(*args) -> "char const *":
    """
    Returns the name of a category, according to its number.

    Parameters
    ----------
    theNum: int

    Returns
    -------
    char *

    """
    return _Interface.Interface_Category_Name(*args)

def Interface_Category_NbCategories(*args) -> "Standard_Integer":
    """
    Returns the count of recorded categories.

    Returns
    -------
    int

    """
    return _Interface.Interface_Category_NbCategories(*args)

def Interface_Category_Number(*args) -> "Standard_Integer":
    """
    Returns the number of a category, according to its name.

    Parameters
    ----------
    theName: char *

    Returns
    -------
    int

    """
    return _Interface.Interface_Category_Number(*args)

class Interface_Check(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_Check, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_Check, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Allows definition of a sequence. used also for global check of an interfacemodel (which stores global messages for file).

        Returns
        -------
        None

        Defines a check on an entity.

        Parameters
        ----------
        anentity: Standard_Transient

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_Check(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddFail(self, *args) -> "void":
        """
        Records a new fail message.

        Parameters
        ----------
        amess: TCollection_HAsciiString

        Returns
        -------
        None

        Records a new fail message under two forms : final,original.

        Parameters
        ----------
        amess: TCollection_HAsciiString
        orig: TCollection_HAsciiString

        Returns
        -------
        None

        Records a new fail message given as 'error text' directly if <orig> is given, a distinct original form is recorded else (d), the original form equates <amess>.

        Parameters
        ----------
        amess: char *
        orig: char *,optional
        	default value is 

        Returns
        -------
        None

        Records a new fail from the definition of a msg (original+value).

        Parameters
        ----------
        amsg: Message_Msg

        Returns
        -------
        None

        """
        return _Interface.Interface_Check_AddFail(self, *args)


    def AddWarning(self, *args) -> "void":
        """
        Records a new warning message.

        Parameters
        ----------
        amess: TCollection_HAsciiString

        Returns
        -------
        None

        Records a new warning message under two forms : final,original.

        Parameters
        ----------
        amess: TCollection_HAsciiString
        orig: TCollection_HAsciiString

        Returns
        -------
        None

        Records a warning message given as 'warning message' directly if <orig> is given, a distinct original form is recorded else (d), the original form equates <amess>.

        Parameters
        ----------
        amess: char *
        orig: char *,optional
        	default value is 

        Returns
        -------
        None

        Records a new warning from the definition of a msg (original+value).

        Parameters
        ----------
        amsg: Message_Msg

        Returns
        -------
        None

        """
        return _Interface.Interface_Check_AddWarning(self, *args)


    def CFail(self, *args) -> "char const *":
        """
        Same as above, but returns a cstring (to be printed ...) final form by default, original form if <final> is false.

        Parameters
        ----------
        num: int
        final: bool,optional
        	default value is Standard_True

        Returns
        -------
        char *

        """
        return _Interface.Interface_Check_CFail(self, *args)


    def CInfoMsg(self, *args) -> "char const *":
        """
        Same as above, but returns a cstring (to be printed ...) final form by default, original form if <final> is false.

        Parameters
        ----------
        num: int
        final: bool,optional
        	default value is Standard_True

        Returns
        -------
        char *

        """
        return _Interface.Interface_Check_CInfoMsg(self, *args)


    def CWarning(self, *args) -> "char const *":
        """
        Same as above, but returns a cstring (to be printed ...) final form by default, original form if <final> is false.

        Parameters
        ----------
        num: int
        final: bool,optional
        	default value is Standard_True

        Returns
        -------
        char *

        """
        return _Interface.Interface_Check_CWarning(self, *args)


    def Clear(self, *args) -> "void":
        """
        Clears a check, in order to receive informations from transfer (messages and entity).

        Returns
        -------
        None

        """
        return _Interface.Interface_Check_Clear(self, *args)


    def ClearFails(self, *args) -> "void":
        """
        Clears the fail messages (for instance to keep only warnings).

        Returns
        -------
        None

        """
        return _Interface.Interface_Check_ClearFails(self, *args)


    def ClearInfoMsgs(self, *args) -> "void":
        """
        Clears the info messages.

        Returns
        -------
        None

        """
        return _Interface.Interface_Check_ClearInfoMsgs(self, *args)


    def ClearWarnings(self, *args) -> "void":
        """
        Clears the warning messages (for instance to keep only fails).

        Returns
        -------
        None

        """
        return _Interface.Interface_Check_ClearWarnings(self, *args)


    def Complies(self, *args) -> "Standard_Boolean":
        """
        Tells if check status complies with a given one (i.e. also status for query).

        Parameters
        ----------
        status: Interface_CheckStatus

        Returns
        -------
        bool

        Tells if a message is brought by a check, as follows : <incl> = 0 : <mess> exactly matches one of the messages <incl> < 0 : <mess> is contained by one of the messages <incl> > 0 : <mess> contains one of the messages for <status> : for checkwarning and checkfail, considers only resp. warning or check messages. for checkany, considers all other values are ignored (answer will be false).

        Parameters
        ----------
        mess: TCollection_HAsciiString
        incl: int
        status: Interface_CheckStatus

        Returns
        -------
        bool

        """
        return _Interface.Interface_Check_Complies(self, *args)


    def Entity(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        Returns the entity on which the check has been defined.

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _Interface.Interface_Check_Entity(self, *args)


    def Fail(self, *args) -> "opencascade::handle< TCollection_HAsciiString > const &":
        """
        Returns fail message as a string final form by default, original form if <final> is false.

        Parameters
        ----------
        num: int
        final: bool,optional
        	default value is Standard_True

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _Interface.Interface_Check_Fail(self, *args)


    def Fails(self, *args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """
        Returns the list of fails, for a frontal-engine logic final forms by default, original forms if <final> is false can be empty.

        Parameters
        ----------
        final: bool,optional
        	default value is Standard_True

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfHAsciiString>

        """
        return _Interface.Interface_Check_Fails(self, *args)


    def GetAsWarning(self, *args) -> "void":
        """
        Copies messages converted into warning messages if failsonly is true, only fails are taken, and converted else, warnings are taken too. does not regard entity used to keep fail messages as warning, after a recovery.

        Parameters
        ----------
        other: Interface_Check
        failsonly: bool

        Returns
        -------
        None

        """
        return _Interface.Interface_Check_GetAsWarning(self, *args)


    def GetEntity(self, *args) -> "void":
        """
        Same as setentity (old form kept for compatibility) warning : does nothing if entity field is not yet clear.

        Parameters
        ----------
        anentity: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_Check_GetEntity(self, *args)


    def GetMessages(self, *args) -> "void":
        """
        Copies messages stored in another check, cumulating does not regard other's entity. used to cumulate messages.

        Parameters
        ----------
        other: Interface_Check

        Returns
        -------
        None

        """
        return _Interface.Interface_Check_GetMessages(self, *args)


    def HasEntity(self, *args) -> "Standard_Boolean":
        """
        Returns true if a check is devoted to an entity; else, it is global (for interfacemodel's storing of global error messages).

        Returns
        -------
        bool

        """
        return _Interface.Interface_Check_HasEntity(self, *args)


    def HasFailed(self, *args) -> "Standard_Boolean":
        """
        Returns true if check brings at least one fail message.

        Returns
        -------
        bool

        """
        return _Interface.Interface_Check_HasFailed(self, *args)


    def HasWarnings(self, *args) -> "Standard_Boolean":
        """
        Returns true if check brings at least one warning message.

        Returns
        -------
        bool

        """
        return _Interface.Interface_Check_HasWarnings(self, *args)


    def InfoMsg(self, *args) -> "opencascade::handle< TCollection_HAsciiString > const &":
        """
        Returns information message as a string.

        Parameters
        ----------
        num: int
        final: bool,optional
        	default value is Standard_True

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _Interface.Interface_Check_InfoMsg(self, *args)


    def InfoMsgs(self, *args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """
        Returns the list of info msg, for a frontal-engine logic final forms by default, original forms if <final> is false can be empty.

        Parameters
        ----------
        final: bool,optional
        	default value is Standard_True

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfHAsciiString>

        """
        return _Interface.Interface_Check_InfoMsgs(self, *args)


    def Mend(self, *args) -> "Standard_Boolean":
        """
        Mends messages, according <pref> and <num> according to <num>, works on the whole list of fails if = 0(d) or only one fail message, given its rank if <pref> is empty, converts fail(s) to warning(s) else, does the conversion but prefixes the new warning(s) but <pref> followed by a semi-column some reserved values of <pref> are : 'fm' : standard prefix 'mended' (can be translated) 'cf' : clears fail(s) 'cw' : clears warning(s) : here, <num> refers to warning list 'ca' : clears all messages : here, <num> is ignored.

        Parameters
        ----------
        pref: char *
        num: int,optional
        	default value is 0

        Returns
        -------
        bool

        """
        return _Interface.Interface_Check_Mend(self, *args)


    def NbFails(self, *args) -> "Standard_Integer":
        """
        Returns count of recorded fails.

        Returns
        -------
        int

        """
        return _Interface.Interface_Check_NbFails(self, *args)


    def NbInfoMsgs(self, *args) -> "Standard_Integer":
        """
        Returns the count of recorded information messages.

        Returns
        -------
        int

        """
        return _Interface.Interface_Check_NbInfoMsgs(self, *args)


    def NbWarnings(self, *args) -> "Standard_Integer":
        """
        Returns count of recorded warning messages.

        Returns
        -------
        int

        """
        return _Interface.Interface_Check_NbWarnings(self, *args)


    def Remove(self, *args) -> "Standard_Boolean":
        """
        Removes the messages which comply with <mess>, as follows : <incl> = 0 : <mess> exactly matches one of the messages <incl> < 0 : <mess> is contained by one of the messages <incl> > 0 : <mess> contains one of the messages for <status> : for checkwarning and checkfail, considers only resp. warning or check messages. for checkany, considers all other values are ignored (nothing is done) returns true if at least one message has been removed, false else.

        Parameters
        ----------
        mess: TCollection_HAsciiString
        incl: int
        status: Interface_CheckStatus

        Returns
        -------
        bool

        """
        return _Interface.Interface_Check_Remove(self, *args)


    def SendFail(self, *args) -> "void":
        """
        New name for addfail (msg).

        Parameters
        ----------
        amsg: Message_Msg

        Returns
        -------
        None

        """
        return _Interface.Interface_Check_SendFail(self, *args)


    def SendMsg(self, *args) -> "void":
        """
        Records an information message this does not change the status of the check.

        Parameters
        ----------
        amsg: Message_Msg

        Returns
        -------
        None

        """
        return _Interface.Interface_Check_SendMsg(self, *args)


    def SendWarning(self, *args) -> "void":
        """
        New name for addwarning.

        Parameters
        ----------
        amsg: Message_Msg

        Returns
        -------
        None

        """
        return _Interface.Interface_Check_SendWarning(self, *args)


    def SetEntity(self, *args) -> "void":
        """
        Receives an entity result of a transfer.

        Parameters
        ----------
        anentity: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_Check_SetEntity(self, *args)


    def Status(self, *args) -> "Interface_CheckStatus":
        """
        Returns the check status : ok, warning or fail.

        Returns
        -------
        Interface_CheckStatus

        """
        return _Interface.Interface_Check_Status(self, *args)


    def Trace(self, *args) -> "void":
        """
        Prints the messages of the check to the default trace file by default, according to the default standard level else, according level (see method print).

        Parameters
        ----------
        level: int,optional
        	default value is -1
        final: int,optional
        	default value is 1

        Returns
        -------
        None

        """
        return _Interface.Interface_Check_Trace(self, *args)


    def Warning(self, *args) -> "opencascade::handle< TCollection_HAsciiString > const &":
        """
        Returns warning message as a string final form by default, original form if <final> is false.

        Parameters
        ----------
        num: int
        final: bool,optional
        	default value is Standard_True

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _Interface.Interface_Check_Warning(self, *args)


    def Warnings(self, *args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """
        Returns the list of warnings, for a frontal-engine logic final forms by default, original forms if <final> is false can be empty.

        Parameters
        ----------
        final: bool,optional
        	default value is Standard_True

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfHAsciiString>

        """
        return _Interface.Interface_Check_Warnings(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_Check_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_Check
    __del__ = lambda self: None
Interface_Check_swigregister = _Interface.Interface_Check_swigregister
Interface_Check_swigregister(Interface_Check)

class Interface_CheckIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_CheckIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_CheckIterator, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an empty checkiterator.

        Returns
        -------
        None

        Creates a checkiterator with a name (displayed by print as a title).

        Parameters
        ----------
        name: char *

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_CheckIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args) -> "void":
        """
        Adds a check to the list to be iterated this check is accompanied by entity number in the model (0 for global check or entity unknown in the model), if 0 and model is recorded in <self>, it is computed.

        Parameters
        ----------
        ach: Interface_Check
        num: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        return _Interface.Interface_CheckIterator_Add(self, *args)


    def CCheck(self, *args) -> "opencascade::handle< Interface_Check > &":
        """
        Returns the check bound to an entity number (0 : global) in order to be consulted or completed on the spot i.e. returns the check if is already exists, or adds it then returns the new empty check.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<Interface_Check>

        Returns the check bound to an entity, in order to be consulted or completed on the spot i.e. returns the check if is already exists, or adds it then returns the new empty check.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        opencascade::handle<Interface_Check>

        """
        return _Interface.Interface_CheckIterator_CCheck(self, *args)


    def Check(self, *args) -> "opencascade::handle< Interface_Check > const &":
        """
        Returns the check which was attached to an entity given its number in the model. <num>=0 is for the global check. if no check was recorded for this number, returns an empty check. remark : works apart from the iteration methods (no interference).

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<Interface_Check>

        Returns the check attached to an entity if no check was recorded for this entity, returns an empty check. remark : works apart from the iteration methods (no interference).

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        opencascade::handle<Interface_Check>

        """
        return _Interface.Interface_CheckIterator_Check(self, *args)


    def Checkeds(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        Returns the list of entities concerned by a check only fails if <failsonly> is true, else all non-empty checks if <global> is true, adds the model for a global check else, global check is ignored.

        Parameters
        ----------
        failsonly: bool
        global: bool

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfTransient>

        """
        return _Interface.Interface_CheckIterator_Checkeds(self, *args)


    def Clear(self, *args) -> "void":
        """
        Clears the list of checks.

        Returns
        -------
        None

        """
        return _Interface.Interface_CheckIterator_Clear(self, *args)


    def Complies(self, *args) -> "Standard_Boolean":
        """
        Tells if this check list complies with a given status : ok (i.e. empty), warning (at least one warning, but no fail), fail (at least one), message (not ok), nofail, any.

        Parameters
        ----------
        status: Interface_CheckStatus

        Returns
        -------
        bool

        """
        return _Interface.Interface_CheckIterator_Complies(self, *args)


    def Destroy(self, *args) -> "void":
        """
        Clears data of iteration.

        Returns
        -------
        None

        """
        return _Interface.Interface_CheckIterator_Destroy(self, *args)


    def Extract(self, *args) -> "Interface_CheckIterator":
        """
        Returns a checkiterator which contains the checks which comply with a given status each check is added completely (no split warning/fail).

        Parameters
        ----------
        status: Interface_CheckStatus

        Returns
        -------
        Interface_CheckIterator

        Returns a checkiterator which contains the check which comply with a message, plus some conditions as follows : <incl> = 0 : <mess> exactly matches one of the messages <incl> < 0 : <mess> is contained by one of the messages <incl> > 0 : <mess> contains one of the messages for <status> : for checkwarning and checkfail, considers only resp. warning or check messages. for checkany, considers all other values are ignored (answer will be false) each check which complies is entirely taken.

        Parameters
        ----------
        mess: char *
        incl: int
        status: Interface_CheckStatus

        Returns
        -------
        Interface_CheckIterator

        """
        return _Interface.Interface_CheckIterator_Extract(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        Returns true if : no fail has been recorded if <failsonly> is true, no check at all if <failsonly> is false.

        Parameters
        ----------
        failsonly: bool

        Returns
        -------
        bool

        """
        return _Interface.Interface_CheckIterator_IsEmpty(self, *args)


    def Merge(self, *args) -> "void":
        """
        Merges another checkiterator into <self>, i.e. adds each of its checks. content of <other> remains unchanged. takes also the model but not the name.

        Parameters
        ----------
        other: Interface_CheckIterator

        Returns
        -------
        None

        """
        return _Interface.Interface_CheckIterator_Merge(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        Returns the stored model (can be a null handle).

        Returns
        -------
        opencascade::handle<Interface_InterfaceModel>

        """
        return _Interface.Interface_CheckIterator_Model(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """
        Returns true if there are more checks to get.

        Returns
        -------
        bool

        """
        return _Interface.Interface_CheckIterator_More(self, *args)


    def Name(self, *args) -> "char const *":
        """
        Returns the recorded name (can be empty).

        Returns
        -------
        char *

        """
        return _Interface.Interface_CheckIterator_Name(self, *args)


    def Next(self, *args) -> "void":
        """
        Sets iteration to next item.

        Returns
        -------
        None

        """
        return _Interface.Interface_CheckIterator_Next(self, *args)


    def Number(self, *args) -> "Standard_Integer":
        """
        Returns number of entity for the check currently iterated or 0 for globalcheck.

        Returns
        -------
        int

        """
        return _Interface.Interface_CheckIterator_Number(self, *args)


    def Remove(self, *args) -> "Standard_Boolean":
        """
        Removes the messages of all checks, under these conditions : <incl> = 0 : <mess> exactly matches one of the messages <incl> < 0 : <mess> is contained by one of the messages <incl> > 0 : <mess> contains one of the messages for <status> : for checkwarning and checkfail, considers only resp. warning or check messages. for checkany, considers all other values are ignored (nothing is done) returns true if at least one message has been removed, false else.

        Parameters
        ----------
        mess: char *
        incl: int
        status: Interface_CheckStatus

        Returns
        -------
        bool

        """
        return _Interface.Interface_CheckIterator_Remove(self, *args)


    def SetModel(self, *args) -> "void":
        """
        Defines a model, used to locate entities (not required, if it is absent, entities are simply less documented).

        Parameters
        ----------
        model: Interface_InterfaceModel

        Returns
        -------
        None

        """
        return _Interface.Interface_CheckIterator_SetModel(self, *args)


    def SetName(self, *args) -> "void":
        """
        Sets / changes the name.

        Parameters
        ----------
        name: char *

        Returns
        -------
        None

        """
        return _Interface.Interface_CheckIterator_SetName(self, *args)


    def Start(self, *args) -> "void":
        """
        Starts iteration. thus, it is possible to restart it remark : an iteration may be done with a const iterator while its content is modified (through a pointer), this allows to give it as a const argument to a function.

        Returns
        -------
        None

        """
        return _Interface.Interface_CheckIterator_Start(self, *args)


    def Status(self, *args) -> "Interface_CheckStatus":
        """
        Returns worst status among : ok, warning, fail.

        Returns
        -------
        Interface_CheckStatus

        """
        return _Interface.Interface_CheckIterator_Status(self, *args)


    def Value(self, *args) -> "opencascade::handle< Interface_Check > const &":
        """
        Returns check currently iterated it brings all other informations (status, messages, ...) the number of the entity in the model is given by number below.

        Returns
        -------
        opencascade::handle<Interface_Check>

        """
        return _Interface.Interface_CheckIterator_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_CheckIterator
    __del__ = lambda self: None
Interface_CheckIterator_swigregister = _Interface.Interface_CheckIterator_swigregister
Interface_CheckIterator_swigregister(Interface_CheckIterator)

class Interface_CheckTool(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_CheckTool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_CheckTool, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a checktool, by calling the general service library and modules, selected through a protocol, to work on a model moreover, protocol recognizes unknown entities.

        Parameters
        ----------
        model: Interface_InterfaceModel
        protocol: Interface_Protocol

        Returns
        -------
        None

        Creates a checktool, by calling the general service library and modules, selected through a protocol, to work on a model protocol and so on are taken from the model (its gtool).

        Parameters
        ----------
        model: Interface_InterfaceModel

        Returns
        -------
        None

        Creates a checktool from a graph. the graph contains a model which designates a protocol: they are used to create sharetool.

        Parameters
        ----------
        graph: Interface_Graph

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        hgraph: Interface_HGraph

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_CheckTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AnalyseCheckList(self, *args) -> "Interface_CheckIterator":
        """
        Returns list of errors dectected at analyse time (syntactic) (note that globalcheck is not in this list).

        Returns
        -------
        Interface_CheckIterator

        """
        return _Interface.Interface_CheckTool_AnalyseCheckList(self, *args)


    def Check(self, *args) -> "opencascade::handle< Interface_Check >":
        """
        Returns the check associated to an entity identified by its number in a model.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<Interface_Check>

        """
        return _Interface.Interface_CheckTool_Check(self, *args)


    def CheckList(self, *args) -> "Interface_CheckIterator":
        """
        Returns list of all errors detected note that presence of unknown entities is not an error cumulates : globalcheck if error + analysechecklist + verifychecklist.

        Returns
        -------
        Interface_CheckIterator

        """
        return _Interface.Interface_CheckTool_CheckList(self, *args)


    def CheckSuccess(self, *args) -> "void":
        """
        Checks if any error has been detected (checklist not empty) returns normally if none, raises exception if some exists. it reuses the last computations from other checking methods, unless the argument <resest> is given true.

        Parameters
        ----------
        reset: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        return _Interface.Interface_CheckTool_CheckSuccess(self, *args)


    def CompleteCheckList(self, *args) -> "Interface_CheckIterator":
        """
        Returns list of all 'remarkable' informations, which include : - globalcheck, if not empty - error checks, for all errors (verify + analyse) - also corrected entities - and unknown entities : for those, each unknown entity is associated to an empty check (it is neither an error nor a correction, but a remarkable information).

        Returns
        -------
        Interface_CheckIterator

        """
        return _Interface.Interface_CheckTool_CompleteCheckList(self, *args)


    def FillCheck(self, *args) -> "void":
        """
        Fills as required a check with the error and warning messages produced by checking a given entity. for an erroneous or corrected entity : check build at analyse time; else, check computed for entity (verify integrity), can use a graph as required to control context.

        Parameters
        ----------
        ent: Standard_Transient
        sh: Interface_ShareTool
        ach: Interface_Check

        Returns
        -------
        None

        """
        return _Interface.Interface_CheckTool_FillCheck(self, *args)


    def UnknownEntities(self, *args) -> "Interface_EntityIterator":
        """
        Returns list of unknown entities note that error and erroneous entities are not considered as unknown.

        Returns
        -------
        Interface_EntityIterator

        """
        return _Interface.Interface_CheckTool_UnknownEntities(self, *args)


    def VerifyCheckList(self, *args) -> "Interface_CheckIterator":
        """
        Returns list of integrity constraints errors (semantic) (note that globalcheck is not in this list).

        Returns
        -------
        Interface_CheckIterator

        """
        return _Interface.Interface_CheckTool_VerifyCheckList(self, *args)


    def WarningCheckList(self, *args) -> "Interface_CheckIterator":
        """
        Returns list of corrections (includes globalcheck if corrected).

        Returns
        -------
        Interface_CheckIterator

        """
        return _Interface.Interface_CheckTool_WarningCheckList(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_CheckTool
    __del__ = lambda self: None
Interface_CheckTool_swigregister = _Interface.Interface_CheckTool_swigregister
Interface_CheckTool_swigregister(Interface_CheckTool)

class Interface_CopyControl(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_CopyControl, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_CopyControl, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Bind(self, *args) -> "void":
        """
        Bind a result to a starting entity identified by its number.

        Parameters
        ----------
        ent: Standard_Transient
        res: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_CopyControl_Bind(self, *args)


    def Clear(self, *args) -> "void":
        """
        Clears list of copy results. gets ready to begin another copy process.

        Returns
        -------
        None

        """
        return _Interface.Interface_CopyControl_Clear(self, *args)


    def Search(self, *args) -> "Standard_Boolean":
        """
        Searches for the result bound to a startingf entity identified by its number. if found, returns true and fills <res> else, returns false and nullifies <res>.

        Parameters
        ----------
        ent: Standard_Transient
        res: Standard_Transient

        Returns
        -------
        bool

        """
        return _Interface.Interface_CopyControl_Search(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_CopyControl_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_CopyControl
    __del__ = lambda self: None
Interface_CopyControl_swigregister = _Interface.Interface_CopyControl_swigregister
Interface_CopyControl_swigregister(Interface_CopyControl)

class Interface_CopyTool(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_CopyTool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_CopyTool, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a copytool adapted to work from a model. works with a general service library, given as an argument.

        Parameters
        ----------
        amodel: Interface_InterfaceModel
        lib: Interface_GeneralLib

        Returns
        -------
        None

        Same as above, but library is defined through a protocol.

        Parameters
        ----------
        amodel: Interface_InterfaceModel
        protocol: Interface_Protocol

        Returns
        -------
        None

        Same as above, but works with the active protocol.

        Parameters
        ----------
        amodel: Interface_InterfaceModel

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_CopyTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Bind(self, *args) -> "void":
        """
        Defines a result for the transfer of a starting object. used by method transferred (which performs a normal copy), but can also be called to enforce a result : in the latter case, the enforced result must be compatible with the other transfers which are performed.

        Parameters
        ----------
        ent: Standard_Transient
        res: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_CopyTool_Bind(self, *args)


    def Clear(self, *args) -> "void":
        """
        Clears transfer list. gets ready to begin another transfer.

        Returns
        -------
        None

        """
        return _Interface.Interface_CopyTool_Clear(self, *args)


    def ClearLastFlags(self, *args) -> "void":
        """
        Clears lastflags only. this allows to know what entities are copied after its call (see method lastcopiedafter). it can be used when copies are done by increments, which must be distinghished. clearlastflags is also called by clear.

        Returns
        -------
        None

        """
        return _Interface.Interface_CopyTool_ClearLastFlags(self, *args)


    def CompleteResult(self, *args) -> "Interface_EntityIterator":
        """
        Returns the complete list of copied entities if <withreports> is given true, the entities which were reported in the starting model are replaced in the list by the copied reportentities.

        Parameters
        ----------
        withreports: bool,optional
        	default value is Standard_False

        Returns
        -------
        Interface_EntityIterator

        """
        return _Interface.Interface_CopyTool_CompleteResult(self, *args)


    def Control(self, *args) -> "opencascade::handle< Interface_CopyControl >":
        """
        Returns the object used for control.

        Returns
        -------
        opencascade::handle<Interface_CopyControl>

        """
        return _Interface.Interface_CopyTool_Control(self, *args)


    def Copy(self, *args) -> "Standard_Boolean":
        """
        Creates the counterpart of an entity (by shallowcopy), binds it, then copies the content of the former entity to the other one (same type), by call to the general service library it may command the copy of referenced entities then, its returns true. //! if <mapped> is true, the map is used to store the result else, the result is simply produced : it can be used to copy internal sub-parts of entities, which are not intended to be shared (strings, arrays, etc...) if <errstat> is true, this means that the entity is recorded in the model as erroneous : in this case, the general service for deep copy is not called (this could be dangerous) : hence the counter-part is produced but empty, it can be referenced. //! this method does nothing and returns false if the protocol does not recognize <ent>. it basically makes a deep copy without changing the types. it can be redefined for special uses.

        Parameters
        ----------
        entfrom: Standard_Transient
        entto: Standard_Transient
        mapped: bool
        errstat: bool

        Returns
        -------
        bool

        """
        return _Interface.Interface_CopyTool_Copy(self, *args)


    def FillModel(self, *args) -> "void":
        """
        Fills a model with the result of the transfer (transferlist) commands copy of header too, and calls renewimpliedrefs.

        Parameters
        ----------
        bmodel: Interface_InterfaceModel

        Returns
        -------
        None

        """
        return _Interface.Interface_CopyTool_FillModel(self, *args)


    def LastCopiedAfter(self, *args) -> "Standard_Integer":
        """
        Returns an copied entity and its result which were operated after last call to clearlastflags. it returns the first 'last copied entity' which number follows <numfrom>, zero if none. it is used in a loop as follow : integer num = 0; while ( (num = copytool.lastcopiedafter(num,ent,res)) ) { .. process starting <ent> and its result <res> }.

        Parameters
        ----------
        numfrom: int
        ent: Standard_Transient
        res: Standard_Transient

        Returns
        -------
        int

        """
        return _Interface.Interface_CopyTool_LastCopiedAfter(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        Returns the model on which the copytool works.

        Returns
        -------
        opencascade::handle<Interface_InterfaceModel>

        """
        return _Interface.Interface_CopyTool_Model(self, *args)


    def RenewImpliedRefs(self, *args) -> "void":
        """
        Renews the implied references. these references do not involve copying of referenced entities. for such a reference, if the entity which defines it and the referenced entity are both copied, then this reference is renewed. else it is deleted in the copied entities. remark : this concerns only some specific references, such as 'back pointers'.

        Returns
        -------
        None

        """
        return _Interface.Interface_CopyTool_RenewImpliedRefs(self, *args)


    def RootResult(self, *args) -> "Interface_EntityIterator":
        """
        Returns the list of root copied entities (those which were asked for copy by the user of copytool, not by copying another entity).

        Parameters
        ----------
        withreports: bool,optional
        	default value is Standard_False

        Returns
        -------
        Interface_EntityIterator

        """
        return _Interface.Interface_CopyTool_RootResult(self, *args)


    def Search(self, *args) -> "Standard_Boolean":
        """
        Search for the result of a starting object (i.e. an entity) returns true if a result is bound (and fills 'result') returns false if no result is bound.

        Parameters
        ----------
        ent: Standard_Transient
        res: Standard_Transient

        Returns
        -------
        bool

        """
        return _Interface.Interface_CopyTool_Search(self, *args)


    def SetControl(self, *args) -> "void":
        """
        Changes the map of result for another one. this allows to work with a more sophisticated mapping control than the standard one which is copymap (e.g. transferprocess from transfer).

        Parameters
        ----------
        othermap: Interface_CopyControl

        Returns
        -------
        None

        """
        return _Interface.Interface_CopyTool_SetControl(self, *args)


    def TransferEntity(self, *args) -> "void":
        """
        Transfers one entity and records result into the transfer list calls method transferred.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_CopyTool_TransferEntity(self, *args)


    def Transferred(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Transfers one entity, if not yet bound to a result remark : for an entity which is reported in the starting model, the reportentity will also be copied with its content if it has one (at least shallowcopy; complete copy if the protocol recognizes the content : see method copy).

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _Interface.Interface_CopyTool_Transferred(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_CopyTool
    __del__ = lambda self: None
Interface_CopyTool_swigregister = _Interface.Interface_CopyTool_swigregister
Interface_CopyTool_swigregister(Interface_CopyTool)

class Interface_EntityCluster(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_EntityCluster, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_EntityCluster, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an empty, non-chained, entitycluster.

        Returns
        -------
        None

        Creates a non-chained entitycluster, filled with one entity.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        None

        Creates an empty entitycluster, chained with another one (that is, put before this other one in the list).

        Parameters
        ----------
        ec: Interface_EntityCluster

        Returns
        -------
        None

        Creates an entitycluster, filled with a first entity, and chained to another entitycluster (before it, as above).

        Parameters
        ----------
        ant: Standard_Transient
        ec: Interface_EntityCluster

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_EntityCluster(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Append(self, *args) -> "void":
        """
        Appends an entity to the cluster. if it is not full, adds the entity directly inside itself. else, transmits to its next and creates it if it does not yet exist.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_EntityCluster_Append(self, *args)


    def FillIterator(self, *args) -> "void":
        """
        Fills an iterator with designated entities (includes next).

        Parameters
        ----------
        iter: Interface_EntityIterator

        Returns
        -------
        None

        """
        return _Interface.Interface_EntityCluster_FillIterator(self, *args)


    def NbEntities(self, *args) -> "Standard_Integer":
        """
        Returns total count of entities (including next).

        Returns
        -------
        int

        """
        return _Interface.Interface_EntityCluster_NbEntities(self, *args)


    def Remove(self, *args) -> "Standard_Boolean":
        """
        Removes an entity from the cluster. if it is not found, calls its next one to do so. returns true if it becomes itself empty, false else (thus, a cluster which becomes empty is deleted from the list).

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        bool

        Removes an entity from the cluster, given its rank. if <num> is greater than nblocal, calls its next with (num - nblocal), returns true if it becomes itself empty, false else.

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _Interface.Interface_EntityCluster_Remove(self, *args)


    def SetValue(self, *args) -> "void":
        """
        Changes an entity given its rank.

        Parameters
        ----------
        num: int
        ent: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_EntityCluster_SetValue(self, *args)


    def Value(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        Returns the entity identified by its rank in the list (including next).

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _Interface.Interface_EntityCluster_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_EntityCluster_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_EntityCluster
    __del__ = lambda self: None
Interface_EntityCluster_swigregister = _Interface.Interface_EntityCluster_swigregister
Interface_EntityCluster_swigregister(Interface_EntityCluster)

class Interface_EntityIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_EntityIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_EntityIterator, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Defines an empty iterator (see addlist & additem).

        Returns
        -------
        None

        Defines an iterator on a list, directly i.e. without copying it.

        Parameters
        ----------
        list: TColStd_HSequenceOfTransient

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_EntityIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddItem(self, *args) -> "void":
        """
        Adds to the iteration list a defined entity.

        Parameters
        ----------
        anentity: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_EntityIterator_AddItem(self, *args)


    def AddList(self, *args) -> "void":
        """
        Gets a list of entities and adds its to the iteration list.

        Parameters
        ----------
        list: TColStd_HSequenceOfTransient

        Returns
        -------
        None

        """
        return _Interface.Interface_EntityIterator_AddList(self, *args)


    def Content(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        Returns the content of the iterator, accessed through a handle to be used by a frontal-engine logic returns an empty sequence if the iterator is empty calls start if not yet done.

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfTransient>

        """
        return _Interface.Interface_EntityIterator_Content(self, *args)


    def Destroy(self, *args) -> "void":
        """
        Clears data of iteration.

        Returns
        -------
        None

        """
        return _Interface.Interface_EntityIterator_Destroy(self, *args)


    def GetOneItem(self, *args) -> "void":
        """
        Same as additem (kept for compatibility).

        Parameters
        ----------
        anentity: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_EntityIterator_GetOneItem(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """
        Says if there are other entities (vertices) to iterate the first time, calls start.

        Returns
        -------
        bool

        """
        return _Interface.Interface_EntityIterator_More(self, *args)


    def NbEntities(self, *args) -> "Standard_Integer":
        """
        Returns count of entities which will be iterated on calls start if not yet done.

        Returns
        -------
        int

        """
        return _Interface.Interface_EntityIterator_NbEntities(self, *args)


    def NbTyped(self, *args) -> "Standard_Integer":
        """
        Returns count of entities of a given type (kind of).

        Parameters
        ----------
        type: Standard_Type

        Returns
        -------
        int

        """
        return _Interface.Interface_EntityIterator_NbTyped(self, *args)


    def Next(self, *args) -> "void":
        """
        Sets iteration to the next entity (vertex) to give.

        Returns
        -------
        None

        """
        return _Interface.Interface_EntityIterator_Next(self, *args)


    def SelectType(self, *args) -> "void":
        """
        Selects entities with are kind of a given type, keep only them (is keep is true) or reject only them (if keep is false).

        Parameters
        ----------
        atype: Standard_Type
        keep: bool

        Returns
        -------
        None

        """
        return _Interface.Interface_EntityIterator_SelectType(self, *args)


    def Start(self, *args) -> "void":
        """
        Allows re-iteration (useless for the first iteration).

        Returns
        -------
        None

        """
        return _Interface.Interface_EntityIterator_Start(self, *args)


    def Typed(self, *args) -> "Interface_EntityIterator":
        """
        Returns the list of entities of a given type (kind of).

        Parameters
        ----------
        type: Standard_Type

        Returns
        -------
        Interface_EntityIterator

        """
        return _Interface.Interface_EntityIterator_Typed(self, *args)


    def Value(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        Returns the current entity iterated, to be used by interface tools.

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _Interface.Interface_EntityIterator_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_EntityIterator
    __del__ = lambda self: None
Interface_EntityIterator_swigregister = _Interface.Interface_EntityIterator_swigregister
Interface_EntityIterator_swigregister(Interface_EntityIterator)

class Interface_EntityList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_EntityList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_EntityList, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a list as beeing empty.

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_EntityList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args) -> "void":
        """
        Adds an entity to the list, that is, with no regard about the order (faster than append if count becomes greater than 10).

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_EntityList_Add(self, *args)


    def Append(self, *args) -> "void":
        """
        Appends an entity, that is to the end of the list (keeps order, but works slowerly than add, see below).

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_EntityList_Append(self, *args)


    def Clear(self, *args) -> "void":
        """
        Clears the list.

        Returns
        -------
        None

        """
        return _Interface.Interface_EntityList_Clear(self, *args)


    def FillIterator(self, *args) -> "void":
        """
        Fills an iterator with the content of the list (normal way to consult a list which has been filled with add).

        Parameters
        ----------
        iter: Interface_EntityIterator

        Returns
        -------
        None

        """
        return _Interface.Interface_EntityList_FillIterator(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        Returns true if the list is empty.

        Returns
        -------
        bool

        """
        return _Interface.Interface_EntityList_IsEmpty(self, *args)


    def NbEntities(self, *args) -> "Standard_Integer":
        """
        Returns count of recorded entities.

        Returns
        -------
        int

        """
        return _Interface.Interface_EntityList_NbEntities(self, *args)


    def NbTypedEntities(self, *args) -> "Standard_Integer":
        """
        Returns count of entities of a given type (0 : none).

        Parameters
        ----------
        atype: Standard_Type

        Returns
        -------
        int

        """
        return _Interface.Interface_EntityList_NbTypedEntities(self, *args)


    def Remove(self, *args) -> "void":
        """
        Removes an entity from the list, if it is there.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        None

        Removes an entity from the list, given its rank.

        Parameters
        ----------
        num: int

        Returns
        -------
        None

        """
        return _Interface.Interface_EntityList_Remove(self, *args)


    def SetValue(self, *args) -> "void":
        """
        Returns an item given its number. beware about the way the list was filled (see above, add and append).

        Parameters
        ----------
        num: int
        ent: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_EntityList_SetValue(self, *args)


    def TypedEntity(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Returns the entity which is of a given type. if num = 0 (d), there must be one and only one if num > 0, returns the num-th entity of this type.

        Parameters
        ----------
        atype: Standard_Type
        num: int,optional
        	default value is 0

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _Interface.Interface_EntityList_TypedEntity(self, *args)


    def Value(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        Returns an item given its number. beware about the way the list was filled (see above, add and append).

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _Interface.Interface_EntityList_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_EntityList
    __del__ = lambda self: None
Interface_EntityList_swigregister = _Interface.Interface_EntityList_swigregister
Interface_EntityList_swigregister(Interface_EntityList)

class Interface_FileParameter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_FileParameter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_FileParameter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_FileParameter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CValue(self, *args) -> "char const *":
        """
        Same as above, but as a cstring (for immediate exploitation) was c++ : return const.

        Returns
        -------
        char *

        """
        return _Interface.Interface_FileParameter_CValue(self, *args)


    def Clear(self, *args) -> "void":
        """
        Clears stored data : frees memory taken for the string value.

        Returns
        -------
        None

        """
        return _Interface.Interface_FileParameter_Clear(self, *args)


    def Destroy(self, *args) -> "void":
        """
        Destructor. does nothing because memory is managed by paramset.

        Returns
        -------
        None

        """
        return _Interface.Interface_FileParameter_Destroy(self, *args)


    def EntityNumber(self, *args) -> "Standard_Integer":
        """
        Returns value set by setentitynumber.

        Returns
        -------
        int

        """
        return _Interface.Interface_FileParameter_EntityNumber(self, *args)


    def Init(self, *args) -> "void":
        """
        Fills fields (with entity number set to zero).

        Parameters
        ----------
        val: TCollection_AsciiString
        typ: Interface_ParamType

        Returns
        -------
        None

        Same as above, but builds the value from a cstring.

        Parameters
        ----------
        val: char *
        typ: Interface_ParamType

        Returns
        -------
        None

        """
        return _Interface.Interface_FileParameter_Init(self, *args)


    def ParamType(self, *args) -> "Interface_ParamType":
        """
        Returns the type of the parameter.

        Returns
        -------
        Interface_ParamType

        """
        return _Interface.Interface_FileParameter_ParamType(self, *args)


    def SetEntityNumber(self, *args) -> "void":
        """
        Allows to set a reference to an entity in a numbered list.

        Parameters
        ----------
        num: int

        Returns
        -------
        None

        """
        return _Interface.Interface_FileParameter_SetEntityNumber(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_FileParameter
    __del__ = lambda self: None
Interface_FileParameter_swigregister = _Interface.Interface_FileParameter_swigregister
Interface_FileParameter_swigregister(Interface_FileParameter)

class Interface_FileReaderData(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_FileReaderData, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_FileReaderData, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AddParam(self, *args) -> "void":
        """
        Adds a parameter to record no 'num' and fills its fields (entitynumber is optional) warning : <aval> is assumed to be memory-managed elsewhere : it is not copied. this gives a best speed : strings remain stored in pages of characters.

        Parameters
        ----------
        num: int
        aval: char *
        atype: Interface_ParamType
        nument: int,optional
        	default value is 0

        Returns
        -------
        None

        Same as above, but gets a asciistring from tcollection remark that the content of the asciistring is locally copied (because its content is most often lost after using).

        Parameters
        ----------
        num: int
        aval: TCollection_AsciiString
        atype: Interface_ParamType
        nument: int,optional
        	default value is 0

        Returns
        -------
        None

        Same as above, but gets a complete fileparameter warning : content of <fp> is not copied : its original address and space in memory are assumed to be managed elsewhere (see paramset).

        Parameters
        ----------
        num: int
        FP: Interface_FileParameter

        Returns
        -------
        None

        """
        return _Interface.Interface_FileReaderData_AddParam(self, *args)


    def BindEntity(self, *args) -> "void":
        """
        Binds an entity to a record.

        Parameters
        ----------
        num: int
        ent: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_FileReaderData_BindEntity(self, *args)


    def BoundEntity(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        Returns the entity bound to a record, set by setentities.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _Interface.Interface_FileReaderData_BoundEntity(self, *args)


    def ChangeParam(self, *args) -> "Interface_FileParameter &":
        """
        Same as above, but in order to be modified on place.

        Parameters
        ----------
        num: int
        nump: int

        Returns
        -------
        Interface_FileParameter

        """
        return _Interface.Interface_FileReaderData_ChangeParam(self, *args)


    def Destroy(self, *args) -> "void":
        """
        Destructor (waiting for memory management).

        Returns
        -------
        None

        """
        return _Interface.Interface_FileReaderData_Destroy(self, *args)


    def Fastof(*args) -> "Standard_Real":
        """
        Same spec.s as standard <atof> but 5 times faster.

        Parameters
        ----------
        str: char *

        Returns
        -------
        float

        """
        return _Interface.Interface_FileReaderData_Fastof(*args)

    Fastof = staticmethod(Fastof)

    def FindNextRecord(self, *args) -> "Standard_Integer":
        """
        Determines the record number defining an entity following a given record number. specific to each sub-class of filereaderdata. returning zero means no record found.

        Parameters
        ----------
        num: int

        Returns
        -------
        int

        """
        return _Interface.Interface_FileReaderData_FindNextRecord(self, *args)


    def InitParams(self, *args) -> "void":
        """
        Attaches an empty paramlist to a record.

        Parameters
        ----------
        num: int

        Returns
        -------
        None

        """
        return _Interface.Interface_FileReaderData_InitParams(self, *args)


    def IsErrorLoad(self, *args) -> "Standard_Boolean":
        """
        Returns true if the status 'error load' has been set (to true or false).

        Returns
        -------
        bool

        """
        return _Interface.Interface_FileReaderData_IsErrorLoad(self, *args)


    def IsParamDefined(self, *args) -> "Standard_Boolean":
        """
        Returns true if parameter 'nump' of record 'num' is defined (it is not if its type is paramvoid).

        Parameters
        ----------
        num: int
        nump: int

        Returns
        -------
        bool

        """
        return _Interface.Interface_FileReaderData_IsParamDefined(self, *args)


    def NbEntities(self, *args) -> "Standard_Integer":
        """
        Returns the count of entities. depending of each norm, records can be entities or subparts (sublist in step, subgroup in set ...). nbentities counts only entities, not subs used for memory reservation in interfacemodel default implementation uses findnextrecord can be redefined into a more performant way.

        Returns
        -------
        int

        """
        return _Interface.Interface_FileReaderData_NbEntities(self, *args)


    def NbParams(self, *args) -> "Standard_Integer":
        """
        Returns count of parameters attached to record 'num' if <num> = 0, returns the total recorded count of parameters.

        Parameters
        ----------
        num: int

        Returns
        -------
        int

        """
        return _Interface.Interface_FileReaderData_NbParams(self, *args)


    def NbRecords(self, *args) -> "Standard_Integer":
        """
        Returns the count of registered records that is, value given for initialization (can be redefined).

        Returns
        -------
        int

        """
        return _Interface.Interface_FileReaderData_NbRecords(self, *args)


    def Param(self, *args) -> "Interface_FileParameter const &":
        """
        Returns parameter 'nump' of record 'num', as a complete fileparameter.

        Parameters
        ----------
        num: int
        nump: int

        Returns
        -------
        Interface_FileParameter

        """
        return _Interface.Interface_FileReaderData_Param(self, *args)


    def ParamCValue(self, *args) -> "char const *":
        """
        Same as above, but as a cstring was c++ : return const.

        Parameters
        ----------
        num: int
        nump: int

        Returns
        -------
        char *

        """
        return _Interface.Interface_FileReaderData_ParamCValue(self, *args)


    def ParamEntity(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        Returns the stepentity referenced by a parameter error if none.

        Parameters
        ----------
        num: int
        nump: int

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _Interface.Interface_FileReaderData_ParamEntity(self, *args)


    def ParamFirstRank(self, *args) -> "Standard_Integer":
        """
        Returns the absolute rank of the beginning of a record (its lsit is from paramfirstrank+1 to paramfirstrank+nbparams).

        Parameters
        ----------
        num: int

        Returns
        -------
        int

        """
        return _Interface.Interface_FileReaderData_ParamFirstRank(self, *args)


    def ParamNumber(self, *args) -> "Standard_Integer":
        """
        Returns record number of an entity referenced by a parameter of type ident; 0 if no entitynumber has been determined note that it is used to reference entities but also sublists (sublists are not objects, but internal descriptions).

        Parameters
        ----------
        num: int
        nump: int

        Returns
        -------
        int

        """
        return _Interface.Interface_FileReaderData_ParamNumber(self, *args)


    def ParamType(self, *args) -> "Interface_ParamType":
        """
        Returns type of parameter 'nump' of record 'num' returns literal value of parameter 'nump' of record 'num' was c++ : return const &.

        Parameters
        ----------
        num: int
        nump: int

        Returns
        -------
        Interface_ParamType

        """
        return _Interface.Interface_FileReaderData_ParamType(self, *args)


    def Params(self, *args) -> "opencascade::handle< Interface_ParamList >":
        """
        Returns the complete paramlist of a record (read only) num = 0 to return the whole param list for the file.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<Interface_ParamList>

        """
        return _Interface.Interface_FileReaderData_Params(self, *args)


    def ResetErrorLoad(self, *args) -> "Standard_Boolean":
        """
        Returns the former value of status 'error load' then resets it used to read the status then ensure it is reset.

        Returns
        -------
        bool

        """
        return _Interface.Interface_FileReaderData_ResetErrorLoad(self, *args)


    def SetErrorLoad(self, *args) -> "void":
        """
        Sets the status 'error load' on, to overside check fails <val> true : declares unloaded <val> false : declares loaded if not called before loading (see filereadertool), check fails give the status iserrorload says if seterrorload has been called by user reseterrorload resets it (called by filereadertool) this allows to specify that the currently loaded entity remains unloaded (because of syntactic fail).

        Parameters
        ----------
        val: bool

        Returns
        -------
        None

        """
        return _Interface.Interface_FileReaderData_SetErrorLoad(self, *args)


    def SetParam(self, *args) -> "void":
        """
        Sets a new value for a parameter of a record, given by : num : record number; nump : parameter number in the record.

        Parameters
        ----------
        num: int
        nump: int
        FP: Interface_FileParameter

        Returns
        -------
        None

        """
        return _Interface.Interface_FileReaderData_SetParam(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_FileReaderData_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_FileReaderData
    __del__ = lambda self: None
Interface_FileReaderData_swigregister = _Interface.Interface_FileReaderData_swigregister
Interface_FileReaderData_swigregister(Interface_FileReaderData)

def Interface_FileReaderData_Fastof(*args) -> "Standard_Real":
    """
    Same spec.s as standard <atof> but 5 times faster.

    Parameters
    ----------
    str: char *

    Returns
    -------
    float

    """
    return _Interface.Interface_FileReaderData_Fastof(*args)

class Interface_FileReaderTool(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_FileReaderTool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_FileReaderTool, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AnalyseRecord(self, *args) -> "Standard_Boolean":
        """
        Fills an entity, given record no; specific to each interface, called by analysefile from interfacemodel (which manages its calling arguments) to work, each interface can define a method in its proper transient class, like this (given as an example) : analyserecord (me : mutable; fr : in out filereadertool; num : integer; acheck : in out check) returns boolean; and call it from analyserecord //! returned value : true if the entity could be loaded, false else (in case of syntactic fail).

        Parameters
        ----------
        num: int
        anent: Standard_Transient
        acheck: Interface_Check

        Returns
        -------
        bool

        """
        return _Interface.Interface_FileReaderTool_AnalyseRecord(self, *args)


    def BeginRead(self, *args) -> "void":
        """
        Fills model's header; each interface defines for its model its own file header; this method fills it from filereadertool.+ it is called by analysefile from interfacemodel.

        Parameters
        ----------
        amodel: Interface_InterfaceModel

        Returns
        -------
        None

        """
        return _Interface.Interface_FileReaderTool_BeginRead(self, *args)


    def Clear(self, *args) -> "void":
        """
        Clear filelds.

        Returns
        -------
        None

        """
        return _Interface.Interface_FileReaderTool_Clear(self, *args)


    def Data(self, *args) -> "opencascade::handle< Interface_FileReaderData >":
        """
        Returns the filereaderdata which is used to work.

        Returns
        -------
        opencascade::handle<Interface_FileReaderData>

        """
        return _Interface.Interface_FileReaderTool_Data(self, *args)


    def EndRead(self, *args) -> "void":
        """
        Ends file reading after reading all the entities default is doing nothing; redefinable as necessary.

        Parameters
        ----------
        amodel: Interface_InterfaceModel

        Returns
        -------
        None

        """
        return _Interface.Interface_FileReaderTool_EndRead(self, *args)


    def ErrorHandle(self, *args) -> "Standard_Boolean":
        """
        Returns errorhandle flag.

        Returns
        -------
        bool

        """
        return _Interface.Interface_FileReaderTool_ErrorHandle(self, *args)


    def LoadModel(self, *args) -> "void":
        """
        Reads and fills entities from the filereaderdata set by setdata to an interfacemodel. it enchains required operations, the specific ones correspond to deferred methods (below) to be defined for each norm. it manages also error recovery and trace. remark : it calls setmodel. it can raise any error which can occur during a load operation, unless error handling is set. this method can also be redefined if judged necessary.

        Parameters
        ----------
        amodel: Interface_InterfaceModel

        Returns
        -------
        None

        """
        return _Interface.Interface_FileReaderTool_LoadModel(self, *args)


    def LoadedEntity(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Reads, fills and returns one entity read from a record of the filereaderdata. this method manages also case of fail or warning, by producing a reportentyty plus , for a fail, a literal content (as an unknownentity). performs also trace.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _Interface.Interface_FileReaderTool_LoadedEntity(self, *args)


    def Messenger(self, *args) -> "opencascade::handle< Message_Messenger >":
        """
        Returns messenger used for outputting messages. the returned object is guaranteed to be non-null; default is message::messenger().

        Returns
        -------
        opencascade::handle<Message_Messenger>

        """
        return _Interface.Interface_FileReaderTool_Messenger(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        Returns the stored model.

        Returns
        -------
        opencascade::handle<Interface_InterfaceModel>

        """
        return _Interface.Interface_FileReaderTool_Model(self, *args)


    def NewModel(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        Creates an empty model of the norm. uses protocol to do it.

        Returns
        -------
        opencascade::handle<Interface_InterfaceModel>

        """
        return _Interface.Interface_FileReaderTool_NewModel(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol >":
        """
        Returns the protocol given at creation time.

        Returns
        -------
        opencascade::handle<Interface_Protocol>

        """
        return _Interface.Interface_FileReaderTool_Protocol(self, *args)


    def Recognize(self, *args) -> "Standard_Boolean":
        """
        Recognizes a record, given its number. specific to each interface; called by setentities. it can call the basic method recognizebylib. returns false if recognition has failed, true else. <ach> has not to be filled if simply recognition has failed : it must record true error messages : recognizebylib can generate error messages if newread is called //! note that it works thru a recognizer (method evaluate) which has to be memorized before starting.

        Parameters
        ----------
        num: int
        ach: Interface_Check
        ent: Standard_Transient

        Returns
        -------
        bool

        """
        return _Interface.Interface_FileReaderTool_Recognize(self, *args)


    def RecognizeByLib(self, *args) -> "Standard_Boolean":
        """
        Recognizes a record with the help of libraries. can be used to implement the method recognize. <rlib> is used to find protocol and casenumber to apply <glib> performs the creation (by service newvoid, or newread if newvoid gave no result) <ach> is a check, which is transmitted to newread if it is called, gives a result but which is false <ent> is the result returns false if recognition has failed, true else.

        Parameters
        ----------
        num: int
        glib: Interface_GeneralLib
        rlib: Interface_ReaderLib
        ach: Interface_Check
        ent: Standard_Transient

        Returns
        -------
        bool

        """
        return _Interface.Interface_FileReaderTool_RecognizeByLib(self, *args)


    def SetData(self, *args) -> "void":
        """
        Sets data to a filereaderdata. works with a protocol.

        Parameters
        ----------
        reader: Interface_FileReaderData
        protocol: Interface_Protocol

        Returns
        -------
        None

        """
        return _Interface.Interface_FileReaderTool_SetData(self, *args)


    def SetEntities(self, *args) -> "void":
        """
        Fills records with empty entities; once done, each entity can ask the filereadertool for any entity referenced through an identifier. calls recognize which is specific to each specific type of filereadertool.

        Returns
        -------
        None

        """
        return _Interface.Interface_FileReaderTool_SetEntities(self, *args)


    def SetErrorHandle(self, *args) -> "void":
        """
        Allows controlling whether exception raisings are handled if err is false, they are not (hence, dbx can take control) if err is true, they are, and they are traced (by putting on messenger entity's number and file record num) default given at model's creation time is true.

        Parameters
        ----------
        err: bool

        Returns
        -------
        None

        """
        return _Interface.Interface_FileReaderTool_SetErrorHandle(self, *args)


    def SetMessenger(self, *args) -> "void":
        """
        Sets messenger used for outputting messages.

        Parameters
        ----------
        messenger: Message_Messenger

        Returns
        -------
        None

        """
        return _Interface.Interface_FileReaderTool_SetMessenger(self, *args)


    def SetModel(self, *args) -> "void":
        """
        Stores a model. used when the model has been loaded.

        Parameters
        ----------
        amodel: Interface_InterfaceModel

        Returns
        -------
        None

        """
        return _Interface.Interface_FileReaderTool_SetModel(self, *args)


    def SetTraceLevel(self, *args) -> "void":
        """
        Sets trace level used for outputting messages - 0: no trace at all - 1: errors - 2: errors and warnings - 3: all messages default is 1 : errors traced.

        Parameters
        ----------
        tracelev: int

        Returns
        -------
        None

        """
        return _Interface.Interface_FileReaderTool_SetTraceLevel(self, *args)


    def TraceLevel(self, *args) -> "Standard_Integer":
        """
        Returns trace level used for outputting messages.

        Returns
        -------
        int

        """
        return _Interface.Interface_FileReaderTool_TraceLevel(self, *args)


    def UnknownEntity(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Provides an unknown entity, specific to the interface called by setentities when recognize has failed (unknown alone) or by loadmodel when an entity has caused a fail on reading (to keep at least its literal description) uses protocol to do it.

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _Interface.Interface_FileReaderTool_UnknownEntity(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_FileReaderTool
    __del__ = lambda self: None
Interface_FileReaderTool_swigregister = _Interface.Interface_FileReaderTool_swigregister
Interface_FileReaderTool_swigregister(Interface_FileReaderTool)

class Interface_FloatWriter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_FloatWriter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_FloatWriter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a floatwriter ready to work, with default options - - zero suppress option is set - main format is set to '%e' - secondary format is set to '%f' for values between 0.1 and 1000. in absolute values if <chars> is given (and positive), it will produce options to produce this count of characters : '%<chars>f','%<chars>%e'.

        Parameters
        ----------
        chars: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_FloatWriter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Convert(*args) -> "Standard_Integer":
        """
        This class method converts a real value to a string, given options given as arguments. it can be called independantly. warning : even if declared in, content of <text> will be modified.

        Parameters
        ----------
        val: float
        text: char *
        zerosup: bool
        Range1: float
        Range2: float
        mainform: char *
        rangeform: char *

        Returns
        -------
        int

        """
        return _Interface.Interface_FloatWriter_Convert(*args)

    Convert = staticmethod(Convert)

    def FormatForRange(self, *args) -> "char const *":
        """
        Returns the format for range, if set meaningful only if <range> from options is true was c++ : return const.

        Returns
        -------
        char *

        """
        return _Interface.Interface_FloatWriter_FormatForRange(self, *args)


    def MainFormat(self, *args) -> "char const *":
        """
        Returns the main format was c++ : return const.

        Returns
        -------
        char *

        """
        return _Interface.Interface_FloatWriter_MainFormat(self, *args)


    def Options(self, *args) -> "void":
        """
        Returns active options : <zerosup> is the option zerosuppress, <range> is true if a range is set, false else r1,r2 give the range (if it is set).

        Parameters
        ----------

        Returns
        -------
        zerosup: bool
        range: bool
        R1: float
        R2: float

        """
        return _Interface.Interface_FloatWriter_Options(self, *args)


    def SetDefaults(self, *args) -> "void":
        """
        Sets again options to the defaults given by create.

        Parameters
        ----------
        chars: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        return _Interface.Interface_FloatWriter_SetDefaults(self, *args)


    def SetFormat(self, *args) -> "void":
        """
        Sets a specific format for sending reals (main format) (default from creation is '%e') if <reset> is given true (default), this call clears effects of former calls to setformatforrange and setzerosuppress.

        Parameters
        ----------
        form: char *
        reset: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        """
        return _Interface.Interface_FloatWriter_SetFormat(self, *args)


    def SetFormatForRange(self, *args) -> "void":
        """
        Sets a secondary format for real, to be applied between r1 and r2 (in absolute values). a call to setrealform cancels this secondary form if <reset> is true. (default from creation is '%f' between 0.1 and 1000.) warning : if the condition (0. <= r1 < r2) is not fulfilled, this secondary form is canceled.

        Parameters
        ----------
        form: char *
        R1: float
        R2: float

        Returns
        -------
        None

        """
        return _Interface.Interface_FloatWriter_SetFormatForRange(self, *args)


    def SetZeroSuppress(self, *args) -> "void":
        """
        Sets sending real parameters to suppress trailing zeros and null exponant ('e+00'), if <mode> is given true, resets this mode if <mode> is false (in addition to real forms) a call to setrealfrom resets this mode to false ig <reset> is given true (default from creation is true).

        Parameters
        ----------
        mode: bool

        Returns
        -------
        None

        """
        return _Interface.Interface_FloatWriter_SetZeroSuppress(self, *args)


    def Write(self, *args) -> "Standard_Integer":
        """
        Writes a real value <val> to a string <text> by using the options. returns the useful length of produced string. it calls the class method convert. warning : <text> is assumed to be wide enough (20-30 is correct) and, even if declared in, its content will be modified.

        Parameters
        ----------
        val: float
        text: char *

        Returns
        -------
        int

        """
        return _Interface.Interface_FloatWriter_Write(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_FloatWriter
    __del__ = lambda self: None
Interface_FloatWriter_swigregister = _Interface.Interface_FloatWriter_swigregister
Interface_FloatWriter_swigregister(Interface_FloatWriter)

def Interface_FloatWriter_Convert(*args) -> "Standard_Integer":
    """
    This class method converts a real value to a string, given options given as arguments. it can be called independantly. warning : even if declared in, content of <text> will be modified.

    Parameters
    ----------
    val: float
    text: char *
    zerosup: bool
    Range1: float
    Range2: float
    mainform: char *
    rangeform: char *

    Returns
    -------
    int

    """
    return _Interface.Interface_FloatWriter_Convert(*args)

class Interface_GTool(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_GTool, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_GTool, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an empty, not set, gtool.

        Returns
        -------
        None

        Creates a gtool from a protocol optional starting count of entities.

        Parameters
        ----------
        proto: Interface_Protocol
        nbent: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_GTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ClearEntities(self, *args) -> "void":
        """
        Clears the maps which record, for each already recorded entity its module and case number.

        Returns
        -------
        None

        """
        return _Interface.Interface_GTool_ClearEntities(self, *args)


    def Lib(self, *args) -> "Interface_GeneralLib &":
        """
        Returns the generallib itself.

        Returns
        -------
        Interface_GeneralLib

        """
        return _Interface.Interface_GTool_Lib(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol >":
        """
        Returns the protocol. warning : it can be null.

        Returns
        -------
        opencascade::handle<Interface_Protocol>

        """
        return _Interface.Interface_GTool_Protocol(self, *args)


    def Reservate(self, *args) -> "void":
        """
        Reservates maps for a count of entities <enforce> false : minimum count <enforce> true : clears former reservations does not clear the maps.

        Parameters
        ----------
        nb: int
        enforce: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        return _Interface.Interface_GTool_Reservate(self, *args)


    def Select(self, *args) -> "Standard_Boolean":
        """
        Selects for an entity, its module and case number it is optimised : once done for each entity, the result is mapped and the generallib is not longer queried <enforce> true overpasses this optimisation.

        Parameters
        ----------
        ent: Standard_Transient
        gmod: Interface_GeneralModule
        enforce: bool,optional
        	default value is Standard_False

        Returns
        -------
        CN: int

        """
        return _Interface.Interface_GTool_Select(self, *args)


    def SetProtocol(self, *args) -> "void":
        """
        Sets a new protocol if <enforce> is false and the new protocol equates the old one then nothing is done.

        Parameters
        ----------
        proto: Interface_Protocol
        enforce: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        return _Interface.Interface_GTool_SetProtocol(self, *args)


    def SetSignType(self, *args) -> "void":
        """
        Sets a new signtype.

        Parameters
        ----------
        sign: Interface_SignType

        Returns
        -------
        None

        """
        return _Interface.Interface_GTool_SetSignType(self, *args)


    def SignName(self, *args) -> "char const *":
        """
        Returns the name of the signtype, or 'class name'.

        Returns
        -------
        char *

        """
        return _Interface.Interface_GTool_SignName(self, *args)


    def SignType(self, *args) -> "opencascade::handle< Interface_SignType >":
        """
        Returns the signtype. can be null.

        Returns
        -------
        opencascade::handle<Interface_SignType>

        """
        return _Interface.Interface_GTool_SignType(self, *args)


    def SignValue(self, *args) -> "char const *":
        """
        Returns the signature for a transient object in a model it calls signtype to do that if signtype is not defined, return classname of <ent>.

        Parameters
        ----------
        ent: Standard_Transient
        model: Interface_InterfaceModel

        Returns
        -------
        char *

        """
        return _Interface.Interface_GTool_SignValue(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_GTool_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_GTool
    __del__ = lambda self: None
Interface_GTool_swigregister = _Interface.Interface_GTool_swigregister
Interface_GTool_swigregister(Interface_GTool)

class Interface_GeneralLib(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_GeneralLib, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_GeneralLib, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a library which complies with a protocol, that is : same class (criterium isinstance) this creation gets the modules from the global set, those which are bound to the given protocol and its resources.

        Parameters
        ----------
        aprotocol: Interface_Protocol

        Returns
        -------
        None

        Creates an empty library : it will later by filled by method addprotocol.

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_GeneralLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddProtocol(self, *args) -> "void":
        """
        Adds a couple (module-protocol) to the library, given the class of a protocol. takes resources into account. (if <aprotocol> is not of type theprotocol, it is not added).

        Parameters
        ----------
        aprotocol: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_GeneralLib_AddProtocol(self, *args)


    def Clear(self, *args) -> "void":
        """
        Clears the list of modules of a library (can be used to redefine the order of modules before action : clear then refill the library by calls to addprotocol).

        Returns
        -------
        None

        """
        return _Interface.Interface_GeneralLib_Clear(self, *args)


    def Module(self, *args) -> "opencascade::handle< Interface_GeneralModule > const &":
        """
        Returns the current module in the iteration.

        Returns
        -------
        opencascade::handle<Interface_GeneralModule>

        """
        return _Interface.Interface_GeneralLib_Module(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """
        Returns true if there are more modules to iterate on.

        Returns
        -------
        bool

        """
        return _Interface.Interface_GeneralLib_More(self, *args)


    def Next(self, *args) -> "void":
        """
        Iterates by getting the next module in the list if there is none, the exception will be raised by value.

        Returns
        -------
        None

        """
        return _Interface.Interface_GeneralLib_Next(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol > const &":
        """
        Returns the current protocol in the iteration.

        Returns
        -------
        opencascade::handle<Interface_Protocol>

        """
        return _Interface.Interface_GeneralLib_Protocol(self, *args)


    def Select(self, *args) -> "Standard_Boolean":
        """
        Selects a module from the library, given an object. returns true if select has succeeded, false else. also returns (as arguments) the selected module and the case number determined by the associated protocol. if select has failed, <module> is null handle and cn is zero. (select can work on any criterium, such as object dynamictype).

        Parameters
        ----------
        obj: Standard_Transient
        module: Interface_GeneralModule

        Returns
        -------
        CN: int

        """
        return _Interface.Interface_GeneralLib_Select(self, *args)


    def SetComplete(self, *args) -> "void":
        """
        Sets a library to be defined with the complete global list (all the couples protocol/modules recorded in it).

        Returns
        -------
        None

        """
        return _Interface.Interface_GeneralLib_SetComplete(self, *args)


    def SetGlobal(*args) -> "void":
        """
        Adds a couple (module-protocol) into the global definition set for this class of library.

        Parameters
        ----------
        amodule: Interface_GeneralModule
        aprotocol: Interface_Protocol

        Returns
        -------
        None

        """
        return _Interface.Interface_GeneralLib_SetGlobal(*args)

    SetGlobal = staticmethod(SetGlobal)

    def Start(self, *args) -> "void":
        """
        Starts iteration on the modules (sets it on the first one).

        Returns
        -------
        None

        """
        return _Interface.Interface_GeneralLib_Start(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_GeneralLib
    __del__ = lambda self: None
Interface_GeneralLib_swigregister = _Interface.Interface_GeneralLib_swigregister
Interface_GeneralLib_swigregister(Interface_GeneralLib)

def Interface_GeneralLib_SetGlobal(*args) -> "void":
    """
    Adds a couple (module-protocol) into the global definition set for this class of library.

    Parameters
    ----------
    amodule: Interface_GeneralModule
    aprotocol: Interface_Protocol

    Returns
    -------
    None

    """
    return _Interface.Interface_GeneralLib_SetGlobal(*args)

class Interface_GeneralModule(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_GeneralModule, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_GeneralModule, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def CanCopy(self, *args) -> "Standard_Boolean":
        """
        Specific answer to the question 'is copy properly implemented' remark that it should be in phase with the implementation of newvoid+copycase/newcopycase default returns always false, can be redefined.

        Parameters
        ----------
        CN: int
        ent: Standard_Transient

        Returns
        -------
        bool

        """
        return _Interface.Interface_GeneralModule_CanCopy(self, *args)


    def CategoryNumber(self, *args) -> "Standard_Integer":
        """
        Returns a category number which characterizes an entity category numbers are managed by the class category <shares> can be used to evaluate this number in the context default returns 0 which means 'unspecified'.

        Parameters
        ----------
        CN: int
        ent: Standard_Transient
        shares: Interface_ShareTool

        Returns
        -------
        int

        """
        return _Interface.Interface_GeneralModule_CategoryNumber(self, *args)


    def CheckCase(self, *args) -> "void":
        """
        Specific checking of an entity <ent> can check context queried through a sharetool, as required.

        Parameters
        ----------
        CN: int
        ent: Standard_Transient
        shares: Interface_ShareTool
        ach: Interface_Check

        Returns
        -------
        None

        """
        return _Interface.Interface_GeneralModule_CheckCase(self, *args)


    def CopyCase(self, *args) -> "void":
        """
        Specific copy ('deep') from <entfrom> to <entto> (same type) by using a copytool which provides its working map. use method transferred from copytool to work.

        Parameters
        ----------
        CN: int
        entfrom: Standard_Transient
        entto: Standard_Transient
        TC: Interface_CopyTool

        Returns
        -------
        None

        """
        return _Interface.Interface_GeneralModule_CopyCase(self, *args)


    def Dispatch(self, *args) -> "Standard_Boolean":
        """
        Dispatches an entity returns true if it works by copy, false if it just duplicates the starting handle //! dispatching means producing a new entity, image of the starting one, in order to be put into a new model, this model being itself the result of a dispatch from an original model //! according to the cases, dispatch can either * just return <entto> as equating <entfrom> -> the new model designates the starting entity : it is lighter, but the dispatched entity being shared might not be modified for dispatch * copy <entfrom> to <entto> by calling newvoid+copycase (two steps) or newcopiedcase (1) -> the dispatched entity is a copy, hence it can be modified //! the provided default just duplicates the handle without copying, then returns false. can be redefined.

        Parameters
        ----------
        CN: int
        entfrom: Standard_Transient
        entto: Standard_Transient
        TC: Interface_CopyTool

        Returns
        -------
        bool

        """
        return _Interface.Interface_GeneralModule_Dispatch(self, *args)


    def FillShared(self, *args) -> "void":
        """
        Specific filling of the list of entities shared by an entity <ent>, according a case number <cn> (formerly computed by casenum), considered in the context of a model <model> default calls fillsharedcase (i.e., ignores the model) can be redefined to use the model for working.

        Parameters
        ----------
        model: Interface_InterfaceModel
        CN: int
        ent: Standard_Transient
        iter: Interface_EntityIterator

        Returns
        -------
        None

        """
        return _Interface.Interface_GeneralModule_FillShared(self, *args)


    def FillSharedCase(self, *args) -> "void":
        """
        Specific filling of the list of entities shared by an entity <ent>, according a case number <cn> (formerly computed by casenum). can use the internal utility method share, below.

        Parameters
        ----------
        CN: int
        ent: Standard_Transient
        iter: Interface_EntityIterator

        Returns
        -------
        None

        """
        return _Interface.Interface_GeneralModule_FillSharedCase(self, *args)


    def ListImplied(self, *args) -> "void":
        """
        List the implied references of <ent> considered in the context of a model <model> : i.e. the entities which are referenced while not considered as shared (not copied if <ent> is, references not renewed by copycase but by impliedcase, only if referenced entities have been copied too) fillshared + listimplied give the complete list of references default calls listimpliedcase (i.e. ignores the model) can be redefined to use the model for working.

        Parameters
        ----------
        model: Interface_InterfaceModel
        CN: int
        ent: Standard_Transient
        iter: Interface_EntityIterator

        Returns
        -------
        None

        """
        return _Interface.Interface_GeneralModule_ListImplied(self, *args)


    def ListImpliedCase(self, *args) -> "void":
        """
        List the implied references of <ent> (see above) are referenced while not considered as shared (not copied if <ent> is, references not renewed by copycase but by impliedcase, only if referenced entities have been copied too) fillsharedcase + listimpliedcase give the complete list of referenced entities the provided default method does nothing (implied references are specific of a little amount of entity classes).

        Parameters
        ----------
        CN: int
        ent: Standard_Transient
        iter: Interface_EntityIterator

        Returns
        -------
        None

        """
        return _Interface.Interface_GeneralModule_ListImpliedCase(self, *args)


    def Name(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Determines if an entity brings a name (or widerly, if a name can be attached to it, through the sharetool by default, returns a null handle (no name can be produced) can be redefined //! warning : while this string may be edited on the spot, if it is a read field, the returned value must be copied before.

        Parameters
        ----------
        CN: int
        ent: Standard_Transient
        shares: Interface_ShareTool

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _Interface.Interface_GeneralModule_Name(self, *args)


    def NewCopiedCase(self, *args) -> "Standard_Boolean":
        """
        Specific operator (create+copy) defaulted to do nothing. it can be redefined : when it is not possible to work in two steps (newvoid then copycase). this can occur when there is no default constructor : hence the result <entto> must be created with an effective definition. remark : if newcopiedcase is defined, copycase has nothing to do returns true if it has produced something, false else.

        Parameters
        ----------
        CN: int
        entfrom: Standard_Transient
        entto: Standard_Transient
        TC: Interface_CopyTool

        Returns
        -------
        bool

        """
        return _Interface.Interface_GeneralModule_NewCopiedCase(self, *args)


    def NewVoid(self, *args) -> "Standard_Boolean":
        """
        Creates a new void entity <entto> according to a case number this entity remains to be filled, by reading from a file or by copying from another entity of same type (see copycase).

        Parameters
        ----------
        CN: int
        entto: Standard_Transient

        Returns
        -------
        bool

        """
        return _Interface.Interface_GeneralModule_NewVoid(self, *args)


    def RenewImpliedCase(self, *args) -> "void":
        """
        Specific copying of implied references a default is provided which does nothing (must current case !) already copied references (by copyfrom) must remain unchanged use method search from copytool to work.

        Parameters
        ----------
        CN: int
        entfrom: Standard_Transient
        entto: Standard_Transient
        TC: Interface_CopyTool

        Returns
        -------
        None

        """
        return _Interface.Interface_GeneralModule_RenewImpliedCase(self, *args)


    def Share(self, *args) -> "void":
        """
        Adds an entity to a shared list (uses getoneitem on <iter>).

        Parameters
        ----------
        iter: Interface_EntityIterator
        shared: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_GeneralModule_Share(self, *args)


    def WhenDeleteCase(self, *args) -> "void":
        """
        Prepares an entity to be deleted. what does it mean : basically, any class of entity may define its own destructor by default, it does nothing but calling destructors on fields with the memory manager, it is useless to call destructor, it is done automatically when the handle is nullified(cleared) but this is ineffective in looping structures (whatever these are 'implied' references or not). //! thus : if no loop may appear in definitions, a class which inherits from tshared is correctly managed by automatic way but if there can be loops (or simply back pointers), they must be broken, for instance by clearing fields of one of the nodes the default does nothing, to be redefined if a loop can occur (implied generally requires whendelete, but other cases can occur) //! warning : <dispatched> tells if the entity to be deleted has been produced by dispatch or not. hence whendelete must be in coherence with dispatch dispatch can either copy or not. if it copies the entity, this one should be deleted if it doesnt (i.e. duplicates the handle) nothing to do //! if <dispatch> is false, normal deletion is to be performed.

        Parameters
        ----------
        CN: int
        ent: Standard_Transient
        dispatched: bool

        Returns
        -------
        None

        """
        return _Interface.Interface_GeneralModule_WhenDeleteCase(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_GeneralModule_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_GeneralModule
    __del__ = lambda self: None
Interface_GeneralModule_swigregister = _Interface.Interface_GeneralModule_swigregister
Interface_GeneralModule_swigregister(Interface_GeneralModule)

class Interface_GlobalNodeOfGeneralLib(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_GlobalNodeOfGeneralLib, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_GlobalNodeOfGeneralLib, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an empty globalnode, with no next.

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_GlobalNodeOfGeneralLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args) -> "void":
        """
        Adds a module bound with a protocol to the list : does nothing if already in the list, that is, same type (exact match) and same state (that is, isequal is not required) once added, stores its attached protocol in correspondance.

        Parameters
        ----------
        amodule: Interface_GeneralModule
        aprotocol: Interface_Protocol

        Returns
        -------
        None

        """
        return _Interface.Interface_GlobalNodeOfGeneralLib_Add(self, *args)


    def Module(self, *args) -> "opencascade::handle< Interface_GeneralModule > const &":
        """
        Returns the module stored in a given globalnode.

        Returns
        -------
        opencascade::handle<Interface_GeneralModule>

        """
        return _Interface.Interface_GlobalNodeOfGeneralLib_Module(self, *args)


    def Next(self, *args) -> "opencascade::handle< Interface_GlobalNodeOfGeneralLib > const &":
        """
        Returns the next globalnode. if none is defined, returned value is a null handle.

        Returns
        -------
        opencascade::handle<Interface_GlobalNodeOfGeneralLib>

        """
        return _Interface.Interface_GlobalNodeOfGeneralLib_Next(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol > const &":
        """
        Returns the attached protocol stored in a given globalnode.

        Returns
        -------
        opencascade::handle<Interface_Protocol>

        """
        return _Interface.Interface_GlobalNodeOfGeneralLib_Protocol(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_GlobalNodeOfGeneralLib_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_GlobalNodeOfGeneralLib
    __del__ = lambda self: None
Interface_GlobalNodeOfGeneralLib_swigregister = _Interface.Interface_GlobalNodeOfGeneralLib_swigregister
Interface_GlobalNodeOfGeneralLib_swigregister(Interface_GlobalNodeOfGeneralLib)

class Interface_GlobalNodeOfReaderLib(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_GlobalNodeOfReaderLib, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_GlobalNodeOfReaderLib, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an empty globalnode, with no next.

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_GlobalNodeOfReaderLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args) -> "void":
        """
        Adds a module bound with a protocol to the list : does nothing if already in the list, that is, same type (exact match) and same state (that is, isequal is not required) once added, stores its attached protocol in correspondance.

        Parameters
        ----------
        amodule: Interface_ReaderModule
        aprotocol: Interface_Protocol

        Returns
        -------
        None

        """
        return _Interface.Interface_GlobalNodeOfReaderLib_Add(self, *args)


    def Module(self, *args) -> "opencascade::handle< Interface_ReaderModule > const &":
        """
        Returns the module stored in a given globalnode.

        Returns
        -------
        opencascade::handle<Interface_ReaderModule>

        """
        return _Interface.Interface_GlobalNodeOfReaderLib_Module(self, *args)


    def Next(self, *args) -> "opencascade::handle< Interface_GlobalNodeOfReaderLib > const &":
        """
        Returns the next globalnode. if none is defined, returned value is a null handle.

        Returns
        -------
        opencascade::handle<Interface_GlobalNodeOfReaderLib>

        """
        return _Interface.Interface_GlobalNodeOfReaderLib_Next(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol > const &":
        """
        Returns the attached protocol stored in a given globalnode.

        Returns
        -------
        opencascade::handle<Interface_Protocol>

        """
        return _Interface.Interface_GlobalNodeOfReaderLib_Protocol(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_GlobalNodeOfReaderLib_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_GlobalNodeOfReaderLib
    __del__ = lambda self: None
Interface_GlobalNodeOfReaderLib_swigregister = _Interface.Interface_GlobalNodeOfReaderLib_swigregister
Interface_GlobalNodeOfReaderLib_swigregister(Interface_GlobalNodeOfReaderLib)

class Interface_Graph(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_Graph, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_Graph, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an empty graph, ready to receive entities from amodel note that this way of creation allows <self> to verify that entities to work with are contained in <amodel> basic shared and sharing lists are obtained from a general services library, given directly as an argument.

        Parameters
        ----------
        amodel: Interface_InterfaceModel
        lib: Interface_GeneralLib
        theModeStats: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        Same as above, but the library is defined through a protocol.

        Parameters
        ----------
        amodel: Interface_InterfaceModel
        protocol: Interface_Protocol
        theModeStats: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        Same as above, but the library is defined through a protocol.

        Parameters
        ----------
        amodel: Interface_InterfaceModel
        gtool: Interface_GTool
        theModeStats: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        Same a above but works with the protocol recorded in the model.

        Parameters
        ----------
        amodel: Interface_InterfaceModel
        theModeStats: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        Creates a graph from another one, getting all its data remark that status are copied from <agraph>, but the other lists (sharing/shared) are copied only if <copied> = true.

        Parameters
        ----------
        agraph: Interface_Graph
        copied: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_Graph(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def BitMap(self, *args) -> "Interface_BitMap const &":
        """
        Returns the bit map in order to read or edit flag values.

        Returns
        -------
        Interface_BitMap

        """
        return _Interface.Interface_Graph_BitMap(self, *args)


    def CBitMap(self, *args) -> "Interface_BitMap &":
        """
        Returns the bit map in order to edit it (add new flags).

        Returns
        -------
        Interface_BitMap

        """
        return _Interface.Interface_Graph_CBitMap(self, *args)


    def ChangeStatus(self, *args) -> "void":
        """
        Changes all status which value is oldstat to new value newstat.

        Parameters
        ----------
        oldstat: int
        newstat: int

        Returns
        -------
        None

        """
        return _Interface.Interface_Graph_ChangeStatus(self, *args)


    def Entity(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        Returns mapped entity given its no (if it is present).

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _Interface.Interface_Graph_Entity(self, *args)


    def EntityNumber(self, *args) -> "Standard_Integer":
        """
        Returns the number of the entity in the map, computed at creation time (entities loaded from the model) returns 0 if <ent> not contained by model used to create <self> (that is, <ent> is unknown from <self>).

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        int

        """
        return _Interface.Interface_Graph_EntityNumber(self, *args)


    def GetFromEntity(self, *args) -> "void":
        """
        Gets an entity, plus its shared ones (at every level) if 'shared' is true. new items are set to status 'newstat' items already present in graph remain unchanged of course, redefinitions of shared lists are taken into account if there are some.

        Parameters
        ----------
        ent: Standard_Transient
        shared: bool
        newstat: int,optional
        	default value is 0

        Returns
        -------
        None

        Gets an entity, plus its shared ones (at every level) if 'shared' is true. new items are set to status 'newstat'. items already present in graph are processed as follows : - if they already have status 'newstat', they remain unchanged - if they have another status, this one is modified : if cumul is true, to former status + overlapstat (cumul) if cumul is false, to overlapstat (enforce).

        Parameters
        ----------
        ent: Standard_Transient
        shared: bool
        newstat: int
        overlapstat: int
        cumul: bool

        Returns
        -------
        None

        """
        return _Interface.Interface_Graph_GetFromEntity(self, *args)


    def GetFromGraph(self, *args) -> "void":
        """
        Gets all present items from another graph.

        Parameters
        ----------
        agraph: Interface_Graph

        Returns
        -------
        None

        Gets items from another graph which have a specific status.

        Parameters
        ----------
        agraph: Interface_Graph
        stat: int

        Returns
        -------
        None

        """
        return _Interface.Interface_Graph_GetFromGraph(self, *args)


    def GetFromIter(self, *args) -> "void":
        """
        Gets entities given by an entityiterator. entities which were not yet present in the graph are mapped with status 'newstat' entities already present remain unchanged.

        Parameters
        ----------
        iter: Interface_EntityIterator
        newstat: int

        Returns
        -------
        None

        Gets entities given by an entityiterator and distinguishes those already present in the graph : - new entities added to the graph with status 'newstst' - entities already present with status = 'newstat' remain unchanged - entities already present with status different form 'newstat' have their status modified : if cumul is true, to former status + overlapstat (cumul) if cumul is false, to overlapstat (enforce) (note : works as getentity, shared = false, for each entity).

        Parameters
        ----------
        iter: Interface_EntityIterator
        newstat: int
        overlapstat: int
        cumul: bool

        Returns
        -------
        None

        """
        return _Interface.Interface_Graph_GetFromIter(self, *args)


    def GetFromModel(self, *args) -> "void":
        """
        Loads graph with all entities contained in the model.

        Returns
        -------
        None

        """
        return _Interface.Interface_Graph_GetFromModel(self, *args)


    def GetShareds(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        Returns the sequence of entities shared by an entity.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfTransient>

        """
        return _Interface.Interface_Graph_GetShareds(self, *args)


    def GetSharings(self, *args) -> "opencascade::handle< TColStd_HSequenceOfTransient >":
        """
        Returns the sequence of entities sharings by an entity.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfTransient>

        """
        return _Interface.Interface_Graph_GetSharings(self, *args)


    def HasShareErrors(self, *args) -> "Standard_Boolean":
        """
        Returns true if <ent> or the list of entities shared by <ent> (not redefined) contains items unknown from this graph remark : apart from the status hasshareerror, these items are ignored.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        bool

        """
        return _Interface.Interface_Graph_HasShareErrors(self, *args)


    def IsPresent(self, *args) -> "Standard_Boolean":
        """
        Returns true if an entity is noted as present in the graph (see methods get... which determine this status) returns false if <num> is out of range too.

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        Same as above but directly on an entity <ent> : if it is not contained in the model, returns false. else calls ispresent(num) with <num> given by entitynumber.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        bool

        """
        return _Interface.Interface_Graph_IsPresent(self, *args)


    def ModeStat(self, *args) -> "Standard_Boolean":
        """
        Returns mode resposible for computation of statuses;.

        Returns
        -------
        bool

        """
        return _Interface.Interface_Graph_ModeStat(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel > const &":
        """
        Returns the model with which this graph was created.

        Returns
        -------
        opencascade::handle<Interface_InterfaceModel>

        """
        return _Interface.Interface_Graph_Model(self, *args)


    def Name(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Determines the name attached to an entity, by using the general service name in generalmodule returns a null handle if no name could be computed or if the entity is not in the model.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _Interface.Interface_Graph_Name(self, *args)


    def NbStatuses(self, *args) -> "Standard_Integer":
        """
        Returns size of array of statuses.

        Returns
        -------
        int

        """
        return _Interface.Interface_Graph_NbStatuses(self, *args)


    def RemoveItem(self, *args) -> "void":
        """
        Clears entity and sets status to 0, for a numero.

        Parameters
        ----------
        num: int

        Returns
        -------
        None

        """
        return _Interface.Interface_Graph_RemoveItem(self, *args)


    def RemoveStatus(self, *args) -> "void":
        """
        Removes all items of which status has a given value stat.

        Parameters
        ----------
        stat: int

        Returns
        -------
        None

        """
        return _Interface.Interface_Graph_RemoveStatus(self, *args)


    def Reset(self, *args) -> "void":
        """
        Erases data, making graph ready to rebegin from void (also resets shared lists redefinitions).

        Returns
        -------
        None

        """
        return _Interface.Interface_Graph_Reset(self, *args)


    def ResetStatus(self, *args) -> "void":
        """
        Erases status (values and flags of presence), making graph ready to rebegin from void. does not concerns shared lists.

        Returns
        -------
        None

        """
        return _Interface.Interface_Graph_ResetStatus(self, *args)


    def RootEntities(self, *args) -> "Interface_EntityIterator":
        """
        Returns the entities which are not shared (their sharing list is empty) in the model.

        Returns
        -------
        Interface_EntityIterator

        """
        return _Interface.Interface_Graph_RootEntities(self, *args)


    def SetStatus(self, *args) -> "void":
        """
        Modifies status associated to a numero.

        Parameters
        ----------
        num: int
        stat: int

        Returns
        -------
        None

        """
        return _Interface.Interface_Graph_SetStatus(self, *args)


    def Shareds(self, *args) -> "Interface_EntityIterator":
        """
        Returns the list of entities shared by an entity, as recorded by the graph. that is, by default basic shared list, else it can be redefined by methods setshare, setnoshare ... see below.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        Interface_EntityIterator

        """
        return _Interface.Interface_Graph_Shareds(self, *args)


    def SharingTable(self, *args) -> "opencascade::handle< TColStd_HArray1OfListOfInteger > const &":
        """
        Returns the table of sharing lists. used to create another graph from <self>.

        Returns
        -------
        opencascade::handle<TColStd_HArray1OfListOfInteger>

        """
        return _Interface.Interface_Graph_SharingTable(self, *args)


    def Sharings(self, *args) -> "Interface_EntityIterator":
        """
        Returns the list of entities which share an entity, computed from the basic or redefined shared lists.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        Interface_EntityIterator

        """
        return _Interface.Interface_Graph_Sharings(self, *args)


    def Size(self, *args) -> "Standard_Integer":
        """
        Returns size (max nb of entities, i.e. model's nb of entities).

        Returns
        -------
        int

        """
        return _Interface.Interface_Graph_Size(self, *args)


    def Status(self, *args) -> "Standard_Integer":
        """
        Returns status associated to a numero (only to read it).

        Parameters
        ----------
        num: int

        Returns
        -------
        int

        """
        return _Interface.Interface_Graph_Status(self, *args)


    def TypedSharings(self, *args) -> "Interface_EntityIterator":
        """
        Returns the list of sharings entities, at any level, which are kind of a given type. a sharing entity kind of this type ends the exploration of its branch.

        Parameters
        ----------
        ent: Standard_Transient
        type: Standard_Type

        Returns
        -------
        Interface_EntityIterator

        """
        return _Interface.Interface_Graph_TypedSharings(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_Graph
    __del__ = lambda self: None
Interface_Graph_swigregister = _Interface.Interface_Graph_swigregister
Interface_Graph_swigregister(Interface_Graph)

class Interface_HGraph(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_HGraph, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_HGraph, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an hgraph directly from a graph. remark that the starting graph is duplicated.

        Parameters
        ----------
        agraph: Interface_Graph

        Returns
        -------
        None

        Creates an hgraph with a graph created from <amodel> and <lib>.

        Parameters
        ----------
        amodel: Interface_InterfaceModel
        lib: Interface_GeneralLib
        theModeStats: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        Creates an hgraph with a graph itself created from <amodel> and <protocol>.

        Parameters
        ----------
        amodel: Interface_InterfaceModel
        protocol: Interface_Protocol
        theModeStats: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        Creates an hgraph with a graph itself created from <amodel> and <protocol>.

        Parameters
        ----------
        amodel: Interface_InterfaceModel
        gtool: Interface_GTool
        theModeStats: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        Same a above, but works with the gtool in the model.

        Parameters
        ----------
        amodel: Interface_InterfaceModel
        theModeStats: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_HGraph(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CGraph(self, *args) -> "Interface_Graph &":
        """
        Same as above, but for read-write operations then, the graph will be modified in the hgraph itself.

        Returns
        -------
        Interface_Graph

        """
        return _Interface.Interface_HGraph_CGraph(self, *args)


    def Graph(self, *args) -> "Interface_Graph const &":
        """
        Returns the graph contained in <self>, for read only operations remark that it is returns as 'const &' getting it in a new variable instead of a reference would be a pitty, because all the graph's content would be duplicated.

        Returns
        -------
        Interface_Graph

        """
        return _Interface.Interface_HGraph_Graph(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_HGraph_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_HGraph
    __del__ = lambda self: None
Interface_HGraph_swigregister = _Interface.Interface_HGraph_swigregister
Interface_HGraph_swigregister(Interface_HGraph)

class Interface_IntList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_IntList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_IntList, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates empty intlist.

        Returns
        -------
        None

        Creates an intlist for <nbe> entities.

        Parameters
        ----------
        nbe: int

        Returns
        -------
        None

        Creates an intlist from another one. if <copied> is true, copies data else, data are not copied, only the header object is.

        Parameters
        ----------
        other: Interface_IntList
        copied: bool

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_IntList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args) -> "void":
        """
        Adds a reference (as an integer value, an entity number) to the current entity number. zero is ignored.

        Parameters
        ----------
        ref: int

        Returns
        -------
        None

        """
        return _Interface.Interface_IntList_Add(self, *args)


    def AdjustSize(self, *args) -> "void":
        """
        Resizes lists to exact sizes. for list of refs, a positive margin can be added.

        Parameters
        ----------
        margin: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        return _Interface.Interface_IntList_AdjustSize(self, *args)


    def Clear(self, *args) -> "void":
        """
        Clears all data, hence each entity number has an empty list.

        Returns
        -------
        None

        """
        return _Interface.Interface_IntList_Clear(self, *args)


    def Initialize(self, *args) -> "void":
        """
        Initialize intlist by number of entities.

        Parameters
        ----------
        nbe: int

        Returns
        -------
        None

        """
        return _Interface.Interface_IntList_Initialize(self, *args)


    def Internals(self, *args) -> "void":
        """
        Returns internal values, used for copying.

        Parameters
        ----------
        ents: TColStd_HArray1OfInteger
        refs: TColStd_HArray1OfInteger

        Returns
        -------
        nbrefs: int

        """
        return _Interface.Interface_IntList_Internals(self, *args)


    def IsRedefined(self, *args) -> "Standard_Boolean":
        """
        Returns true if the list for a number (default is taken as current) is 'redefined' (usefull for empty list).

        Parameters
        ----------
        num: int,optional
        	default value is 0

        Returns
        -------
        bool

        """
        return _Interface.Interface_IntList_IsRedefined(self, *args)


    def Length(self, *args) -> "Standard_Integer":
        """
        Returns the count of refs attached to current entity number.

        Returns
        -------
        int

        """
        return _Interface.Interface_IntList_Length(self, *args)


    def List(self, *args) -> "Interface_IntList":
        """
        Returns an intlist, identical to <self> but set to a specified entity number by default, not copied (in order to be read) specified <copied> to produce another list and edit it.

        Parameters
        ----------
        number: int
        copied: bool,optional
        	default value is Standard_False

        Returns
        -------
        Interface_IntList

        """
        return _Interface.Interface_IntList_List(self, *args)


    def NbEntities(self, *args) -> "Standard_Integer":
        """
        Returns count of entities to be aknowledged.

        Returns
        -------
        int

        """
        return _Interface.Interface_IntList_NbEntities(self, *args)


    def Number(self, *args) -> "Standard_Integer":
        """
        Returns the current entity number.

        Returns
        -------
        int

        """
        return _Interface.Interface_IntList_Number(self, *args)


    def Remove(self, *args) -> "Standard_Boolean":
        """
        Removes an item in the list for current number, given its rank returns true if done, false else.

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _Interface.Interface_IntList_Remove(self, *args)


    def Reservate(self, *args) -> "void":
        """
        Makes a reservation for <count> references to be later attached to the current entity. if required, it increases the size of array used to store refs. remark that if count is less than two, it does nothing (because immediate storing).

        Parameters
        ----------
        count: int

        Returns
        -------
        None

        """
        return _Interface.Interface_IntList_Reservate(self, *args)


    def SetNbEntities(self, *args) -> "void":
        """
        Changes the count of entities (ignored if decreased).

        Parameters
        ----------
        nbe: int

        Returns
        -------
        None

        """
        return _Interface.Interface_IntList_SetNbEntities(self, *args)


    def SetNumber(self, *args) -> "void":
        """
        Sets an entity number as current (for read and fill).

        Parameters
        ----------
        number: int

        Returns
        -------
        None

        """
        return _Interface.Interface_IntList_SetNumber(self, *args)


    def SetRedefined(self, *args) -> "void":
        """
        Sets current entity list to be redefined or not this is used in a graph for redefinition list : it can be disable (no redefinition, i.e. list is cleared), or enabled (starts as empty). the original list has not to be 'redefined'.

        Parameters
        ----------
        mode: bool

        Returns
        -------
        None

        """
        return _Interface.Interface_IntList_SetRedefined(self, *args)


    def Value(self, *args) -> "Standard_Integer":
        """
        Returns a reference number in the list for current number, according to its rank.

        Parameters
        ----------
        num: int

        Returns
        -------
        int

        """
        return _Interface.Interface_IntList_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_IntList
    __del__ = lambda self: None
Interface_IntList_swigregister = _Interface.Interface_IntList_swigregister
Interface_IntList_swigregister(Interface_IntList)

class Interface_IntVal(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_IntVal, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_IntVal, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_IntVal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetCValue(self) -> "Standard_Integer":
        """GetCValue(Interface_IntVal self) -> Standard_Integer"""
        return _Interface.Interface_IntVal_GetCValue(self)


    def SetCValue(self, value: 'Standard_Integer') -> "void":
        """SetCValue(Interface_IntVal self, Standard_Integer value)"""
        return _Interface.Interface_IntVal_SetCValue(self, value)


    def Value(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _Interface.Interface_IntVal_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_IntVal_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_IntVal
    __del__ = lambda self: None
Interface_IntVal_swigregister = _Interface.Interface_IntVal_swigregister
Interface_IntVal_swigregister(Interface_IntVal)

class Interface_InterfaceModel(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_InterfaceModel, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_InterfaceModel, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AddEntity(self, *args) -> "void":
        """
        Internal method for adding an entity. used by file reading (defined by each interface) and transfer tools. it adds the entity required to be added, not its refs : see addwithrefs. if <anentity> is a reportentity, it is added to the list of reports, its concerned entity (erroneous or corrected, else unknown) is added to the list of entities. that is, the reportentity must be created before adding.

        Parameters
        ----------
        anentity: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_InterfaceModel_AddEntity(self, *args)


    def AddReportEntity(self, *args) -> "Standard_Boolean":
        """
        Adds a reportentity as such. returns false if the concerned entity is not recorded in the model else, adds it into, either the main report list or the list for semantic checks, then returns true.

        Parameters
        ----------
        rep: Interface_ReportEntity
        semantic: bool,optional
        	default value is Standard_False

        Returns
        -------
        bool

        """
        return _Interface.Interface_InterfaceModel_AddReportEntity(self, *args)


    def AddWithRefs(self, *args) -> "void":
        """
        Adds to the model, an entity with all its references, as they are defined by general services fillshared and listimplied. process is recursive (any sub-levels) if <level> = 0 (default) else, adds sub-entities until the required sub-level. especially, if <level> = 1, adds immediate subs and that's all //! if <listall> is false (default), an entity (<anentity> itself or one of its subs at any level) which is already recorded in the model is not analysed, only the newly added ones are. if <listall> is true, all items are analysed (this allows to ensure the consistency of an adding made by steps).

        Parameters
        ----------
        anent: Standard_Transient
        proto: Interface_Protocol
        level: int,optional
        	default value is 0
        listall: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        Same as above, but works with the protocol of the model.

        Parameters
        ----------
        anent: Standard_Transient
        level: int,optional
        	default value is 0
        listall: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        Same as above, but works with an already created generallib.

        Parameters
        ----------
        anent: Standard_Transient
        lib: Interface_GeneralLib
        level: int,optional
        	default value is 0
        listall: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        return _Interface.Interface_InterfaceModel_AddWithRefs(self, *args)


    def CategoryNumber(self, *args) -> "Standard_Integer":
        """
        Returns the recorded category number for a given entity number 0 if none was defined for this entity.

        Parameters
        ----------
        num: int

        Returns
        -------
        int

        """
        return _Interface.Interface_InterfaceModel_CategoryNumber(self, *args)


    def ChangeOrder(self, *args) -> "void":
        """
        Changes the numbers of some entities : <oldnum> is moved to <newnum>, same for <count> entities. thus : 1,2 ... newnum-1 newnum ... oldnum .. oldnum+count oldnum+count+1 .. gives 1,2 ... newnum-1 oldnum .. oldnum+count newnum ... oldnum+count+1 (can be seen as a circular permutation).

        Parameters
        ----------
        oldnum: int
        newnum: int
        count: int,optional
        	default value is 1

        Returns
        -------
        None

        """
        return _Interface.Interface_InterfaceModel_ChangeOrder(self, *args)


    def Check(self, *args) -> "opencascade::handle< Interface_Check > const &":
        """
        Returns the check attached to an entity, designated by its number. 0 for global check <semantic> true : recorded semantic check <semantic> false : recorded syntactic check (see reportentity) if no check is recorded for <num>, returns an empty check.

        Parameters
        ----------
        num: int
        syntactic: bool

        Returns
        -------
        opencascade::handle<Interface_Check>

        """
        return _Interface.Interface_InterfaceModel_Check(self, *args)


    def ClassName(*args) -> "char const *":
        """
        From a cdl type name, returns the class part (package dropped) warning : buffered, to be immediately copied or printed.

        Parameters
        ----------
        typnam: char *

        Returns
        -------
        char *

        """
        return _Interface.Interface_InterfaceModel_ClassName(*args)

    ClassName = staticmethod(ClassName)

    def Clear(self, *args) -> "void":
        """
        Erases contained data; used when a model is copied to others : the new copied ones begin from clear clear calls specific method clearheader (see below).

        Returns
        -------
        None

        """
        return _Interface.Interface_InterfaceModel_Clear(self, *args)


    def ClearEntities(self, *args) -> "void":
        """
        Clears the entities; uses the general service whendelete, in addition to the standard memory manager; can be redefined.

        Returns
        -------
        None

        """
        return _Interface.Interface_InterfaceModel_ClearEntities(self, *args)


    def ClearHeader(self, *args) -> "void":
        """
        Clears model's header : specific to each norm.

        Returns
        -------
        None

        """
        return _Interface.Interface_InterfaceModel_ClearHeader(self, *args)


    def ClearLabels(self, *args) -> "void":
        """
        Erases informations about labels, if any : specific to each norm.

        Returns
        -------
        None

        """
        return _Interface.Interface_InterfaceModel_ClearLabels(self, *args)


    def ClearReportEntity(self, *args) -> "Standard_Boolean":
        """
        Removes the reportentity attached to entity <num>. returns true if done, false if no reportentity was attached to <num>. warning : the caller must assume that this clearing is meaningfull.

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _Interface.Interface_InterfaceModel_ClearReportEntity(self, *args)


    def Contains(self, *args) -> "Standard_Boolean":
        """
        Returns true if a model contains an entity (for a reportentity, looks for the reportentity itself and its concerned entity).

        Parameters
        ----------
        anentity: Standard_Transient

        Returns
        -------
        bool

        """
        return _Interface.Interface_InterfaceModel_Contains(self, *args)


    def Destroy(self, *args) -> "void":
        """
        Clears the list of entities (service whendelete).

        Returns
        -------
        None

        """
        return _Interface.Interface_InterfaceModel_Destroy(self, *args)


    def GetDispatchStatus(self) -> "Standard_Boolean":
        """GetDispatchStatus(Interface_InterfaceModel self) -> Standard_Boolean"""
        return _Interface.Interface_InterfaceModel_GetDispatchStatus(self)


    def SetDispatchStatus(self, value: 'Standard_Boolean') -> "void":
        """SetDispatchStatus(Interface_InterfaceModel self, Standard_Boolean value)"""
        return _Interface.Interface_InterfaceModel_SetDispatchStatus(self, value)


    def Entities(self, *args) -> "Interface_EntityIterator":
        """
        Returns the list of all entities, as an iterator on entities (the entities themselves, not the reports).

        Returns
        -------
        Interface_EntityIterator

        """
        return _Interface.Interface_InterfaceModel_Entities(self, *args)


    def EntityState(self, *args) -> "Interface_DataState":
        """
        Returns the state of an entity, given its number.

        Parameters
        ----------
        num: int

        Returns
        -------
        Interface_DataState

        """
        return _Interface.Interface_InterfaceModel_EntityState(self, *args)


    def FillIterator(self, *args) -> "void":
        """
        Allows an entityiterator to get a list of entities.

        Parameters
        ----------
        iter: Interface_EntityIterator

        Returns
        -------
        None

        """
        return _Interface.Interface_InterfaceModel_FillIterator(self, *args)


    def FillSemanticChecks(self, *args) -> "void":
        """
        Fills the list of semantic checks. this list is computed (by checktool). hence, it can be stored in the model for later queries <clear> true (d) : new list replaces <clear> false : new list is cumulated.

        Parameters
        ----------
        checks: Interface_CheckIterator
        clear: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        """
        return _Interface.Interface_InterfaceModel_FillSemanticChecks(self, *args)


    def GTool(self, *args) -> "opencascade::handle< Interface_GTool >":
        """
        Returns the gtool, set by setprotocol or by setgtool.

        Returns
        -------
        opencascade::handle<Interface_GTool>

        """
        return _Interface.Interface_InterfaceModel_GTool(self, *args)


    def GetFromAnother(self, *args) -> "void":
        """
        Gets header (data specific of a defined interface) from another interfacemodel; called from transfercopy.

        Parameters
        ----------
        other: Interface_InterfaceModel

        Returns
        -------
        None

        """
        return _Interface.Interface_InterfaceModel_GetFromAnother(self, *args)


    def GetFromTransfer(self, *args) -> "void":
        """
        Gets contents from an entityiterator, prepared by a transfer tool (e.g transfercopy). starts from clear.

        Parameters
        ----------
        aniter: Interface_EntityIterator

        Returns
        -------
        None

        """
        return _Interface.Interface_InterfaceModel_GetFromTransfer(self, *args)


    def GlobalCheck(self, *args) -> "opencascade::handle< Interface_Check > const &":
        """
        Returns the globalcheck, which memorizes messages global to the file (not specific to an entity), especially header.

        Parameters
        ----------
        syntactic: bool,optional
        	default value is Standard_True

        Returns
        -------
        opencascade::handle<Interface_Check>

        """
        return _Interface.Interface_InterfaceModel_GlobalCheck(self, *args)


    def HasSemanticChecks(self, *args) -> "Standard_Boolean":
        """
        Returns true if semantic checks have been filled.

        Returns
        -------
        bool

        """
        return _Interface.Interface_InterfaceModel_HasSemanticChecks(self, *args)


    def HasTemplate(*args) -> "Standard_Boolean":
        """
        Returns true if a template is attached to a given name.

        Parameters
        ----------
        name: char *

        Returns
        -------
        bool

        """
        return _Interface.Interface_InterfaceModel_HasTemplate(*args)

    HasTemplate = staticmethod(HasTemplate)

    def IsErrorEntity(self, *args) -> "Standard_Boolean":
        """
        Returns true if <num> identifies an error entity : in this case, a reportentity brings fail messages and possibly an 'undefined' content, see isredefinedentity.

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _Interface.Interface_InterfaceModel_IsErrorEntity(self, *args)


    def IsRedefinedContent(self, *args) -> "Standard_Boolean":
        """
        Returns true if <num> identifies an entity which content is redefined through a reportentity (i.e. with literal data only) this happens when an entity is syntactically erroneous in the way that its basic content remains empty. for more details (such as content itself), see reportentity.

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _Interface.Interface_InterfaceModel_IsRedefinedContent(self, *args)


    def IsReportEntity(self, *args) -> "Standard_Boolean":
        """
        Returns true if <num> identifies a reportentity in the model hence, reportentity can be called. //! by default, queries main report, if <semantic> is true, it queries report for semantic check //! remember that a report entity can be defined for an unknown entity, or a corrected or erroneous (at read time) entity. the reportentity is defined before call to method addentity.

        Parameters
        ----------
        num: int
        semantic: bool,optional
        	default value is Standard_False

        Returns
        -------
        bool

        """
        return _Interface.Interface_InterfaceModel_IsReportEntity(self, *args)


    def IsUnknownEntity(self, *args) -> "Standard_Boolean":
        """
        Returns true if <num> identifies an unknown entity : in this case, a reportentity with no check messages designates it.

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _Interface.Interface_InterfaceModel_IsUnknownEntity(self, *args)


    def ListTemplates(*args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """
        Returns the complete list of names attached to template models.

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfHAsciiString>

        """
        return _Interface.Interface_InterfaceModel_ListTemplates(*args)

    ListTemplates = staticmethod(ListTemplates)

    def NbEntities(self, *args) -> "Standard_Integer":
        """
        Returns count of contained entities.

        Returns
        -------
        int

        """
        return _Interface.Interface_InterfaceModel_NbEntities(self, *args)


    def NbTypes(self, *args) -> "Standard_Integer":
        """
        Returns the count of distinct types under which an entity may be processed. defined by the protocol, which gives default as 1 (dynamic type).

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        int

        """
        return _Interface.Interface_InterfaceModel_NbTypes(self, *args)


    def NewEmptyModel(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        Returns a new empty model, same type as <self> (whatever its type); called to copy parts a model into other ones, then followed by a call to getfromanother (header) then filling with specified entities, themselves copied.

        Returns
        -------
        opencascade::handle<Interface_InterfaceModel>

        """
        return _Interface.Interface_InterfaceModel_NewEmptyModel(self, *args)


    def NextNumberForLabel(self, *args) -> "Standard_Integer":
        """
        Searches a label which matches with one entity. begins from <lastnum>+1 (default:1) and scans the entities until <nbentities>. for the first which matches <label>, this method returns its number. returns 0 if nothing found can be called recursively (labels are not specified as unique) <exact> : if true (default), exact match is required else, checks the end of entity label //! this method is virtual, hence it can be redefined for a more efficient search (if exact is true).

        Parameters
        ----------
        label: char *
        lastnum: int,optional
        	default value is 0
        exact: bool,optional
        	default value is Standard_True

        Returns
        -------
        int

        """
        return _Interface.Interface_InterfaceModel_NextNumberForLabel(self, *args)


    def Number(self, *args) -> "Standard_Integer":
        """
        Returns the number of an entity in the model if it contains it. else returns 0. for a reportentity, looks at concerned entity. returns the directory entry number of an entity in the model if it contains it. else returns 0. for a reportentity, looks at concerned entity.

        Parameters
        ----------
        anentity: Standard_Transient

        Returns
        -------
        int

        """
        return _Interface.Interface_InterfaceModel_Number(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol >":
        """
        Returns the protocol which has been set by setprotocol, or addwithrefs with protocol.

        Returns
        -------
        opencascade::handle<Interface_Protocol>

        """
        return _Interface.Interface_InterfaceModel_Protocol(self, *args)


    def Redefineds(self, *args) -> "Interface_EntityIterator":
        """
        Returns the list of reportentities which redefine data (generally, if concerned entity is 'error', a literal content is added to it : this is a 'redefined entity'.

        Returns
        -------
        Interface_EntityIterator

        """
        return _Interface.Interface_InterfaceModel_Redefineds(self, *args)


    def ReplaceEntity(self, *args) -> "void":
        """
        Replace entity with number=nument on other entity - 'anent'.

        Parameters
        ----------
        nument: int
        anent: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_InterfaceModel_ReplaceEntity(self, *args)


    def ReportEntity(self, *args) -> "opencascade::handle< Interface_ReportEntity >":
        """
        Returns a reportentity identified by its number in the model, or a null handle if <num> does not identify a reportentity. //! by default, queries main report, if <semantic> is true, it queries report for semantic check.

        Parameters
        ----------
        num: int
        semantic: bool,optional
        	default value is Standard_False

        Returns
        -------
        opencascade::handle<Interface_ReportEntity>

        """
        return _Interface.Interface_InterfaceModel_ReportEntity(self, *args)


    def Reports(self, *args) -> "Interface_EntityIterator":
        """
        Returns the list of all reportentities, i.e. data about entities read with error or warning informations (each item has to be casted to report entity then it can be queried for concerned entity, content, check ...) by default, returns the main reports, is <semantic> is true it returns the list for sematic checks.

        Parameters
        ----------
        semantic: bool,optional
        	default value is Standard_False

        Returns
        -------
        Interface_EntityIterator

        """
        return _Interface.Interface_InterfaceModel_Reports(self, *args)


    def Reservate(self, *args) -> "void":
        """
        Does a reservation for the list of entities (for optimized storage management). if it is not called, storage management can be less efficient. <nbent> is the expected count of entities to store.

        Parameters
        ----------
        nbent: int

        Returns
        -------
        None

        """
        return _Interface.Interface_InterfaceModel_Reservate(self, *args)


    def ReverseOrders(self, *args) -> "void":
        """
        Reverses the numbers of the entities, between <after> and the total count of entities. thus, the entities : 1,2 ... after, after+1 ... nb-1, nb become numbered as : 1,2 ... after, nb, nb-1 ... after+1 by default (after = 0) the whole list of entities is reversed.

        Parameters
        ----------
        after: int,optional
        	default value is 0

        Returns
        -------
        None

        """
        return _Interface.Interface_InterfaceModel_ReverseOrders(self, *args)


    def SetCategoryNumber(self, *args) -> "Standard_Boolean":
        """
        Records a category number for an entity number returns true when done, false if <num> is out of range.

        Parameters
        ----------
        num: int
        val: int

        Returns
        -------
        bool

        """
        return _Interface.Interface_InterfaceModel_SetCategoryNumber(self, *args)


    def SetGTool(self, *args) -> "void":
        """
        Sets a gtool for this model, which already defines a protocol.

        Parameters
        ----------
        gtool: Interface_GTool

        Returns
        -------
        None

        """
        return _Interface.Interface_InterfaceModel_SetGTool(self, *args)


    def SetGlobalCheck(self, *args) -> "void":
        """
        Allows to modify globalcheck, after getting then completing it remark : it is syntactic check. semantics, see fillchecks.

        Parameters
        ----------
        ach: Interface_Check

        Returns
        -------
        None

        """
        return _Interface.Interface_InterfaceModel_SetGlobalCheck(self, *args)


    def SetProtocol(self, *args) -> "void":
        """
        Sets a protocol for this model it is also set by a call to addwithrefs with protocol it is used for : dumpheader (as required), clearentities ...

        Parameters
        ----------
        proto: Interface_Protocol

        Returns
        -------
        None

        """
        return _Interface.Interface_InterfaceModel_SetProtocol(self, *args)


    def SetReportEntity(self, *args) -> "Standard_Boolean":
        """
        Sets or replaces a reportentity for the entity <num>. returns true if report is replaced, false if it has been replaced warning : the caller must assume that this setting is meaningfull.

        Parameters
        ----------
        num: int
        rep: Interface_ReportEntity

        Returns
        -------
        bool

        """
        return _Interface.Interface_InterfaceModel_SetReportEntity(self, *args)


    def SetTemplate(*args) -> "Standard_Boolean":
        """
        Records a new template model with a name. if the name was already recorded, the corresponding template is replaced by the new one. then, warning : test hastemplate to avoid surprises.

        Parameters
        ----------
        name: char *
        model: Interface_InterfaceModel

        Returns
        -------
        bool

        """
        return _Interface.Interface_InterfaceModel_SetTemplate(*args)

    SetTemplate = staticmethod(SetTemplate)

    def StringLabel(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Returns a string with the label attached to a given entity. warning : while this string may be edited on the spot, if it is a read field, the returned value must be copied before.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _Interface.Interface_InterfaceModel_StringLabel(self, *args)


    def Template(*args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        Returns the template model attached to a name, or a null handle.

        Parameters
        ----------
        name: char *

        Returns
        -------
        opencascade::handle<Interface_InterfaceModel>

        """
        return _Interface.Interface_InterfaceModel_Template(*args)

    Template = staticmethod(Template)

    def Type(self, *args) -> "opencascade::handle< Standard_Type >":
        """
        Returns a type, given its rank : defined by the protocol (by default, the first one).

        Parameters
        ----------
        ent: Standard_Transient
        num: int,optional
        	default value is 1

        Returns
        -------
        opencascade::handle<Standard_Type>

        """
        return _Interface.Interface_InterfaceModel_Type(self, *args)


    def TypeName(self, *args) -> "char const *":
        """
        Returns the type name of an entity, from the list of types (one or more ...) <complete> true (d) gives the complete type, else packages are removed warning : buffered, to be immediately copied or printed.

        Parameters
        ----------
        ent: Standard_Transient
        complete: bool,optional
        	default value is Standard_True

        Returns
        -------
        char *

        """
        return _Interface.Interface_InterfaceModel_TypeName(self, *args)


    def Value(self, *args) -> "opencascade::handle< Standard_Transient > const &":
        """
        Returns an entity identified by its number in the model each sub-class of interfacemodel can define its own method entity to return its specific class of entity (e.g. for vda, vdamodel returns a vdaentity), working by calling value remark : for a reported entity, (erroneous, corrected, unknown), this method returns this reported entity. see reportentity for other questions.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _Interface.Interface_InterfaceModel_Value(self, *args)


    def VerifyCheck(self, *args) -> "void":
        """
        Minimum semantic global check on data in model (header) can only check basic data. see also globalcheck from protocol for a check which takes the graph into account default does nothing, can be redefined.

        Parameters
        ----------
        ach: Interface_Check

        Returns
        -------
        None

        """
        return _Interface.Interface_InterfaceModel_VerifyCheck(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_InterfaceModel_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_InterfaceModel
    __del__ = lambda self: None
Interface_InterfaceModel_swigregister = _Interface.Interface_InterfaceModel_swigregister
Interface_InterfaceModel_swigregister(Interface_InterfaceModel)

def Interface_InterfaceModel_ClassName(*args) -> "char const *":
    """
    From a cdl type name, returns the class part (package dropped) warning : buffered, to be immediately copied or printed.

    Parameters
    ----------
    typnam: char *

    Returns
    -------
    char *

    """
    return _Interface.Interface_InterfaceModel_ClassName(*args)

def Interface_InterfaceModel_HasTemplate(*args) -> "Standard_Boolean":
    """
    Returns true if a template is attached to a given name.

    Parameters
    ----------
    name: char *

    Returns
    -------
    bool

    """
    return _Interface.Interface_InterfaceModel_HasTemplate(*args)

def Interface_InterfaceModel_ListTemplates(*args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
    """
    Returns the complete list of names attached to template models.

    Returns
    -------
    opencascade::handle<TColStd_HSequenceOfHAsciiString>

    """
    return _Interface.Interface_InterfaceModel_ListTemplates(*args)

def Interface_InterfaceModel_SetTemplate(*args) -> "Standard_Boolean":
    """
    Records a new template model with a name. if the name was already recorded, the corresponding template is replaced by the new one. then, warning : test hastemplate to avoid surprises.

    Parameters
    ----------
    name: char *
    model: Interface_InterfaceModel

    Returns
    -------
    bool

    """
    return _Interface.Interface_InterfaceModel_SetTemplate(*args)

def Interface_InterfaceModel_Template(*args) -> "opencascade::handle< Interface_InterfaceModel >":
    """
    Returns the template model attached to a name, or a null handle.

    Parameters
    ----------
    name: char *

    Returns
    -------
    opencascade::handle<Interface_InterfaceModel>

    """
    return _Interface.Interface_InterfaceModel_Template(*args)

class Interface_LineBuffer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_LineBuffer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_LineBuffer, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a linebuffer with an absolute maximum size (default value is only to satisfy compiler requirement).

        Parameters
        ----------
        size: int,optional
        	default value is 10

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_LineBuffer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args) -> "void":
        """
        Adds a text as a cstring. its length is evaluated from the text (by c function strlen).

        Parameters
        ----------
        text: char *

        Returns
        -------
        None

        Adds a text as a cstring. its length is given as <lntext>.

        Parameters
        ----------
        text: char *
        lntext: int

        Returns
        -------
        None

        Adds a text as a asciistring from tcollection.

        Parameters
        ----------
        text: TCollection_AsciiString

        Returns
        -------
        None

        Adds a text made of only one character.

        Parameters
        ----------
        text: Standard_Character

        Returns
        -------
        None

        """
        return _Interface.Interface_LineBuffer_Add(self, *args)


    def CanGet(self, *args) -> "Standard_Boolean":
        """
        Returns true if there is room enough to add <more> characters else, it is required to dump the buffer before refilling it <more> is recorded to manage setkeep status.

        Parameters
        ----------
        more: int

        Returns
        -------
        bool

        """
        return _Interface.Interface_LineBuffer_CanGet(self, *args)


    def Clear(self, *args) -> "void":
        """
        Clears completely the linebuffer.

        Returns
        -------
        None

        """
        return _Interface.Interface_LineBuffer_Clear(self, *args)


    def Content(self, *args) -> "char const *":
        """
        Returns the content of the linebuffer.

        Returns
        -------
        char *

        """
        return _Interface.Interface_LineBuffer_Content(self, *args)


    def FreezeInitial(self, *args) -> "void":
        """
        Inhibits effect of setinitial until the next move (i.e. keep) then prepare will not insert initial blanks, but further ones will. this allows to cancel initial blanks on an internal split a call to setinitial has no effect on this until move.

        Returns
        -------
        None

        """
        return _Interface.Interface_LineBuffer_FreezeInitial(self, *args)


    def Length(self, *args) -> "Standard_Integer":
        """
        Returns the length of the linebuffer.

        Returns
        -------
        int

        """
        return _Interface.Interface_LineBuffer_Length(self, *args)


    def Move(self, *args) -> "void":
        """
        Fills a asciistring <str> with the content of the line buffer, then clears the linebuffer.

        Parameters
        ----------
        str: TCollection_AsciiString

        Returns
        -------
        None

        Same as above, but <str> is known through a handle.

        Parameters
        ----------
        str: TCollection_HAsciiString

        Returns
        -------
        None

        """
        return _Interface.Interface_LineBuffer_Move(self, *args)


    def Moved(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Same as above, but generates the hasciistring.

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _Interface.Interface_LineBuffer_Moved(self, *args)


    def SetInitial(self, *args) -> "void":
        """
        Sets an initial reservation for blank characters (this reservation is counted in the size of the current line).

        Parameters
        ----------
        initial: int

        Returns
        -------
        None

        """
        return _Interface.Interface_LineBuffer_SetInitial(self, *args)


    def SetKeep(self, *args) -> "void":
        """
        Sets a keep status at current length. it means that at next move, the new line will begin by characters between keep + 1 and current length.

        Returns
        -------
        None

        """
        return _Interface.Interface_LineBuffer_SetKeep(self, *args)


    def SetMax(self, *args) -> "void":
        """
        Changes maximum allowed size of buffer. if <max> is zero, maximum size is set to the initial size.

        Parameters
        ----------
        max: int

        Returns
        -------
        None

        """
        return _Interface.Interface_LineBuffer_SetMax(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_LineBuffer
    __del__ = lambda self: None
Interface_LineBuffer_swigregister = _Interface.Interface_LineBuffer_swigregister
Interface_LineBuffer_swigregister(Interface_LineBuffer)

class Interface_MSG(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_MSG, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_MSG, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        A msg is created to write a 'functional code' in conjunction with operator () attached to value then, to have a translated message, write in c++ : //! interface_msg('...mykey...') which returns a cstring see also some help which follow.

        Parameters
        ----------
        key: char *

        Returns
        -------
        None

        Translates a message which contains one integer variable it is just a help which avoid the following : char mess[100]; sprintf(mess,interface_msg('code'),ival); then addfail(mess); replaced by addfail (interface_msg('code',ival)); //! the basic message is intended to be in c-sprintf format, with one %d form in it.

        Parameters
        ----------
        key: char *
        i1: int

        Returns
        -------
        None

        Translates a message which contains two integer variables as for one integer, it is just a writing help //! the basic message is intended to be in c-sprintf format with two %d forms in it.

        Parameters
        ----------
        key: char *
        i1: int
        i2: int

        Returns
        -------
        None

        Translates a message which contains one real variable <intervals> if set, commands the variable to be rounded to an interval (see below, method intervals) as for one integer, it is just a writing help //! the basic message is intended to be in c-sprintf format with one %f form (or equivalent : %e etc) in it.

        Parameters
        ----------
        key: char *
        r1: float
        intervals: int,optional
        	default value is -1

        Returns
        -------
        None

        Translates a message which contains one string variable as for one integer, it is just a writing help //! the basic message is intended to be in c-sprintf format with one %s form in it.

        Parameters
        ----------
        key: char *
        str: char *

        Returns
        -------
        None

        Translates a message which contains one integer and one string variables as for one integer, it is just a writing help used for instance to say 'param n0.<ival> i.e. <str> is not..' //! the basic message is intended to be in c-sprintf format with one %d then one %s forms in it.

        Parameters
        ----------
        key: char *
        ival: int
        str: char *

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_MSG(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Blanks(*args) -> "char const *":
        """
        Returns a blank string, of length between 0 and <max>, to fill the printing of a numeric value <val>, i.e. : if val < 10 , max-1 blanks if val between 10 and 99, max-2 blanks ... etc...

        Parameters
        ----------
        val: int
        max: int

        Returns
        -------
        char *

        Returns a blank string, to complete a given string <val> up to <max> characters : if strlen(val) is 0, max blanks if strlen(val) is 5, max-5 blanks etc...

        Parameters
        ----------
        val: char *
        max: int

        Returns
        -------
        char *

        Returns a blank string of <count> blanks (mini 0, maxi 76).

        Parameters
        ----------
        count: int

        Returns
        -------
        char *

        """
        return _Interface.Interface_MSG_Blanks(*args)

    Blanks = staticmethod(Blanks)

    def CDate(*args) -> "Standard_Integer":
        """
        Returns a value about comparison of two dates 0 : equal. <0 text1 anterior. >0 text1 posterior.

        Parameters
        ----------
        text1: char *
        text2: char *

        Returns
        -------
        int

        """
        return _Interface.Interface_MSG_CDate(*args)

    CDate = staticmethod(CDate)

    def Destroy(self, *args) -> "void":
        """
        Optimised destructor (applies for additional forms of create).

        Returns
        -------
        None

        """
        return _Interface.Interface_MSG_Destroy(self, *args)


    def Intervalled(*args) -> "Standard_Real":
        """
        Returns an 'intervalled' value from a starting real <val> : i.e. a value which is rounded on an interval limit interval limits are defined to be in a coarsely 'geometric' progression (two successive intervals are inside a limit ratio) //! <order> gives the count of desired intervals in a range <1-10> <upper> false, returns the first lower interval (d) <upper> true, returns the first upper interval values of intervals according <order> : 0,1 : 1 10 100 ... 2 : 1 3 10 30 100 ... 3(d): 1 2 5 10 20 50 100 ... 4 : 1 2 3 6 10 20 30 60 100 ... 6 : 1 1.5 2 3 5 7 10 15 20 ... 10 : 1 1.2 1.5 2 2.5 3 4 5 6 8 10 12 15 20 25 ...

        Parameters
        ----------
        val: float
        order: int,optional
        	default value is 3
        upper: bool,optional
        	default value is Standard_False

        Returns
        -------
        float

        """
        return _Interface.Interface_MSG_Intervalled(*args)

    Intervalled = staticmethod(Intervalled)

    def IsKey(*args) -> "Standard_Boolean":
        """
        Returns true if a given message is surely a key (according to the form adopted for keys) (before activating messages, answer is false).

        Parameters
        ----------
        mess: char *

        Returns
        -------
        bool

        """
        return _Interface.Interface_MSG_IsKey(*args)

    IsKey = staticmethod(IsKey)

    def NDate(*args) -> "Standard_Integer &, Standard_Integer &, Standard_Integer &, Standard_Integer &, Standard_Integer &, Standard_Integer &":
        """
        Decodes a date to numeric integer values returns true if ok, false if text does not fit with required format. incomplete forms are allowed (for instance, for only yyyy-mm-dd, hour is zero).

        Parameters
        ----------
        text: char *

        Returns
        -------
        yy: int
        mm: int
        dd: int
        hh: int
        mn: int
        ss: int

        """
        return _Interface.Interface_MSG_NDate(*args)

    NDate = staticmethod(NDate)

    def PrintTraceToString(self) -> "std::string":
        """PrintTraceToString(Interface_MSG self) -> std::string"""
        return _Interface.Interface_MSG_PrintTraceToString(self)


    def ReadFromString(self, src: 'std::string') -> "void":
        """ReadFromString(Interface_MSG self, std::string src)"""
        return _Interface.Interface_MSG_ReadFromString(self, src)


    def Read(*args) -> "Standard_Integer":
        """
        Reads a list of messages from a file defined by its name.

        Parameters
        ----------
        file: char *

        Returns
        -------
        int

        """
        return _Interface.Interface_MSG_Read(*args)

    Read = staticmethod(Read)

    def Record(*args) -> "void":
        """
        Fills the dictionary with a couple (key-item) if a key is already recorded, it is possible to : - keep the last definition, and activate the trace system.

        Parameters
        ----------
        key: char *
        item: char *

        Returns
        -------
        None

        """
        return _Interface.Interface_MSG_Record(*args)

    Record = staticmethod(Record)

    def SetMode(*args) -> "void":
        """
        Sets the main modes for msg : - if <running> is true, translation works normally - if <running> is false, translated item equate keys - if <raising> is true, errors (from record or translate) cause msg to raise an exception - if <raising> is false, msg runs without exception, then see also trace modes above.

        Parameters
        ----------
        running: bool
        raising: bool

        Returns
        -------
        None

        """
        return _Interface.Interface_MSG_SetMode(*args)

    SetMode = staticmethod(SetMode)

    def SetTrace(*args) -> "void":
        """
        Sets the trace system to work when activated, as follow : - if <toprint> is true, print immediately on standard output - if <torecord> is true, record it for further print.

        Parameters
        ----------
        toprint: bool
        torecord: bool

        Returns
        -------
        None

        """
        return _Interface.Interface_MSG_SetTrace(*args)

    SetTrace = staticmethod(SetTrace)

    def TDate(*args) -> "void":
        """
        Codes a date as a text, from its numeric value (-> seconds) : yyyy-mm-dd:hh-mn-ss fixed format, completed by leading zeros another format can be provided, as follows : c:%d ... c like format, preceeded by c: s:... format to call system (not yet implemented).

        Parameters
        ----------
        text: char *
        yy: int
        mm: int
        dd: int
        hh: int
        mn: int
        ss: int
        format: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _Interface.Interface_MSG_TDate(*args)

    TDate = staticmethod(TDate)

    def Translated(*args) -> "char const *":
        """
        Returns the item recorded for a key. returns the key itself if : - it is not recorded (then, the trace system is activated) - msg has been required to be hung on.

        Parameters
        ----------
        key: char *

        Returns
        -------
        char *

        """
        return _Interface.Interface_MSG_Translated(*args)

    Translated = staticmethod(Translated)

    def Value(self, *args) -> "char const *":
        """
        Returns the translated message, in a functional form with operator () was c++ : return const.

        Returns
        -------
        char *

        """
        return _Interface.Interface_MSG_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_MSG
    __del__ = lambda self: None
Interface_MSG_swigregister = _Interface.Interface_MSG_swigregister
Interface_MSG_swigregister(Interface_MSG)

def Interface_MSG_Blanks(*args) -> "char const *":
    """
    Returns a blank string, of length between 0 and <max>, to fill the printing of a numeric value <val>, i.e. : if val < 10 , max-1 blanks if val between 10 and 99, max-2 blanks ... etc...

    Parameters
    ----------
    val: int
    max: int

    Returns
    -------
    char *

    Returns a blank string, to complete a given string <val> up to <max> characters : if strlen(val) is 0, max blanks if strlen(val) is 5, max-5 blanks etc...

    Parameters
    ----------
    val: char *
    max: int

    Returns
    -------
    char *

    Returns a blank string of <count> blanks (mini 0, maxi 76).

    Parameters
    ----------
    count: int

    Returns
    -------
    char *

    """
    return _Interface.Interface_MSG_Blanks(*args)

def Interface_MSG_CDate(*args) -> "Standard_Integer":
    """
    Returns a value about comparison of two dates 0 : equal. <0 text1 anterior. >0 text1 posterior.

    Parameters
    ----------
    text1: char *
    text2: char *

    Returns
    -------
    int

    """
    return _Interface.Interface_MSG_CDate(*args)

def Interface_MSG_Intervalled(*args) -> "Standard_Real":
    """
    Returns an 'intervalled' value from a starting real <val> : i.e. a value which is rounded on an interval limit interval limits are defined to be in a coarsely 'geometric' progression (two successive intervals are inside a limit ratio) //! <order> gives the count of desired intervals in a range <1-10> <upper> false, returns the first lower interval (d) <upper> true, returns the first upper interval values of intervals according <order> : 0,1 : 1 10 100 ... 2 : 1 3 10 30 100 ... 3(d): 1 2 5 10 20 50 100 ... 4 : 1 2 3 6 10 20 30 60 100 ... 6 : 1 1.5 2 3 5 7 10 15 20 ... 10 : 1 1.2 1.5 2 2.5 3 4 5 6 8 10 12 15 20 25 ...

    Parameters
    ----------
    val: float
    order: int,optional
    	default value is 3
    upper: bool,optional
    	default value is Standard_False

    Returns
    -------
    float

    """
    return _Interface.Interface_MSG_Intervalled(*args)

def Interface_MSG_IsKey(*args) -> "Standard_Boolean":
    """
    Returns true if a given message is surely a key (according to the form adopted for keys) (before activating messages, answer is false).

    Parameters
    ----------
    mess: char *

    Returns
    -------
    bool

    """
    return _Interface.Interface_MSG_IsKey(*args)

def Interface_MSG_NDate(*args) -> "Standard_Integer &, Standard_Integer &, Standard_Integer &, Standard_Integer &, Standard_Integer &, Standard_Integer &":
    """
    Decodes a date to numeric integer values returns true if ok, false if text does not fit with required format. incomplete forms are allowed (for instance, for only yyyy-mm-dd, hour is zero).

    Parameters
    ----------
    text: char *

    Returns
    -------
    yy: int
    mm: int
    dd: int
    hh: int
    mn: int
    ss: int

    """
    return _Interface.Interface_MSG_NDate(*args)

def Interface_MSG_Read(*args) -> "Standard_Integer":
    """
    Reads a list of messages from a file defined by its name.

    Parameters
    ----------
    file: char *

    Returns
    -------
    int

    """
    return _Interface.Interface_MSG_Read(*args)

def Interface_MSG_Record(*args) -> "void":
    """
    Fills the dictionary with a couple (key-item) if a key is already recorded, it is possible to : - keep the last definition, and activate the trace system.

    Parameters
    ----------
    key: char *
    item: char *

    Returns
    -------
    None

    """
    return _Interface.Interface_MSG_Record(*args)

def Interface_MSG_SetMode(*args) -> "void":
    """
    Sets the main modes for msg : - if <running> is true, translation works normally - if <running> is false, translated item equate keys - if <raising> is true, errors (from record or translate) cause msg to raise an exception - if <raising> is false, msg runs without exception, then see also trace modes above.

    Parameters
    ----------
    running: bool
    raising: bool

    Returns
    -------
    None

    """
    return _Interface.Interface_MSG_SetMode(*args)

def Interface_MSG_SetTrace(*args) -> "void":
    """
    Sets the trace system to work when activated, as follow : - if <toprint> is true, print immediately on standard output - if <torecord> is true, record it for further print.

    Parameters
    ----------
    toprint: bool
    torecord: bool

    Returns
    -------
    None

    """
    return _Interface.Interface_MSG_SetTrace(*args)

def Interface_MSG_TDate(*args) -> "void":
    """
    Codes a date as a text, from its numeric value (-> seconds) : yyyy-mm-dd:hh-mn-ss fixed format, completed by leading zeros another format can be provided, as follows : c:%d ... c like format, preceeded by c: s:... format to call system (not yet implemented).

    Parameters
    ----------
    text: char *
    yy: int
    mm: int
    dd: int
    hh: int
    mn: int
    ss: int
    format: char *,optional
    	default value is 

    Returns
    -------
    None

    """
    return _Interface.Interface_MSG_TDate(*args)

def Interface_MSG_Translated(*args) -> "char const *":
    """
    Returns the item recorded for a key. returns the key itself if : - it is not recorded (then, the trace system is activated) - msg has been required to be hung on.

    Parameters
    ----------
    key: char *

    Returns
    -------
    char *

    """
    return _Interface.Interface_MSG_Translated(*args)

class Interface_MapAsciiStringHasher(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_MapAsciiStringHasher, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_MapAsciiStringHasher, name)
    __repr__ = _swig_repr

    def HashCode(*args) -> "Standard_Integer":
        """
        Computes a hash code for the given ascii string, in the range [1, theupperbound] @param theasciistring the ascii string which hash code is to be computed @param theupperbound the upper bound of the range a computing hash code must be within returns a computed hash code, in the range [1, theupperbound].

        Parameters
        ----------
        theAsciiString: TCollection_AsciiString
        theUpperBound: int

        Returns
        -------
        int

        """
        return _Interface.Interface_MapAsciiStringHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args) -> "Standard_Boolean":
        """
        No available documentation.

        Parameters
        ----------
        K1: TCollection_AsciiString
        K2: TCollection_AsciiString

        Returns
        -------
        bool

        """
        return _Interface.Interface_MapAsciiStringHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    __repr__ = _dumps_object


    def __init__(self):
        this = _Interface.new_Interface_MapAsciiStringHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Interface.delete_Interface_MapAsciiStringHasher
    __del__ = lambda self: None
Interface_MapAsciiStringHasher_swigregister = _Interface.Interface_MapAsciiStringHasher_swigregister
Interface_MapAsciiStringHasher_swigregister(Interface_MapAsciiStringHasher)

def Interface_MapAsciiStringHasher_HashCode(*args) -> "Standard_Integer":
    """
    Computes a hash code for the given ascii string, in the range [1, theupperbound] @param theasciistring the ascii string which hash code is to be computed @param theupperbound the upper bound of the range a computing hash code must be within returns a computed hash code, in the range [1, theupperbound].

    Parameters
    ----------
    theAsciiString: TCollection_AsciiString
    theUpperBound: int

    Returns
    -------
    int

    """
    return _Interface.Interface_MapAsciiStringHasher_HashCode(*args)

def Interface_MapAsciiStringHasher_IsEqual(*args) -> "Standard_Boolean":
    """
    No available documentation.

    Parameters
    ----------
    K1: TCollection_AsciiString
    K2: TCollection_AsciiString

    Returns
    -------
    bool

    """
    return _Interface.Interface_MapAsciiStringHasher_IsEqual(*args)

class Interface_NodeOfGeneralLib(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_NodeOfGeneralLib, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_NodeOfGeneralLib, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an empty node, with no next.

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_NodeOfGeneralLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddNode(self, *args) -> "void":
        """
        Adds a couple (module,protocol), that is, stores it into itself if not yet done, else creates a next node to do it.

        Parameters
        ----------
        anode: Interface_GlobalNodeOfGeneralLib

        Returns
        -------
        None

        """
        return _Interface.Interface_NodeOfGeneralLib_AddNode(self, *args)


    def Module(self, *args) -> "opencascade::handle< Interface_GeneralModule > const &":
        """
        Returns the module designated by a precise node.

        Returns
        -------
        opencascade::handle<Interface_GeneralModule>

        """
        return _Interface.Interface_NodeOfGeneralLib_Module(self, *args)


    def Next(self, *args) -> "opencascade::handle< Interface_NodeOfGeneralLib > const &":
        """
        Returns the next node. if none was defined, returned value is a null handle.

        Returns
        -------
        opencascade::handle<Interface_NodeOfGeneralLib>

        """
        return _Interface.Interface_NodeOfGeneralLib_Next(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol > const &":
        """
        Returns the protocol designated by a precise node.

        Returns
        -------
        opencascade::handle<Interface_Protocol>

        """
        return _Interface.Interface_NodeOfGeneralLib_Protocol(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_NodeOfGeneralLib_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_NodeOfGeneralLib
    __del__ = lambda self: None
Interface_NodeOfGeneralLib_swigregister = _Interface.Interface_NodeOfGeneralLib_swigregister
Interface_NodeOfGeneralLib_swigregister(Interface_NodeOfGeneralLib)

class Interface_NodeOfReaderLib(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_NodeOfReaderLib, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_NodeOfReaderLib, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an empty node, with no next.

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_NodeOfReaderLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddNode(self, *args) -> "void":
        """
        Adds a couple (module,protocol), that is, stores it into itself if not yet done, else creates a next node to do it.

        Parameters
        ----------
        anode: Interface_GlobalNodeOfReaderLib

        Returns
        -------
        None

        """
        return _Interface.Interface_NodeOfReaderLib_AddNode(self, *args)


    def Module(self, *args) -> "opencascade::handle< Interface_ReaderModule > const &":
        """
        Returns the module designated by a precise node.

        Returns
        -------
        opencascade::handle<Interface_ReaderModule>

        """
        return _Interface.Interface_NodeOfReaderLib_Module(self, *args)


    def Next(self, *args) -> "opencascade::handle< Interface_NodeOfReaderLib > const &":
        """
        Returns the next node. if none was defined, returned value is a null handle.

        Returns
        -------
        opencascade::handle<Interface_NodeOfReaderLib>

        """
        return _Interface.Interface_NodeOfReaderLib_Next(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol > const &":
        """
        Returns the protocol designated by a precise node.

        Returns
        -------
        opencascade::handle<Interface_Protocol>

        """
        return _Interface.Interface_NodeOfReaderLib_Protocol(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_NodeOfReaderLib_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_NodeOfReaderLib
    __del__ = lambda self: None
Interface_NodeOfReaderLib_swigregister = _Interface.Interface_NodeOfReaderLib_swigregister
Interface_NodeOfReaderLib_swigregister(Interface_NodeOfReaderLib)

class Interface_ParamList(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_ParamList, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_ParamList, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an vector with size of memmory blok equal to theincrement.

        Parameters
        ----------
        theIncrement: int,optional
        	default value is 256

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_ParamList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ChangeValue(self, *args) -> "Interface_FileParameter &":
        """
        Return the value of the <index>th element of the array.

        Parameters
        ----------
        Index: int

        Returns
        -------
        Interface_FileParameter

        """
        return _Interface.Interface_ParamList_ChangeValue(self, *args)


    def Clear(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _Interface.Interface_ParamList_Clear(self, *args)


    def Length(self, *args) -> "Standard_Integer":
        """
        Returns the number of elements of <self>.

        Returns
        -------
        int

        """
        return _Interface.Interface_ParamList_Length(self, *args)


    def Lower(self, *args) -> "Standard_Integer":
        """
        Returns the lower bound. warning.

        Returns
        -------
        int

        """
        return _Interface.Interface_ParamList_Lower(self, *args)


    def SetValue(self, *args) -> "void":
        """
        Assigns the value <value> to the <index>-th item of this array.

        Parameters
        ----------
        Index: int
        Value: Interface_FileParameter

        Returns
        -------
        None

        """
        return _Interface.Interface_ParamList_SetValue(self, *args)


    def Upper(self, *args) -> "Standard_Integer":
        """
        Returns the upper bound. warning.

        Returns
        -------
        int

        """
        return _Interface.Interface_ParamList_Upper(self, *args)


    def Value(self, *args) -> "Interface_FileParameter const &":
        """
        Return the value of the <index>th element of the array.

        Parameters
        ----------
        Index: int

        Returns
        -------
        Interface_FileParameter

        """
        return _Interface.Interface_ParamList_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_ParamList_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_ParamList
    __del__ = lambda self: None
Interface_ParamList_swigregister = _Interface.Interface_ParamList_swigregister
Interface_ParamList_swigregister(Interface_ParamList)

class Interface_ParamSet(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_ParamSet, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_ParamSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an empty paramset, beginning at number 'nst' and of initial reservation 'nres' : the 'nres' first parameters which follow 'ndeb' (included) will be put in an array (a paramlist). the remainders are set in next(s) paramset(s).

        Parameters
        ----------
        nres: int
        nst: int,optional
        	default value is 1

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_ParamSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Append(self, *args) -> "Standard_Integer":
        """
        Adds a parameter defined as its value (cstring and length) and type. optionnal entitynumber (for filereaderdata) can be given allows a better memory management than appending a complete fileparameter if <lnval> < 0, <val> is assumed to be managed elsewhere : its adress is stored as such. else, <val> is copied in a locally (quickly) managed page of characters returns new count of recorded parameters.

        Parameters
        ----------
        val: char *
        lnval: int
        typ: Interface_ParamType
        nument: int

        Returns
        -------
        int

        Adds a parameter at the end of the paramset (transparent about reservation and 'next') returns new count of recorded parameters.

        Parameters
        ----------
        FP: Interface_FileParameter

        Returns
        -------
        int

        """
        return _Interface.Interface_ParamSet_Append(self, *args)


    def ChangeParam(self, *args) -> "Interface_FileParameter &":
        """
        Same as above, but in order to be modified on place.

        Parameters
        ----------
        num: int

        Returns
        -------
        Interface_FileParameter

        """
        return _Interface.Interface_ParamSet_ChangeParam(self, *args)


    def Destroy(self, *args) -> "void":
        """
        Destructor (waiting for transparent memory management).

        Returns
        -------
        None

        """
        return _Interface.Interface_ParamSet_Destroy(self, *args)


    def NbParams(self, *args) -> "Standard_Integer":
        """
        Returns the total count of parameters (including nexts).

        Returns
        -------
        int

        """
        return _Interface.Interface_ParamSet_NbParams(self, *args)


    def Param(self, *args) -> "Interface_FileParameter const &":
        """
        Returns a parameter identified by its number.

        Parameters
        ----------
        num: int

        Returns
        -------
        Interface_FileParameter

        """
        return _Interface.Interface_ParamSet_Param(self, *args)


    def Params(self, *args) -> "opencascade::handle< Interface_ParamList >":
        """
        Builds and returns the sub-list correspinding to parameters, from 'num' included, with count 'nb' if <num> and <nb> are zero, returns the whole list.

        Parameters
        ----------
        num: int
        nb: int

        Returns
        -------
        opencascade::handle<Interface_ParamList>

        """
        return _Interface.Interface_ParamSet_Params(self, *args)


    def SetParam(self, *args) -> "void":
        """
        Changes a parameter identified by its number.

        Parameters
        ----------
        num: int
        FP: Interface_FileParameter

        Returns
        -------
        None

        """
        return _Interface.Interface_ParamSet_SetParam(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_ParamSet_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_ParamSet
    __del__ = lambda self: None
Interface_ParamSet_swigregister = _Interface.Interface_ParamSet_swigregister
Interface_ParamSet_swigregister(Interface_ParamSet)

class Interface_Protocol(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_Protocol, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_Protocol, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Active(*args) -> "opencascade::handle< Interface_Protocol >":
        """
        Returns the active protocol, if defined (else, returns a null handle, which means 'no defined active protocol').

        Returns
        -------
        opencascade::handle<Interface_Protocol>

        """
        return _Interface.Interface_Protocol_Active(*args)

    Active = staticmethod(Active)

    def CaseNumber(self, *args) -> "Standard_Integer":
        """
        Returns a unique positive casenumber for each recognized object. by default, recognition is based on type(1) by default, calls the following one which is deferred.

        Parameters
        ----------
        obj: Standard_Transient

        Returns
        -------
        int

        """
        return _Interface.Interface_Protocol_CaseNumber(self, *args)


    def ClearActive(*args) -> "void":
        """
        Erases the active protocol (hence it becomes undefined).

        Returns
        -------
        None

        """
        return _Interface.Interface_Protocol_ClearActive(*args)

    ClearActive = staticmethod(ClearActive)

    def GlobalCheck(self, *args) -> "Standard_Boolean":
        """
        Evaluates a global check for a model (with its graph) returns true when done, false if data in model do not apply //! very specific of each norm, i.e. of each protocol : the uppest level protocol assumes it, it can call globalcheck of its ressources only if it is necessary //! default does nothing, can be redefined.

        Parameters
        ----------
        G: Interface_Graph
        ach: Interface_Check

        Returns
        -------
        bool

        """
        return _Interface.Interface_Protocol_GlobalCheck(self, *args)


    def IsDynamicType(self, *args) -> "Standard_Boolean":
        """
        Returns true if type of <obj> is that defined from cdl this is the default but it may change according implementation.

        Parameters
        ----------
        obj: Standard_Transient

        Returns
        -------
        bool

        """
        return _Interface.Interface_Protocol_IsDynamicType(self, *args)


    def IsSuitableModel(self, *args) -> "Standard_Boolean":
        """
        Returns true if <model> is a model of the considered norm.

        Parameters
        ----------
        model: Interface_InterfaceModel

        Returns
        -------
        bool

        """
        return _Interface.Interface_Protocol_IsSuitableModel(self, *args)


    def IsUnknownEntity(self, *args) -> "Standard_Boolean":
        """
        Returns true if <ent> is an unknown entity for the norm, i.e. same type as them created by method unknownentity (for an entity out of the norm, answer can be unpredicable).

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        bool

        """
        return _Interface.Interface_Protocol_IsUnknownEntity(self, *args)


    def NbResources(self, *args) -> "Standard_Integer":
        """
        Returns count of protocol used as resources (level one).

        Returns
        -------
        int

        """
        return _Interface.Interface_Protocol_NbResources(self, *args)


    def NbTypes(self, *args) -> "Standard_Integer":
        """
        Returns the count of distinct types under which an entity may be processed. each one is candidate to be recognized by typenumber, <obj> is then processed according it by default, returns 1 (the dynamictype).

        Parameters
        ----------
        obj: Standard_Transient

        Returns
        -------
        int

        """
        return _Interface.Interface_Protocol_NbTypes(self, *args)


    def NewModel(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        Creates an empty model of the considered norm.

        Returns
        -------
        opencascade::handle<Interface_InterfaceModel>

        """
        return _Interface.Interface_Protocol_NewModel(self, *args)


    def Resource(self, *args) -> "opencascade::handle< Interface_Protocol >":
        """
        Returns a resource, given its rank (between 1 and nbresources).

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<Interface_Protocol>

        """
        return _Interface.Interface_Protocol_Resource(self, *args)


    def SetActive(*args) -> "void":
        """
        Sets a given protocol to be the active one (for the users of active, see just above). applies to every sub-type of protocol.

        Parameters
        ----------
        aprotocol: Interface_Protocol

        Returns
        -------
        None

        """
        return _Interface.Interface_Protocol_SetActive(*args)

    SetActive = staticmethod(SetActive)

    def Type(self, *args) -> "opencascade::handle< Standard_Type >":
        """
        Returns a type under which <obj> can be recognized and processed, according its rank in its definition list (see nbtypes). by default, returns dynamictype.

        Parameters
        ----------
        obj: Standard_Transient
        nt: int,optional
        	default value is 1

        Returns
        -------
        opencascade::handle<Standard_Type>

        """
        return _Interface.Interface_Protocol_Type(self, *args)


    def TypeNumber(self, *args) -> "Standard_Integer":
        """
        Returns a unique positive casenumber for each recognized type, returns zero for '<type> not recognized'.

        Parameters
        ----------
        atype: Standard_Type

        Returns
        -------
        int

        """
        return _Interface.Interface_Protocol_TypeNumber(self, *args)


    def UnknownEntity(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Creates a new unknown entity for the considered norm.

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _Interface.Interface_Protocol_UnknownEntity(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_Protocol_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_Protocol
    __del__ = lambda self: None
Interface_Protocol_swigregister = _Interface.Interface_Protocol_swigregister
Interface_Protocol_swigregister(Interface_Protocol)

def Interface_Protocol_Active(*args) -> "opencascade::handle< Interface_Protocol >":
    """
    Returns the active protocol, if defined (else, returns a null handle, which means 'no defined active protocol').

    Returns
    -------
    opencascade::handle<Interface_Protocol>

    """
    return _Interface.Interface_Protocol_Active(*args)

def Interface_Protocol_ClearActive(*args) -> "void":
    """
    Erases the active protocol (hence it becomes undefined).

    Returns
    -------
    None

    """
    return _Interface.Interface_Protocol_ClearActive(*args)

def Interface_Protocol_SetActive(*args) -> "void":
    """
    Sets a given protocol to be the active one (for the users of active, see just above). applies to every sub-type of protocol.

    Parameters
    ----------
    aprotocol: Interface_Protocol

    Returns
    -------
    None

    """
    return _Interface.Interface_Protocol_SetActive(*args)

class Interface_ReaderLib(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_ReaderLib, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_ReaderLib, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a library which complies with a protocol, that is : same class (criterium isinstance) this creation gets the modules from the global set, those which are bound to the given protocol and its resources.

        Parameters
        ----------
        aprotocol: Interface_Protocol

        Returns
        -------
        None

        Creates an empty library : it will later by filled by method addprotocol.

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_ReaderLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddProtocol(self, *args) -> "void":
        """
        Adds a couple (module-protocol) to the library, given the class of a protocol. takes resources into account. (if <aprotocol> is not of type theprotocol, it is not added).

        Parameters
        ----------
        aprotocol: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_ReaderLib_AddProtocol(self, *args)


    def Clear(self, *args) -> "void":
        """
        Clears the list of modules of a library (can be used to redefine the order of modules before action : clear then refill the library by calls to addprotocol).

        Returns
        -------
        None

        """
        return _Interface.Interface_ReaderLib_Clear(self, *args)


    def Module(self, *args) -> "opencascade::handle< Interface_ReaderModule > const &":
        """
        Returns the current module in the iteration.

        Returns
        -------
        opencascade::handle<Interface_ReaderModule>

        """
        return _Interface.Interface_ReaderLib_Module(self, *args)


    def More(self, *args) -> "Standard_Boolean":
        """
        Returns true if there are more modules to iterate on.

        Returns
        -------
        bool

        """
        return _Interface.Interface_ReaderLib_More(self, *args)


    def Next(self, *args) -> "void":
        """
        Iterates by getting the next module in the list if there is none, the exception will be raised by value.

        Returns
        -------
        None

        """
        return _Interface.Interface_ReaderLib_Next(self, *args)


    def Protocol(self, *args) -> "opencascade::handle< Interface_Protocol > const &":
        """
        Returns the current protocol in the iteration.

        Returns
        -------
        opencascade::handle<Interface_Protocol>

        """
        return _Interface.Interface_ReaderLib_Protocol(self, *args)


    def Select(self, *args) -> "Standard_Boolean":
        """
        Selects a module from the library, given an object. returns true if select has succeeded, false else. also returns (as arguments) the selected module and the case number determined by the associated protocol. if select has failed, <module> is null handle and cn is zero. (select can work on any criterium, such as object dynamictype).

        Parameters
        ----------
        obj: Standard_Transient
        module: Interface_ReaderModule

        Returns
        -------
        CN: int

        """
        return _Interface.Interface_ReaderLib_Select(self, *args)


    def SetComplete(self, *args) -> "void":
        """
        Sets a library to be defined with the complete global list (all the couples protocol/modules recorded in it).

        Returns
        -------
        None

        """
        return _Interface.Interface_ReaderLib_SetComplete(self, *args)


    def SetGlobal(*args) -> "void":
        """
        Adds a couple (module-protocol) into the global definition set for this class of library.

        Parameters
        ----------
        amodule: Interface_ReaderModule
        aprotocol: Interface_Protocol

        Returns
        -------
        None

        """
        return _Interface.Interface_ReaderLib_SetGlobal(*args)

    SetGlobal = staticmethod(SetGlobal)

    def Start(self, *args) -> "void":
        """
        Starts iteration on the modules (sets it on the first one).

        Returns
        -------
        None

        """
        return _Interface.Interface_ReaderLib_Start(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_ReaderLib
    __del__ = lambda self: None
Interface_ReaderLib_swigregister = _Interface.Interface_ReaderLib_swigregister
Interface_ReaderLib_swigregister(Interface_ReaderLib)

def Interface_ReaderLib_SetGlobal(*args) -> "void":
    """
    Adds a couple (module-protocol) into the global definition set for this class of library.

    Parameters
    ----------
    amodule: Interface_ReaderModule
    aprotocol: Interface_Protocol

    Returns
    -------
    None

    """
    return _Interface.Interface_ReaderLib_SetGlobal(*args)

class Interface_ReaderModule(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_ReaderModule, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_ReaderModule, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def CaseNum(self, *args) -> "Standard_Integer":
        """
        Translates the type of record <num> in <data> to a positive case number. if recognition fails, must return 0.

        Parameters
        ----------
        data: Interface_FileReaderData
        num: int

        Returns
        -------
        int

        """
        return _Interface.Interface_ReaderModule_CaseNum(self, *args)


    def NewRead(self, *args) -> "Standard_Boolean":
        """
        Specific operator (create+read) defaulted to do nothing. it can be redefined when it is not possible to work in two steps (newvoid then read). this occurs when no default constructor is defined : hence the result <ent> must be created with an effective definition from the reader. remark : if newread is defined, copy has nothing to do. //! returns true if it has produced something, false else. if nothing was produced, <ach> should be filled : it will be treated as 'unrecognized case' by reader tool.

        Parameters
        ----------
        casenum: int
        data: Interface_FileReaderData
        num: int
        ach: Interface_Check
        ent: Standard_Transient

        Returns
        -------
        bool

        """
        return _Interface.Interface_ReaderModule_NewRead(self, *args)


    def Read(self, *args) -> "void":
        """
        Performs the effective loading from <data>, record <num>, to the entity <ent> formerly created in case of error or warning, fills <ach> with messages remark that the case number comes from translating a record.

        Parameters
        ----------
        casenum: int
        data: Interface_FileReaderData
        num: int
        ach: Interface_Check
        ent: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_ReaderModule_Read(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_ReaderModule_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_ReaderModule
    __del__ = lambda self: None
Interface_ReaderModule_swigregister = _Interface.Interface_ReaderModule_swigregister
Interface_ReaderModule_swigregister(Interface_ReaderModule)

class Interface_ReportEntity(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_ReportEntity, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_ReportEntity, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a reportentity for an unknown entity : check is empty, and concerned equates content (i.e. the unknown entity).

        Parameters
        ----------
        unknown: Standard_Transient

        Returns
        -------
        None

        Creates a reportentity with its features : - <acheck> is the check to be memorised - <concerned> is the entity to which the check is bound later, a content can be set : it is required for an error.

        Parameters
        ----------
        acheck: Interface_Check
        concerned: Standard_Transient

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_ReportEntity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CCheck(self, *args) -> "opencascade::handle< Interface_Check > &":
        """
        Returns the stored check in order to change it.

        Returns
        -------
        opencascade::handle<Interface_Check>

        """
        return _Interface.Interface_ReportEntity_CCheck(self, *args)


    def Check(self, *args) -> "opencascade::handle< Interface_Check > const &":
        """
        Returns the stored check.

        Returns
        -------
        opencascade::handle<Interface_Check>

        """
        return _Interface.Interface_ReportEntity_Check(self, *args)


    def Concerned(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Returns the stored concerned entity. it equates the content in the case of an unknown entity.

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _Interface.Interface_ReportEntity_Concerned(self, *args)


    def Content(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Returns the stored content, or a null handle remark that it must be an 'unknown entity' suitable for the norm of the containing model.

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _Interface.Interface_ReportEntity_Content(self, *args)


    def HasContent(self, *args) -> "Standard_Boolean":
        """
        Returns true if a content is stored (it can equate concerned).

        Returns
        -------
        bool

        """
        return _Interface.Interface_ReportEntity_HasContent(self, *args)


    def HasNewContent(self, *args) -> "Standard_Boolean":
        """
        Returns true if a content is stored and differs from concerned (i.e. redefines content) : used when concerned could not be loaded.

        Returns
        -------
        bool

        """
        return _Interface.Interface_ReportEntity_HasNewContent(self, *args)


    def IsError(self, *args) -> "Standard_Boolean":
        """
        Returns true for an error entity, i.e. if the check brings at least one fail message.

        Returns
        -------
        bool

        """
        return _Interface.Interface_ReportEntity_IsError(self, *args)


    def IsUnknown(self, *args) -> "Standard_Boolean":
        """
        Returns true for an unknown entity, i,e. if the check is empty and concerned equates content.

        Returns
        -------
        bool

        """
        return _Interface.Interface_ReportEntity_IsUnknown(self, *args)


    def SetContent(self, *args) -> "void":
        """
        Sets a content : it brings non interpreted data which belong to the concerned entity. it can be empty then loaded later. remark that for an unknown entity, content is set by create.

        Parameters
        ----------
        content: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_ReportEntity_SetContent(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_ReportEntity_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_ReportEntity
    __del__ = lambda self: None
Interface_ReportEntity_swigregister = _Interface.Interface_ReportEntity_swigregister
Interface_ReportEntity_swigregister(Interface_ReportEntity)

class Interface_STAT(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_STAT, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_STAT, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a stat form. at start, one default phase is defined, with one default step. then, it suffises to start with a count of items (and cycles if several) then record items, to have a queryable report.

        Parameters
        ----------
        title: char *,optional
        	default value is 

        Returns
        -------
        None

        Used when starting.

        Parameters
        ----------
        other: Interface_STAT

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_STAT(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddPhase(self, *args) -> "void":
        """
        Adds a new phase to the description. the first one after create replaces the default unique one.

        Parameters
        ----------
        weight: float
        name: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _Interface.Interface_STAT_AddPhase(self, *args)


    def AddStep(self, *args) -> "void":
        """
        Adds a new step for the last added phase, the default unique one if no addphase has already been added warning : addstep before the first addphase are cancelled.

        Parameters
        ----------
        weight: float,optional
        	default value is 1

        Returns
        -------
        None

        """
        return _Interface.Interface_STAT_AddStep(self, *args)


    def Description(self, *args) -> "void":
        """
        Returns global description (cumulated weights of all phases, count of phases,1 for default, and title).

        Parameters
        ----------
        title: char *

        Returns
        -------
        nbphases: int
        total: float

        """
        return _Interface.Interface_STAT_Description(self, *args)


    def End(*args) -> "void":
        """
        Commands to declare the process ended (hence, advancement is forced to 100 %).

        Returns
        -------
        None

        """
        return _Interface.Interface_STAT_End(*args)

    End = staticmethod(End)

    def Internals(self, *args) -> "void":
        """
        Returns fields in once, without copying them, used for copy when starting.

        Parameters
        ----------
        tit: TCollection_HAsciiString
        phn: TColStd_HSequenceOfAsciiString
        phw: TColStd_HSequenceOfReal
        phdeb: TColStd_HSequenceOfInteger
        phfin: TColStd_HSequenceOfInteger
        stw: TColStd_HSequenceOfReal

        Returns
        -------
        total: float

        """
        return _Interface.Interface_STAT_Internals(self, *args)


    def NextCycle(*args) -> "void":
        """
        Commands to resume the preceeding cycle and start a new one, with a count of items ignored if count of cycles is already passed then, first step is started (or default one) nextitem can be called for the first step, or nextstep to pass to the next one.

        Parameters
        ----------
        items: int

        Returns
        -------
        None

        """
        return _Interface.Interface_STAT_NextCycle(*args)

    NextCycle = staticmethod(NextCycle)

    def NextItem(*args) -> "void":
        """
        Commands to add an item in the current step of the current cycle of the current phase by default, one item per call, can be overpassed ignored if count of items of this cycle is already passed.

        Parameters
        ----------
        nbitems: int,optional
        	default value is 1

        Returns
        -------
        None

        """
        return _Interface.Interface_STAT_NextItem(*args)

    NextItem = staticmethod(NextItem)

    def NextPhase(*args) -> "void":
        """
        Commands to resume the preceeding phase and start a new one <items> and <cycles> as for start, but for this new phase ignored if count of phases is already passed if <cycles> is more than one, the first cycle must then be started by nextcycle (nextstep/nextitem are ignored). if it is one, nextitem/nextstep can then be called.

        Parameters
        ----------
        items: int
        cycles: int,optional
        	default value is 1

        Returns
        -------
        None

        """
        return _Interface.Interface_STAT_NextPhase(*args)

    NextPhase = staticmethod(NextPhase)

    def NextStep(*args) -> "void":
        """
        Commands to resume the preceeding step of the cycle ignored if count of steps is already passed nextitem can be called for this step, nextstep passes to next.

        Returns
        -------
        None

        """
        return _Interface.Interface_STAT_NextStep(*args)

    NextStep = staticmethod(NextStep)

    def Percent(*args) -> "Standard_Integer":
        """
        Returns the advancement as a percentage : <phase> true : inside the current phase <phase> false (d) : relative to the whole process.

        Parameters
        ----------
        phase: bool,optional
        	default value is Standard_False

        Returns
        -------
        int

        """
        return _Interface.Interface_STAT_Percent(*args)

    Percent = staticmethod(Percent)

    def Phase(self, *args) -> "void":
        """
        Returns description of a phase, given its rank (n0 for first step, count of steps, default gives one; weight, name).

        Parameters
        ----------
        num: int
        name: char *

        Returns
        -------
        n0step: int
        nbstep: int
        weight: float

        """
        return _Interface.Interface_STAT_Phase(self, *args)


    def SetPhase(*args) -> "void":
        """
        Changes the parameters of the phase to start to be used before first counting (i.e. just after nextphase) can be used by an operator which has to reajust counts on run.

        Parameters
        ----------
        items: int
        cycles: int,optional
        	default value is 1

        Returns
        -------
        None

        """
        return _Interface.Interface_STAT_SetPhase(*args)

    SetPhase = staticmethod(SetPhase)

    def Start(self, *args) -> "void":
        """
        Starts a stat on its first phase (or its default one) <items> gives the total count of items, <cycles> the count of cycles if <cycles> is more than one, the first cycle must then be started by nextcycle (nextstep/nextitem are ignored). if it is one, nextitem/nextstep can then be called.

        Parameters
        ----------
        items: int
        cycles: int,optional
        	default value is 1

        Returns
        -------
        None

        """
        return _Interface.Interface_STAT_Start(self, *args)


    def StartCount(*args) -> "void":
        """
        Starts a default stat, with no phase, no step, ready to just count items. <items> gives the total count of items hence, nextitem is available to directly count.

        Parameters
        ----------
        items: int
        title: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        return _Interface.Interface_STAT_StartCount(*args)

    StartCount = staticmethod(StartCount)

    def Step(self, *args) -> "Standard_Real":
        """
        Returns weight of a step, related to the cumul given for the phase. <num> is given by <n0step> + i, i between 1 and <nbsteps> (default gives n0step < 0 then weight is one).

        Parameters
        ----------
        num: int

        Returns
        -------
        float

        """
        return _Interface.Interface_STAT_Step(self, *args)


    def Where(*args) -> "char const *":
        """
        Returns an identification of the stat : <phase> true (d) : the name of the current phase <phase> false : the title of the current stat.

        Parameters
        ----------
        phase: bool,optional
        	default value is Standard_True

        Returns
        -------
        char *

        """
        return _Interface.Interface_STAT_Where(*args)

    Where = staticmethod(Where)

    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_STAT
    __del__ = lambda self: None
Interface_STAT_swigregister = _Interface.Interface_STAT_swigregister
Interface_STAT_swigregister(Interface_STAT)

def Interface_STAT_End(*args) -> "void":
    """
    Commands to declare the process ended (hence, advancement is forced to 100 %).

    Returns
    -------
    None

    """
    return _Interface.Interface_STAT_End(*args)

def Interface_STAT_NextCycle(*args) -> "void":
    """
    Commands to resume the preceeding cycle and start a new one, with a count of items ignored if count of cycles is already passed then, first step is started (or default one) nextitem can be called for the first step, or nextstep to pass to the next one.

    Parameters
    ----------
    items: int

    Returns
    -------
    None

    """
    return _Interface.Interface_STAT_NextCycle(*args)

def Interface_STAT_NextItem(*args) -> "void":
    """
    Commands to add an item in the current step of the current cycle of the current phase by default, one item per call, can be overpassed ignored if count of items of this cycle is already passed.

    Parameters
    ----------
    nbitems: int,optional
    	default value is 1

    Returns
    -------
    None

    """
    return _Interface.Interface_STAT_NextItem(*args)

def Interface_STAT_NextPhase(*args) -> "void":
    """
    Commands to resume the preceeding phase and start a new one <items> and <cycles> as for start, but for this new phase ignored if count of phases is already passed if <cycles> is more than one, the first cycle must then be started by nextcycle (nextstep/nextitem are ignored). if it is one, nextitem/nextstep can then be called.

    Parameters
    ----------
    items: int
    cycles: int,optional
    	default value is 1

    Returns
    -------
    None

    """
    return _Interface.Interface_STAT_NextPhase(*args)

def Interface_STAT_NextStep(*args) -> "void":
    """
    Commands to resume the preceeding step of the cycle ignored if count of steps is already passed nextitem can be called for this step, nextstep passes to next.

    Returns
    -------
    None

    """
    return _Interface.Interface_STAT_NextStep(*args)

def Interface_STAT_Percent(*args) -> "Standard_Integer":
    """
    Returns the advancement as a percentage : <phase> true : inside the current phase <phase> false (d) : relative to the whole process.

    Parameters
    ----------
    phase: bool,optional
    	default value is Standard_False

    Returns
    -------
    int

    """
    return _Interface.Interface_STAT_Percent(*args)

def Interface_STAT_SetPhase(*args) -> "void":
    """
    Changes the parameters of the phase to start to be used before first counting (i.e. just after nextphase) can be used by an operator which has to reajust counts on run.

    Parameters
    ----------
    items: int
    cycles: int,optional
    	default value is 1

    Returns
    -------
    None

    """
    return _Interface.Interface_STAT_SetPhase(*args)

def Interface_STAT_StartCount(*args) -> "void":
    """
    Starts a default stat, with no phase, no step, ready to just count items. <items> gives the total count of items hence, nextitem is available to directly count.

    Parameters
    ----------
    items: int
    title: char *,optional
    	default value is 

    Returns
    -------
    None

    """
    return _Interface.Interface_STAT_StartCount(*args)

def Interface_STAT_Where(*args) -> "char const *":
    """
    Returns an identification of the stat : <phase> true (d) : the name of the current phase <phase> false : the title of the current stat.

    Parameters
    ----------
    phase: bool,optional
    	default value is Standard_True

    Returns
    -------
    char *

    """
    return _Interface.Interface_STAT_Where(*args)

class Interface_ShareFlags(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_ShareFlags, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_ShareFlags, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a shareflags from a model and builds required data (flags) by calling the general service library given as argument <lib>.

        Parameters
        ----------
        amodel: Interface_InterfaceModel
        lib: Interface_GeneralLib

        Returns
        -------
        None

        Same as above, but generallib is detained by a gtool.

        Parameters
        ----------
        amodel: Interface_InterfaceModel
        gtool: Interface_GTool

        Returns
        -------
        None

        Same as above, but generallib is defined through a protocol.

        Parameters
        ----------
        amodel: Interface_InterfaceModel
        protocol: Interface_Protocol

        Returns
        -------
        None

        Same as above, but works with the gtool of the model.

        Parameters
        ----------
        amodel: Interface_InterfaceModel

        Returns
        -------
        None

        Creates a shareflags by querying informations from a graph (remark that graph also has a method isshared).

        Parameters
        ----------
        agraph: Interface_Graph

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_ShareFlags(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsShared(self, *args) -> "Standard_Boolean":
        """
        Returns true if <ent> is shared by one or more other entity(ies) of the model.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        bool

        """
        return _Interface.Interface_ShareFlags_IsShared(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        Returns the model used for the evaluation.

        Returns
        -------
        opencascade::handle<Interface_InterfaceModel>

        """
        return _Interface.Interface_ShareFlags_Model(self, *args)


    def NbRoots(self, *args) -> "Standard_Integer":
        """
        Returns the count of root entities.

        Returns
        -------
        int

        """
        return _Interface.Interface_ShareFlags_NbRoots(self, *args)


    def Root(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Returns a root entity according its rank in the list of roots by default, it returns the first one.

        Parameters
        ----------
        num: int,optional
        	default value is 1

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _Interface.Interface_ShareFlags_Root(self, *args)


    def RootEntities(self, *args) -> "Interface_EntityIterator":
        """
        Returns the entities which are not shared (see their flags).

        Returns
        -------
        Interface_EntityIterator

        """
        return _Interface.Interface_ShareFlags_RootEntities(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_ShareFlags
    __del__ = lambda self: None
Interface_ShareFlags_swigregister = _Interface.Interface_ShareFlags_swigregister
Interface_ShareFlags_swigregister(Interface_ShareFlags)

class Interface_ShareTool(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_ShareTool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_ShareTool, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a sharetool from a model and builds all required data, by calling the general service library and modules (generallib given as an argument).

        Parameters
        ----------
        amodel: Interface_InterfaceModel
        lib: Interface_GeneralLib

        Returns
        -------
        None

        Same a above, but generallib is detained by a gtool.

        Parameters
        ----------
        amodel: Interface_InterfaceModel
        gtool: Interface_GTool

        Returns
        -------
        None

        Same a above, but generallib is defined through a protocol protocol is used to build the working library.

        Parameters
        ----------
        amodel: Interface_InterfaceModel
        protocol: Interface_Protocol

        Returns
        -------
        None

        Same as above, but works with the gtool of the model.

        Parameters
        ----------
        amodel: Interface_InterfaceModel

        Returns
        -------
        None

        Creates a sharetool from an already defined graph remark that the data of the graph are copied.

        Parameters
        ----------
        agraph: Interface_Graph

        Returns
        -------
        None

        Completes the graph by adding implied references. hence, they are considered as sharing references in all the other queries.

        Parameters
        ----------
        ahgraph: Interface_HGraph

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_ShareTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def All(self, *args) -> "Interface_EntityIterator":
        """
        Returns the complete list of entities shared by <ent> at any level, including <ent> itself if <ent> is the model, considers the concatenation of allshared for each root if <rootlast> is true (d), the list starts with lower level entities and ends by the root. else, the root is first and the lower level entities are at end.

        Parameters
        ----------
        ent: Standard_Transient
        rootlast: bool,optional
        	default value is Standard_True

        Returns
        -------
        Interface_EntityIterator

        """
        return _Interface.Interface_ShareTool_All(self, *args)


    def Graph(self, *args) -> "Interface_Graph const &":
        """
        Returns the data used by the sharetool to work can then be used directly (read only).

        Returns
        -------
        Interface_Graph

        """
        return _Interface.Interface_ShareTool_Graph(self, *args)


    def IsShared(self, *args) -> "Standard_Boolean":
        """
        Returns true if <ent> is shared by other entities in the model.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        bool

        """
        return _Interface.Interface_ShareTool_IsShared(self, *args)


    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        Returns the model used for creation (directly or for graph).

        Returns
        -------
        opencascade::handle<Interface_InterfaceModel>

        """
        return _Interface.Interface_ShareTool_Model(self, *args)


    def NbTypedSharings(self, *args) -> "Standard_Integer":
        """
        Returns the count of sharing entities of an entity, which are kind of a given type.

        Parameters
        ----------
        ent: Standard_Transient
        atype: Standard_Type

        Returns
        -------
        int

        """
        return _Interface.Interface_ShareTool_NbTypedSharings(self, *args)


    def RootEntities(self, *args) -> "Interface_EntityIterator":
        """
        Returns the entities which are not shared (their sharing list is empty) in the model.

        Returns
        -------
        Interface_EntityIterator

        """
        return _Interface.Interface_ShareTool_RootEntities(self, *args)


    def Shareds(self, *args) -> "Interface_EntityIterator":
        """
        Returns the list of entities shared by a given entity <ent>.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        Interface_EntityIterator

        """
        return _Interface.Interface_ShareTool_Shareds(self, *args)


    def Sharings(self, *args) -> "Interface_EntityIterator":
        """
        Returns the list of entities sharing a given entity <ent>.

        Parameters
        ----------
        ent: Standard_Transient

        Returns
        -------
        Interface_EntityIterator

        """
        return _Interface.Interface_ShareTool_Sharings(self, *args)


    def TypedSharing(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Returns the sharing entity of an entity, which is kind of a given type. allows to access a sharing entity of a given type when there is one and only one (current case).

        Parameters
        ----------
        ent: Standard_Transient
        atype: Standard_Type

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _Interface.Interface_ShareTool_TypedSharing(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_ShareTool
    __del__ = lambda self: None
Interface_ShareTool_swigregister = _Interface.Interface_ShareTool_swigregister
Interface_ShareTool_swigregister(Interface_ShareTool)

class Interface_SignLabel(OCC.Core.MoniTool.MoniTool_SignText):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.MoniTool.MoniTool_SignText]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_SignLabel, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.MoniTool.MoniTool_SignText]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_SignLabel, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_SignLabel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this


    @staticmethod
    def DownCast(t):
      return Handle_Interface_SignLabel_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_SignLabel
    __del__ = lambda self: None
Interface_SignLabel_swigregister = _Interface.Interface_SignLabel_swigregister
Interface_SignLabel_swigregister(Interface_SignLabel)

class Interface_SignType(OCC.Core.MoniTool.MoniTool_SignText):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.MoniTool.MoniTool_SignText]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_SignType, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.MoniTool.MoniTool_SignText]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_SignType, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ClassName(*args) -> "char const *":
        """
        From a cdl type name, returns the class part (package dropped) warning : buffered, to be immediately copied or printed.

        Parameters
        ----------
        typnam: char *

        Returns
        -------
        char *

        """
        return _Interface.Interface_SignType_ClassName(*args)

    ClassName = staticmethod(ClassName)

    def Value(self, *args) -> "char const *":
        """
        Returns the signature for a transient object. it is specific of each sub-class of signature. for a null handle, it should provide '' it can work with the model which contains the entity.

        Parameters
        ----------
        ent: Standard_Transient
        model: Interface_InterfaceModel

        Returns
        -------
        char *

        """
        return _Interface.Interface_SignType_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_SignType_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_SignType
    __del__ = lambda self: None
Interface_SignType_swigregister = _Interface.Interface_SignType_swigregister
Interface_SignType_swigregister(Interface_SignType)

def Interface_SignType_ClassName(*args) -> "char const *":
    """
    From a cdl type name, returns the class part (package dropped) warning : buffered, to be immediately copied or printed.

    Parameters
    ----------
    typnam: char *

    Returns
    -------
    char *

    """
    return _Interface.Interface_SignType_ClassName(*args)

class Interface_TypedValue(OCC.Core.MoniTool.MoniTool_TypedValue):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.MoniTool.MoniTool_TypedValue]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_TypedValue, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.MoniTool.MoniTool_TypedValue]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_TypedValue, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a typedvalue, with a name //! type gives the type of the parameter, default is free text also available : integer, real, enum, entity (i.e. object) more precise specifications, titles, can be given to the typedvalue once created //! init gives an initial value. if it is not given, the typedvalue begins as 'not set', its value is empty.

        Parameters
        ----------
        name: char *
        type: Interface_ParamType,optional
        	default value is Interface_ParamText
        init: char *,optional
        	default value is 

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_TypedValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ParamTypeToValueType(*args) -> "MoniTool_ValueType":
        """
        Correspondance paramtype from interface to valuetype from monitool.

        Parameters
        ----------
        typ: Interface_ParamType

        Returns
        -------
        MoniTool_ValueType

        """
        return _Interface.Interface_TypedValue_ParamTypeToValueType(*args)

    ParamTypeToValueType = staticmethod(ParamTypeToValueType)

    def Type(self, *args) -> "Interface_ParamType":
        """
        Returns the type i.e. calls valuetype then makes correspondance between paramtype from interface (which remains for compatibility reasons) and valuetype from monitool.

        Returns
        -------
        Interface_ParamType

        """
        return _Interface.Interface_TypedValue_Type(self, *args)


    def ValueTypeToParamType(*args) -> "Interface_ParamType":
        """
        Correspondance paramtype from interface to valuetype from monitool.

        Parameters
        ----------
        typ: MoniTool_ValueType

        Returns
        -------
        Interface_ParamType

        """
        return _Interface.Interface_TypedValue_ValueTypeToParamType(*args)

    ValueTypeToParamType = staticmethod(ValueTypeToParamType)


    @staticmethod
    def DownCast(t):
      return Handle_Interface_TypedValue_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_TypedValue
    __del__ = lambda self: None
Interface_TypedValue_swigregister = _Interface.Interface_TypedValue_swigregister
Interface_TypedValue_swigregister(Interface_TypedValue)

def Interface_TypedValue_ParamTypeToValueType(*args) -> "MoniTool_ValueType":
    """
    Correspondance paramtype from interface to valuetype from monitool.

    Parameters
    ----------
    typ: Interface_ParamType

    Returns
    -------
    MoniTool_ValueType

    """
    return _Interface.Interface_TypedValue_ParamTypeToValueType(*args)

def Interface_TypedValue_ValueTypeToParamType(*args) -> "Interface_ParamType":
    """
    Correspondance paramtype from interface to valuetype from monitool.

    Parameters
    ----------
    typ: MoniTool_ValueType

    Returns
    -------
    Interface_ParamType

    """
    return _Interface.Interface_TypedValue_ValueTypeToParamType(*args)

class Interface_UndefinedContent(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_UndefinedContent, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_UndefinedContent, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Defines an empty undefinedcontent.

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_UndefinedContent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddEntity(self, *args) -> "void":
        """
        Adds a parameter which references an entity.

        Parameters
        ----------
        ptype: Interface_ParamType
        ent: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_UndefinedContent_AddEntity(self, *args)


    def AddLiteral(self, *args) -> "void":
        """
        Adds a literal parameter to the list.

        Parameters
        ----------
        ptype: Interface_ParamType
        val: TCollection_HAsciiString

        Returns
        -------
        None

        """
        return _Interface.Interface_UndefinedContent_AddLiteral(self, *args)


    def EntityList(self, *args) -> "Interface_EntityList":
        """
        Returns globally the list of param entities. note that it can be used as shared entity list for the undefinedentity.

        Returns
        -------
        Interface_EntityList

        """
        return _Interface.Interface_UndefinedContent_EntityList(self, *args)


    def GetFromAnother(self, *args) -> "void":
        """
        Copies contents of undefined entities; deigned to be called by getfromanother method from undefined entity of each interface (the basic operation is the same regardless the norm).

        Parameters
        ----------
        other: Interface_UndefinedContent
        TC: Interface_CopyTool

        Returns
        -------
        None

        """
        return _Interface.Interface_UndefinedContent_GetFromAnother(self, *args)


    def IsParamEntity(self, *args) -> "Standard_Boolean":
        """
        Returns true if a parameter is recorded as an entity error if num is not between 1 and nbparams.

        Parameters
        ----------
        num: int

        Returns
        -------
        bool

        """
        return _Interface.Interface_UndefinedContent_IsParamEntity(self, *args)


    def NbLiterals(self, *args) -> "Standard_Integer":
        """
        Gives count of literal parameters.

        Returns
        -------
        int

        """
        return _Interface.Interface_UndefinedContent_NbLiterals(self, *args)


    def NbParams(self, *args) -> "Standard_Integer":
        """
        Gives count of recorded parameters.

        Returns
        -------
        int

        """
        return _Interface.Interface_UndefinedContent_NbParams(self, *args)


    def ParamData(self, *args) -> "Standard_Boolean":
        """
        Returns data of a parameter : its type, and the entity if it designates en entity ('ent') or its literal value else ('str') returned value (boolean) : true if it is an entity, false else.

        Parameters
        ----------
        num: int
        ent: Standard_Transient
        val: TCollection_HAsciiString

        Returns
        -------
        ptype: Interface_ParamType

        """
        return _Interface.Interface_UndefinedContent_ParamData(self, *args)


    def ParamEntity(self, *args) -> "opencascade::handle< Standard_Transient >":
        """
        Returns entity corresponding to a param, given its rank.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<Standard_Transient>

        """
        return _Interface.Interface_UndefinedContent_ParamEntity(self, *args)


    def ParamType(self, *args) -> "Interface_ParamType":
        """
        Returns the paramtype of a param, given its rank error if num is not between 1 and nbparams.

        Parameters
        ----------
        num: int

        Returns
        -------
        Interface_ParamType

        """
        return _Interface.Interface_UndefinedContent_ParamType(self, *args)


    def ParamValue(self, *args) -> "opencascade::handle< TCollection_HAsciiString >":
        """
        Returns litteral value of a parameter, given its rank.

        Parameters
        ----------
        num: int

        Returns
        -------
        opencascade::handle<TCollection_HAsciiString>

        """
        return _Interface.Interface_UndefinedContent_ParamValue(self, *args)


    def RemoveParam(self, *args) -> "void":
        """
        Removes a parameter given its rank.

        Parameters
        ----------
        num: int

        Returns
        -------
        None

        """
        return _Interface.Interface_UndefinedContent_RemoveParam(self, *args)


    def Reservate(self, *args) -> "void":
        """
        Manages reservation for parameters (internal use) (nb : total count of parameters, nblit : count of literals).

        Parameters
        ----------
        nb: int
        nblit: int

        Returns
        -------
        None

        """
        return _Interface.Interface_UndefinedContent_Reservate(self, *args)


    def SetEntity(self, *args) -> "void":
        """
        Sets a new value for the parameter <num>, to reference an entity. to simply change the entity, see the variant below.

        Parameters
        ----------
        num: int
        ptype: Interface_ParamType
        ent: Standard_Transient

        Returns
        -------
        None

        Changes the entity referenced by the parameter <num> (with same paramtype).

        Parameters
        ----------
        num: int
        ent: Standard_Transient

        Returns
        -------
        None

        """
        return _Interface.Interface_UndefinedContent_SetEntity(self, *args)


    def SetLiteral(self, *args) -> "void":
        """
        Sets a new value for the parameter <num>, to a literal value (if it referenced formerly an entity, this entity is removed).

        Parameters
        ----------
        num: int
        ptype: Interface_ParamType
        val: TCollection_HAsciiString

        Returns
        -------
        None

        """
        return _Interface.Interface_UndefinedContent_SetLiteral(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_UndefinedContent_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_UndefinedContent
    __del__ = lambda self: None
Interface_UndefinedContent_swigregister = _Interface.Interface_UndefinedContent_swigregister
Interface_UndefinedContent_swigregister(Interface_UndefinedContent)

class Interface_CopyMap(Interface_CopyControl):
    __swig_setmethods__ = {}
    for _s in [Interface_CopyControl]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_CopyMap, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface_CopyControl]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_CopyMap, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a copymap adapted to work from a model.

        Parameters
        ----------
        amodel: Interface_InterfaceModel

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_CopyMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Model(self, *args) -> "opencascade::handle< Interface_InterfaceModel >":
        """
        Returns the interfacemodel used at creation time.

        Returns
        -------
        opencascade::handle<Interface_InterfaceModel>

        """
        return _Interface.Interface_CopyMap_Model(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_CopyMap_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_CopyMap
    __del__ = lambda self: None
Interface_CopyMap_swigregister = _Interface.Interface_CopyMap_swigregister
Interface_CopyMap_swigregister(Interface_CopyMap)

class Interface_GraphContent(Interface_EntityIterator):
    __swig_setmethods__ = {}
    for _s in [Interface_EntityIterator]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_GraphContent, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface_EntityIterator]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_GraphContent, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an empty graphcontent, ready to be filled.

        Returns
        -------
        None

        Creates with all entities designated by a graph.

        Parameters
        ----------
        agraph: Interface_Graph

        Returns
        -------
        None

        Creates with entities having specific status value in a graph.

        Parameters
        ----------
        agraph: Interface_Graph
        stat: int

        Returns
        -------
        None

        Creates an iterator with shared entities of an entity (equivalente to entityiterator but with a graph).

        Parameters
        ----------
        agraph: Interface_Graph
        ent: Standard_Transient

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_GraphContent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Begin(self, *args) -> "void":
        """
        Does the evaluation before starting the iteration itself (in out).

        Returns
        -------
        None

        """
        return _Interface.Interface_GraphContent_Begin(self, *args)


    def Evaluate(self, *args) -> "void":
        """
        Evaluates list of entities to be iterated. called by start default is set to doing nothing : intended to be redefined by each sub-class.

        Returns
        -------
        None

        """
        return _Interface.Interface_GraphContent_Evaluate(self, *args)


    def GetFromGraph(self, *args) -> "void":
        """
        Gets all entities designated by a graph (once created), adds them to those already recorded.

        Parameters
        ----------
        agraph: Interface_Graph

        Returns
        -------
        None

        Gets entities from a graph which have a specific status value (one created), adds them to those already recorded.

        Parameters
        ----------
        agraph: Interface_Graph
        stat: int

        Returns
        -------
        None

        """
        return _Interface.Interface_GraphContent_GetFromGraph(self, *args)


    def Result(self, *args) -> "Interface_EntityIterator":
        """
        Returns result under the exact form of an entityiterator : can be used when entityiterator itself is required (as a returned value for instance), whitout way for a sub-class.

        Returns
        -------
        Interface_EntityIterator

        """
        return _Interface.Interface_GraphContent_Result(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_GraphContent
    __del__ = lambda self: None
Interface_GraphContent_swigregister = _Interface.Interface_GraphContent_swigregister
Interface_GraphContent_swigregister(Interface_GraphContent)

class Interface_Static(Interface_TypedValue):
    __swig_setmethods__ = {}
    for _s in [Interface_TypedValue]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_Static, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface_TypedValue]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_Static, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates and records a static, with a family and a name family can report to a name of ressource or to a system or internal definition. the name must be unique. //! type gives the type of the parameter, default is free text also available : integer, real, enum, entity (i.e. object) more precise specifications, titles, can be given to the static once created //! init gives an initial value. if it is not given, the static begin as 'not set', its value is empty.

        Parameters
        ----------
        family: char *
        name: char *
        type: Interface_ParamType,optional
        	default value is Interface_ParamText
        init: char *,optional
        	default value is 

        Returns
        -------
        None

        Creates a new static with same definition as another one (value is copied, except for entity : it remains null).

        Parameters
        ----------
        family: char *
        name: char *
        other: Interface_Static

        Returns
        -------
        None

        """
        this = _Interface.new_Interface_Static(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CDef(*args) -> "char const *":
        """
        Returns a part of the definition of a static, as a cstring the part is designated by its name, as a cstring if the required value is not a string, it is converted to a cstring then returned if <name> is not present, or <part> not defined for <name>, this function returns an empty string //! allowed parts for cdef : family : the family type : the type ('integer','real','text','enum') label : the label satis : satisfy function name if any rmin : minimum real value rmax : maximum real value imin : minimum integer value imax : maximum integer value enum nn (nn : value of an integer) : enum value for nn unit : unit definition for a real.

        Parameters
        ----------
        name: char *
        part: char *

        Returns
        -------
        char *

        """
        return _Interface.Interface_Static_CDef(*args)

    CDef = staticmethod(CDef)

    def CVal(*args) -> "char const *":
        """
        Returns the value of the parameter identified by the string name. if the specified parameter does not exist, an empty string is returned. example interface_static::cval('write.step.schema'); which could return: 'ap214'.

        Parameters
        ----------
        name: char *

        Returns
        -------
        char *

        """
        return _Interface.Interface_Static_CVal(*args)

    CVal = staticmethod(CVal)

    def Family(self, *args) -> "char const *":
        """
        Returns the family. it can be : a resource name for applis, an internal name between : $e (environment variables), $l (other, purely local).

        Returns
        -------
        char *

        """
        return _Interface.Interface_Static_Family(self, *args)


    def IDef(*args) -> "Standard_Integer":
        """
        Returns a part of the definition of a static, as an integer the part is designated by its name, as a cstring if the required value is not a string, returns zero for a boolean, 0 for false, 1 for true if <name> is not present, or <part> not defined for <name>, this function returns zero //! allowed parts for idef : imin, imax : minimum or maximum integer value estart : starting number for enum ecount : count of enum values (starting from estart) ematch : exact match status eval val : case determined from a string.

        Parameters
        ----------
        name: char *
        part: char *

        Returns
        -------
        int

        """
        return _Interface.Interface_Static_IDef(*args)

    IDef = staticmethod(IDef)

    def IVal(*args) -> "Standard_Integer":
        """
        Returns the integer value of the translation parameter identified by the string name. returns the value 0 if the parameter does not exist. example interface_static::ival('write.step.schema'); which could return: 3.

        Parameters
        ----------
        name: char *

        Returns
        -------
        int

        """
        return _Interface.Interface_Static_IVal(*args)

    IVal = staticmethod(IVal)

    def Init(*args) -> "Standard_Boolean":
        """
        Declares a new static (by calling its constructor) if this name is already taken, does nothing and returns false else, creates it and returns true for additional definitions, get the static then edit it.

        Parameters
        ----------
        family: char *
        name: char *
        type: Interface_ParamType
        init: char *,optional
        	default value is 

        Returns
        -------
        bool

        As init with paramtype, but type is given as a character this allows a simpler call types : 'i' integer, 'r' real, 't' text, 'e' enum, 'o' object '=' for same definition as, <init> gives the initial static returns false if <type> does not match this list.

        Parameters
        ----------
        family: char *
        name: char *
        type: Standard_Character
        init: char *,optional
        	default value is 

        Returns
        -------
        bool

        """
        return _Interface.Interface_Static_Init(*args)

    Init = staticmethod(Init)

    def IsPresent(*args) -> "Standard_Boolean":
        """
        Returns true if a static named <name> is present, false else.

        Parameters
        ----------
        name: char *

        Returns
        -------
        bool

        """
        return _Interface.Interface_Static_IsPresent(*args)

    IsPresent = staticmethod(IsPresent)

    def IsSet(*args) -> "Standard_Boolean":
        """
        Returns true if <name> is present and set <proper> true (d) : considers this item only <proper> false : if not set and attached to a wild-card, considers this wild-card.

        Parameters
        ----------
        name: char *
        proper: bool,optional
        	default value is Standard_True

        Returns
        -------
        bool

        """
        return _Interface.Interface_Static_IsSet(*args)

    IsSet = staticmethod(IsSet)

    def IsUpdated(*args) -> "Standard_Boolean":
        """
        Returns the status 'uptodate' from a static returns false if <name> is not present.

        Parameters
        ----------
        name: char *

        Returns
        -------
        bool

        """
        return _Interface.Interface_Static_IsUpdated(*args)

    IsUpdated = staticmethod(IsUpdated)

    def Items(*args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
        """
        Returns a list of names of statics : <mode> = 0 (d) : criter is for family <mode> = 1 : criter is regexp on names, takes final items (ignore wild cards) <mode> = 2 : idem but take only wilded, not final items <mode> = 3 : idem, take all items matching criter idem + 100 : takes only non-updated items idem + 200 : takes only updated items criter empty (d) : returns all names else returns names which match the given criter remark : families beginning by '$' are not listed by criter '' they are listed only by criter '$' //! this allows for instance to set new values after having loaded or reloaded a resource, then to update them as required.

        Parameters
        ----------
        mode: int,optional
        	default value is 0
        criter: char *,optional
        	default value is 

        Returns
        -------
        opencascade::handle<TColStd_HSequenceOfHAsciiString>

        """
        return _Interface.Interface_Static_Items(*args)

    Items = staticmethod(Items)

    def PrintStaticToString(self) -> "std::string":
        """PrintStaticToString(Interface_Static self) -> std::string"""
        return _Interface.Interface_Static_PrintStaticToString(self)


    def RVal(*args) -> "Standard_Real":
        """
        Returns the value of a static translation parameter identified by the string name. returns the value 0.0 if the parameter does not exist.

        Parameters
        ----------
        name: char *

        Returns
        -------
        float

        """
        return _Interface.Interface_Static_RVal(*args)

    RVal = staticmethod(RVal)

    def SetCVal(*args) -> "Standard_Boolean":
        """
        Modifies the value of the parameter identified by name. the modification is specified by the string val. false is returned if the parameter does not exist. example interface_static::setcval ('write.step.schema','ap203') this syntax specifies a switch from the default step 214 mode to step 203 mode.

        Parameters
        ----------
        name: char *
        val: char *

        Returns
        -------
        bool

        """
        return _Interface.Interface_Static_SetCVal(*args)

    SetCVal = staticmethod(SetCVal)

    def SetIVal(*args) -> "Standard_Boolean":
        """
        Modifies the value of the parameter identified by name. the modification is specified by the integer value val. false is returned if the parameter does not exist. example interface_static::setival ('write.step.schema', 3) this syntax specifies a switch from the default step 214 mode to step 203 mode.s.

        Parameters
        ----------
        name: char *
        val: int

        Returns
        -------
        bool

        """
        return _Interface.Interface_Static_SetIVal(*args)

    SetIVal = staticmethod(SetIVal)

    def SetRVal(*args) -> "Standard_Boolean":
        """
        Modifies the value of a translation parameter. false is returned if the parameter does not exist. the modification is specified by the real number value val.

        Parameters
        ----------
        name: char *
        val: float

        Returns
        -------
        bool

        """
        return _Interface.Interface_Static_SetRVal(*args)

    SetRVal = staticmethod(SetRVal)

    def SetUptodate(self, *args) -> "void":
        """
        Records a static has 'uptodate', i.e. its value has been taken into account by a reinitialisation procedure this flag is reset at each successful setvalue.

        Returns
        -------
        None

        """
        return _Interface.Interface_Static_SetUptodate(self, *args)


    def SetWild(self, *args) -> "void":
        """
        Sets a 'wild-card' static : its value will be considered if <self> is not properly set. (reset by set a null one).

        Parameters
        ----------
        wildcard: Interface_Static

        Returns
        -------
        None

        """
        return _Interface.Interface_Static_SetWild(self, *args)


    def Standards(*args) -> "void":
        """
        Initializes all standard static parameters, which can be used by every function. statics specific of a norm or a function must be defined around it.

        Returns
        -------
        None

        """
        return _Interface.Interface_Static_Standards(*args)

    Standards = staticmethod(Standards)

    def Static(*args) -> "opencascade::handle< Interface_Static >":
        """
        Returns a static from its name. null handle if not present.

        Parameters
        ----------
        name: char *

        Returns
        -------
        opencascade::handle<Interface_Static>

        """
        return _Interface.Interface_Static_Static(*args)

    Static = staticmethod(Static)

    def Update(*args) -> "Standard_Boolean":
        """
        Sets a static to be 'uptodate' returns false if <name> is not present this status can be used by a reinitialisation procedure to rerun if a value has been changed.

        Parameters
        ----------
        name: char *

        Returns
        -------
        bool

        """
        return _Interface.Interface_Static_Update(*args)

    Update = staticmethod(Update)

    def UpdatedStatus(self, *args) -> "Standard_Boolean":
        """
        Returns the status 'uptodate'.

        Returns
        -------
        bool

        """
        return _Interface.Interface_Static_UpdatedStatus(self, *args)


    def Wild(self, *args) -> "opencascade::handle< Interface_Static >":
        """
        Returns the wildcard static, which can be (is most often) null.

        Returns
        -------
        opencascade::handle<Interface_Static>

        """
        return _Interface.Interface_Static_Wild(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_Interface_Static_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _Interface.delete_Interface_Static
    __del__ = lambda self: None
Interface_Static_swigregister = _Interface.Interface_Static_swigregister
Interface_Static_swigregister(Interface_Static)

def Interface_Static_CDef(*args) -> "char const *":
    """
    Returns a part of the definition of a static, as a cstring the part is designated by its name, as a cstring if the required value is not a string, it is converted to a cstring then returned if <name> is not present, or <part> not defined for <name>, this function returns an empty string //! allowed parts for cdef : family : the family type : the type ('integer','real','text','enum') label : the label satis : satisfy function name if any rmin : minimum real value rmax : maximum real value imin : minimum integer value imax : maximum integer value enum nn (nn : value of an integer) : enum value for nn unit : unit definition for a real.

    Parameters
    ----------
    name: char *
    part: char *

    Returns
    -------
    char *

    """
    return _Interface.Interface_Static_CDef(*args)

def Interface_Static_CVal(*args) -> "char const *":
    """
    Returns the value of the parameter identified by the string name. if the specified parameter does not exist, an empty string is returned. example interface_static::cval('write.step.schema'); which could return: 'ap214'.

    Parameters
    ----------
    name: char *

    Returns
    -------
    char *

    """
    return _Interface.Interface_Static_CVal(*args)

def Interface_Static_IDef(*args) -> "Standard_Integer":
    """
    Returns a part of the definition of a static, as an integer the part is designated by its name, as a cstring if the required value is not a string, returns zero for a boolean, 0 for false, 1 for true if <name> is not present, or <part> not defined for <name>, this function returns zero //! allowed parts for idef : imin, imax : minimum or maximum integer value estart : starting number for enum ecount : count of enum values (starting from estart) ematch : exact match status eval val : case determined from a string.

    Parameters
    ----------
    name: char *
    part: char *

    Returns
    -------
    int

    """
    return _Interface.Interface_Static_IDef(*args)

def Interface_Static_IVal(*args) -> "Standard_Integer":
    """
    Returns the integer value of the translation parameter identified by the string name. returns the value 0 if the parameter does not exist. example interface_static::ival('write.step.schema'); which could return: 3.

    Parameters
    ----------
    name: char *

    Returns
    -------
    int

    """
    return _Interface.Interface_Static_IVal(*args)

def Interface_Static_Init(*args) -> "Standard_Boolean":
    """
    Declares a new static (by calling its constructor) if this name is already taken, does nothing and returns false else, creates it and returns true for additional definitions, get the static then edit it.

    Parameters
    ----------
    family: char *
    name: char *
    type: Interface_ParamType
    init: char *,optional
    	default value is 

    Returns
    -------
    bool

    As init with paramtype, but type is given as a character this allows a simpler call types : 'i' integer, 'r' real, 't' text, 'e' enum, 'o' object '=' for same definition as, <init> gives the initial static returns false if <type> does not match this list.

    Parameters
    ----------
    family: char *
    name: char *
    type: Standard_Character
    init: char *,optional
    	default value is 

    Returns
    -------
    bool

    """
    return _Interface.Interface_Static_Init(*args)

def Interface_Static_IsPresent(*args) -> "Standard_Boolean":
    """
    Returns true if a static named <name> is present, false else.

    Parameters
    ----------
    name: char *

    Returns
    -------
    bool

    """
    return _Interface.Interface_Static_IsPresent(*args)

def Interface_Static_IsSet(*args) -> "Standard_Boolean":
    """
    Returns true if <name> is present and set <proper> true (d) : considers this item only <proper> false : if not set and attached to a wild-card, considers this wild-card.

    Parameters
    ----------
    name: char *
    proper: bool,optional
    	default value is Standard_True

    Returns
    -------
    bool

    """
    return _Interface.Interface_Static_IsSet(*args)

def Interface_Static_IsUpdated(*args) -> "Standard_Boolean":
    """
    Returns the status 'uptodate' from a static returns false if <name> is not present.

    Parameters
    ----------
    name: char *

    Returns
    -------
    bool

    """
    return _Interface.Interface_Static_IsUpdated(*args)

def Interface_Static_Items(*args) -> "opencascade::handle< TColStd_HSequenceOfHAsciiString >":
    """
    Returns a list of names of statics : <mode> = 0 (d) : criter is for family <mode> = 1 : criter is regexp on names, takes final items (ignore wild cards) <mode> = 2 : idem but take only wilded, not final items <mode> = 3 : idem, take all items matching criter idem + 100 : takes only non-updated items idem + 200 : takes only updated items criter empty (d) : returns all names else returns names which match the given criter remark : families beginning by '$' are not listed by criter '' they are listed only by criter '$' //! this allows for instance to set new values after having loaded or reloaded a resource, then to update them as required.

    Parameters
    ----------
    mode: int,optional
    	default value is 0
    criter: char *,optional
    	default value is 

    Returns
    -------
    opencascade::handle<TColStd_HSequenceOfHAsciiString>

    """
    return _Interface.Interface_Static_Items(*args)

def Interface_Static_RVal(*args) -> "Standard_Real":
    """
    Returns the value of a static translation parameter identified by the string name. returns the value 0.0 if the parameter does not exist.

    Parameters
    ----------
    name: char *

    Returns
    -------
    float

    """
    return _Interface.Interface_Static_RVal(*args)

def Interface_Static_SetCVal(*args) -> "Standard_Boolean":
    """
    Modifies the value of the parameter identified by name. the modification is specified by the string val. false is returned if the parameter does not exist. example interface_static::setcval ('write.step.schema','ap203') this syntax specifies a switch from the default step 214 mode to step 203 mode.

    Parameters
    ----------
    name: char *
    val: char *

    Returns
    -------
    bool

    """
    return _Interface.Interface_Static_SetCVal(*args)

def Interface_Static_SetIVal(*args) -> "Standard_Boolean":
    """
    Modifies the value of the parameter identified by name. the modification is specified by the integer value val. false is returned if the parameter does not exist. example interface_static::setival ('write.step.schema', 3) this syntax specifies a switch from the default step 214 mode to step 203 mode.s.

    Parameters
    ----------
    name: char *
    val: int

    Returns
    -------
    bool

    """
    return _Interface.Interface_Static_SetIVal(*args)

def Interface_Static_SetRVal(*args) -> "Standard_Boolean":
    """
    Modifies the value of a translation parameter. false is returned if the parameter does not exist. the modification is specified by the real number value val.

    Parameters
    ----------
    name: char *
    val: float

    Returns
    -------
    bool

    """
    return _Interface.Interface_Static_SetRVal(*args)

def Interface_Static_Standards(*args) -> "void":
    """
    Initializes all standard static parameters, which can be used by every function. statics specific of a norm or a function must be defined around it.

    Returns
    -------
    None

    """
    return _Interface.Interface_Static_Standards(*args)

def Interface_Static_Static(*args) -> "opencascade::handle< Interface_Static >":
    """
    Returns a static from its name. null handle if not present.

    Parameters
    ----------
    name: char *

    Returns
    -------
    opencascade::handle<Interface_Static>

    """
    return _Interface.Interface_Static_Static(*args)

def Interface_Static_Update(*args) -> "Standard_Boolean":
    """
    Sets a static to be 'uptodate' returns false if <name> is not present this status can be used by a reinitialisation procedure to rerun if a value has been changed.

    Parameters
    ----------
    name: char *

    Returns
    -------
    bool

    """
    return _Interface.Interface_Static_Update(*args)

class Interface_HArray1OfHAsciiString(Interface_Array1OfHAsciiString, OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [Interface_Array1OfHAsciiString, OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_HArray1OfHAsciiString, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface_Array1OfHAsciiString, OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_HArray1OfHAsciiString, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Interface.new_Interface_HArray1OfHAsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Array1(self) -> "Interface_Array1OfHAsciiString const &":
        return _Interface.Interface_HArray1OfHAsciiString_Array1(self)

    def ChangeArray1(self) -> "Interface_Array1OfHAsciiString &":
        return _Interface.Interface_HArray1OfHAsciiString_ChangeArray1(self)


    @staticmethod
    def DownCast(t):
      return Handle_Interface_HArray1OfHAsciiString_DownCast(t)

    __swig_destroy__ = _Interface.delete_Interface_HArray1OfHAsciiString
    __del__ = lambda self: None
Interface_HArray1OfHAsciiString_swigregister = _Interface.Interface_HArray1OfHAsciiString_swigregister
Interface_HArray1OfHAsciiString_swigregister(Interface_HArray1OfHAsciiString)

class Interface_HSequenceOfCheck(Interface_SequenceOfCheck, OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [Interface_SequenceOfCheck, OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Interface_HSequenceOfCheck, name, value)
    __swig_getmethods__ = {}
    for _s in [Interface_SequenceOfCheck, OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Interface_HSequenceOfCheck, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _Interface.new_Interface_HSequenceOfCheck(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Sequence(self) -> "Interface_SequenceOfCheck const &":
        return _Interface.Interface_HSequenceOfCheck_Sequence(self)

    def Append(self, *args) -> "void":
        return _Interface.Interface_HSequenceOfCheck_Append(self, *args)

    def ChangeSequence(self) -> "Interface_SequenceOfCheck &":
        return _Interface.Interface_HSequenceOfCheck_ChangeSequence(self)


    @staticmethod
    def DownCast(t):
      return Handle_Interface_HSequenceOfCheck_DownCast(t)

    __swig_destroy__ = _Interface.delete_Interface_HSequenceOfCheck
    __del__ = lambda self: None
Interface_HSequenceOfCheck_swigregister = _Interface.Interface_HSequenceOfCheck_swigregister
Interface_HSequenceOfCheck_swigregister(Interface_HSequenceOfCheck)



# This file is compatible with both classic and new-style classes.


