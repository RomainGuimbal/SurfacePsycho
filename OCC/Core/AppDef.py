# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
AppDef module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_appdef.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_AppDef')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_AppDef')
    _AppDef = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_AppDef', [dirname(__file__)])
        except ImportError:
            import _AppDef
            return _AppDef
        try:
            _mod = imp.load_module('_AppDef', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _AppDef = swig_import_helper()
    del swig_import_helper
else:
    import _AppDef
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _AppDef.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _AppDef.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _AppDef.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _AppDef.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _AppDef.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _AppDef.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _AppDef.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _AppDef.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _AppDef.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _AppDef.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _AppDef.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _AppDef.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _AppDef.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _AppDef.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _AppDef.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _AppDef.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _AppDef.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _AppDef.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _AppDef.process_exception(error, method_name, class_name)
process_exception = _AppDef.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.math
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Message
import OCC.Core.OSD
import OCC.Core.gp
import OCC.Core.AppParCurves
import OCC.Core.TColgp
import OCC.Core.Approx
import OCC.Core.Adaptor3d
import OCC.Core.Geom
import OCC.Core.GeomAbs
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.AppCont
import OCC.Core.FEmTool
import OCC.Core.PLib

from enum import IntEnum
from OCC.Core.Exception import *




def Handle_AppDef_SmoothCriterion_Create() -> "opencascade::handle< AppDef_SmoothCriterion >":
    return _AppDef.Handle_AppDef_SmoothCriterion_Create()
Handle_AppDef_SmoothCriterion_Create = _AppDef.Handle_AppDef_SmoothCriterion_Create

def Handle_AppDef_SmoothCriterion_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< AppDef_SmoothCriterion >":
    return _AppDef.Handle_AppDef_SmoothCriterion_DownCast(t)
Handle_AppDef_SmoothCriterion_DownCast = _AppDef.Handle_AppDef_SmoothCriterion_DownCast

def Handle_AppDef_SmoothCriterion_IsNull(t: 'opencascade::handle< AppDef_SmoothCriterion > const &') -> "bool":
    return _AppDef.Handle_AppDef_SmoothCriterion_IsNull(t)
Handle_AppDef_SmoothCriterion_IsNull = _AppDef.Handle_AppDef_SmoothCriterion_IsNull

def Handle_AppDef_LinearCriteria_Create() -> "opencascade::handle< AppDef_LinearCriteria >":
    return _AppDef.Handle_AppDef_LinearCriteria_Create()
Handle_AppDef_LinearCriteria_Create = _AppDef.Handle_AppDef_LinearCriteria_Create

def Handle_AppDef_LinearCriteria_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< AppDef_LinearCriteria >":
    return _AppDef.Handle_AppDef_LinearCriteria_DownCast(t)
Handle_AppDef_LinearCriteria_DownCast = _AppDef.Handle_AppDef_LinearCriteria_DownCast

def Handle_AppDef_LinearCriteria_IsNull(t: 'opencascade::handle< AppDef_LinearCriteria > const &') -> "bool":
    return _AppDef.Handle_AppDef_LinearCriteria_IsNull(t)
Handle_AppDef_LinearCriteria_IsNull = _AppDef.Handle_AppDef_LinearCriteria_IsNull

def Handle_AppDef_HArray1OfMultiPointConstraint_Create() -> "opencascade::handle< AppDef_HArray1OfMultiPointConstraint >":
    return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_Create()
Handle_AppDef_HArray1OfMultiPointConstraint_Create = _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_Create

def Handle_AppDef_HArray1OfMultiPointConstraint_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< AppDef_HArray1OfMultiPointConstraint >":
    return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_DownCast(t)
Handle_AppDef_HArray1OfMultiPointConstraint_DownCast = _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_DownCast

def Handle_AppDef_HArray1OfMultiPointConstraint_IsNull(t: 'opencascade::handle< AppDef_HArray1OfMultiPointConstraint > const &') -> "bool":
    return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_IsNull(t)
Handle_AppDef_HArray1OfMultiPointConstraint_IsNull = _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_IsNull
class AppDef_Array1OfMultiPointConstraint(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_Array1OfMultiPointConstraint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_Array1OfMultiPointConstraint, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Array1< AppDef_MultiPointConstraint >::iterator":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_begin(self)

    def end(self) -> "NCollection_Array1< AppDef_MultiPointConstraint >::iterator":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_end(self)

    def cbegin(self) -> "NCollection_Array1< AppDef_MultiPointConstraint >::const_iterator":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_cbegin(self)

    def cend(self) -> "NCollection_Array1< AppDef_MultiPointConstraint >::const_iterator":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_cend(self)

    def __init__(self, *args):
        this = _AppDef.new_AppDef_Array1OfMultiPointConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, theValue: 'AppDef_MultiPointConstraint') -> "void":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_Init(self, theValue)

    def Size(self) -> "Standard_Integer":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_Size(self)

    def Length(self) -> "Standard_Integer":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_Length(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_IsEmpty(self)

    def Lower(self) -> "Standard_Integer":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_Upper(self)

    def IsDeletable(self) -> "Standard_Boolean":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_IsDeletable(self)

    def IsAllocated(self) -> "Standard_Boolean":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_IsAllocated(self)

    def Assign(self, theOther: 'AppDef_Array1OfMultiPointConstraint') -> "NCollection_Array1< AppDef_MultiPointConstraint > &":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_Assign(self, theOther)

    def Move(self, theOther: 'AppDef_Array1OfMultiPointConstraint') -> "NCollection_Array1< AppDef_MultiPointConstraint > &":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_Move(self, theOther)

    def Set(self, *args) -> "NCollection_Array1< AppDef_MultiPointConstraint > &":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_Set(self, *args)

    def First(self) -> "AppDef_MultiPointConstraint const &":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_First(self)

    def ChangeFirst(self) -> "AppDef_MultiPointConstraint &":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_ChangeFirst(self)

    def Last(self) -> "AppDef_MultiPointConstraint const &":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_Last(self)

    def ChangeLast(self) -> "AppDef_MultiPointConstraint &":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "AppDef_MultiPointConstraint const &":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "AppDef_MultiPointConstraint &":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "AppDef_MultiPointConstraint &":
        return _AppDef.AppDef_Array1OfMultiPointConstraint___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'AppDef_MultiPointConstraint') -> "void":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_SetValue(self, theIndex, theItem)

    def Resize(self, theLower: 'Standard_Integer const', theUpper: 'Standard_Integer const', theToCopyData: 'Standard_Boolean const') -> "void":
        return _AppDef.AppDef_Array1OfMultiPointConstraint_Resize(self, theLower, theUpper, theToCopyData)
    __swig_destroy__ = _AppDef.delete_AppDef_Array1OfMultiPointConstraint
    __del__ = lambda self: None

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next

AppDef_Array1OfMultiPointConstraint_swigregister = _AppDef.AppDef_Array1OfMultiPointConstraint_swigregister
AppDef_Array1OfMultiPointConstraint_swigregister(AppDef_Array1OfMultiPointConstraint)

class AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute(OCC.Core.math.math_BFGS):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.math.math_BFGS]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.math.math_BFGS]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        F: math_MultipleVarFunctionWithGradient
        StartingPoint: math_Vector
        Tolerance3d: float
        Tolerance2d: float
        Eps: float
        NbIterations: int,optional
        	default value is 200

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute
    __del__ = lambda self: None
AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute_swigregister = _AppDef.AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute_swigregister
AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute_swigregister(AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute)

class AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.math.math_MultipleVarFunctionWithGradient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.math.math_MultipleVarFunctionWithGradient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Initializes the fields of the function. the approximating curve has <nbpol> control points.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        Parameters: math_Vector
        Knots: TColStd_Array1OfReal
        Mults: TColStd_Array1OfInteger
        NbPol: int

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CurveValue(self, *args) -> "AppParCurves_MultiBSpCurve":
        """
        Returns the multibspcurve approximating the set after computing the value f or grad(f).

        Returns
        -------
        AppParCurves_MultiBSpCurve

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_CurveValue(self, *args)


    def DerivativeFunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        Returns the derivative function matrix used to approximate the multiline.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_DerivativeFunctionMatrix(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        Returns the distance between the multipoint of range ipoint and the curve curveindex.

        Parameters
        ----------
        IPoint: int
        CurveIndex: int

        Returns
        -------
        float

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_Error(self, *args)


    def FirstConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        No available documentation.

        Parameters
        ----------
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        FirstPoint: int

        Returns
        -------
        AppParCurves_Constraint

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_FirstConstraint(self, *args)


    def FunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        Returns the function matrix used to approximate the multiline.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_FunctionMatrix(self, *args)


    def Index(self, *args) -> "math_IntegerVector const &":
        """
        Returns the indexes of the first non null values of a and da. the values are non null from index(ieme point) +1 to index(ieme point) + degree +1.

        Returns
        -------
        math_IntegerVector

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_Index(self, *args)


    def LastConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        No available documentation.

        Parameters
        ----------
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        LastPoint: int

        Returns
        -------
        AppParCurves_Constraint

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_LastConstraint(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        Returns the maximum distance between the points and the multibspcurve.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        Returns the maximum distance between the points and the multibspcurve.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_MaxError3d(self, *args)


    def NewParameters(self, *args) -> "math_Vector const &":
        """
        Returns the new parameters of the multiline.

        Returns
        -------
        math_Vector

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_NewParameters(self, *args)


    def SetFirstLambda(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        l1: float

        Returns
        -------
        None

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_SetFirstLambda(self, *args)


    def SetLastLambda(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        l2: float

        Returns
        -------
        None

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_SetLastLambda(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute
    __del__ = lambda self: None
AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_swigregister = _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_swigregister
AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_swigregister(AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute)

class AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Given a multiline, this algorithm computes the least square resolution using the householder-qr method. if the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. nbpol is the number of control points wanted for the approximating curves. the system to solve is the following: a x = b. where a is the bernstein matrix computed with the parameters, b the points coordinates and x the poles solutions. the matrix a is the same for each coordinate x, y and z and is also the same for each multiline point because they are approximated in parallel(so with the same parameter, only the vector b changes).

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        FirstCons: AppParCurves_Constraint
        LastCons: AppParCurves_Constraint
        Parameters: math_Vector
        NbPol: int

        Returns
        -------
        None

        Initializes the fields of the object.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        FirstCons: AppParCurves_Constraint
        LastCons: AppParCurves_Constraint
        NbPol: int

        Returns
        -------
        None

        Given a multiline, this algorithm computes the least square resolution using the householder-qr method. if the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. deg is the degree wanted for the approximating curves. the system to solve is the following: a x = b. where a is the bspline functions matrix computed with <parameters>, b the points coordinates and x the poles solutions. the matrix a is the same for each coordinate x, y and z and is also the same for each multiline point because they are approximated in parallel(so with the same parameter, only the vector b changes).

        Parameters
        ----------
        SSP: AppDef_MultiLine
        Knots: TColStd_Array1OfReal
        Mults: TColStd_Array1OfInteger
        FirstPoint: int
        LastPoint: int
        FirstCons: AppParCurves_Constraint
        LastCons: AppParCurves_Constraint
        Parameters: math_Vector
        NbPol: int

        Returns
        -------
        None

        Initializes the fields of the object.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        Knots: TColStd_Array1OfReal
        Mults: TColStd_Array1OfInteger
        FirstPoint: int
        LastPoint: int
        FirstCons: AppParCurves_Constraint
        LastCons: AppParCurves_Constraint
        NbPol: int

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def BSplineValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        Returns the result of the approximation, i.e. all the curves. an exception is raised if notdone.

        Returns
        -------
        AppParCurves_MultiBSpCurve

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_BSplineValue(self, *args)


    def BezierValue(self, *args) -> "AppParCurves_MultiCurve":
        """
        Returns the result of the approximation, i.e. all the curves. an exception is raised if notdone.

        Returns
        -------
        AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_BezierValue(self, *args)


    def DerivativeFunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        Returns the derivative function matrix used to approximate the set.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_DerivativeFunctionMatrix(self, *args)


    def Distance(self, *args) -> "math_Matrix const &":
        """
        Returns the distances between the points of the multiline and the approximation curves.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Distance(self, *args)


    def Error(self, *args) -> "void":
        """
        Returns the maximum errors between the multiline and the approximation curves. f is the sum of the square distances.

        Parameters
        ----------

        Returns
        -------
        F: float
        MaxE3d: float
        MaxE2d: float

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Error(self, *args)


    def ErrorGradient(self, *args) -> "void":
        """
        Returns the maximum errors between the multiline and the approximation curves. f is the sum of the square distances. grad is the derivative vector of the function f.

        Parameters
        ----------
        Grad: math_Vector

        Returns
        -------
        F: float
        MaxE3d: float
        MaxE2d: float

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_ErrorGradient(self, *args)


    def FirstLambda(self, *args) -> "Standard_Real":
        """
        Returns the value (p2 - p1)/ v1 if the first point was a tangency point.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_FirstLambda(self, *args)


    def FunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        Returns the function matrix used to approximate the set.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_FunctionMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if all has been correctly done.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_IsDone(self, *args)


    def KIndex(self, *args) -> "math_IntegerVector const &":
        """
        Returns the indexes of the first non null values of a and da. the values are non null from index(ieme point) +1 to index(ieme point) + degree +1.

        Returns
        -------
        math_IntegerVector

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_KIndex(self, *args)


    def LastLambda(self, *args) -> "Standard_Real":
        """
        Returns the value (pn - pn-1)/ vn if the last point was a tangency point.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_LastLambda(self, *args)


    def Perform(self, *args) -> "void":
        """
        Is used after having initialized the fields. the case 'curvaturepoint' is not treated in this method.

        Parameters
        ----------
        Parameters: math_Vector

        Returns
        -------
        None

        Is used after having initialized the fields.

        Parameters
        ----------
        Parameters: math_Vector
        l1: float
        l2: float

        Returns
        -------
        None

        Is used after having initialized the fields. <v1t> is the tangent vector at the first point. <v2t> is the tangent vector at the last point.

        Parameters
        ----------
        Parameters: math_Vector
        V1t: math_Vector
        V2t: math_Vector
        l1: float
        l2: float

        Returns
        -------
        None

        Is used after having initialized the fields. <v1t> is the tangent vector at the first point. <v2t> is the tangent vector at the last point. <v1c> is the tangent vector at the first point. <v2c> is the tangent vector at the last point.

        Parameters
        ----------
        Parameters: math_Vector
        V1t: math_Vector
        V2t: math_Vector
        V1c: math_Vector
        V2c: math_Vector
        l1: float
        l2: float

        Returns
        -------
        None

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Perform(self, *args)


    def Points(self, *args) -> "math_Matrix const &":
        """
        Returns the matrix of points value.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Points(self, *args)


    def Poles(self, *args) -> "math_Matrix const &":
        """
        Returns the matrix of resulting control points value.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Poles(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute
    __del__ = lambda self: None
AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_swigregister = _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_swigregister
AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_swigregister(AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute)

class AppDef_BSplineCompute(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_BSplineCompute, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_BSplineCompute, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        The multiline <line> will be approximated until tolerances will be reached. the approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is true. if <squares> is true, the computation will be done with no iteration at all. //! the multiplicities of the internal knots is set by default.

        Parameters
        ----------
        Line: AppDef_MultiLine
        degreemin: int,optional
        	default value is 4
        degreemax: int,optional
        	default value is 8
        Tolerance3d: float,optional
        	default value is 1.0e-3
        Tolerance2d: float,optional
        	default value is 1.0e-6
        NbIterations: int,optional
        	default value is 5
        cutting: bool,optional
        	default value is Standard_True
        parametrization: Approx_ParametrizationType,optional
        	default value is Approx_ChordLength
        Squares: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        The multiline <line> will be approximated until tolerances will be reached. the approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is true. if <squares> is true, the computation will be done with no iteration at all.

        Parameters
        ----------
        Line: AppDef_MultiLine
        Parameters: math_Vector
        degreemin: int,optional
        	default value is 4
        degreemax: int,optional
        	default value is 8
        Tolerance3d: float,optional
        	default value is 1.0e-03
        Tolerance2d: float,optional
        	default value is 1.0e-06
        NbIterations: int,optional
        	default value is 5
        cutting: bool,optional
        	default value is Standard_True
        Squares: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        Initializes the fields of the algorithm.

        Parameters
        ----------
        Parameters: math_Vector
        degreemin: int,optional
        	default value is 4
        degreemax: int,optional
        	default value is 8
        Tolerance3d: float,optional
        	default value is 1.0e-03
        Tolerance2d: float,optional
        	default value is 1.0e-06
        NbIterations: int,optional
        	default value is 5
        cutting: bool,optional
        	default value is Standard_True
        Squares: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        Initializes the fields of the algorithm.

        Parameters
        ----------
        degreemin: int,optional
        	default value is 4
        degreemax: int,optional
        	default value is 8
        Tolerance3d: float,optional
        	default value is 1.0e-03
        Tolerance2d: float,optional
        	default value is 1.0e-06
        NbIterations: int,optional
        	default value is 5
        cutting: bool,optional
        	default value is Standard_True
        parametrization: Approx_ParametrizationType,optional
        	default value is Approx_ChordLength
        Squares: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_BSplineCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ChangeValue(self, *args) -> "AppParCurves_MultiBSpCurve &":
        """
        Returns the result of the approximation.

        Returns
        -------
        AppParCurves_MultiBSpCurve

        """
        return _AppDef.AppDef_BSplineCompute_ChangeValue(self, *args)


    def Error(self, *args) -> "void":
        """
        Returns the tolerances 2d and 3d of the multibspcurve.

        Parameters
        ----------

        Returns
        -------
        tol3d: float
        tol2d: float

        """
        return _AppDef.AppDef_BSplineCompute_Error(self, *args)


    def Init(self, *args) -> "void":
        """
        Initializes the fields of the algorithm.

        Parameters
        ----------
        degreemin: int,optional
        	default value is 4
        degreemax: int,optional
        	default value is 8
        Tolerance3d: float,optional
        	default value is 1.0e-03
        Tolerance2d: float,optional
        	default value is 1.0e-06
        NbIterations: int,optional
        	default value is 5
        cutting: bool,optional
        	default value is Standard_True
        parametrization: Approx_ParametrizationType,optional
        	default value is Approx_ChordLength
        Squares: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        return _AppDef.AppDef_BSplineCompute_Init(self, *args)


    def Interpol(self, *args) -> "void":
        """
        Constructs an interpolation of the multiline <line> the result will be a c2 curve of degree 3.

        Parameters
        ----------
        Line: AppDef_MultiLine

        Returns
        -------
        None

        """
        return _AppDef.AppDef_BSplineCompute_Interpol(self, *args)


    def IsAllApproximated(self, *args) -> "Standard_Boolean":
        """
        Returns false if at a moment of the approximation, the status noapproximation has been sent by the user when more points were needed.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_BSplineCompute_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args) -> "Standard_Boolean":
        """
        Returns false if the status nopointsadded has been sent.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_BSplineCompute_IsToleranceReached(self, *args)


    def Parameters(self, *args) -> "TColStd_Array1OfReal const &":
        """
        Returns the new parameters of the approximation corresponding to the points of the multibspcurve.

        Returns
        -------
        TColStd_Array1OfReal

        """
        return _AppDef.AppDef_BSplineCompute_Parameters(self, *args)


    def Perform(self, *args) -> "void":
        """
        Runs the algorithm after having initialized the fields.

        Parameters
        ----------
        Line: AppDef_MultiLine

        Returns
        -------
        None

        """
        return _AppDef.AppDef_BSplineCompute_Perform(self, *args)


    def SetConstraints(self, *args) -> "void":
        """
        Changes the first and the last constraint points.

        Parameters
        ----------
        firstC: AppParCurves_Constraint
        lastC: AppParCurves_Constraint

        Returns
        -------
        None

        """
        return _AppDef.AppDef_BSplineCompute_SetConstraints(self, *args)


    def SetContinuity(self, *args) -> "void":
        """
        Sets the continuity of the spline. if c = 2, the spline will be c2.

        Parameters
        ----------
        C: int

        Returns
        -------
        None

        """
        return _AppDef.AppDef_BSplineCompute_SetContinuity(self, *args)


    def SetDegrees(self, *args) -> "void":
        """
        Changes the degrees of the approximation.

        Parameters
        ----------
        degreemin: int
        degreemax: int

        Returns
        -------
        None

        """
        return _AppDef.AppDef_BSplineCompute_SetDegrees(self, *args)


    def SetKnots(self, *args) -> "void":
        """
        The approximation will be done with the set of knots <knots>. the multiplicities will be set with the degree and the desired continuity.

        Parameters
        ----------
        Knots: TColStd_Array1OfReal

        Returns
        -------
        None

        """
        return _AppDef.AppDef_BSplineCompute_SetKnots(self, *args)


    def SetKnotsAndMultiplicities(self, *args) -> "void":
        """
        The approximation will be done with the set of knots <knots> and the multiplicities <mults>.

        Parameters
        ----------
        Knots: TColStd_Array1OfReal
        Mults: TColStd_Array1OfInteger

        Returns
        -------
        None

        """
        return _AppDef.AppDef_BSplineCompute_SetKnotsAndMultiplicities(self, *args)


    def SetParameters(self, *args) -> "void":
        """
        The approximation will begin with the set of parameters <thepar>.

        Parameters
        ----------
        ThePar: math_Vector

        Returns
        -------
        None

        """
        return _AppDef.AppDef_BSplineCompute_SetParameters(self, *args)


    def SetPeriodic(self, *args) -> "void":
        """
        Sets periodic flag. if theperiodic = standard_true, algorith tries to build periodic multicurve using corresponding c1 boundary condition for first and last multipoints. multiline must be closed.

        Parameters
        ----------
        thePeriodic: bool

        Returns
        -------
        None

        """
        return _AppDef.AppDef_BSplineCompute_SetPeriodic(self, *args)


    def SetTolerances(self, *args) -> "void":
        """
        Changes the tolerances of the approximation.

        Parameters
        ----------
        Tolerance3d: float
        Tolerance2d: float

        Returns
        -------
        None

        """
        return _AppDef.AppDef_BSplineCompute_SetTolerances(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        Returns the result of the approximation.

        Returns
        -------
        AppParCurves_MultiBSpCurve

        """
        return _AppDef.AppDef_BSplineCompute_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_BSplineCompute
    __del__ = lambda self: None
AppDef_BSplineCompute_swigregister = _AppDef.AppDef_BSplineCompute_swigregister
AppDef_BSplineCompute_swigregister(AppDef_BSplineCompute)

class AppDef_Compute(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_Compute, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_Compute, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        The multiline <line> will be approximated until tolerances will be reached. the approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is true. if <squares> is true, the computation will be done with no iteration at all.

        Parameters
        ----------
        Line: AppDef_MultiLine
        degreemin: int,optional
        	default value is 4
        degreemax: int,optional
        	default value is 8
        Tolerance3d: float,optional
        	default value is 1.0e-3
        Tolerance2d: float,optional
        	default value is 1.0e-6
        NbIterations: int,optional
        	default value is 5
        cutting: bool,optional
        	default value is Standard_True
        parametrization: Approx_ParametrizationType,optional
        	default value is Approx_ChordLength
        Squares: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        The multiline <line> will be approximated until tolerances will be reached. the approximation will be done from degreemin to degreemax with a cutting if the corresponding boolean is true. if <squares> is true, the computation will be done with no iteration at all.

        Parameters
        ----------
        Line: AppDef_MultiLine
        Parameters: math_Vector
        degreemin: int,optional
        	default value is 4
        degreemax: int,optional
        	default value is 8
        Tolerance3d: float,optional
        	default value is 1.0e-03
        Tolerance2d: float,optional
        	default value is 1.0e-06
        NbIterations: int,optional
        	default value is 5
        cutting: bool,optional
        	default value is Standard_True
        Squares: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        Initializes the fields of the algorithm.

        Parameters
        ----------
        Parameters: math_Vector
        degreemin: int,optional
        	default value is 4
        degreemax: int,optional
        	default value is 8
        Tolerance3d: float,optional
        	default value is 1.0e-03
        Tolerance2d: float,optional
        	default value is 1.0e-06
        NbIterations: int,optional
        	default value is 5
        cutting: bool,optional
        	default value is Standard_True
        Squares: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        Initializes the fields of the algorithm.

        Parameters
        ----------
        degreemin: int,optional
        	default value is 4
        degreemax: int,optional
        	default value is 8
        Tolerance3d: float,optional
        	default value is 1.0e-03
        Tolerance2d: float,optional
        	default value is 1.0e-06
        NbIterations: int,optional
        	default value is 5
        cutting: bool,optional
        	default value is Standard_True
        parametrization: Approx_ParametrizationType,optional
        	default value is Approx_ChordLength
        Squares: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_Compute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ChangeValue(self, *args) -> "AppParCurves_MultiCurve &":
        """
        Returns the result of the approximation.

        Parameters
        ----------
        Index: int,optional
        	default value is 1

        Returns
        -------
        AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_Compute_ChangeValue(self, *args)


    def Error(self, *args) -> "void":
        """
        Returns the tolerances 2d and 3d of the <index> multicurve.

        Parameters
        ----------
        Index: int

        Returns
        -------
        tol3d: float
        tol2d: float

        """
        return _AppDef.AppDef_Compute_Error(self, *args)


    def Init(self, *args) -> "void":
        """
        Initializes the fields of the algorithm.

        Parameters
        ----------
        degreemin: int,optional
        	default value is 4
        degreemax: int,optional
        	default value is 8
        Tolerance3d: float,optional
        	default value is 1.0e-03
        Tolerance2d: float,optional
        	default value is 1.0e-06
        NbIterations: int,optional
        	default value is 5
        cutting: bool,optional
        	default value is Standard_True
        parametrization: Approx_ParametrizationType,optional
        	default value is Approx_ChordLength
        Squares: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        return _AppDef.AppDef_Compute_Init(self, *args)


    def IsAllApproximated(self, *args) -> "Standard_Boolean":
        """
        Returns false if at a moment of the approximation, the status noapproximation has been sent by the user when more points were needed.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_Compute_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args) -> "Standard_Boolean":
        """
        Returns false if the status nopointsadded has been sent.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_Compute_IsToleranceReached(self, *args)


    def NbMultiCurves(self, *args) -> "Standard_Integer":
        """
        Returns the number of multicurve doing the approximation of the multiline.

        Returns
        -------
        int

        """
        return _AppDef.AppDef_Compute_NbMultiCurves(self, *args)


    def Parameters(self, *args) -> "TColStd_Array1OfReal const &":
        """
        Returns the new parameters of the approximation corresponding to the points of the multicurve <index>.

        Parameters
        ----------
        Index: int,optional
        	default value is 1

        Returns
        -------
        TColStd_Array1OfReal

        """
        return _AppDef.AppDef_Compute_Parameters(self, *args)


    def Parametrization(self, *args) -> "Approx_ParametrizationType":
        """
        Returns the type of parametrization.

        Returns
        -------
        Approx_ParametrizationType

        """
        return _AppDef.AppDef_Compute_Parametrization(self, *args)


    def Perform(self, *args) -> "void":
        """
        Runs the algorithm after having initialized the fields.

        Parameters
        ----------
        Line: AppDef_MultiLine

        Returns
        -------
        None

        """
        return _AppDef.AppDef_Compute_Perform(self, *args)


    def SetConstraints(self, *args) -> "void":
        """
        Changes the first and the last constraint points.

        Parameters
        ----------
        firstC: AppParCurves_Constraint
        lastC: AppParCurves_Constraint

        Returns
        -------
        None

        """
        return _AppDef.AppDef_Compute_SetConstraints(self, *args)


    def SetDegrees(self, *args) -> "void":
        """
        Changes the degrees of the approximation.

        Parameters
        ----------
        degreemin: int
        degreemax: int

        Returns
        -------
        None

        """
        return _AppDef.AppDef_Compute_SetDegrees(self, *args)


    def SetTolerances(self, *args) -> "void":
        """
        Changes the tolerances of the approximation.

        Parameters
        ----------
        Tolerance3d: float
        Tolerance2d: float

        Returns
        -------
        None

        """
        return _AppDef.AppDef_Compute_SetTolerances(self, *args)


    def SplineValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        Returns the result of the approximation.

        Returns
        -------
        AppParCurves_MultiBSpCurve

        """
        return _AppDef.AppDef_Compute_SplineValue(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiCurve const &":
        """
        Returns the result of the approximation.

        Parameters
        ----------
        Index: int,optional
        	default value is 1

        Returns
        -------
        AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_Compute_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_Compute
    __del__ = lambda self: None
AppDef_Compute_swigregister = _AppDef.AppDef_Compute_swigregister
AppDef_Compute_swigregister(AppDef_Compute)

class AppDef_Gradient_BFGSOfMyGradientOfCompute(OCC.Core.math.math_BFGS):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.math.math_BFGS]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_Gradient_BFGSOfMyGradientOfCompute, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.math.math_BFGS]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_Gradient_BFGSOfMyGradientOfCompute, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        F: math_MultipleVarFunctionWithGradient
        StartingPoint: math_Vector
        Tolerance3d: float
        Tolerance2d: float
        Eps: float
        NbIterations: int,optional
        	default value is 200

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_Gradient_BFGSOfMyGradientOfCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_Gradient_BFGSOfMyGradientOfCompute
    __del__ = lambda self: None
AppDef_Gradient_BFGSOfMyGradientOfCompute_swigregister = _AppDef.AppDef_Gradient_BFGSOfMyGradientOfCompute_swigregister
AppDef_Gradient_BFGSOfMyGradientOfCompute_swigregister(AppDef_Gradient_BFGSOfMyGradientOfCompute)

class AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute(OCC.Core.math.math_BFGS):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.math.math_BFGS]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.math.math_BFGS]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        F: math_MultipleVarFunctionWithGradient
        StartingPoint: math_Vector
        Tolerance3d: float
        Tolerance2d: float
        Eps: float
        NbIterations: int,optional
        	default value is 200

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute
    __del__ = lambda self: None
AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute_swigregister = _AppDef.AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute_swigregister
AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute_swigregister(AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute)

class AppDef_Gradient_BFGSOfTheGradient(OCC.Core.math.math_BFGS):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.math.math_BFGS]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_Gradient_BFGSOfTheGradient, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.math.math_BFGS]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_Gradient_BFGSOfTheGradient, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        F: math_MultipleVarFunctionWithGradient
        StartingPoint: math_Vector
        Tolerance3d: float
        Tolerance2d: float
        Eps: float
        NbIterations: int,optional
        	default value is 200

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_Gradient_BFGSOfTheGradient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_Gradient_BFGSOfTheGradient
    __del__ = lambda self: None
AppDef_Gradient_BFGSOfTheGradient_swigregister = _AppDef.AppDef_Gradient_BFGSOfTheGradient_swigregister
AppDef_Gradient_BFGSOfTheGradient_swigregister(AppDef_Gradient_BFGSOfTheGradient)

class AppDef_MultiLine(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_MultiLine, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_MultiLine, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an undefined multiline.

        Returns
        -------
        None

        Given the number nbmult of multipointconstraints of this multiline , it initializes all the fields.setvalue must be called in order for the values of the multipoint constraint to be taken into account. an exception is raised if nbmult < 0.

        Parameters
        ----------
        NbMult: int

        Returns
        -------
        None

        Constructs a multiline with an array of multipointconstraints.

        Parameters
        ----------
        tabMultiP: AppDef_Array1OfMultiPointConstraint

        Returns
        -------
        None

        The multiline constructed will have one line of 3d points without their tangencies.

        Parameters
        ----------
        tabP3d: TColgp_Array1OfPnt

        Returns
        -------
        None

        The multiline constructed will have one line of 2d points without their tangencies.

        Parameters
        ----------
        tabP2d: TColgp_Array1OfPnt2d

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_MultiLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DumpToString(self) -> "std::string":
        """DumpToString(AppDef_MultiLine self) -> std::string"""
        return _AppDef.AppDef_MultiLine_DumpToString(self)


    def NbMultiPoints(self, *args) -> "Standard_Integer":
        """
        Returns the number of multipointconstraints of the multiline.

        Returns
        -------
        int

        """
        return _AppDef.AppDef_MultiLine_NbMultiPoints(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        Returns the number of points from multipoints composing the multiline.

        Returns
        -------
        int

        """
        return _AppDef.AppDef_MultiLine_NbPoints(self, *args)


    def SetValue(self, *args) -> "void":
        """
        It sets the multipointconstraint of range index to the value mpoint. an exception is raised if index < 0 or index> mpoint. an exception is raised if the dimensions of the multipoints are different.

        Parameters
        ----------
        Index: int
        MPoint: AppDef_MultiPointConstraint

        Returns
        -------
        None

        """
        return _AppDef.AppDef_MultiLine_SetValue(self, *args)


    def Value(self, *args) -> "AppDef_MultiPointConstraint":
        """
        Returns the multipointconstraint of range index an exception is raised if index<0 or index>mpoint.

        Parameters
        ----------
        Index: int

        Returns
        -------
        AppDef_MultiPointConstraint

        """
        return _AppDef.AppDef_MultiLine_Value(self, *args)


    __repr__ = _dumps_object

    @methodnotwrapped
    def SetParameter(self):
    	pass

    __swig_destroy__ = _AppDef.delete_AppDef_MultiLine
    __del__ = lambda self: None
AppDef_MultiLine_swigregister = _AppDef.AppDef_MultiLine_swigregister
AppDef_MultiLine_swigregister(AppDef_MultiLine)

class AppDef_MultiPointConstraint(OCC.Core.AppParCurves.AppParCurves_MultiPoint):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.AppParCurves.AppParCurves_MultiPoint]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_MultiPointConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.AppParCurves.AppParCurves_MultiPoint]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_MultiPointConstraint, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an undefined multipointconstraint.

        Returns
        -------
        None

        Constructs a set of points used to approximate a multiline. these points can be of 2 or 3 dimensions. points will be initialized with setpoint and setpoint2d.

        Parameters
        ----------
        NbPoints: int
        NbPoints2d: int

        Returns
        -------
        None

        Creates a multipoint only composed of 3d points.

        Parameters
        ----------
        tabP: TColgp_Array1OfPnt

        Returns
        -------
        None

        Creates a multipoint only composed of 2d points.

        Parameters
        ----------
        tabP: TColgp_Array1OfPnt2d

        Returns
        -------
        None

        Constructs a set of points used to approximate a multiline. these points can be of 2 or 3 dimensions. points will be initialized with setpoint and setpoint2d.

        Parameters
        ----------
        tabP: TColgp_Array1OfPnt
        tabP2d: TColgp_Array1OfPnt2d

        Returns
        -------
        None

        Creates a multipointconstraint with a constraint of curvature. an exception is raised if (length of <tabp> + length of <tabp2d> ) is different from (length of <tabvec> + length of <tabvec2d> ) or from (length of <tabcur> + length of <tabcur2d> ).

        Parameters
        ----------
        tabP: TColgp_Array1OfPnt
        tabP2d: TColgp_Array1OfPnt2d
        tabVec: TColgp_Array1OfVec
        tabVec2d: TColgp_Array1OfVec2d
        tabCur: TColgp_Array1OfVec
        tabCur2d: TColgp_Array1OfVec2d

        Returns
        -------
        None

        Creates a multipointconstraint with a constraint of tangency. an exception is raised if (length of <tabp> + length of <tabp2d> ) is different from (length of <tabvec> + length of <tabvec2d> ).

        Parameters
        ----------
        tabP: TColgp_Array1OfPnt
        tabP2d: TColgp_Array1OfPnt2d
        tabVec: TColgp_Array1OfVec
        tabVec2d: TColgp_Array1OfVec2d

        Returns
        -------
        None

        Creates a multipointconstraint only composed of 3d points with constraints of curvature. an exception is raised if the length of tabp is different from the length of tabvec or from tabcur.

        Parameters
        ----------
        tabP: TColgp_Array1OfPnt
        tabVec: TColgp_Array1OfVec
        tabCur: TColgp_Array1OfVec

        Returns
        -------
        None

        Creates a multipointconstraint only composed of 3d points with constraints of tangency. an exception is raised if the length of tabp is different from the length of tabvec.

        Parameters
        ----------
        tabP: TColgp_Array1OfPnt
        tabVec: TColgp_Array1OfVec

        Returns
        -------
        None

        Creates a multipointconstraint only composed of 2d points with constraints of tangency. an exception is raised if the length of tabp is different from the length of tabvec2d.

        Parameters
        ----------
        tabP2d: TColgp_Array1OfPnt2d
        tabVec2d: TColgp_Array1OfVec2d

        Returns
        -------
        None

        Creates a multipointconstraint only composed of 2d points with constraints of curvature. an exception is raised if the length of tabp is different from the length of tabvec2d or from tabcur2d.

        Parameters
        ----------
        tabP2d: TColgp_Array1OfPnt2d
        tabVec2d: TColgp_Array1OfVec2d
        tabCur2d: TColgp_Array1OfVec2d

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_MultiPointConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Curv(self, *args) -> "gp_Vec":
        """
        Returns the normal vector at the point of range index. an exception is raised if index < 0 or if index > number of 3d points.

        Parameters
        ----------
        Index: int

        Returns
        -------
        gp_Vec

        """
        return _AppDef.AppDef_MultiPointConstraint_Curv(self, *args)


    def Curv2d(self, *args) -> "gp_Vec2d":
        """
        Returns the normal vector at the point of range index. an exception is raised if index < 0 or if index > number of 3d points.

        Parameters
        ----------
        Index: int

        Returns
        -------
        gp_Vec2d

        """
        return _AppDef.AppDef_MultiPointConstraint_Curv2d(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(AppDef_MultiPointConstraint self) -> std::string"""
        return _AppDef.AppDef_MultiPointConstraint_DumpToString(self)


    def IsCurvaturePoint(self, *args) -> "Standard_Boolean":
        """
        Returns true if the multipoint has a curvature value.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_MultiPointConstraint_IsCurvaturePoint(self, *args)


    def IsTangencyPoint(self, *args) -> "Standard_Boolean":
        """
        Returns true if the multipoint has a tangency value.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_MultiPointConstraint_IsTangencyPoint(self, *args)


    def SetCurv(self, *args) -> "void":
        """
        Vec sets the value of the normal vector at the point of index index. the norm of the normal vector at the point of position index is set to the normal curvature. an exception is raised if index <0 or if index > number of 3d points. an exception is raised if curv has an incorrect number of dimensions.

        Parameters
        ----------
        Index: int
        Curv: gp_Vec

        Returns
        -------
        None

        """
        return _AppDef.AppDef_MultiPointConstraint_SetCurv(self, *args)


    def SetCurv2d(self, *args) -> "void":
        """
        Vec sets the value of the normal vector at the point of index index. the norm of the normal vector at the point of position index is set to the normal curvature. an exception is raised if index <0 or if index > number of 3d points. an exception is raised if curv has an incorrect number of dimensions.

        Parameters
        ----------
        Index: int
        Curv2d: gp_Vec2d

        Returns
        -------
        None

        """
        return _AppDef.AppDef_MultiPointConstraint_SetCurv2d(self, *args)


    def SetTang(self, *args) -> "void":
        """
        Sets the value of the tangency of the point of range index. an exception is raised if index <0 or if index > number of 3d points. an exception is raised if tang has an incorrect number of dimensions.

        Parameters
        ----------
        Index: int
        Tang: gp_Vec

        Returns
        -------
        None

        """
        return _AppDef.AppDef_MultiPointConstraint_SetTang(self, *args)


    def SetTang2d(self, *args) -> "void":
        """
        Sets the value of the tangency of the point of range index. an exception is raised if index <number of 3d points or if index > total number of points an exception is raised if tang has an incorrect number of dimensions.

        Parameters
        ----------
        Index: int
        Tang2d: gp_Vec2d

        Returns
        -------
        None

        """
        return _AppDef.AppDef_MultiPointConstraint_SetTang2d(self, *args)


    def Tang(self, *args) -> "gp_Vec":
        """
        Returns the tangency value of the point of range index. an exception is raised if index < 0 or if index > number of 3d points.

        Parameters
        ----------
        Index: int

        Returns
        -------
        gp_Vec

        """
        return _AppDef.AppDef_MultiPointConstraint_Tang(self, *args)


    def Tang2d(self, *args) -> "gp_Vec2d":
        """
        Returns the tangency value of the point of range index. an exception is raised if index < number of 3d points or if index > total number of points.

        Parameters
        ----------
        Index: int

        Returns
        -------
        gp_Vec2d

        """
        return _AppDef.AppDef_MultiPointConstraint_Tang2d(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_MultiPointConstraint
    __del__ = lambda self: None
AppDef_MultiPointConstraint_swigregister = _AppDef.AppDef_MultiPointConstraint_swigregister
AppDef_MultiPointConstraint_swigregister(AppDef_MultiPointConstraint)

class AppDef_MyBSplGradientOfBSplineCompute(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_MyBSplGradientOfBSplineCompute, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_MyBSplGradientOfBSplineCompute, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Tries to minimize the sum (square(||qui - bi*pi||)) where pui describe the approximating bspline curves'poles and qi the multiline points with a parameter ui. in this algorithm, the parameters ui are the unknowns. the tolerance required on this sum is given by tol. the desired degree of the resulting curve is deg.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        Parameters: math_Vector
        Knots: TColStd_Array1OfReal
        Mults: TColStd_Array1OfInteger
        Deg: int
        Tol3d: float
        Tol2d: float
        NbIterations: int,optional
        	default value is 1

        Returns
        -------
        None

        Tries to minimize the sum (square(||qui - bi*pi||)) where pui describe the approximating bspline curves'poles and qi the multiline points with a parameter ui. in this algorithm, the parameters ui are the unknowns. the tolerance required on this sum is given by tol. the desired degree of the resulting curve is deg.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        Parameters: math_Vector
        Knots: TColStd_Array1OfReal
        Mults: TColStd_Array1OfInteger
        Deg: int
        Tol3d: float
        Tol2d: float
        NbIterations: int
        lambda1: float
        lambda2: float

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_MyBSplGradientOfBSplineCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AverageError(self, *args) -> "Standard_Real":
        """
        Returns the average error between the old and the new approximation.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_MyBSplGradientOfBSplineCompute_AverageError(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        Returns the difference between the old and the new approximation. an exception is raised if notdone. an exception is raised if index<1 or index>nbparameters.

        Parameters
        ----------
        Index: int

        Returns
        -------
        float

        """
        return _AppDef.AppDef_MyBSplGradientOfBSplineCompute_Error(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if all has been correctly done.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_MyBSplGradientOfBSplineCompute_IsDone(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        Returns the maximum difference between the old and the new approximation.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_MyBSplGradientOfBSplineCompute_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        Returns the maximum difference between the old and the new approximation.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_MyBSplGradientOfBSplineCompute_MaxError3d(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiBSpCurve":
        """
        Returns all the bspline curves approximating the multiline ssp after minimization of the parameter.

        Returns
        -------
        AppParCurves_MultiBSpCurve

        """
        return _AppDef.AppDef_MyBSplGradientOfBSplineCompute_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_MyBSplGradientOfBSplineCompute
    __del__ = lambda self: None
AppDef_MyBSplGradientOfBSplineCompute_swigregister = _AppDef.AppDef_MyBSplGradientOfBSplineCompute_swigregister
AppDef_MyBSplGradientOfBSplineCompute_swigregister(AppDef_MyBSplGradientOfBSplineCompute)

class AppDef_MyGradientOfCompute(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_MyGradientOfCompute, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_MyGradientOfCompute, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Tries to minimize the sum (square(||qui - bi*pi||)) where pui describe the approximating bezier curves'poles and qi the multiline points with a parameter ui. in this algorithm, the parameters ui are the unknowns. the tolerance required on this sum is given by tol. the desired degree of the resulting curve is deg.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        Parameters: math_Vector
        Deg: int
        Tol3d: float
        Tol2d: float
        NbIterations: int,optional
        	default value is 200

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_MyGradientOfCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AverageError(self, *args) -> "Standard_Real":
        """
        Returns the average error between the old and the new approximation.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_MyGradientOfCompute_AverageError(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        Returns the difference between the old and the new approximation. an exception is raised if notdone. an exception is raised if index<1 or index>nbparameters.

        Parameters
        ----------
        Index: int

        Returns
        -------
        float

        """
        return _AppDef.AppDef_MyGradientOfCompute_Error(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if all has been correctly done.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_MyGradientOfCompute_IsDone(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        Returns the maximum difference between the old and the new approximation.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_MyGradientOfCompute_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        Returns the maximum difference between the old and the new approximation.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_MyGradientOfCompute_MaxError3d(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiCurve":
        """
        Returns all the bezier curves approximating the multiline ssp after minimization of the parameter.

        Returns
        -------
        AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_MyGradientOfCompute_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_MyGradientOfCompute
    __del__ = lambda self: None
AppDef_MyGradientOfCompute_swigregister = _AppDef.AppDef_MyGradientOfCompute_swigregister
AppDef_MyGradientOfCompute_swigregister(AppDef_MyGradientOfCompute)

class AppDef_MyGradientbisOfBSplineCompute(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_MyGradientbisOfBSplineCompute, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_MyGradientbisOfBSplineCompute, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Tries to minimize the sum (square(||qui - bi*pi||)) where pui describe the approximating bezier curves'poles and qi the multiline points with a parameter ui. in this algorithm, the parameters ui are the unknowns. the tolerance required on this sum is given by tol. the desired degree of the resulting curve is deg.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        Parameters: math_Vector
        Deg: int
        Tol3d: float
        Tol2d: float
        NbIterations: int,optional
        	default value is 200

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_MyGradientbisOfBSplineCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AverageError(self, *args) -> "Standard_Real":
        """
        Returns the average error between the old and the new approximation.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_MyGradientbisOfBSplineCompute_AverageError(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        Returns the difference between the old and the new approximation. an exception is raised if notdone. an exception is raised if index<1 or index>nbparameters.

        Parameters
        ----------
        Index: int

        Returns
        -------
        float

        """
        return _AppDef.AppDef_MyGradientbisOfBSplineCompute_Error(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if all has been correctly done.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_MyGradientbisOfBSplineCompute_IsDone(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        Returns the maximum difference between the old and the new approximation.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_MyGradientbisOfBSplineCompute_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        Returns the maximum difference between the old and the new approximation.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_MyGradientbisOfBSplineCompute_MaxError3d(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiCurve":
        """
        Returns all the bezier curves approximating the multiline ssp after minimization of the parameter.

        Returns
        -------
        AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_MyGradientbisOfBSplineCompute_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_MyGradientbisOfBSplineCompute
    __del__ = lambda self: None
AppDef_MyGradientbisOfBSplineCompute_swigregister = _AppDef.AppDef_MyGradientbisOfBSplineCompute_swigregister
AppDef_MyGradientbisOfBSplineCompute_swigregister(AppDef_MyGradientbisOfBSplineCompute)

class AppDef_MyLineTool(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_MyLineTool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_MyLineTool, name)
    __repr__ = _swig_repr

    def Curvature(*args) -> "Standard_Boolean":
        """
        Returns the 3d curvatures of the multipoint <mpointindex> when only 3d points exist.

        Parameters
        ----------
        ML: AppDef_MultiLine
        MPointIndex: int
        tabV: TColgp_Array1OfVec

        Returns
        -------
        bool

        Returns the 2d curvatures of the multipoint <mpointindex> only when 2d points exist.

        Parameters
        ----------
        ML: AppDef_MultiLine
        MPointIndex: int
        tabV2d: TColgp_Array1OfVec2d

        Returns
        -------
        bool

        Returns the 3d and 2d curvatures of the multipoint <mpointindex>.

        Parameters
        ----------
        ML: AppDef_MultiLine
        MPointIndex: int
        tabV: TColgp_Array1OfVec
        tabV2d: TColgp_Array1OfVec2d

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_MyLineTool_Curvature(*args)

    Curvature = staticmethod(Curvature)

    def FirstPoint(*args) -> "Standard_Integer":
        """
        Returns the first index of multipoints of the multiline.

        Parameters
        ----------
        ML: AppDef_MultiLine

        Returns
        -------
        int

        """
        return _AppDef.AppDef_MyLineTool_FirstPoint(*args)

    FirstPoint = staticmethod(FirstPoint)

    def LastPoint(*args) -> "Standard_Integer":
        """
        Returns the last index of multipoints of the multiline.

        Parameters
        ----------
        ML: AppDef_MultiLine

        Returns
        -------
        int

        """
        return _AppDef.AppDef_MyLineTool_LastPoint(*args)

    LastPoint = staticmethod(LastPoint)

    def MakeMLBetween(*args) -> "AppDef_MultiLine":
        """
        Is never called in the algorithms. nothing is done.

        Parameters
        ----------
        ML: AppDef_MultiLine
        I1: int
        I2: int
        NbPMin: int

        Returns
        -------
        AppDef_MultiLine

        """
        return _AppDef.AppDef_MyLineTool_MakeMLBetween(*args)

    MakeMLBetween = staticmethod(MakeMLBetween)

    def MakeMLOneMorePoint(*args) -> "Standard_Boolean":
        """
        Is never called in the algorithms. nothing is done.

        Parameters
        ----------
        ML: AppDef_MultiLine
        I1: int
        I2: int
        indbad: int
        OtherLine: AppDef_MultiLine

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_MyLineTool_MakeMLOneMorePoint(*args)

    MakeMLOneMorePoint = staticmethod(MakeMLOneMorePoint)

    def NbP2d(*args) -> "Standard_Integer":
        """
        Returns the number of 2d points of a multiline.

        Parameters
        ----------
        ML: AppDef_MultiLine

        Returns
        -------
        int

        """
        return _AppDef.AppDef_MyLineTool_NbP2d(*args)

    NbP2d = staticmethod(NbP2d)

    def NbP3d(*args) -> "Standard_Integer":
        """
        Returns the number of 3d points of a multiline.

        Parameters
        ----------
        ML: AppDef_MultiLine

        Returns
        -------
        int

        """
        return _AppDef.AppDef_MyLineTool_NbP3d(*args)

    NbP3d = staticmethod(NbP3d)

    def Tangency(*args) -> "Standard_Boolean":
        """
        Returns the 3d points of the multipoint <mpointindex> when only 3d points exist.

        Parameters
        ----------
        ML: AppDef_MultiLine
        MPointIndex: int
        tabV: TColgp_Array1OfVec

        Returns
        -------
        bool

        Returns the 2d tangency points of the multipoint <mpointindex> only when 2d points exist.

        Parameters
        ----------
        ML: AppDef_MultiLine
        MPointIndex: int
        tabV2d: TColgp_Array1OfVec2d

        Returns
        -------
        bool

        Returns the 3d and 2d points of the multipoint <mpointindex>.

        Parameters
        ----------
        ML: AppDef_MultiLine
        MPointIndex: int
        tabV: TColgp_Array1OfVec
        tabV2d: TColgp_Array1OfVec2d

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_MyLineTool_Tangency(*args)

    Tangency = staticmethod(Tangency)

    def Value(*args) -> "void":
        """
        Returns the 3d points of the multipoint <mpointindex> when only 3d points exist.

        Parameters
        ----------
        ML: AppDef_MultiLine
        MPointIndex: int
        tabPt: TColgp_Array1OfPnt

        Returns
        -------
        None

        Returns the 2d points of the multipoint <mpointindex> when only 2d points exist.

        Parameters
        ----------
        ML: AppDef_MultiLine
        MPointIndex: int
        tabPt2d: TColgp_Array1OfPnt2d

        Returns
        -------
        None

        Returns the 3d and 2d points of the multipoint <mpointindex>.

        Parameters
        ----------
        ML: AppDef_MultiLine
        MPointIndex: int
        tabPt: TColgp_Array1OfPnt
        tabPt2d: TColgp_Array1OfPnt2d

        Returns
        -------
        None

        """
        return _AppDef.AppDef_MyLineTool_Value(*args)

    Value = staticmethod(Value)

    def WhatStatus(*args) -> "Approx_Status":
        """
        Returns nopointsadded.

        Parameters
        ----------
        ML: AppDef_MultiLine
        I1: int
        I2: int

        Returns
        -------
        Approx_Status

        """
        return _AppDef.AppDef_MyLineTool_WhatStatus(*args)

    WhatStatus = staticmethod(WhatStatus)

    __repr__ = _dumps_object


    def __init__(self):
        this = _AppDef.new_AppDef_MyLineTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AppDef.delete_AppDef_MyLineTool
    __del__ = lambda self: None
AppDef_MyLineTool_swigregister = _AppDef.AppDef_MyLineTool_swigregister
AppDef_MyLineTool_swigregister(AppDef_MyLineTool)

def AppDef_MyLineTool_Curvature(*args) -> "Standard_Boolean":
    """
    Returns the 3d curvatures of the multipoint <mpointindex> when only 3d points exist.

    Parameters
    ----------
    ML: AppDef_MultiLine
    MPointIndex: int
    tabV: TColgp_Array1OfVec

    Returns
    -------
    bool

    Returns the 2d curvatures of the multipoint <mpointindex> only when 2d points exist.

    Parameters
    ----------
    ML: AppDef_MultiLine
    MPointIndex: int
    tabV2d: TColgp_Array1OfVec2d

    Returns
    -------
    bool

    Returns the 3d and 2d curvatures of the multipoint <mpointindex>.

    Parameters
    ----------
    ML: AppDef_MultiLine
    MPointIndex: int
    tabV: TColgp_Array1OfVec
    tabV2d: TColgp_Array1OfVec2d

    Returns
    -------
    bool

    """
    return _AppDef.AppDef_MyLineTool_Curvature(*args)

def AppDef_MyLineTool_FirstPoint(*args) -> "Standard_Integer":
    """
    Returns the first index of multipoints of the multiline.

    Parameters
    ----------
    ML: AppDef_MultiLine

    Returns
    -------
    int

    """
    return _AppDef.AppDef_MyLineTool_FirstPoint(*args)

def AppDef_MyLineTool_LastPoint(*args) -> "Standard_Integer":
    """
    Returns the last index of multipoints of the multiline.

    Parameters
    ----------
    ML: AppDef_MultiLine

    Returns
    -------
    int

    """
    return _AppDef.AppDef_MyLineTool_LastPoint(*args)

def AppDef_MyLineTool_MakeMLBetween(*args) -> "AppDef_MultiLine":
    """
    Is never called in the algorithms. nothing is done.

    Parameters
    ----------
    ML: AppDef_MultiLine
    I1: int
    I2: int
    NbPMin: int

    Returns
    -------
    AppDef_MultiLine

    """
    return _AppDef.AppDef_MyLineTool_MakeMLBetween(*args)

def AppDef_MyLineTool_MakeMLOneMorePoint(*args) -> "Standard_Boolean":
    """
    Is never called in the algorithms. nothing is done.

    Parameters
    ----------
    ML: AppDef_MultiLine
    I1: int
    I2: int
    indbad: int
    OtherLine: AppDef_MultiLine

    Returns
    -------
    bool

    """
    return _AppDef.AppDef_MyLineTool_MakeMLOneMorePoint(*args)

def AppDef_MyLineTool_NbP2d(*args) -> "Standard_Integer":
    """
    Returns the number of 2d points of a multiline.

    Parameters
    ----------
    ML: AppDef_MultiLine

    Returns
    -------
    int

    """
    return _AppDef.AppDef_MyLineTool_NbP2d(*args)

def AppDef_MyLineTool_NbP3d(*args) -> "Standard_Integer":
    """
    Returns the number of 3d points of a multiline.

    Parameters
    ----------
    ML: AppDef_MultiLine

    Returns
    -------
    int

    """
    return _AppDef.AppDef_MyLineTool_NbP3d(*args)

def AppDef_MyLineTool_Tangency(*args) -> "Standard_Boolean":
    """
    Returns the 3d points of the multipoint <mpointindex> when only 3d points exist.

    Parameters
    ----------
    ML: AppDef_MultiLine
    MPointIndex: int
    tabV: TColgp_Array1OfVec

    Returns
    -------
    bool

    Returns the 2d tangency points of the multipoint <mpointindex> only when 2d points exist.

    Parameters
    ----------
    ML: AppDef_MultiLine
    MPointIndex: int
    tabV2d: TColgp_Array1OfVec2d

    Returns
    -------
    bool

    Returns the 3d and 2d points of the multipoint <mpointindex>.

    Parameters
    ----------
    ML: AppDef_MultiLine
    MPointIndex: int
    tabV: TColgp_Array1OfVec
    tabV2d: TColgp_Array1OfVec2d

    Returns
    -------
    bool

    """
    return _AppDef.AppDef_MyLineTool_Tangency(*args)

def AppDef_MyLineTool_Value(*args) -> "void":
    """
    Returns the 3d points of the multipoint <mpointindex> when only 3d points exist.

    Parameters
    ----------
    ML: AppDef_MultiLine
    MPointIndex: int
    tabPt: TColgp_Array1OfPnt

    Returns
    -------
    None

    Returns the 2d points of the multipoint <mpointindex> when only 2d points exist.

    Parameters
    ----------
    ML: AppDef_MultiLine
    MPointIndex: int
    tabPt2d: TColgp_Array1OfPnt2d

    Returns
    -------
    None

    Returns the 3d and 2d points of the multipoint <mpointindex>.

    Parameters
    ----------
    ML: AppDef_MultiLine
    MPointIndex: int
    tabPt: TColgp_Array1OfPnt
    tabPt2d: TColgp_Array1OfPnt2d

    Returns
    -------
    None

    """
    return _AppDef.AppDef_MyLineTool_Value(*args)

def AppDef_MyLineTool_WhatStatus(*args) -> "Approx_Status":
    """
    Returns nopointsadded.

    Parameters
    ----------
    ML: AppDef_MultiLine
    I1: int
    I2: int

    Returns
    -------
    Approx_Status

    """
    return _AppDef.AppDef_MyLineTool_WhatStatus(*args)

class AppDef_ParFunctionOfMyGradientOfCompute(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.math.math_MultipleVarFunctionWithGradient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_ParFunctionOfMyGradientOfCompute, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.math.math_MultipleVarFunctionWithGradient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_ParFunctionOfMyGradientOfCompute, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Initializes the fields of the function. the approximating curve has the desired degree deg.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        Parameters: math_Vector
        Deg: int

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_ParFunctionOfMyGradientOfCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CurveValue(self, *args) -> "AppParCurves_MultiCurve const &":
        """
        Returns the multicurve approximating the set after computing the value f or grad(f).

        Returns
        -------
        AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_CurveValue(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        Returns the distance between the multipoint of range ipoint and the curve curveindex.

        Parameters
        ----------
        IPoint: int
        CurveIndex: int

        Returns
        -------
        float

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_Error(self, *args)


    def FirstConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        No available documentation.

        Parameters
        ----------
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        FirstPoint: int

        Returns
        -------
        AppParCurves_Constraint

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_FirstConstraint(self, *args)


    def LastConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        No available documentation.

        Parameters
        ----------
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        LastPoint: int

        Returns
        -------
        AppParCurves_Constraint

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_LastConstraint(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        Returns the maximum distance between the points and the multicurve.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        Returns the maximum distance between the points and the multicurve.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_MaxError3d(self, *args)


    def NewParameters(self, *args) -> "math_Vector const &":
        """
        Returns the new parameters of the multiline.

        Returns
        -------
        math_Vector

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_NewParameters(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ParFunctionOfMyGradientOfCompute
    __del__ = lambda self: None
AppDef_ParFunctionOfMyGradientOfCompute_swigregister = _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_swigregister
AppDef_ParFunctionOfMyGradientOfCompute_swigregister(AppDef_ParFunctionOfMyGradientOfCompute)

class AppDef_ParFunctionOfMyGradientbisOfBSplineCompute(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.math.math_MultipleVarFunctionWithGradient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_ParFunctionOfMyGradientbisOfBSplineCompute, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.math.math_MultipleVarFunctionWithGradient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_ParFunctionOfMyGradientbisOfBSplineCompute, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Initializes the fields of the function. the approximating curve has the desired degree deg.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        Parameters: math_Vector
        Deg: int

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_ParFunctionOfMyGradientbisOfBSplineCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CurveValue(self, *args) -> "AppParCurves_MultiCurve const &":
        """
        Returns the multicurve approximating the set after computing the value f or grad(f).

        Returns
        -------
        AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_CurveValue(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        Returns the distance between the multipoint of range ipoint and the curve curveindex.

        Parameters
        ----------
        IPoint: int
        CurveIndex: int

        Returns
        -------
        float

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_Error(self, *args)


    def FirstConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        No available documentation.

        Parameters
        ----------
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        FirstPoint: int

        Returns
        -------
        AppParCurves_Constraint

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_FirstConstraint(self, *args)


    def LastConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        No available documentation.

        Parameters
        ----------
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        LastPoint: int

        Returns
        -------
        AppParCurves_Constraint

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_LastConstraint(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        Returns the maximum distance between the points and the multicurve.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        Returns the maximum distance between the points and the multicurve.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_MaxError3d(self, *args)


    def NewParameters(self, *args) -> "math_Vector const &":
        """
        Returns the new parameters of the multiline.

        Returns
        -------
        math_Vector

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_NewParameters(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ParFunctionOfMyGradientbisOfBSplineCompute
    __del__ = lambda self: None
AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_swigregister = _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_swigregister
AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_swigregister(AppDef_ParFunctionOfMyGradientbisOfBSplineCompute)

class AppDef_ParFunctionOfTheGradient(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.math.math_MultipleVarFunctionWithGradient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_ParFunctionOfTheGradient, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.math.math_MultipleVarFunctionWithGradient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_ParFunctionOfTheGradient, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Initializes the fields of the function. the approximating curve has the desired degree deg.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        Parameters: math_Vector
        Deg: int

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_ParFunctionOfTheGradient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CurveValue(self, *args) -> "AppParCurves_MultiCurve const &":
        """
        Returns the multicurve approximating the set after computing the value f or grad(f).

        Returns
        -------
        AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_CurveValue(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        Returns the distance between the multipoint of range ipoint and the curve curveindex.

        Parameters
        ----------
        IPoint: int
        CurveIndex: int

        Returns
        -------
        float

        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_Error(self, *args)


    def FirstConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        No available documentation.

        Parameters
        ----------
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        FirstPoint: int

        Returns
        -------
        AppParCurves_Constraint

        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_FirstConstraint(self, *args)


    def LastConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        No available documentation.

        Parameters
        ----------
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        LastPoint: int

        Returns
        -------
        AppParCurves_Constraint

        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_LastConstraint(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        Returns the maximum distance between the points and the multicurve.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        Returns the maximum distance between the points and the multicurve.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_MaxError3d(self, *args)


    def NewParameters(self, *args) -> "math_Vector const &":
        """
        Returns the new parameters of the multiline.

        Returns
        -------
        math_Vector

        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_NewParameters(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ParFunctionOfTheGradient
    __del__ = lambda self: None
AppDef_ParFunctionOfTheGradient_swigregister = _AppDef.AppDef_ParFunctionOfTheGradient_swigregister
AppDef_ParFunctionOfTheGradient_swigregister(AppDef_ParFunctionOfTheGradient)

class AppDef_ParLeastSquareOfMyGradientOfCompute(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_ParLeastSquareOfMyGradientOfCompute, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_ParLeastSquareOfMyGradientOfCompute, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Given a multiline, this algorithm computes the least square resolution using the householder-qr method. if the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. nbpol is the number of control points wanted for the approximating curves. the system to solve is the following: a x = b. where a is the bernstein matrix computed with the parameters, b the points coordinates and x the poles solutions. the matrix a is the same for each coordinate x, y and z and is also the same for each multiline point because they are approximated in parallel(so with the same parameter, only the vector b changes).

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        FirstCons: AppParCurves_Constraint
        LastCons: AppParCurves_Constraint
        Parameters: math_Vector
        NbPol: int

        Returns
        -------
        None

        Initializes the fields of the object.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        FirstCons: AppParCurves_Constraint
        LastCons: AppParCurves_Constraint
        NbPol: int

        Returns
        -------
        None

        Given a multiline, this algorithm computes the least square resolution using the householder-qr method. if the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. deg is the degree wanted for the approximating curves. the system to solve is the following: a x = b. where a is the bspline functions matrix computed with <parameters>, b the points coordinates and x the poles solutions. the matrix a is the same for each coordinate x, y and z and is also the same for each multiline point because they are approximated in parallel(so with the same parameter, only the vector b changes).

        Parameters
        ----------
        SSP: AppDef_MultiLine
        Knots: TColStd_Array1OfReal
        Mults: TColStd_Array1OfInteger
        FirstPoint: int
        LastPoint: int
        FirstCons: AppParCurves_Constraint
        LastCons: AppParCurves_Constraint
        Parameters: math_Vector
        NbPol: int

        Returns
        -------
        None

        Initializes the fields of the object.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        Knots: TColStd_Array1OfReal
        Mults: TColStd_Array1OfInteger
        FirstPoint: int
        LastPoint: int
        FirstCons: AppParCurves_Constraint
        LastCons: AppParCurves_Constraint
        NbPol: int

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_ParLeastSquareOfMyGradientOfCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def BSplineValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        Returns the result of the approximation, i.e. all the curves. an exception is raised if notdone.

        Returns
        -------
        AppParCurves_MultiBSpCurve

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_BSplineValue(self, *args)


    def BezierValue(self, *args) -> "AppParCurves_MultiCurve":
        """
        Returns the result of the approximation, i.e. all the curves. an exception is raised if notdone.

        Returns
        -------
        AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_BezierValue(self, *args)


    def DerivativeFunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        Returns the derivative function matrix used to approximate the set.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_DerivativeFunctionMatrix(self, *args)


    def Distance(self, *args) -> "math_Matrix const &":
        """
        Returns the distances between the points of the multiline and the approximation curves.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Distance(self, *args)


    def Error(self, *args) -> "void":
        """
        Returns the maximum errors between the multiline and the approximation curves. f is the sum of the square distances.

        Parameters
        ----------

        Returns
        -------
        F: float
        MaxE3d: float
        MaxE2d: float

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Error(self, *args)


    def ErrorGradient(self, *args) -> "void":
        """
        Returns the maximum errors between the multiline and the approximation curves. f is the sum of the square distances. grad is the derivative vector of the function f.

        Parameters
        ----------
        Grad: math_Vector

        Returns
        -------
        F: float
        MaxE3d: float
        MaxE2d: float

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_ErrorGradient(self, *args)


    def FirstLambda(self, *args) -> "Standard_Real":
        """
        Returns the value (p2 - p1)/ v1 if the first point was a tangency point.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_FirstLambda(self, *args)


    def FunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        Returns the function matrix used to approximate the set.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_FunctionMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if all has been correctly done.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_IsDone(self, *args)


    def KIndex(self, *args) -> "math_IntegerVector const &":
        """
        Returns the indexes of the first non null values of a and da. the values are non null from index(ieme point) +1 to index(ieme point) + degree +1.

        Returns
        -------
        math_IntegerVector

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_KIndex(self, *args)


    def LastLambda(self, *args) -> "Standard_Real":
        """
        Returns the value (pn - pn-1)/ vn if the last point was a tangency point.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_LastLambda(self, *args)


    def Perform(self, *args) -> "void":
        """
        Is used after having initialized the fields. the case 'curvaturepoint' is not treated in this method.

        Parameters
        ----------
        Parameters: math_Vector

        Returns
        -------
        None

        Is used after having initialized the fields.

        Parameters
        ----------
        Parameters: math_Vector
        l1: float
        l2: float

        Returns
        -------
        None

        Is used after having initialized the fields. <v1t> is the tangent vector at the first point. <v2t> is the tangent vector at the last point.

        Parameters
        ----------
        Parameters: math_Vector
        V1t: math_Vector
        V2t: math_Vector
        l1: float
        l2: float

        Returns
        -------
        None

        Is used after having initialized the fields. <v1t> is the tangent vector at the first point. <v2t> is the tangent vector at the last point. <v1c> is the tangent vector at the first point. <v2c> is the tangent vector at the last point.

        Parameters
        ----------
        Parameters: math_Vector
        V1t: math_Vector
        V2t: math_Vector
        V1c: math_Vector
        V2c: math_Vector
        l1: float
        l2: float

        Returns
        -------
        None

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Perform(self, *args)


    def Points(self, *args) -> "math_Matrix const &":
        """
        Returns the matrix of points value.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Points(self, *args)


    def Poles(self, *args) -> "math_Matrix const &":
        """
        Returns the matrix of resulting control points value.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Poles(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ParLeastSquareOfMyGradientOfCompute
    __del__ = lambda self: None
AppDef_ParLeastSquareOfMyGradientOfCompute_swigregister = _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_swigregister
AppDef_ParLeastSquareOfMyGradientOfCompute_swigregister(AppDef_ParLeastSquareOfMyGradientOfCompute)

class AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Given a multiline, this algorithm computes the least square resolution using the householder-qr method. if the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. nbpol is the number of control points wanted for the approximating curves. the system to solve is the following: a x = b. where a is the bernstein matrix computed with the parameters, b the points coordinates and x the poles solutions. the matrix a is the same for each coordinate x, y and z and is also the same for each multiline point because they are approximated in parallel(so with the same parameter, only the vector b changes).

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        FirstCons: AppParCurves_Constraint
        LastCons: AppParCurves_Constraint
        Parameters: math_Vector
        NbPol: int

        Returns
        -------
        None

        Initializes the fields of the object.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        FirstCons: AppParCurves_Constraint
        LastCons: AppParCurves_Constraint
        NbPol: int

        Returns
        -------
        None

        Given a multiline, this algorithm computes the least square resolution using the householder-qr method. if the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. deg is the degree wanted for the approximating curves. the system to solve is the following: a x = b. where a is the bspline functions matrix computed with <parameters>, b the points coordinates and x the poles solutions. the matrix a is the same for each coordinate x, y and z and is also the same for each multiline point because they are approximated in parallel(so with the same parameter, only the vector b changes).

        Parameters
        ----------
        SSP: AppDef_MultiLine
        Knots: TColStd_Array1OfReal
        Mults: TColStd_Array1OfInteger
        FirstPoint: int
        LastPoint: int
        FirstCons: AppParCurves_Constraint
        LastCons: AppParCurves_Constraint
        Parameters: math_Vector
        NbPol: int

        Returns
        -------
        None

        Initializes the fields of the object.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        Knots: TColStd_Array1OfReal
        Mults: TColStd_Array1OfInteger
        FirstPoint: int
        LastPoint: int
        FirstCons: AppParCurves_Constraint
        LastCons: AppParCurves_Constraint
        NbPol: int

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def BSplineValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        Returns the result of the approximation, i.e. all the curves. an exception is raised if notdone.

        Returns
        -------
        AppParCurves_MultiBSpCurve

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_BSplineValue(self, *args)


    def BezierValue(self, *args) -> "AppParCurves_MultiCurve":
        """
        Returns the result of the approximation, i.e. all the curves. an exception is raised if notdone.

        Returns
        -------
        AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_BezierValue(self, *args)


    def DerivativeFunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        Returns the derivative function matrix used to approximate the set.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_DerivativeFunctionMatrix(self, *args)


    def Distance(self, *args) -> "math_Matrix const &":
        """
        Returns the distances between the points of the multiline and the approximation curves.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Distance(self, *args)


    def Error(self, *args) -> "void":
        """
        Returns the maximum errors between the multiline and the approximation curves. f is the sum of the square distances.

        Parameters
        ----------

        Returns
        -------
        F: float
        MaxE3d: float
        MaxE2d: float

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Error(self, *args)


    def ErrorGradient(self, *args) -> "void":
        """
        Returns the maximum errors between the multiline and the approximation curves. f is the sum of the square distances. grad is the derivative vector of the function f.

        Parameters
        ----------
        Grad: math_Vector

        Returns
        -------
        F: float
        MaxE3d: float
        MaxE2d: float

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_ErrorGradient(self, *args)


    def FirstLambda(self, *args) -> "Standard_Real":
        """
        Returns the value (p2 - p1)/ v1 if the first point was a tangency point.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_FirstLambda(self, *args)


    def FunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        Returns the function matrix used to approximate the set.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_FunctionMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if all has been correctly done.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_IsDone(self, *args)


    def KIndex(self, *args) -> "math_IntegerVector const &":
        """
        Returns the indexes of the first non null values of a and da. the values are non null from index(ieme point) +1 to index(ieme point) + degree +1.

        Returns
        -------
        math_IntegerVector

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_KIndex(self, *args)


    def LastLambda(self, *args) -> "Standard_Real":
        """
        Returns the value (pn - pn-1)/ vn if the last point was a tangency point.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_LastLambda(self, *args)


    def Perform(self, *args) -> "void":
        """
        Is used after having initialized the fields. the case 'curvaturepoint' is not treated in this method.

        Parameters
        ----------
        Parameters: math_Vector

        Returns
        -------
        None

        Is used after having initialized the fields.

        Parameters
        ----------
        Parameters: math_Vector
        l1: float
        l2: float

        Returns
        -------
        None

        Is used after having initialized the fields. <v1t> is the tangent vector at the first point. <v2t> is the tangent vector at the last point.

        Parameters
        ----------
        Parameters: math_Vector
        V1t: math_Vector
        V2t: math_Vector
        l1: float
        l2: float

        Returns
        -------
        None

        Is used after having initialized the fields. <v1t> is the tangent vector at the first point. <v2t> is the tangent vector at the last point. <v1c> is the tangent vector at the first point. <v2c> is the tangent vector at the last point.

        Parameters
        ----------
        Parameters: math_Vector
        V1t: math_Vector
        V2t: math_Vector
        V1c: math_Vector
        V2c: math_Vector
        l1: float
        l2: float

        Returns
        -------
        None

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Perform(self, *args)


    def Points(self, *args) -> "math_Matrix const &":
        """
        Returns the matrix of points value.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Points(self, *args)


    def Poles(self, *args) -> "math_Matrix const &":
        """
        Returns the matrix of resulting control points value.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Poles(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute
    __del__ = lambda self: None
AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_swigregister = _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_swigregister
AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_swigregister(AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute)

class AppDef_ParLeastSquareOfTheGradient(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_ParLeastSquareOfTheGradient, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_ParLeastSquareOfTheGradient, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Given a multiline, this algorithm computes the least square resolution using the householder-qr method. if the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. nbpol is the number of control points wanted for the approximating curves. the system to solve is the following: a x = b. where a is the bernstein matrix computed with the parameters, b the points coordinates and x the poles solutions. the matrix a is the same for each coordinate x, y and z and is also the same for each multiline point because they are approximated in parallel(so with the same parameter, only the vector b changes).

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        FirstCons: AppParCurves_Constraint
        LastCons: AppParCurves_Constraint
        Parameters: math_Vector
        NbPol: int

        Returns
        -------
        None

        Initializes the fields of the object.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        FirstCons: AppParCurves_Constraint
        LastCons: AppParCurves_Constraint
        NbPol: int

        Returns
        -------
        None

        Given a multiline, this algorithm computes the least square resolution using the householder-qr method. if the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. deg is the degree wanted for the approximating curves. the system to solve is the following: a x = b. where a is the bspline functions matrix computed with <parameters>, b the points coordinates and x the poles solutions. the matrix a is the same for each coordinate x, y and z and is also the same for each multiline point because they are approximated in parallel(so with the same parameter, only the vector b changes).

        Parameters
        ----------
        SSP: AppDef_MultiLine
        Knots: TColStd_Array1OfReal
        Mults: TColStd_Array1OfInteger
        FirstPoint: int
        LastPoint: int
        FirstCons: AppParCurves_Constraint
        LastCons: AppParCurves_Constraint
        Parameters: math_Vector
        NbPol: int

        Returns
        -------
        None

        Initializes the fields of the object.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        Knots: TColStd_Array1OfReal
        Mults: TColStd_Array1OfInteger
        FirstPoint: int
        LastPoint: int
        FirstCons: AppParCurves_Constraint
        LastCons: AppParCurves_Constraint
        NbPol: int

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_ParLeastSquareOfTheGradient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def BSplineValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        Returns the result of the approximation, i.e. all the curves. an exception is raised if notdone.

        Returns
        -------
        AppParCurves_MultiBSpCurve

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_BSplineValue(self, *args)


    def BezierValue(self, *args) -> "AppParCurves_MultiCurve":
        """
        Returns the result of the approximation, i.e. all the curves. an exception is raised if notdone.

        Returns
        -------
        AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_BezierValue(self, *args)


    def DerivativeFunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        Returns the derivative function matrix used to approximate the set.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_DerivativeFunctionMatrix(self, *args)


    def Distance(self, *args) -> "math_Matrix const &":
        """
        Returns the distances between the points of the multiline and the approximation curves.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_Distance(self, *args)


    def Error(self, *args) -> "void":
        """
        Returns the maximum errors between the multiline and the approximation curves. f is the sum of the square distances.

        Parameters
        ----------

        Returns
        -------
        F: float
        MaxE3d: float
        MaxE2d: float

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_Error(self, *args)


    def ErrorGradient(self, *args) -> "void":
        """
        Returns the maximum errors between the multiline and the approximation curves. f is the sum of the square distances. grad is the derivative vector of the function f.

        Parameters
        ----------
        Grad: math_Vector

        Returns
        -------
        F: float
        MaxE3d: float
        MaxE2d: float

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_ErrorGradient(self, *args)


    def FirstLambda(self, *args) -> "Standard_Real":
        """
        Returns the value (p2 - p1)/ v1 if the first point was a tangency point.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_FirstLambda(self, *args)


    def FunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        Returns the function matrix used to approximate the set.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_FunctionMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if all has been correctly done.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_IsDone(self, *args)


    def KIndex(self, *args) -> "math_IntegerVector const &":
        """
        Returns the indexes of the first non null values of a and da. the values are non null from index(ieme point) +1 to index(ieme point) + degree +1.

        Returns
        -------
        math_IntegerVector

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_KIndex(self, *args)


    def LastLambda(self, *args) -> "Standard_Real":
        """
        Returns the value (pn - pn-1)/ vn if the last point was a tangency point.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_LastLambda(self, *args)


    def Perform(self, *args) -> "void":
        """
        Is used after having initialized the fields. the case 'curvaturepoint' is not treated in this method.

        Parameters
        ----------
        Parameters: math_Vector

        Returns
        -------
        None

        Is used after having initialized the fields.

        Parameters
        ----------
        Parameters: math_Vector
        l1: float
        l2: float

        Returns
        -------
        None

        Is used after having initialized the fields. <v1t> is the tangent vector at the first point. <v2t> is the tangent vector at the last point.

        Parameters
        ----------
        Parameters: math_Vector
        V1t: math_Vector
        V2t: math_Vector
        l1: float
        l2: float

        Returns
        -------
        None

        Is used after having initialized the fields. <v1t> is the tangent vector at the first point. <v2t> is the tangent vector at the last point. <v1c> is the tangent vector at the first point. <v2c> is the tangent vector at the last point.

        Parameters
        ----------
        Parameters: math_Vector
        V1t: math_Vector
        V2t: math_Vector
        V1c: math_Vector
        V2c: math_Vector
        l1: float
        l2: float

        Returns
        -------
        None

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_Perform(self, *args)


    def Points(self, *args) -> "math_Matrix const &":
        """
        Returns the matrix of points value.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_Points(self, *args)


    def Poles(self, *args) -> "math_Matrix const &":
        """
        Returns the matrix of resulting control points value.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_Poles(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_ParLeastSquareOfTheGradient
    __del__ = lambda self: None
AppDef_ParLeastSquareOfTheGradient_swigregister = _AppDef.AppDef_ParLeastSquareOfTheGradient_swigregister
AppDef_ParLeastSquareOfTheGradient_swigregister(AppDef_ParLeastSquareOfTheGradient)

class AppDef_ResConstraintOfMyGradientOfCompute(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_ResConstraintOfMyGradientOfCompute, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_ResConstraintOfMyGradientOfCompute, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Given a multiline ssp with constraints points, this algorithm finds the best curve solution to approximate it. the poles from scurv issued for example from the least squares are used as a guess solution for the uzawa algorithm. the tolerance used in the uzawa algorithms is tolerance. a is the bernstein matrix associated to the multiline and da is the derivative bernstein matrix.(they can come from an approximation with parleastsquare.) the multicurve is modified. new multipoles are given.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        SCurv: AppParCurves_MultiCurve
        FirstPoint: int
        LastPoint: int
        Constraints: AppParCurves_HArray1OfConstraintCouple
        Bern: math_Matrix
        DerivativeBern: math_Matrix
        Tolerance: float,optional
        	default value is 1.0e-10

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_ResConstraintOfMyGradientOfCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ConstraintDerivative(self, *args) -> "math_Matrix const &":
        """
        Returns the derivative of the constraint matrix.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        Parameters: math_Vector
        Deg: int
        DA: math_Matrix

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ResConstraintOfMyGradientOfCompute_ConstraintDerivative(self, *args)


    def ConstraintMatrix(self, *args) -> "math_Matrix const &":
        """
        No available documentation.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ResConstraintOfMyGradientOfCompute_ConstraintMatrix(self, *args)


    def Duale(self, *args) -> "math_Vector const &":
        """
        Returns the duale variables of the system.

        Returns
        -------
        math_Vector

        """
        return _AppDef.AppDef_ResConstraintOfMyGradientOfCompute_Duale(self, *args)


    def InverseMatrix(self, *args) -> "math_Matrix const &":
        """
        Returns the inverse of cont*transposed(cont), where cont is the constraint matrix for the algorithm.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ResConstraintOfMyGradientOfCompute_InverseMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if all has been correctly done.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_ResConstraintOfMyGradientOfCompute_IsDone(self, *args)


    __repr__ = _dumps_object

    @methodnotwrapped
    def Error(self):
    	pass

    __swig_destroy__ = _AppDef.delete_AppDef_ResConstraintOfMyGradientOfCompute
    __del__ = lambda self: None
AppDef_ResConstraintOfMyGradientOfCompute_swigregister = _AppDef.AppDef_ResConstraintOfMyGradientOfCompute_swigregister
AppDef_ResConstraintOfMyGradientOfCompute_swigregister(AppDef_ResConstraintOfMyGradientOfCompute)

class AppDef_ResConstraintOfMyGradientbisOfBSplineCompute(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_ResConstraintOfMyGradientbisOfBSplineCompute, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_ResConstraintOfMyGradientbisOfBSplineCompute, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Given a multiline ssp with constraints points, this algorithm finds the best curve solution to approximate it. the poles from scurv issued for example from the least squares are used as a guess solution for the uzawa algorithm. the tolerance used in the uzawa algorithms is tolerance. a is the bernstein matrix associated to the multiline and da is the derivative bernstein matrix.(they can come from an approximation with parleastsquare.) the multicurve is modified. new multipoles are given.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        SCurv: AppParCurves_MultiCurve
        FirstPoint: int
        LastPoint: int
        Constraints: AppParCurves_HArray1OfConstraintCouple
        Bern: math_Matrix
        DerivativeBern: math_Matrix
        Tolerance: float,optional
        	default value is 1.0e-10

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_ResConstraintOfMyGradientbisOfBSplineCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ConstraintDerivative(self, *args) -> "math_Matrix const &":
        """
        Returns the derivative of the constraint matrix.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        Parameters: math_Vector
        Deg: int
        DA: math_Matrix

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_ConstraintDerivative(self, *args)


    def ConstraintMatrix(self, *args) -> "math_Matrix const &":
        """
        No available documentation.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_ConstraintMatrix(self, *args)


    def Duale(self, *args) -> "math_Vector const &":
        """
        Returns the duale variables of the system.

        Returns
        -------
        math_Vector

        """
        return _AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_Duale(self, *args)


    def InverseMatrix(self, *args) -> "math_Matrix const &":
        """
        Returns the inverse of cont*transposed(cont), where cont is the constraint matrix for the algorithm.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_InverseMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if all has been correctly done.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_IsDone(self, *args)


    __repr__ = _dumps_object

    @methodnotwrapped
    def Error(self):
    	pass

    __swig_destroy__ = _AppDef.delete_AppDef_ResConstraintOfMyGradientbisOfBSplineCompute
    __del__ = lambda self: None
AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_swigregister = _AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_swigregister
AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_swigregister(AppDef_ResConstraintOfMyGradientbisOfBSplineCompute)

class AppDef_ResConstraintOfTheGradient(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_ResConstraintOfTheGradient, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_ResConstraintOfTheGradient, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Given a multiline ssp with constraints points, this algorithm finds the best curve solution to approximate it. the poles from scurv issued for example from the least squares are used as a guess solution for the uzawa algorithm. the tolerance used in the uzawa algorithms is tolerance. a is the bernstein matrix associated to the multiline and da is the derivative bernstein matrix.(they can come from an approximation with parleastsquare.) the multicurve is modified. new multipoles are given.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        SCurv: AppParCurves_MultiCurve
        FirstPoint: int
        LastPoint: int
        Constraints: AppParCurves_HArray1OfConstraintCouple
        Bern: math_Matrix
        DerivativeBern: math_Matrix
        Tolerance: float,optional
        	default value is 1.0e-10

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_ResConstraintOfTheGradient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ConstraintDerivative(self, *args) -> "math_Matrix const &":
        """
        Returns the derivative of the constraint matrix.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        Parameters: math_Vector
        Deg: int
        DA: math_Matrix

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ResConstraintOfTheGradient_ConstraintDerivative(self, *args)


    def ConstraintMatrix(self, *args) -> "math_Matrix const &":
        """
        No available documentation.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ResConstraintOfTheGradient_ConstraintMatrix(self, *args)


    def Duale(self, *args) -> "math_Vector const &":
        """
        Returns the duale variables of the system.

        Returns
        -------
        math_Vector

        """
        return _AppDef.AppDef_ResConstraintOfTheGradient_Duale(self, *args)


    def InverseMatrix(self, *args) -> "math_Matrix const &":
        """
        Returns the inverse of cont*transposed(cont), where cont is the constraint matrix for the algorithm.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_ResConstraintOfTheGradient_InverseMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if all has been correctly done.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_ResConstraintOfTheGradient_IsDone(self, *args)


    __repr__ = _dumps_object

    @methodnotwrapped
    def Error(self):
    	pass

    __swig_destroy__ = _AppDef.delete_AppDef_ResConstraintOfTheGradient
    __del__ = lambda self: None
AppDef_ResConstraintOfTheGradient_swigregister = _AppDef.AppDef_ResConstraintOfTheGradient_swigregister
AppDef_ResConstraintOfTheGradient_swigregister(AppDef_ResConstraintOfTheGradient)

class AppDef_SmoothCriterion(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_SmoothCriterion, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_SmoothCriterion, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AssemblyTable(self, *args) -> "opencascade::handle< FEmTool_HAssemblyTable >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<FEmTool_HAssemblyTable>

        """
        return _AppDef.AppDef_SmoothCriterion_AssemblyTable(self, *args)


    def DependenceTable(self, *args) -> "opencascade::handle< TColStd_HArray2OfInteger >":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<TColStd_HArray2OfInteger>

        """
        return _AppDef.AppDef_SmoothCriterion_DependenceTable(self, *args)


    def ErrorValues(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------

        Returns
        -------
        MaxError: float
        QuadraticError: float
        AverageError: float

        """
        return _AppDef.AppDef_SmoothCriterion_ErrorValues(self, *args)


    def EstLength(self, *args) -> "Standard_Real &":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_SmoothCriterion_EstLength(self, *args)


    def GetCurve(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        C: FEmTool_Curve

        Returns
        -------
        None

        """
        return _AppDef.AppDef_SmoothCriterion_GetCurve(self, *args)


    def GetEstimation(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------

        Returns
        -------
        E1: float
        E2: float
        E3: float

        """
        return _AppDef.AppDef_SmoothCriterion_GetEstimation(self, *args)


    def GetWeight(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------

        Returns
        -------
        QuadraticWeight: float
        QualityWeight: float

        """
        return _AppDef.AppDef_SmoothCriterion_GetWeight(self, *args)


    def Gradient(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        Element: int
        Dimension: int
        G: math_Vector

        Returns
        -------
        None

        """
        return _AppDef.AppDef_SmoothCriterion_Gradient(self, *args)


    def Hessian(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        Element: int
        Dimension1: int
        Dimension2: int
        H: math_Matrix

        Returns
        -------
        None

        """
        return _AppDef.AppDef_SmoothCriterion_Hessian(self, *args)


    def InputVector(self, *args) -> "void":
        """
        Convert the assembly vector in an curve;.

        Parameters
        ----------
        X: math_Vector
        AssTable: FEmTool_HAssemblyTable

        Returns
        -------
        None

        """
        return _AppDef.AppDef_SmoothCriterion_InputVector(self, *args)


    def QualityValues(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Parameters
        ----------
        J1min: float
        J2min: float
        J3min: float

        Returns
        -------
        J1: float
        J2: float
        J3: float

        """
        return _AppDef.AppDef_SmoothCriterion_QualityValues(self, *args)


    def SetCurve(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        C: FEmTool_Curve

        Returns
        -------
        None

        """
        return _AppDef.AppDef_SmoothCriterion_SetCurve(self, *args)


    def SetEstimation(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        E1: float
        E2: float
        E3: float

        Returns
        -------
        None

        """
        return _AppDef.AppDef_SmoothCriterion_SetEstimation(self, *args)


    def SetParameters(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        Parameters: TColStd_HArray1OfReal

        Returns
        -------
        None

        """
        return _AppDef.AppDef_SmoothCriterion_SetParameters(self, *args)


    def SetWeight(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        QuadraticWeight: float
        QualityWeight: float
        percentJ1: float
        percentJ2: float
        percentJ3: float

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        Weight: TColStd_Array1OfReal

        Returns
        -------
        None

        """
        return _AppDef.AppDef_SmoothCriterion_SetWeight(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_AppDef_SmoothCriterion_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_SmoothCriterion
    __del__ = lambda self: None
AppDef_SmoothCriterion_swigregister = _AppDef.AppDef_SmoothCriterion_swigregister
AppDef_SmoothCriterion_swigregister(AppDef_SmoothCriterion)

class AppDef_TheFunction(OCC.Core.math.math_MultipleVarFunctionWithGradient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.math.math_MultipleVarFunctionWithGradient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_TheFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.math.math_MultipleVarFunctionWithGradient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_TheFunction, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Initializes the fields of the function. the approximating curve has the desired degree deg.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        Parameters: math_Vector
        Deg: int

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_TheFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CurveValue(self, *args) -> "AppParCurves_MultiCurve const &":
        """
        Returns the multicurve approximating the set after computing the value f or grad(f).

        Returns
        -------
        AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_TheFunction_CurveValue(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        Returns the distance between the multipoint of range ipoint and the curve curveindex.

        Parameters
        ----------
        IPoint: int
        CurveIndex: int

        Returns
        -------
        float

        """
        return _AppDef.AppDef_TheFunction_Error(self, *args)


    def FirstConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        No available documentation.

        Parameters
        ----------
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        FirstPoint: int

        Returns
        -------
        AppParCurves_Constraint

        """
        return _AppDef.AppDef_TheFunction_FirstConstraint(self, *args)


    def LastConstraint(self, *args) -> "AppParCurves_Constraint":
        """
        No available documentation.

        Parameters
        ----------
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        LastPoint: int

        Returns
        -------
        AppParCurves_Constraint

        """
        return _AppDef.AppDef_TheFunction_LastConstraint(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        Returns the maximum distance between the points and the multicurve.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_TheFunction_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        Returns the maximum distance between the points and the multicurve.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_TheFunction_MaxError3d(self, *args)


    def NewParameters(self, *args) -> "math_Vector const &":
        """
        Returns the new parameters of the multiline.

        Returns
        -------
        math_Vector

        """
        return _AppDef.AppDef_TheFunction_NewParameters(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_TheFunction
    __del__ = lambda self: None
AppDef_TheFunction_swigregister = _AppDef.AppDef_TheFunction_swigregister
AppDef_TheFunction_swigregister(AppDef_TheFunction)

class AppDef_TheGradient(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_TheGradient, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_TheGradient, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Tries to minimize the sum (square(||qui - bi*pi||)) where pui describe the approximating bezier curves'poles and qi the multiline points with a parameter ui. in this algorithm, the parameters ui are the unknowns. the tolerance required on this sum is given by tol. the desired degree of the resulting curve is deg.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        Parameters: math_Vector
        Deg: int
        Tol3d: float
        Tol2d: float
        NbIterations: int,optional
        	default value is 200

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_TheGradient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AverageError(self, *args) -> "Standard_Real":
        """
        Returns the average error between the old and the new approximation.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_TheGradient_AverageError(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        Returns the difference between the old and the new approximation. an exception is raised if notdone. an exception is raised if index<1 or index>nbparameters.

        Parameters
        ----------
        Index: int

        Returns
        -------
        float

        """
        return _AppDef.AppDef_TheGradient_Error(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if all has been correctly done.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_TheGradient_IsDone(self, *args)


    def MaxError2d(self, *args) -> "Standard_Real":
        """
        Returns the maximum difference between the old and the new approximation.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_TheGradient_MaxError2d(self, *args)


    def MaxError3d(self, *args) -> "Standard_Real":
        """
        Returns the maximum difference between the old and the new approximation.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_TheGradient_MaxError3d(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiCurve":
        """
        Returns all the bezier curves approximating the multiline ssp after minimization of the parameter.

        Returns
        -------
        AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_TheGradient_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_TheGradient
    __del__ = lambda self: None
AppDef_TheGradient_swigregister = _AppDef.AppDef_TheGradient_swigregister
AppDef_TheGradient_swigregister(AppDef_TheGradient)

class AppDef_TheLeastSquares(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_TheLeastSquares, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_TheLeastSquares, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Given a multiline, this algorithm computes the least square resolution using the householder-qr method. if the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. nbpol is the number of control points wanted for the approximating curves. the system to solve is the following: a x = b. where a is the bernstein matrix computed with the parameters, b the points coordinates and x the poles solutions. the matrix a is the same for each coordinate x, y and z and is also the same for each multiline point because they are approximated in parallel(so with the same parameter, only the vector b changes).

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        FirstCons: AppParCurves_Constraint
        LastCons: AppParCurves_Constraint
        Parameters: math_Vector
        NbPol: int

        Returns
        -------
        None

        Initializes the fields of the object.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        FirstCons: AppParCurves_Constraint
        LastCons: AppParCurves_Constraint
        NbPol: int

        Returns
        -------
        None

        Given a multiline, this algorithm computes the least square resolution using the householder-qr method. if the first and/or the last point is a constraint point, the value of the tangency or curvature is computed in the resolution. deg is the degree wanted for the approximating curves. the system to solve is the following: a x = b. where a is the bspline functions matrix computed with <parameters>, b the points coordinates and x the poles solutions. the matrix a is the same for each coordinate x, y and z and is also the same for each multiline point because they are approximated in parallel(so with the same parameter, only the vector b changes).

        Parameters
        ----------
        SSP: AppDef_MultiLine
        Knots: TColStd_Array1OfReal
        Mults: TColStd_Array1OfInteger
        FirstPoint: int
        LastPoint: int
        FirstCons: AppParCurves_Constraint
        LastCons: AppParCurves_Constraint
        Parameters: math_Vector
        NbPol: int

        Returns
        -------
        None

        Initializes the fields of the object.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        Knots: TColStd_Array1OfReal
        Mults: TColStd_Array1OfInteger
        FirstPoint: int
        LastPoint: int
        FirstCons: AppParCurves_Constraint
        LastCons: AppParCurves_Constraint
        NbPol: int

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_TheLeastSquares(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def BSplineValue(self, *args) -> "AppParCurves_MultiBSpCurve const &":
        """
        Returns the result of the approximation, i.e. all the curves. an exception is raised if notdone.

        Returns
        -------
        AppParCurves_MultiBSpCurve

        """
        return _AppDef.AppDef_TheLeastSquares_BSplineValue(self, *args)


    def BezierValue(self, *args) -> "AppParCurves_MultiCurve":
        """
        Returns the result of the approximation, i.e. all the curves. an exception is raised if notdone.

        Returns
        -------
        AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_TheLeastSquares_BezierValue(self, *args)


    def DerivativeFunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        Returns the derivative function matrix used to approximate the set.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_TheLeastSquares_DerivativeFunctionMatrix(self, *args)


    def Distance(self, *args) -> "math_Matrix const &":
        """
        Returns the distances between the points of the multiline and the approximation curves.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_TheLeastSquares_Distance(self, *args)


    def Error(self, *args) -> "void":
        """
        Returns the maximum errors between the multiline and the approximation curves. f is the sum of the square distances.

        Parameters
        ----------

        Returns
        -------
        F: float
        MaxE3d: float
        MaxE2d: float

        """
        return _AppDef.AppDef_TheLeastSquares_Error(self, *args)


    def ErrorGradient(self, *args) -> "void":
        """
        Returns the maximum errors between the multiline and the approximation curves. f is the sum of the square distances. grad is the derivative vector of the function f.

        Parameters
        ----------
        Grad: math_Vector

        Returns
        -------
        F: float
        MaxE3d: float
        MaxE2d: float

        """
        return _AppDef.AppDef_TheLeastSquares_ErrorGradient(self, *args)


    def FirstLambda(self, *args) -> "Standard_Real":
        """
        Returns the value (p2 - p1)/ v1 if the first point was a tangency point.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_TheLeastSquares_FirstLambda(self, *args)


    def FunctionMatrix(self, *args) -> "math_Matrix const &":
        """
        Returns the function matrix used to approximate the set.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_TheLeastSquares_FunctionMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if all has been correctly done.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_TheLeastSquares_IsDone(self, *args)


    def KIndex(self, *args) -> "math_IntegerVector const &":
        """
        Returns the indexes of the first non null values of a and da. the values are non null from index(ieme point) +1 to index(ieme point) + degree +1.

        Returns
        -------
        math_IntegerVector

        """
        return _AppDef.AppDef_TheLeastSquares_KIndex(self, *args)


    def LastLambda(self, *args) -> "Standard_Real":
        """
        Returns the value (pn - pn-1)/ vn if the last point was a tangency point.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_TheLeastSquares_LastLambda(self, *args)


    def Perform(self, *args) -> "void":
        """
        Is used after having initialized the fields. the case 'curvaturepoint' is not treated in this method.

        Parameters
        ----------
        Parameters: math_Vector

        Returns
        -------
        None

        Is used after having initialized the fields.

        Parameters
        ----------
        Parameters: math_Vector
        l1: float
        l2: float

        Returns
        -------
        None

        Is used after having initialized the fields. <v1t> is the tangent vector at the first point. <v2t> is the tangent vector at the last point.

        Parameters
        ----------
        Parameters: math_Vector
        V1t: math_Vector
        V2t: math_Vector
        l1: float
        l2: float

        Returns
        -------
        None

        Is used after having initialized the fields. <v1t> is the tangent vector at the first point. <v2t> is the tangent vector at the last point. <v1c> is the tangent vector at the first point. <v2c> is the tangent vector at the last point.

        Parameters
        ----------
        Parameters: math_Vector
        V1t: math_Vector
        V2t: math_Vector
        V1c: math_Vector
        V2c: math_Vector
        l1: float
        l2: float

        Returns
        -------
        None

        """
        return _AppDef.AppDef_TheLeastSquares_Perform(self, *args)


    def Points(self, *args) -> "math_Matrix const &":
        """
        Returns the matrix of points value.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_TheLeastSquares_Points(self, *args)


    def Poles(self, *args) -> "math_Matrix const &":
        """
        Returns the matrix of resulting control points value.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_TheLeastSquares_Poles(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_TheLeastSquares
    __del__ = lambda self: None
AppDef_TheLeastSquares_swigregister = _AppDef.AppDef_TheLeastSquares_swigregister
AppDef_TheLeastSquares_swigregister(AppDef_TheLeastSquares)

class AppDef_TheResol(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_TheResol, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_TheResol, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Given a multiline ssp with constraints points, this algorithm finds the best curve solution to approximate it. the poles from scurv issued for example from the least squares are used as a guess solution for the uzawa algorithm. the tolerance used in the uzawa algorithms is tolerance. a is the bernstein matrix associated to the multiline and da is the derivative bernstein matrix.(they can come from an approximation with parleastsquare.) the multicurve is modified. new multipoles are given.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        SCurv: AppParCurves_MultiCurve
        FirstPoint: int
        LastPoint: int
        Constraints: AppParCurves_HArray1OfConstraintCouple
        Bern: math_Matrix
        DerivativeBern: math_Matrix
        Tolerance: float,optional
        	default value is 1.0e-10

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_TheResol(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ConstraintDerivative(self, *args) -> "math_Matrix const &":
        """
        Returns the derivative of the constraint matrix.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        Parameters: math_Vector
        Deg: int
        DA: math_Matrix

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_TheResol_ConstraintDerivative(self, *args)


    def ConstraintMatrix(self, *args) -> "math_Matrix const &":
        """
        No available documentation.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_TheResol_ConstraintMatrix(self, *args)


    def Duale(self, *args) -> "math_Vector const &":
        """
        Returns the duale variables of the system.

        Returns
        -------
        math_Vector

        """
        return _AppDef.AppDef_TheResol_Duale(self, *args)


    def InverseMatrix(self, *args) -> "math_Matrix const &":
        """
        Returns the inverse of cont*transposed(cont), where cont is the constraint matrix for the algorithm.

        Returns
        -------
        math_Matrix

        """
        return _AppDef.AppDef_TheResol_InverseMatrix(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if all has been correctly done.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_TheResol_IsDone(self, *args)


    __repr__ = _dumps_object

    @methodnotwrapped
    def Error(self):
    	pass

    __swig_destroy__ = _AppDef.delete_AppDef_TheResol
    __del__ = lambda self: None
AppDef_TheResol_swigregister = _AppDef.AppDef_TheResol_swigregister
AppDef_TheResol_swigregister(AppDef_TheResol)

class AppDef_Variational(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_Variational, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_Variational, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Constructor. initialization of the fields. warning : nc0 : number of passagepoint consraints nc2 : number of tangencypoint constraints nc3 : number of curvaturepoint constraints if ((maxdegree-continuity)*maxsegment -nc0 - 2*nc1 -3*nc2) is negative the problem is over-constrained. //! limitation : the multiline from appdef has to be composed by only one line ( dimension 2 or 3).

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int
        TheConstraints: AppParCurves_HArray1OfConstraintCouple
        MaxDegree: int,optional
        	default value is 14
        MaxSegment: int,optional
        	default value is 100
        Continuity: GeomAbs_Shape,optional
        	default value is GeomAbs_C2
        WithMinMax: bool,optional
        	default value is Standard_False
        WithCutting: bool,optional
        	default value is Standard_True
        Tolerance: float,optional
        	default value is 1.0
        NbIterations: int,optional
        	default value is 2

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_Variational(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Approximate(self, *args) -> "void":
        """
        Makes the approximation with the current fields.

        Returns
        -------
        None

        """
        return _AppDef.AppDef_Variational_Approximate(self, *args)


    def AverageError(self, *args) -> "Standard_Real":
        """
        Returns the average error between the multiline from appdef and the approximation.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_Variational_AverageError(self, *args)


    def Continuity(self, *args) -> "GeomAbs_Shape":
        """
        Returns the continuity used in the approximation.

        Returns
        -------
        GeomAbs_Shape

        """
        return _AppDef.AppDef_Variational_Continuity(self, *args)


    def Criterium(self, *args) -> "void":
        """
        Returns the values of the quality criterium.

        Parameters
        ----------

        Returns
        -------
        VFirstOrder: float
        VSecondOrder: float
        VThirdOrder: float

        """
        return _AppDef.AppDef_Variational_Criterium(self, *args)


    def CriteriumWeight(self, *args) -> "void":
        """
        Returns the weights (as percent) associed to the criterium used in the optimization.

        Parameters
        ----------

        Returns
        -------
        Percent1: float
        Percent2: float
        Percent3: float

        """
        return _AppDef.AppDef_Variational_CriteriumWeight(self, *args)


    def Distance(self, *args) -> "void":
        """
        Returns the distances between the points of the multiline and the approximation curves.

        Parameters
        ----------
        mat: math_Matrix

        Returns
        -------
        None

        """
        return _AppDef.AppDef_Variational_Distance(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(AppDef_Variational self) -> std::string"""
        return _AppDef.AppDef_Variational_DumpToString(self)


    def IsCreated(self, *args) -> "Standard_Boolean":
        """
        Returns true if the creation is done and correspond to the current fields.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_Variational_IsCreated(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the approximation is ok and correspond to the current fields.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_Variational_IsDone(self, *args)


    def IsOverConstrained(self, *args) -> "Standard_Boolean":
        """
        Returns true if the problem is overconstrained in this case, approximation cannot be done.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_Variational_IsOverConstrained(self, *args)


    def Knots(self, *args) -> "opencascade::handle< TColStd_HArray1OfReal > const &":
        """
        Returns the knots uses to the approximations.

        Returns
        -------
        opencascade::handle<TColStd_HArray1OfReal>

        """
        return _AppDef.AppDef_Variational_Knots(self, *args)


    def MaxDegree(self, *args) -> "Standard_Integer":
        """
        Returns the maximum degree used in the approximation.

        Returns
        -------
        int

        """
        return _AppDef.AppDef_Variational_MaxDegree(self, *args)


    def MaxError(self, *args) -> "Standard_Real":
        """
        Returns the maximum of the distances between the points of the multiline and the approximation curves.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_Variational_MaxError(self, *args)


    def MaxErrorIndex(self, *args) -> "Standard_Integer":
        """
        Returns the index of the multipoint of errormax.

        Returns
        -------
        int

        """
        return _AppDef.AppDef_Variational_MaxErrorIndex(self, *args)


    def MaxSegment(self, *args) -> "Standard_Integer":
        """
        Returns the maximum of segment used in the approximation.

        Returns
        -------
        int

        """
        return _AppDef.AppDef_Variational_MaxSegment(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        Returns the number of iterations used in the approximation.

        Returns
        -------
        int

        """
        return _AppDef.AppDef_Variational_NbIterations(self, *args)


    def Parameters(self, *args) -> "opencascade::handle< TColStd_HArray1OfReal > const &":
        """
        Returns the parameters uses to the approximations.

        Returns
        -------
        opencascade::handle<TColStd_HArray1OfReal>

        """
        return _AppDef.AppDef_Variational_Parameters(self, *args)


    def QuadraticError(self, *args) -> "Standard_Real":
        """
        Returns the quadratic average of the distances between the points of the multiline and the approximation curves.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_Variational_QuadraticError(self, *args)


    def SetConstraints(self, *args) -> "Standard_Boolean":
        """
        Define the constraints to approximate if this value is incompatible with the others fields this method modify nothing and returns false.

        Parameters
        ----------
        aConstrainst: AppParCurves_HArray1OfConstraintCouple

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_Variational_SetConstraints(self, *args)


    def SetContinuity(self, *args) -> "Standard_Boolean":
        """
        Define the continuity used in the approximation if this value is incompatible with the others fields this method modify nothing and returns false.

        Parameters
        ----------
        C: GeomAbs_Shape

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_Variational_SetContinuity(self, *args)


    def SetCriteriumWeight(self, *args) -> "void":
        """
        Define the weights (as percent) associed to the criterium used in the optimization. //! if percent <= 0.

        Parameters
        ----------
        Percent1: float
        Percent2: float
        Percent3: float

        Returns
        -------
        None

        Define the weight (as percent) associed to the criterium order used in the optimization : others weights are updated. if percent < 0 if order < 1 or order > 3.

        Parameters
        ----------
        Order: int
        Percent: float

        Returns
        -------
        None

        """
        return _AppDef.AppDef_Variational_SetCriteriumWeight(self, *args)


    def SetKnots(self, *args) -> "Standard_Boolean":
        """
        Defines the knots used by the approximations if this value is incompatible with the others fields this method modify nothing and returns false.

        Parameters
        ----------
        knots: TColStd_HArray1OfReal

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_Variational_SetKnots(self, *args)


    def SetMaxDegree(self, *args) -> "Standard_Boolean":
        """
        Define the maximum degree used in the approximation if this value is incompatible with the others fields this method modify nothing and returns false.

        Parameters
        ----------
        Degree: int

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_Variational_SetMaxDegree(self, *args)


    def SetMaxSegment(self, *args) -> "Standard_Boolean":
        """
        Define the maximum number of segments used in the approximation if this value is incompatible with the others fields this method modify nothing and returns false.

        Parameters
        ----------
        NbSegment: int

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_Variational_SetMaxSegment(self, *args)


    def SetNbIterations(self, *args) -> "void":
        """
        Define the number of iterations used in the approximation. if iter < 1.

        Parameters
        ----------
        Iter: int

        Returns
        -------
        None

        """
        return _AppDef.AppDef_Variational_SetNbIterations(self, *args)


    def SetParameters(self, *args) -> "void":
        """
        Defines the parameters used by the approximations.

        Parameters
        ----------
        param: TColStd_HArray1OfReal

        Returns
        -------
        None

        """
        return _AppDef.AppDef_Variational_SetParameters(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        Define the tolerance used in the approximation.

        Parameters
        ----------
        Tol: float

        Returns
        -------
        None

        """
        return _AppDef.AppDef_Variational_SetTolerance(self, *args)


    def SetWithCutting(self, *args) -> "Standard_Boolean":
        """
        Define if the approximation can insert new knots or not. if this value is incompatible with the others fields this method modify nothing and returns false.

        Parameters
        ----------
        Cutting: bool

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_Variational_SetWithCutting(self, *args)


    def SetWithMinMax(self, *args) -> "void":
        """
        Define if the approximation search to minimize the maximum error or not.

        Parameters
        ----------
        MinMax: bool

        Returns
        -------
        None

        """
        return _AppDef.AppDef_Variational_SetWithMinMax(self, *args)


    def Tolerance(self, *args) -> "Standard_Real":
        """
        Returns the tolerance used in the approximation.

        Returns
        -------
        float

        """
        return _AppDef.AppDef_Variational_Tolerance(self, *args)


    def Value(self, *args) -> "AppParCurves_MultiBSpCurve":
        """
        Returns all the bspline curves approximating the multiline from appdef ssp after minimization of the parameter.

        Returns
        -------
        AppParCurves_MultiBSpCurve

        """
        return _AppDef.AppDef_Variational_Value(self, *args)


    def WithCutting(self, *args) -> "Standard_Boolean":
        """
        Returns if the approximation can insert new knots or not.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_Variational_WithCutting(self, *args)


    def WithMinMax(self, *args) -> "Standard_Boolean":
        """
        Returns if the approximation search to minimize the maximum error or not.

        Returns
        -------
        bool

        """
        return _AppDef.AppDef_Variational_WithMinMax(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_Variational
    __del__ = lambda self: None
AppDef_Variational_swigregister = _AppDef.AppDef_Variational_swigregister
AppDef_Variational_swigregister(AppDef_Variational)

class AppDef_LinearCriteria(AppDef_SmoothCriterion):
    __swig_setmethods__ = {}
    for _s in [AppDef_SmoothCriterion]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_LinearCriteria, name, value)
    __swig_getmethods__ = {}
    for _s in [AppDef_SmoothCriterion]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_LinearCriteria, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        SSP: AppDef_MultiLine
        FirstPoint: int
        LastPoint: int

        Returns
        -------
        None

        """
        this = _AppDef.new_AppDef_LinearCriteria(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetEstLength(self) -> "Standard_Real":
        """GetEstLength(AppDef_LinearCriteria self) -> Standard_Real"""
        return _AppDef.AppDef_LinearCriteria_GetEstLength(self)


    def SetEstLength(self, value: 'Standard_Real') -> "void":
        """SetEstLength(AppDef_LinearCriteria self, Standard_Real value)"""
        return _AppDef.AppDef_LinearCriteria_SetEstLength(self, value)


    def SetWeight(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        QuadraticWeight: float
        QualityWeight: float
        percentJ1: float
        percentJ2: float
        percentJ3: float

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        Weight: TColStd_Array1OfReal

        Returns
        -------
        None

        """
        return _AppDef.AppDef_LinearCriteria_SetWeight(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_AppDef_LinearCriteria_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _AppDef.delete_AppDef_LinearCriteria
    __del__ = lambda self: None
AppDef_LinearCriteria_swigregister = _AppDef.AppDef_LinearCriteria_swigregister
AppDef_LinearCriteria_swigregister(AppDef_LinearCriteria)

class AppDef_HArray1OfMultiPointConstraint(AppDef_Array1OfMultiPointConstraint, OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [AppDef_Array1OfMultiPointConstraint, OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AppDef_HArray1OfMultiPointConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [AppDef_Array1OfMultiPointConstraint, OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AppDef_HArray1OfMultiPointConstraint, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _AppDef.new_AppDef_HArray1OfMultiPointConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Array1(self) -> "AppDef_Array1OfMultiPointConstraint const &":
        return _AppDef.AppDef_HArray1OfMultiPointConstraint_Array1(self)

    def ChangeArray1(self) -> "AppDef_Array1OfMultiPointConstraint &":
        return _AppDef.AppDef_HArray1OfMultiPointConstraint_ChangeArray1(self)


    @staticmethod
    def DownCast(t):
      return Handle_AppDef_HArray1OfMultiPointConstraint_DownCast(t)

    __swig_destroy__ = _AppDef.delete_AppDef_HArray1OfMultiPointConstraint
    __del__ = lambda self: None
AppDef_HArray1OfMultiPointConstraint_swigregister = _AppDef.AppDef_HArray1OfMultiPointConstraint_swigregister
AppDef_HArray1OfMultiPointConstraint_swigregister(AppDef_HArray1OfMultiPointConstraint)



# This file is compatible with both classic and new-style classes.


