from enum import IntEnum
from typing import overload, NewType, Optional, Tuple

from OCC.Core.Standard import *
from OCC.Core.NCollection import *
from OCC.Core.TColgp import *
from OCC.Core.TColStd import *
from OCC.Core.gp import *

Convert_SequenceOfArray1OfPoles2d = NewType("Convert_SequenceOfArray1OfPoles2d", TColgp_SequenceOfArray1OfPnt2d)

class Convert_SequenceOfArray1OfPoles:
    def __init__(self) -> None: ...
    def __len__(self) -> int: ...
    def Size(self) -> int: ...
    def Clear(self) -> None: ...
    def First(self) -> False: ...
    def Last(self) -> False: ...
    def Length(self) -> int: ...
    def Append(self, theItem: False) -> False: ...
    def Prepend(self, theItem: False) -> False: ...
    def RemoveFirst(self) -> None: ...
    def Reverse(self) -> None: ...
    def Value(self, theIndex: int) -> False: ...
    def SetValue(self, theIndex: int, theValue: False) -> None: ...

class Convert_ParameterisationType(IntEnum):
    Convert_TgtThetaOver2: int = ...
    Convert_TgtThetaOver2_1: int = ...
    Convert_TgtThetaOver2_2: int = ...
    Convert_TgtThetaOver2_3: int = ...
    Convert_TgtThetaOver2_4: int = ...
    Convert_QuasiAngular: int = ...
    Convert_RationalC1: int = ...
    Convert_Polynomial: int = ...

Convert_TgtThetaOver2 = Convert_ParameterisationType.Convert_TgtThetaOver2
Convert_TgtThetaOver2_1 = Convert_ParameterisationType.Convert_TgtThetaOver2_1
Convert_TgtThetaOver2_2 = Convert_ParameterisationType.Convert_TgtThetaOver2_2
Convert_TgtThetaOver2_3 = Convert_ParameterisationType.Convert_TgtThetaOver2_3
Convert_TgtThetaOver2_4 = Convert_ParameterisationType.Convert_TgtThetaOver2_4
Convert_QuasiAngular = Convert_ParameterisationType.Convert_QuasiAngular
Convert_RationalC1 = Convert_ParameterisationType.Convert_RationalC1
Convert_Polynomial = Convert_ParameterisationType.Convert_Polynomial

class Convert_CompBezierCurves2dToBSplineCurve2d:
    def __init__(self, AngularTolerance: Optional[float] = 1.0e-4) -> None: ...
    def AddCurve(self, Poles: TColgp_Array1OfPnt2d) -> None: ...
    def Degree(self) -> int: ...
    def KnotsAndMults(self, Knots: TColStd_Array1OfReal, Mults: TColStd_Array1OfInteger) -> None: ...
    def NbKnots(self) -> int: ...
    def NbPoles(self) -> int: ...
    def Perform(self) -> None: ...
    def Poles(self, Poles: TColgp_Array1OfPnt2d) -> None: ...

class Convert_CompBezierCurvesToBSplineCurve:
    def __init__(self, AngularTolerance: Optional[float] = 1.0e-4) -> None: ...
    def AddCurve(self, Poles: TColgp_Array1OfPnt) -> None: ...
    def Degree(self) -> int: ...
    def KnotsAndMults(self, Knots: TColStd_Array1OfReal, Mults: TColStd_Array1OfInteger) -> None: ...
    def NbKnots(self) -> int: ...
    def NbPoles(self) -> int: ...
    def Perform(self) -> None: ...
    def Poles(self, Poles: TColgp_Array1OfPnt) -> None: ...

class Convert_CompPolynomialToPoles:
    @overload
    def __init__(self, NumCurves: int, Continuity: int, Dimension: int, MaxDegree: int, NumCoeffPerCurve: TColStd_HArray1OfInteger, Coefficients: TColStd_HArray1OfReal, PolynomialIntervals: TColStd_HArray2OfReal, TrueIntervals: TColStd_HArray1OfReal) -> None: ...
    @overload
    def __init__(self, NumCurves: int, Dimension: int, MaxDegree: int, Continuity: TColStd_Array1OfInteger, NumCoeffPerCurve: TColStd_Array1OfInteger, Coefficients: TColStd_Array1OfReal, PolynomialIntervals: TColStd_Array2OfReal, TrueIntervals: TColStd_Array1OfReal) -> None: ...
    @overload
    def __init__(self, Dimension: int, MaxDegree: int, Degree: int, Coefficients: TColStd_Array1OfReal, PolynomialIntervals: TColStd_Array1OfReal, TrueIntervals: TColStd_Array1OfReal) -> None: ...
    def Degree(self) -> int: ...
    def IsDone(self) -> bool: ...
    def Knots(self, K: TColStd_HArray1OfReal) -> None: ...
    def Multiplicities(self, M: TColStd_HArray1OfInteger) -> None: ...
    def NbKnots(self) -> int: ...
    def NbPoles(self) -> int: ...
    def Poles(self, Poles: TColStd_HArray2OfReal) -> None: ...

class Convert_ConicToBSplineCurve:
    @overload
    def BuildCosAndSin(self, Parametrisation: Convert_ParameterisationType, CosNumerator: TColStd_HArray1OfReal, SinNumerator: TColStd_HArray1OfReal, Denominator: TColStd_HArray1OfReal, Knots: TColStd_HArray1OfReal, Mults: TColStd_HArray1OfInteger) -> int: ...
    @overload
    def BuildCosAndSin(self, Parametrisation: Convert_ParameterisationType, UFirst: float, ULast: float, CosNumerator: TColStd_HArray1OfReal, SinNumerator: TColStd_HArray1OfReal, Denominator: TColStd_HArray1OfReal, Knots: TColStd_HArray1OfReal, Mults: TColStd_HArray1OfInteger) -> int: ...
    def Degree(self) -> int: ...
    def IsPeriodic(self) -> bool: ...
    def Knot(self, Index: int) -> float: ...
    def Multiplicity(self, Index: int) -> int: ...
    def NbKnots(self) -> int: ...
    def NbPoles(self) -> int: ...
    def Pole(self, Index: int) -> gp_Pnt2d: ...
    def Weight(self, Index: int) -> float: ...

class Convert_ElementarySurfaceToBSplineSurface:
    def IsUPeriodic(self) -> bool: ...
    def IsVPeriodic(self) -> bool: ...
    def NbUKnots(self) -> int: ...
    def NbUPoles(self) -> int: ...
    def NbVKnots(self) -> int: ...
    def NbVPoles(self) -> int: ...
    def Pole(self, UIndex: int, VIndex: int) -> gp_Pnt: ...
    def UDegree(self) -> int: ...
    def UKnot(self, UIndex: int) -> float: ...
    def UMultiplicity(self, UIndex: int) -> int: ...
    def VDegree(self) -> int: ...
    def VKnot(self, UIndex: int) -> float: ...
    def VMultiplicity(self, VIndex: int) -> int: ...
    def Weight(self, UIndex: int, VIndex: int) -> float: ...

class Convert_GridPolynomialToPoles:
    @overload
    def __init__(self, MaxUDegree: int, MaxVDegree: int, NumCoeff: TColStd_HArray1OfInteger, Coefficients: TColStd_HArray1OfReal, PolynomialUIntervals: TColStd_HArray1OfReal, PolynomialVIntervals: TColStd_HArray1OfReal) -> None: ...
    @overload
    def __init__(self, NbUSurfaces: int, NBVSurfaces: int, UContinuity: int, VContinuity: int, MaxUDegree: int, MaxVDegree: int, NumCoeffPerSurface: TColStd_HArray2OfInteger, Coefficients: TColStd_HArray1OfReal, PolynomialUIntervals: TColStd_HArray1OfReal, PolynomialVIntervals: TColStd_HArray1OfReal, TrueUIntervals: TColStd_HArray1OfReal, TrueVIntervals: TColStd_HArray1OfReal) -> None: ...
    def IsDone(self) -> bool: ...
    def NbUKnots(self) -> int: ...
    def NbUPoles(self) -> int: ...
    def NbVKnots(self) -> int: ...
    def NbVPoles(self) -> int: ...
    def Perform(self, UContinuity: int, VContinuity: int, MaxUDegree: int, MaxVDegree: int, NumCoeffPerSurface: TColStd_HArray2OfInteger, Coefficients: TColStd_HArray1OfReal, PolynomialUIntervals: TColStd_HArray1OfReal, PolynomialVIntervals: TColStd_HArray1OfReal, TrueUIntervals: TColStd_HArray1OfReal, TrueVIntervals: TColStd_HArray1OfReal) -> None: ...
    def Poles(self) -> TColgp_HArray2OfPnt: ...
    def UDegree(self) -> int: ...
    def UKnots(self) -> TColStd_HArray1OfReal: ...
    def UMultiplicities(self) -> TColStd_HArray1OfInteger: ...
    def VDegree(self) -> int: ...
    def VKnots(self) -> TColStd_HArray1OfReal: ...
    def VMultiplicities(self) -> TColStd_HArray1OfInteger: ...

class Convert_CircleToBSplineCurve(Convert_ConicToBSplineCurve):
    @overload
    def __init__(self, C: gp_Circ2d, Parameterisation: Optional[Convert_ParameterisationType] = Convert_TgtThetaOver2) -> None: ...
    @overload
    def __init__(self, C: gp_Circ2d, U1: float, U2: float, Parameterisation: Optional[Convert_ParameterisationType] = Convert_TgtThetaOver2) -> None: ...

class Convert_ConeToBSplineSurface(Convert_ElementarySurfaceToBSplineSurface):
    @overload
    def __init__(self, C: gp_Cone, U1: float, U2: float, V1: float, V2: float) -> None: ...
    @overload
    def __init__(self, C: gp_Cone, V1: float, V2: float) -> None: ...

class Convert_CylinderToBSplineSurface(Convert_ElementarySurfaceToBSplineSurface):
    @overload
    def __init__(self, Cyl: gp_Cylinder, U1: float, U2: float, V1: float, V2: float) -> None: ...
    @overload
    def __init__(self, Cyl: gp_Cylinder, V1: float, V2: float) -> None: ...

class Convert_EllipseToBSplineCurve(Convert_ConicToBSplineCurve):
    @overload
    def __init__(self, E: gp_Elips2d, Parameterisation: Optional[Convert_ParameterisationType] = Convert_TgtThetaOver2) -> None: ...
    @overload
    def __init__(self, E: gp_Elips2d, U1: float, U2: float, Parameterisation: Optional[Convert_ParameterisationType] = Convert_TgtThetaOver2) -> None: ...

class Convert_HyperbolaToBSplineCurve(Convert_ConicToBSplineCurve):
    def __init__(self, H: gp_Hypr2d, U1: float, U2: float) -> None: ...

class Convert_ParabolaToBSplineCurve(Convert_ConicToBSplineCurve):
    def __init__(self, Prb: gp_Parab2d, U1: float, U2: float) -> None: ...

class Convert_SphereToBSplineSurface(Convert_ElementarySurfaceToBSplineSurface):
    @overload
    def __init__(self, Sph: gp_Sphere, U1: float, U2: float, V1: float, V2: float) -> None: ...
    @overload
    def __init__(self, Sph: gp_Sphere, Param1: float, Param2: float, UTrim: Optional[bool] = True) -> None: ...
    @overload
    def __init__(self, Sph: gp_Sphere) -> None: ...

class Convert_TorusToBSplineSurface(Convert_ElementarySurfaceToBSplineSurface):
    @overload
    def __init__(self, T: gp_Torus, U1: float, U2: float, V1: float, V2: float) -> None: ...
    @overload
    def __init__(self, T: gp_Torus, Param1: float, Param2: float, UTrim: Optional[bool] = True) -> None: ...
    @overload
    def __init__(self, T: gp_Torus) -> None: ...

# harray1 classes
# harray2 classes
# hsequence classes

