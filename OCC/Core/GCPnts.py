# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
GCPnts module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_gcpnts.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_GCPnts')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_GCPnts')
    _GCPnts = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_GCPnts', [dirname(__file__)])
        except ImportError:
            import _GCPnts
            return _GCPnts
        try:
            _mod = imp.load_module('_GCPnts', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _GCPnts = swig_import_helper()
    del swig_import_helper
else:
    import _GCPnts
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GCPnts.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _GCPnts.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _GCPnts.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _GCPnts.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _GCPnts.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _GCPnts.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _GCPnts.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _GCPnts.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _GCPnts.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _GCPnts.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _GCPnts.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _GCPnts.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _GCPnts.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _GCPnts.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _GCPnts.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _GCPnts.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _GCPnts.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _GCPnts.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _GCPnts.process_exception(error, method_name, class_name)
process_exception = _GCPnts.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.Adaptor3d
import OCC.Core.Geom
import OCC.Core.gp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.math
import OCC.Core.Message
import OCC.Core.OSD

from enum import IntEnum
from OCC.Core.Exception import *

GCPnts_Linear = _GCPnts.GCPnts_Linear
GCPnts_Circular = _GCPnts.GCPnts_Circular
GCPnts_Curved = _GCPnts.GCPnts_Curved
GCPnts_DefComposite = _GCPnts.GCPnts_DefComposite
GCPnts_LengthParametrized = _GCPnts.GCPnts_LengthParametrized
GCPnts_Parametrized = _GCPnts.GCPnts_Parametrized
GCPnts_AbsComposite = _GCPnts.GCPnts_AbsComposite


class GCPnts_DeflectionType(IntEnum):
	GCPnts_Linear = 0
	GCPnts_Circular = 1
	GCPnts_Curved = 2
	GCPnts_DefComposite = 3
GCPnts_Linear = GCPnts_DeflectionType.GCPnts_Linear
GCPnts_Circular = GCPnts_DeflectionType.GCPnts_Circular
GCPnts_Curved = GCPnts_DeflectionType.GCPnts_Curved
GCPnts_DefComposite = GCPnts_DeflectionType.GCPnts_DefComposite

class GCPnts_AbscissaType(IntEnum):
	GCPnts_LengthParametrized = 0
	GCPnts_Parametrized = 1
	GCPnts_AbsComposite = 2
GCPnts_LengthParametrized = GCPnts_AbscissaType.GCPnts_LengthParametrized
GCPnts_Parametrized = GCPnts_AbscissaType.GCPnts_Parametrized
GCPnts_AbsComposite = GCPnts_AbscissaType.GCPnts_AbsComposite

class GCPnts_AbscissaPoint(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GCPnts_AbscissaPoint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GCPnts_AbscissaPoint, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        The algorithm computes a point on a curve <curve> at the distance <abscissa> from the point of parameter <u0>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Abscissa: float
        U0: float

        Returns
        -------
        None

        The algorithm computes a point on a curve <curve> at the distance <abscissa> from the point of parameter <u0> with the given tolerance.

        Parameters
        ----------
        Tol: float
        C: Adaptor3d_Curve
        Abscissa: float
        U0: float

        Returns
        -------
        None

        The algorithm computes a point on a curve <curve> at the distance <abscissa> from the point of parameter <u0> with the given tolerance.

        Parameters
        ----------
        Tol: float
        C: Adaptor2d_Curve2d
        Abscissa: float
        U0: float

        Returns
        -------
        None

        The algorithm computes a point on a curve <curve> at the distance <abscissa> from the point of parameter <u0>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Abscissa: float
        U0: float

        Returns
        -------
        None

        The algorithm computes a point on a curve <curve> at the distance <abscissa> from the point of parameter <u0>. <ui> is the starting value used in the iterative process which find the solution, it must be close to the final solution.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Abscissa: float
        U0: float
        Ui: float

        Returns
        -------
        None

        The algorithm computes a point on a curve <curve> at the distance <abscissa> from the point of parameter <u0>. <ui> is the starting value used in the iterative process which find the solution, it must be closed to the final solution.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Abscissa: float
        U0: float
        Ui: float

        Returns
        -------
        None

        The algorithm computes a point on a curve <curve> at the distance <abscissa> from the point of parameter <u0>. <ui> is the starting value used in the iterative process which find the solution, it must be close to the final solution.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Abscissa: float
        U0: float
        Ui: float
        Tol: float

        Returns
        -------
        None

        The algorithm computes a point on a curve <curve> at the distance <abscissa> from the point of parameter <u0>. <ui> is the starting value used in the iterative process which find the solution, it must be close to the final solution.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Abscissa: float
        U0: float
        Ui: float
        Tol: float

        Returns
        -------
        None

        """
        this = _GCPnts.new_GCPnts_AbscissaPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        True if the computation was successful, false otherwise. isdone is a protection against: - non-convergence of the algorithm - querying the results before computation.

        Returns
        -------
        bool

        """
        return _GCPnts.GCPnts_AbscissaPoint_IsDone(self, *args)


    def Length(*args) -> "Standard_Real":
        """
        Computes the length of the curve <c>.

        Parameters
        ----------
        C: Adaptor3d_Curve

        Returns
        -------
        float

        Computes the length of the curve <c>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d

        Returns
        -------
        float

        Computes the length of the curve <c> with the given tolerance.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Tol: float

        Returns
        -------
        float

        Computes the length of the curve <c> with the given tolerance.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Tol: float

        Returns
        -------
        float

        Computes the length of the curve <c>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        U1: float
        U2: float

        Returns
        -------
        float

        Computes the length of the curve <c>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        U1: float
        U2: float

        Returns
        -------
        float

        Computes the length of the curve <c> with the given tolerance.

        Parameters
        ----------
        C: Adaptor3d_Curve
        U1: float
        U2: float
        Tol: float

        Returns
        -------
        float

        Computes the length of the curve <c> with the given tolerance. constructs an empty algorithm. this function is used only for initializing a framework to compute the length of a curve (or a series of curves). warning the function isdone will return the value false after the use of this function.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        U1: float
        U2: float
        Tol: float

        Returns
        -------
        float

        """
        return _GCPnts.GCPnts_AbscissaPoint_Length(*args)

    Length = staticmethod(Length)

    def Parameter(self, *args) -> "Standard_Real":
        """
        Returns the parameter on the curve of the point solution of this algorithm. exceptions stdfail_notdone if the computation was not successful, or was not done.

        Returns
        -------
        float

        """
        return _GCPnts.GCPnts_AbscissaPoint_Parameter(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GCPnts.delete_GCPnts_AbscissaPoint
    __del__ = lambda self: None
GCPnts_AbscissaPoint_swigregister = _GCPnts.GCPnts_AbscissaPoint_swigregister
GCPnts_AbscissaPoint_swigregister(GCPnts_AbscissaPoint)

def GCPnts_AbscissaPoint_Length(*args) -> "Standard_Real":
    """
    Computes the length of the curve <c>.

    Parameters
    ----------
    C: Adaptor3d_Curve

    Returns
    -------
    float

    Computes the length of the curve <c>.

    Parameters
    ----------
    C: Adaptor2d_Curve2d

    Returns
    -------
    float

    Computes the length of the curve <c> with the given tolerance.

    Parameters
    ----------
    C: Adaptor3d_Curve
    Tol: float

    Returns
    -------
    float

    Computes the length of the curve <c> with the given tolerance.

    Parameters
    ----------
    C: Adaptor2d_Curve2d
    Tol: float

    Returns
    -------
    float

    Computes the length of the curve <c>.

    Parameters
    ----------
    C: Adaptor3d_Curve
    U1: float
    U2: float

    Returns
    -------
    float

    Computes the length of the curve <c>.

    Parameters
    ----------
    C: Adaptor2d_Curve2d
    U1: float
    U2: float

    Returns
    -------
    float

    Computes the length of the curve <c> with the given tolerance.

    Parameters
    ----------
    C: Adaptor3d_Curve
    U1: float
    U2: float
    Tol: float

    Returns
    -------
    float

    Computes the length of the curve <c> with the given tolerance. constructs an empty algorithm. this function is used only for initializing a framework to compute the length of a curve (or a series of curves). warning the function isdone will return the value false after the use of this function.

    Parameters
    ----------
    C: Adaptor2d_Curve2d
    U1: float
    U2: float
    Tol: float

    Returns
    -------
    float

    """
    return _GCPnts.GCPnts_AbscissaPoint_Length(*args)

class GCPnts_DistFunction2dMV(OCC.Core.math.math_MultipleVarFunction):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.math.math_MultipleVarFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GCPnts_DistFunction2dMV, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.math.math_MultipleVarFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GCPnts_DistFunction2dMV, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        theCurvLinDist: GCPnts_DistFunction2d

        Returns
        -------
        None

        """
        this = _GCPnts.new_GCPnts_DistFunction2dMV(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    __repr__ = _dumps_object

    __swig_destroy__ = _GCPnts.delete_GCPnts_DistFunction2dMV
    __del__ = lambda self: None
GCPnts_DistFunction2dMV_swigregister = _GCPnts.GCPnts_DistFunction2dMV_swigregister
GCPnts_DistFunction2dMV_swigregister(GCPnts_DistFunction2dMV)

class GCPnts_DistFunctionMV(OCC.Core.math.math_MultipleVarFunction):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.math.math_MultipleVarFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GCPnts_DistFunctionMV, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.math.math_MultipleVarFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GCPnts_DistFunctionMV, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        theCurvLinDist: GCPnts_DistFunction

        Returns
        -------
        None

        """
        this = _GCPnts.new_GCPnts_DistFunctionMV(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    __repr__ = _dumps_object

    __swig_destroy__ = _GCPnts.delete_GCPnts_DistFunctionMV
    __del__ = lambda self: None
GCPnts_DistFunctionMV_swigregister = _GCPnts.GCPnts_DistFunctionMV_swigregister
GCPnts_DistFunctionMV_swigregister(GCPnts_DistFunctionMV)

class GCPnts_QuasiUniformAbscissa(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GCPnts_QuasiUniformAbscissa, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GCPnts_QuasiUniformAbscissa, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Constructs an empty algorithm. to define the problem to be solved, use the function initialize.

        Returns
        -------
        None

        Computes a uniform abscissa distribution of points - on the curve c where abscissa is the curvilinear distance between two consecutive points of the distribution.

        Parameters
        ----------
        C: Adaptor3d_Curve
        NbPoints: int

        Returns
        -------
        None

        Computes a uniform abscissa distribution of points on the part of curve c limited by the two parameter values u1 and u2, where abscissa is the curvilinear distance between two consecutive points of the distribution. the first point of the distribution is either the origin of curve c or the point of parameter u1. the following points are computed such that the curvilinear distance between two consecutive points is equal to abscissa. the last point of the distribution is either the end point of curve c or the point of parameter u2. however the curvilinear distance between this last point and the point just preceding it in the distribution is, of course, generally not equal to abscissa. use the function isdone to verify that the computation was successful, the function nbpoints to obtain the number of points of the computed distribution, and the function parameter to read the parameter of each point. warning the roles of u1 and u2 are inverted if u1 > u2 . warning c is an adapted curve, that is, an object which is an interface between: - the services provided by either a 2d curve from the package geom2d (in the case of an adaptor2d_curve2d curve) or a 3d curve from the package geom (in the case of an adaptor3d_curve curve), - and those required on the curve by the computation algorithm.

        Parameters
        ----------
        C: Adaptor3d_Curve
        NbPoints: int
        U1: float
        U2: float

        Returns
        -------
        None

        Computes a uniform abscissa distribution of points on the curve2d <c>. <nbpoints> defines the nomber of desired points.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        NbPoints: int

        Returns
        -------
        None

        Computes a uniform abscissa distribution of points on a part of the curve2d <c>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        NbPoints: int
        U1: float
        U2: float

        Returns
        -------
        None

        """
        this = _GCPnts.new_GCPnts_QuasiUniformAbscissa(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args) -> "void":
        """
        Initialize the algoritms with <c>, <nbpoints> and.

        Parameters
        ----------
        C: Adaptor3d_Curve
        NbPoints: int

        Returns
        -------
        None

        Initialize the algoritms with <c>, <abscissa>, <u1>, <u2>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        NbPoints: int
        U1: float
        U2: float

        Returns
        -------
        None

        Initialize the algoritms with <c>, <nbpoints> and.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        NbPoints: int

        Returns
        -------
        None

        Initialize the algoritms with <c>, <abscissa>, <u1>, <u2>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        NbPoints: int
        U1: float
        U2: float

        Returns
        -------
        None

        """
        return _GCPnts.GCPnts_QuasiUniformAbscissa_Initialize(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computation was successful. isdone is a protection against: - non-convergence of the algorithm - querying the results before computation.

        Returns
        -------
        bool

        """
        return _GCPnts.GCPnts_QuasiUniformAbscissa_IsDone(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        Returns the number of points of the distribution computed by this algorithm. this value is either: - the one imposed on the algorithm at the time of construction (or initialization), or - the one computed by the algorithm when the curvilinear distance between two consecutive points of the distribution is imposed on the algorithm at the time of construction (or initialization). exceptions stdfail_notdone if this algorithm has not been initialized, or if the computation was not successful.

        Returns
        -------
        int

        """
        return _GCPnts.GCPnts_QuasiUniformAbscissa_NbPoints(self, *args)


    def Parameter(self, *args) -> "Standard_Real":
        """
        Returns the parameter of the point of index index in the distribution computed by this algorithm. warning index must be greater than or equal to 1, and less than or equal to the number of points of the distribution. however, pay particular attention as this condition is not checked by this function. exceptions stdfail_notdone if this algorithm has not been initialized, or if the computation was not successful.

        Parameters
        ----------
        Index: int

        Returns
        -------
        float

        """
        return _GCPnts.GCPnts_QuasiUniformAbscissa_Parameter(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GCPnts.delete_GCPnts_QuasiUniformAbscissa
    __del__ = lambda self: None
GCPnts_QuasiUniformAbscissa_swigregister = _GCPnts.GCPnts_QuasiUniformAbscissa_swigregister
GCPnts_QuasiUniformAbscissa_swigregister(GCPnts_QuasiUniformAbscissa)

class GCPnts_QuasiUniformDeflection(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GCPnts_QuasiUniformDeflection, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GCPnts_QuasiUniformDeflection, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Constructs an empty algorithm. to define the problem to be solved, use the function initialize.

        Returns
        -------
        None

        Computes a quasiuniform deflection distribution of points on the curve <c>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Deflection: float
        Continuity: GeomAbs_Shape,optional
        	default value is GeomAbs_C1

        Returns
        -------
        None

        Computes a quasiuniform deflection distribution of points on the curve <c>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Deflection: float
        Continuity: GeomAbs_Shape,optional
        	default value is GeomAbs_C1

        Returns
        -------
        None

        Computes a quasiuniform deflection distribution of points on a part of the curve <c>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Deflection: float
        U1: float
        U2: float
        Continuity: GeomAbs_Shape,optional
        	default value is GeomAbs_C1

        Returns
        -------
        None

        Computes a quasiuniform deflection distribution of points on a part of the curve <c>. this and the above algorithms compute a distribution of points: - on the curve c, or - on the part of curve c limited by the two parameter values u1 and u2, where the deflection resulting from the distributed points is not greater than deflection. the first point of the distribution is either the origin of curve c or the point of parameter u1. the last point of the distribution is either the end point of curve c or the point of parameter u2. intermediate points of the distribution are built such that the deflection is not greater than deflection. using the following evaluation of the deflection: if pi and pj are two consecutive points of the distribution, respectively of parameter ui and uj on the curve, the deflection is the distance between: - the mid-point of pi and pj (the center of the chord joining these two points) - and the point of mid-parameter of these two points (the point of parameter [(ui+uj) / 2 ] on curve c). continuity, defaulted to geomabs_c1, gives the degree of continuity of the curve c. (note that c is an adaptor3d_curve or an adaptor2d_curve2d object, and does not know the degree of continuity of the underlying curve). use the function isdone to verify that the computation was successful, the function nbpoints to obtain the number of points of the computed distribution, and the function parameter to read the parameter of each point. warning - the roles of u1 and u2 are inverted if u1 > u2. - derivative functions on the curve are called according to continuity. an error may occur if continuity is greater than the real degree of continuity of the curve. warning c is an adapted curve, i.e. an object which is an interface between: - the services provided by either a 2d curve from the package geom2d (in the case of an adaptor2d_curve2d curve) or a 3d curve from the package geom (in the case of an adaptor3d_curve curve), - and those required on the curve by the computation algorithm.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Deflection: float
        U1: float
        U2: float
        Continuity: GeomAbs_Shape,optional
        	default value is GeomAbs_C1

        Returns
        -------
        None

        """
        this = _GCPnts.new_GCPnts_QuasiUniformDeflection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Deflection(self, *args) -> "Standard_Real":
        """
        Returns the deflection between the curve and the polygon resulting from the points of the distribution computed by this algorithm. this is the value given to the algorithm at the time of construction (or initialization). exceptions stdfail_notdone if this algorithm has not been initialized, or if the computation was not successful.

        Returns
        -------
        float

        """
        return _GCPnts.GCPnts_QuasiUniformDeflection_Deflection(self, *args)


    def Initialize(self, *args) -> "void":
        """
        Initialize the algoritms with <c>, <deflection>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Deflection: float
        Continuity: GeomAbs_Shape,optional
        	default value is GeomAbs_C1

        Returns
        -------
        None

        Initialize the algoritms with <c>, <deflection>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Deflection: float
        Continuity: GeomAbs_Shape,optional
        	default value is GeomAbs_C1

        Returns
        -------
        None

        Initialize the algoritms with <c>, <deflection>, <u1>,<u2>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Deflection: float
        U1: float
        U2: float
        Continuity: GeomAbs_Shape,optional
        	default value is GeomAbs_C1

        Returns
        -------
        None

        Initialize the algoritms with <c>, <deflection>, -- <u1>,<u2> this and the above algorithms initialize (or reinitialize) this algorithm and compute a distribution of points: - on the curve c, or - on the part of curve c limited by the two parameter values u1 and u2, where the deflection resulting from the distributed points is not greater than deflection. the first point of the distribution is either the origin of curve c or the point of parameter u1. the last point of the distribution is either the end point of curve c or the point of parameter u2. intermediate points of the distribution are built in such a way that the deflection is not greater than deflection. using the following evaluation of the deflection: if pi and pj are two consecutive points of the distribution, respectively of parameter ui and uj on the curve, the deflection is the distance between: - the mid-point of pi and pj (the center of the chord joining these two points) - and the point of mid-parameter of these two points (the point of parameter [(ui+uj) / 2 ] on curve c). continuity, defaulted to geomabs_c1, gives the degree of continuity of the curve c. (note that c is an adaptor3d_curve or an adaptor2d_curve2d object, and does not know the degree of continuity of the underlying curve). use the function isdone to verify that the computation was successful, the function nbpoints to obtain the number of points of the computed distribution, and the function parameter to read the parameter of each point. warning - the roles of u1 and u2 are inverted if u1 > u2. - derivative functions on the curve are called according to continuity. an error may occur if continuity is greater than the real degree of continuity of the curve. warning c is an adapted curve, i.e. an object which is an interface between: - the services provided by either a 2d curve from the package geom2d (in the case of an adaptor2d_curve2d curve) or a 3d curve from the package geom (in the case of an adaptor3d_curve curve), and those required on the curve by the computation algorithm.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Deflection: float
        U1: float
        U2: float
        Continuity: GeomAbs_Shape,optional
        	default value is GeomAbs_C1

        Returns
        -------
        None

        """
        return _GCPnts.GCPnts_QuasiUniformDeflection_Initialize(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computation was successful. isdone is a protection against: - non-convergence of the algorithm - querying the results before computation.

        Returns
        -------
        bool

        """
        return _GCPnts.GCPnts_QuasiUniformDeflection_IsDone(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        Returns the number of points of the distribution computed by this algorithm. exceptions stdfail_notdone if this algorithm has not been initialized, or if the computation was not successful.

        Returns
        -------
        int

        """
        return _GCPnts.GCPnts_QuasiUniformDeflection_NbPoints(self, *args)


    def Parameter(self, *args) -> "Standard_Real":
        """
        Returns the parameter of the point of index index in the distribution computed by this algorithm. warning index must be greater than or equal to 1, and less than or equal to the number of points of the distribution. however, pay particular attention as this condition is not checked by this function. exceptions stdfail_notdone if this algorithm has not been initialized, or if the computation was not successful.

        Parameters
        ----------
        Index: int

        Returns
        -------
        float

        """
        return _GCPnts.GCPnts_QuasiUniformDeflection_Parameter(self, *args)


    def Value(self, *args) -> "gp_Pnt":
        """
        Returns the point of index index in the distribution computed by this algorithm. warning index must be greater than or equal to 1, and less than or equal to the number of points of the distribution. however, pay particular attention as this condition is not checked by this function. exceptions stdfail_notdone if this algorithm has not been initialized, or if the computation was not successful.

        Parameters
        ----------
        Index: int

        Returns
        -------
        gp_Pnt

        """
        return _GCPnts.GCPnts_QuasiUniformDeflection_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GCPnts.delete_GCPnts_QuasiUniformDeflection
    __del__ = lambda self: None
GCPnts_QuasiUniformDeflection_swigregister = _GCPnts.GCPnts_QuasiUniformDeflection_swigregister
GCPnts_QuasiUniformDeflection_swigregister(GCPnts_QuasiUniformDeflection)

class GCPnts_TangentialDeflection(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GCPnts_TangentialDeflection, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GCPnts_TangentialDeflection, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        C: Adaptor3d_Curve
        AngularDeflection: float
        CurvatureDeflection: float
        MinimumOfPoints: int,optional
        	default value is 2
        UTol: float,optional
        	default value is 1.0e-9
        theMinLen: float,optional
        	default value is 1.0e-7

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        C: Adaptor3d_Curve
        FirstParameter: float
        LastParameter: float
        AngularDeflection: float
        CurvatureDeflection: float
        MinimumOfPoints: int,optional
        	default value is 2
        UTol: float,optional
        	default value is 1.0e-9
        theMinLen: float,optional
        	default value is 1.0e-7

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        AngularDeflection: float
        CurvatureDeflection: float
        MinimumOfPoints: int,optional
        	default value is 2
        UTol: float,optional
        	default value is 1.0e-9
        theMinLen: float,optional
        	default value is 1.0e-7

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        FirstParameter: float
        LastParameter: float
        AngularDeflection: float
        CurvatureDeflection: float
        MinimumOfPoints: int,optional
        	default value is 2
        UTol: float,optional
        	default value is 1.0e-9
        theMinLen: float,optional
        	default value is 1.0e-7

        Returns
        -------
        None

        """
        this = _GCPnts.new_GCPnts_TangentialDeflection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddPoint(self, *args) -> "Standard_Integer":
        """
        Add point to already calculated points (or replace existing) returns index of new added point or founded with parametric tolerance (replaced if theisreplace is true).

        Parameters
        ----------
        thePnt: gp_Pnt
        theParam: float
        theIsReplace: bool,optional
        	default value is Standard_True

        Returns
        -------
        int

        """
        return _GCPnts.GCPnts_TangentialDeflection_AddPoint(self, *args)


    def ArcAngularStep(*args) -> "Standard_Real":
        """
        Computes angular step for the arc using the given parameters.

        Parameters
        ----------
        theRadius: float
        theLinearDeflection: float
        theAngularDeflection: float
        theMinLength: float

        Returns
        -------
        float

        """
        return _GCPnts.GCPnts_TangentialDeflection_ArcAngularStep(*args)

    ArcAngularStep = staticmethod(ArcAngularStep)

    def Initialize(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        C: Adaptor3d_Curve
        AngularDeflection: float
        CurvatureDeflection: float
        MinimumOfPoints: int,optional
        	default value is 2
        UTol: float,optional
        	default value is 1.0e-9
        theMinLen: float,optional
        	default value is 1.0e-7

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        C: Adaptor3d_Curve
        FirstParameter: float
        LastParameter: float
        AngularDeflection: float
        CurvatureDeflection: float
        MinimumOfPoints: int,optional
        	default value is 2
        UTol: float,optional
        	default value is 1.0e-9
        theMinLen: float,optional
        	default value is 1.0e-7

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        AngularDeflection: float
        CurvatureDeflection: float
        MinimumOfPoints: int,optional
        	default value is 2
        UTol: float,optional
        	default value is 1.0e-9
        theMinLen: float,optional
        	default value is 1.0e-7

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        FirstParameter: float
        LastParameter: float
        AngularDeflection: float
        CurvatureDeflection: float
        MinimumOfPoints: int,optional
        	default value is 2
        UTol: float,optional
        	default value is 1.0e-9
        theMinLen: float,optional
        	default value is 1.0e-7

        Returns
        -------
        None

        """
        return _GCPnts.GCPnts_TangentialDeflection_Initialize(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _GCPnts.GCPnts_TangentialDeflection_NbPoints(self, *args)


    def Parameter(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Parameters
        ----------
        I: int

        Returns
        -------
        float

        """
        return _GCPnts.GCPnts_TangentialDeflection_Parameter(self, *args)


    def Value(self, *args) -> "gp_Pnt":
        """
        No available documentation.

        Parameters
        ----------
        I: int

        Returns
        -------
        gp_Pnt

        """
        return _GCPnts.GCPnts_TangentialDeflection_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GCPnts.delete_GCPnts_TangentialDeflection
    __del__ = lambda self: None
GCPnts_TangentialDeflection_swigregister = _GCPnts.GCPnts_TangentialDeflection_swigregister
GCPnts_TangentialDeflection_swigregister(GCPnts_TangentialDeflection)

def GCPnts_TangentialDeflection_ArcAngularStep(*args) -> "Standard_Real":
    """
    Computes angular step for the arc using the given parameters.

    Parameters
    ----------
    theRadius: float
    theLinearDeflection: float
    theAngularDeflection: float
    theMinLength: float

    Returns
    -------
    float

    """
    return _GCPnts.GCPnts_TangentialDeflection_ArcAngularStep(*args)

class GCPnts_UniformAbscissa(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GCPnts_UniformAbscissa, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GCPnts_UniformAbscissa, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creation of a indefinite uniformabscissa.

        Returns
        -------
        None

        Computes a uniform abscissa distribution of points on the curve <c>. parameter toler is equal precision::confusion by default. it is used for more precise calculation of curve length.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Abscissa: float
        Toler: float,optional
        	default value is -1

        Returns
        -------
        None

        Computes a uniform abscissa distribution of points on a part of the curve <c>. parameter toler is equal precision::confusion by default. it is used for more precise calculation of curve length.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Abscissa: float
        U1: float
        U2: float
        Toler: float,optional
        	default value is -1

        Returns
        -------
        None

        Computes a uniform abscissa distribution of points on the curve <c>. <nbpoints> defines the nomber of desired points. parameter toler is equal precision::confusion by default. it is used for more precise calculation of curve length.

        Parameters
        ----------
        C: Adaptor3d_Curve
        NbPoints: int
        Toler: float,optional
        	default value is -1

        Returns
        -------
        None

        Computes a uniform abscissa distribution of points on a part of the curve <c>. parameter toler is equal precision::confusion by default. it is used for more precise calculation of curve length.

        Parameters
        ----------
        C: Adaptor3d_Curve
        NbPoints: int
        U1: float
        U2: float
        Toler: float,optional
        	default value is -1

        Returns
        -------
        None

        Computes a uniform abscissa distribution of points on the curve2d <c>. parameter toler is equal precision::confusion by default. it is used for more precise calculation of curve length.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Abscissa: float
        Toler: float,optional
        	default value is -1

        Returns
        -------
        None

        Computes a uniform abscissa distribution of points on a part of the curve2d <c>. parameter toler is equal precision::confusion by default. it is used for more precise calculation of curve length.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Abscissa: float
        U1: float
        U2: float
        Toler: float,optional
        	default value is -1

        Returns
        -------
        None

        Computes a uniform abscissa distribution of points on the curve2d <c>. <nbpoints> defines the nomber of desired points. parameter toler is equal precision::confusion by default. it is used for more precise calculation of curve length.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        NbPoints: int
        Toler: float,optional
        	default value is -1

        Returns
        -------
        None

        Computes a uniform abscissa distribution of points on a part of the curve2d <c>. parameter toler is equal precision::confusion by default. it is used for more precise calculation of curve length.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        NbPoints: int
        U1: float
        U2: float
        Toler: float,optional
        	default value is -1

        Returns
        -------
        None

        """
        this = _GCPnts.new_GCPnts_UniformAbscissa(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Abscissa(self, *args) -> "Standard_Real":
        """
        Returne the current abscissa ie the distance between two consecutive points.

        Returns
        -------
        float

        """
        return _GCPnts.GCPnts_UniformAbscissa_Abscissa(self, *args)


    def Initialize(self, *args) -> "void":
        """
        Initialize the algoritms with <c>, <abscissa>, <toler>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Abscissa: float
        Toler: float,optional
        	default value is -1

        Returns
        -------
        None

        Initialize the algoritms with <c>, <abscissa>, <u1>, <u2>, <toler>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Abscissa: float
        U1: float
        U2: float
        Toler: float,optional
        	default value is -1

        Returns
        -------
        None

        Initialize the algoritms with <c>, <nbpoints>, <toler> and.

        Parameters
        ----------
        C: Adaptor3d_Curve
        NbPoints: int
        Toler: float,optional
        	default value is -1

        Returns
        -------
        None

        Initialize the algoritms with <c>, <abscissa>, <u1>, <u2>, <toler>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        NbPoints: int
        U1: float
        U2: float
        Toler: float,optional
        	default value is -1

        Returns
        -------
        None

        Initialize the algoritms with <c>, <abscissa>, <toler>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Abscissa: float
        Toler: float,optional
        	default value is -1

        Returns
        -------
        None

        Initialize the algoritms with <c>, <abscissa>, <u1>, <u2>, <toler>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Abscissa: float
        U1: float
        U2: float
        Toler: float,optional
        	default value is -1

        Returns
        -------
        None

        Initialize the algoritms with <c>, <nbpoints>, <toler> and.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        NbPoints: int
        Toler: float,optional
        	default value is -1

        Returns
        -------
        None

        Initialize the algoritms with <c>, <abscissa>, <u1>, <u2>, <toler>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        NbPoints: int
        U1: float
        U2: float
        Toler: float,optional
        	default value is -1

        Returns
        -------
        None

        """
        return _GCPnts.GCPnts_UniformAbscissa_Initialize(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _GCPnts.GCPnts_UniformAbscissa_IsDone(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _GCPnts.GCPnts_UniformAbscissa_NbPoints(self, *args)


    def Parameter(self, *args) -> "Standard_Real":
        """
        Returns the computed parameter of index <index>.

        Parameters
        ----------
        Index: int

        Returns
        -------
        float

        """
        return _GCPnts.GCPnts_UniformAbscissa_Parameter(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GCPnts.delete_GCPnts_UniformAbscissa
    __del__ = lambda self: None
GCPnts_UniformAbscissa_swigregister = _GCPnts.GCPnts_UniformAbscissa_swigregister
GCPnts_UniformAbscissa_swigregister(GCPnts_UniformAbscissa)

class GCPnts_UniformDeflection(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GCPnts_UniformDeflection, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GCPnts_UniformDeflection, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Constructs an empty algorithm. to define the problem to be solved, use the function initialize.

        Returns
        -------
        None

        Computes a uniform deflection distribution of points on the curve <c>. if <withcontrol> is true,the algorithm controls the estimate deflection.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Deflection: float
        WithControl: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        Computes a uniform deflection distribution of points on the curve <c>. if <withcontrol> is true,the algorithm controls the estimate deflection.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Deflection: float
        WithControl: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        Computes a uniform deflection distribution of points on a part of the curve <c>. if <withcontrol> is true,the algorithm controls the estimate deflection.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Deflection: float
        U1: float
        U2: float
        WithControl: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        Computes a uniform deflection distribution of points on a part of the curve <c>. if <withcontrol> is true,the algorithm controls the estimate deflection.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Deflection: float
        U1: float
        U2: float
        WithControl: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        """
        this = _GCPnts.new_GCPnts_UniformDeflection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Deflection(self, *args) -> "Standard_Real":
        """
        Returns the deflection between the curve and the polygon resulting from the points of the distribution computed by this algorithm. this value is the one given to the algorithm at the time of construction (or initialization). exceptions stdfail_notdone if this algorithm has not been initialized, or if the computation was not successful.

        Returns
        -------
        float

        """
        return _GCPnts.GCPnts_UniformDeflection_Deflection(self, *args)


    def Initialize(self, *args) -> "void":
        """
        Initialize the algoritms with <c>, <deflection>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Deflection: float
        WithControl: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        Initialize the algoritms with <c>, <deflection>.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Deflection: float
        WithControl: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        Initialize the algoritms with <c>, <deflection>, <u1>,<u2>.

        Parameters
        ----------
        C: Adaptor3d_Curve
        Deflection: float
        U1: float
        U2: float
        WithControl: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        Initialize the algoritms with <c>, <deflection>, <u1>,<u2> this and the above methods initialize (or reinitialize) this algorithm and compute a distribution of points: - on the curve c, or - on the part of curve c limited by the two parameter values u1 and u2, where the maximum distance between c and the polygon that results from the points of the distribution is not greater than deflection. the first point of the distribution is either the origin of curve c or the point of parameter u1. the last point of the distribution is either the end point of curve c or the point of parameter u2. intermediate points of the distribution are built using interpolations of segments of the curve limited at the 2nd degree. the construction ensures, in a first step, that the chordal deviation for this interpolation of the curve is less than or equal to deflection. however, it does not ensure that the chordal deviation for the curve itself is less than or equal to deflection. to do this a check is necessary, which may generate (second step) additional intermediate points. this check is time consuming, and can be avoided by setting withcontrol to false. note that by default withcontrol is true and check is performed. use the function isdone to verify that the computation was successful, the function nbpoints to obtain the number of points of the computed distribution, and the function parameter to read the parameter of each point. warning - c is necessary, 'c2' continuous. this property is not checked at construction time. - the roles of u1 and u2 are inverted if u1 > u2. warning c is an adapted curve, i.e. an object which is an interface between: - the services provided by either a 2d curve from the package geom2d (in the case of an adaptor2d_curve2d curve) or a 3d curve from the package geom (in the case of an adaptor3d_curve curve), - and those required on the curve by the computation algorithm.

        Parameters
        ----------
        C: Adaptor2d_Curve2d
        Deflection: float
        U1: float
        U2: float
        WithControl: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        """
        return _GCPnts.GCPnts_UniformDeflection_Initialize(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computation was successful. isdone is a protection against: - non-convergence of the algorithm - querying the results before computation.

        Returns
        -------
        bool

        """
        return _GCPnts.GCPnts_UniformDeflection_IsDone(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        Returns the number of points of the distribution computed by this algorithm. exceptions stdfail_notdone if this algorithm has not been initialized, or if the computation was not successful.

        Returns
        -------
        int

        """
        return _GCPnts.GCPnts_UniformDeflection_NbPoints(self, *args)


    def Parameter(self, *args) -> "Standard_Real":
        """
        Returns the parameter of the point of index index in the distribution computed by this algorithm. warning index must be greater than or equal to 1, and less than or equal to the number of points of the distribution. however, pay particular attention as this condition is not checked by this function. exceptions stdfail_notdone if this algorithm has not been initialized, or if the computation was not successful.

        Parameters
        ----------
        Index: int

        Returns
        -------
        float

        """
        return _GCPnts.GCPnts_UniformDeflection_Parameter(self, *args)


    def Value(self, *args) -> "gp_Pnt":
        """
        Returns the point of index index in the distribution computed by this algorithm. warning index must be greater than or equal to 1, and less than or equal to the number of points of the distribution. however, pay particular attention as this condition is not checked by this function. exceptions stdfail_notdone if this algorithm has not been initialized, or if the computation was not successful.

        Parameters
        ----------
        Index: int

        Returns
        -------
        gp_Pnt

        """
        return _GCPnts.GCPnts_UniformDeflection_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _GCPnts.delete_GCPnts_UniformDeflection
    __del__ = lambda self: None
GCPnts_UniformDeflection_swigregister = _GCPnts.GCPnts_UniformDeflection_swigregister
GCPnts_UniformDeflection_swigregister(GCPnts_UniformDeflection)


@classnotwrapped
class GCPnts_DistFunction:
	pass

@classnotwrapped
class GCPnts_DistFunction2d:
	pass




# This file is compatible with both classic and new-style classes.


