# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
math module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_math.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_math')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_math')
    _math = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_math', [dirname(__file__)])
        except ImportError:
            import _math
            return _math
        try:
            _mod = imp.load_module('_math', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _math = swig_import_helper()
    del swig_import_helper
else:
    import _math
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _math.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _math.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _math.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _math.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _math.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _math.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _math.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _math.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _math.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _math.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _math.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _math.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _math.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _math.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _math.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _math.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _math.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _math.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _math.process_exception(error, method_name, class_name)
process_exception = _math.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Message
import OCC.Core.OSD
import OCC.Core.gp

from enum import IntEnum
from OCC.Core.Exception import *

math_OK = _math.math_OK
math_TooManyIterations = _math.math_TooManyIterations
math_FunctionError = _math.math_FunctionError
math_DirectionSearchError = _math.math_DirectionSearchError
math_NotBracketed = _math.math_NotBracketed


class math_Status(IntEnum):
	math_OK = 0
	math_TooManyIterations = 1
	math_FunctionError = 2
	math_DirectionSearchError = 3
	math_NotBracketed = 4
math_OK = math_Status.math_OK
math_TooManyIterations = math_Status.math_TooManyIterations
math_FunctionError = math_Status.math_FunctionError
math_DirectionSearchError = math_Status.math_DirectionSearchError
math_NotBracketed = math_Status.math_NotBracketed

class math_Array1OfValueAndWeight(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_Array1OfValueAndWeight, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_Array1OfValueAndWeight, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Array1< math_ValueAndWeight >::iterator":
        return _math.math_Array1OfValueAndWeight_begin(self)

    def end(self) -> "NCollection_Array1< math_ValueAndWeight >::iterator":
        return _math.math_Array1OfValueAndWeight_end(self)

    def cbegin(self) -> "NCollection_Array1< math_ValueAndWeight >::const_iterator":
        return _math.math_Array1OfValueAndWeight_cbegin(self)

    def cend(self) -> "NCollection_Array1< math_ValueAndWeight >::const_iterator":
        return _math.math_Array1OfValueAndWeight_cend(self)

    def __init__(self, *args):
        this = _math.new_math_Array1OfValueAndWeight(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, theValue: 'math_ValueAndWeight') -> "void":
        return _math.math_Array1OfValueAndWeight_Init(self, theValue)

    def Size(self) -> "Standard_Integer":
        return _math.math_Array1OfValueAndWeight_Size(self)

    def Length(self) -> "Standard_Integer":
        return _math.math_Array1OfValueAndWeight_Length(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _math.math_Array1OfValueAndWeight_IsEmpty(self)

    def Lower(self) -> "Standard_Integer":
        return _math.math_Array1OfValueAndWeight_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _math.math_Array1OfValueAndWeight_Upper(self)

    def IsDeletable(self) -> "Standard_Boolean":
        return _math.math_Array1OfValueAndWeight_IsDeletable(self)

    def IsAllocated(self) -> "Standard_Boolean":
        return _math.math_Array1OfValueAndWeight_IsAllocated(self)

    def Assign(self, theOther: 'math_Array1OfValueAndWeight') -> "NCollection_Array1< math_ValueAndWeight > &":
        return _math.math_Array1OfValueAndWeight_Assign(self, theOther)

    def Move(self, theOther: 'math_Array1OfValueAndWeight') -> "NCollection_Array1< math_ValueAndWeight > &":
        return _math.math_Array1OfValueAndWeight_Move(self, theOther)

    def Set(self, *args) -> "NCollection_Array1< math_ValueAndWeight > &":
        return _math.math_Array1OfValueAndWeight_Set(self, *args)

    def First(self) -> "math_ValueAndWeight const &":
        return _math.math_Array1OfValueAndWeight_First(self)

    def ChangeFirst(self) -> "math_ValueAndWeight &":
        return _math.math_Array1OfValueAndWeight_ChangeFirst(self)

    def Last(self) -> "math_ValueAndWeight const &":
        return _math.math_Array1OfValueAndWeight_Last(self)

    def ChangeLast(self) -> "math_ValueAndWeight &":
        return _math.math_Array1OfValueAndWeight_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "math_ValueAndWeight const &":
        return _math.math_Array1OfValueAndWeight_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "math_ValueAndWeight &":
        return _math.math_Array1OfValueAndWeight_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "math_ValueAndWeight &":
        return _math.math_Array1OfValueAndWeight___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'math_ValueAndWeight') -> "void":
        return _math.math_Array1OfValueAndWeight_SetValue(self, theIndex, theItem)

    def Resize(self, theLower: 'Standard_Integer const', theUpper: 'Standard_Integer const', theToCopyData: 'Standard_Boolean const') -> "void":
        return _math.math_Array1OfValueAndWeight_Resize(self, theLower, theUpper, theToCopyData)
    __swig_destroy__ = _math.delete_math_Array1OfValueAndWeight
    __del__ = lambda self: None

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next

math_Array1OfValueAndWeight_swigregister = _math.math_Array1OfValueAndWeight_swigregister
math_Array1OfValueAndWeight_swigregister(math_Array1OfValueAndWeight)

class math(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math, name)
    __repr__ = _swig_repr

    def GaussPoints(*args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        Index: int
        Points: math_Vector

        Returns
        -------
        None

        """
        return _math.math_GaussPoints(*args)

    GaussPoints = staticmethod(GaussPoints)

    def GaussPointsMax(*args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _math.math_GaussPointsMax(*args)

    GaussPointsMax = staticmethod(GaussPointsMax)

    def GaussWeights(*args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        Index: int
        Weights: math_Vector

        Returns
        -------
        None

        """
        return _math.math_GaussWeights(*args)

    GaussWeights = staticmethod(GaussWeights)

    def KronrodPointsAndWeights(*args) -> "Standard_Boolean":
        """
        Returns a vector of kronrod points and a vector of their weights for gauss-kronrod computation method. index should be odd and greater then or equal to 3, as the number of kronrod points is equal to 2*n + 1, where n is a number of gauss points. points and weights should have the size equal to index. each even element of points represents a gauss point value of n-th gauss quadrature. the values from index equal to 3 to 123 are stored in a table (see the file math_kronrod.cxx). if index is greater, then points and weights will be computed. returns standard_true if index is odd, it is equal to the size of points and weights and the computation of points and weights is performed successfully. otherwise this method returns standard_false.

        Parameters
        ----------
        Index: int
        Points: math_Vector
        Weights: math_Vector

        Returns
        -------
        bool

        """
        return _math.math_KronrodPointsAndWeights(*args)

    KronrodPointsAndWeights = staticmethod(KronrodPointsAndWeights)

    def KronrodPointsMax(*args) -> "Standard_Integer":
        """
        Returns the maximal number of points for that the values are stored in the table. if the number is greater then kronrodpointsmax, the points will be computed.

        Returns
        -------
        int

        """
        return _math.math_KronrodPointsMax(*args)

    KronrodPointsMax = staticmethod(KronrodPointsMax)

    def OrderedGaussPointsAndWeights(*args) -> "Standard_Boolean":
        """
        Returns a vector of gauss points and a vector of their weights. the difference with the method gausspoints is the following: - the points are returned in increasing order. - if index is greater then gausspointsmax, the points are computed. returns standard_true if index is positive, points' and weights' length is equal to index, points and weights are successfully computed.

        Parameters
        ----------
        Index: int
        Points: math_Vector
        Weights: math_Vector

        Returns
        -------
        bool

        """
        return _math.math_OrderedGaussPointsAndWeights(*args)

    OrderedGaussPointsAndWeights = staticmethod(OrderedGaussPointsAndWeights)

    __repr__ = _dumps_object


    def __init__(self):
        this = _math.new_math()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _math.delete_math
    __del__ = lambda self: None
math_swigregister = _math.math_swigregister
math_swigregister(math)

def math_GaussPoints(*args) -> "void":
    """
    No available documentation.

    Parameters
    ----------
    Index: int
    Points: math_Vector

    Returns
    -------
    None

    """
    return _math.math_GaussPoints(*args)

def math_GaussPointsMax(*args) -> "Standard_Integer":
    """
    No available documentation.

    Returns
    -------
    int

    """
    return _math.math_GaussPointsMax(*args)

def math_GaussWeights(*args) -> "void":
    """
    No available documentation.

    Parameters
    ----------
    Index: int
    Weights: math_Vector

    Returns
    -------
    None

    """
    return _math.math_GaussWeights(*args)

def math_KronrodPointsAndWeights(*args) -> "Standard_Boolean":
    """
    Returns a vector of kronrod points and a vector of their weights for gauss-kronrod computation method. index should be odd and greater then or equal to 3, as the number of kronrod points is equal to 2*n + 1, where n is a number of gauss points. points and weights should have the size equal to index. each even element of points represents a gauss point value of n-th gauss quadrature. the values from index equal to 3 to 123 are stored in a table (see the file math_kronrod.cxx). if index is greater, then points and weights will be computed. returns standard_true if index is odd, it is equal to the size of points and weights and the computation of points and weights is performed successfully. otherwise this method returns standard_false.

    Parameters
    ----------
    Index: int
    Points: math_Vector
    Weights: math_Vector

    Returns
    -------
    bool

    """
    return _math.math_KronrodPointsAndWeights(*args)

def math_KronrodPointsMax(*args) -> "Standard_Integer":
    """
    Returns the maximal number of points for that the values are stored in the table. if the number is greater then kronrodpointsmax, the points will be computed.

    Returns
    -------
    int

    """
    return _math.math_KronrodPointsMax(*args)

def math_OrderedGaussPointsAndWeights(*args) -> "Standard_Boolean":
    """
    Returns a vector of gauss points and a vector of their weights. the difference with the method gausspoints is the following: - the points are returned in increasing order. - if index is greater then gausspointsmax, the points are computed. returns standard_true if index is positive, points' and weights' length is equal to index, points and weights are successfully computed.

    Parameters
    ----------
    Index: int
    Points: math_Vector
    Weights: math_Vector

    Returns
    -------
    bool

    """
    return _math.math_OrderedGaussPointsAndWeights(*args)

class math_BFGS(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_BFGS, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_BFGS, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Initializes the computation of the minimum of a function with nbvariables. tolerance, zeps and nbiterations are described in the method perform. warning: a call to the perform method must be made after this initialization to effectively compute the minimum of the function f.

        Parameters
        ----------
        NbVariables: int
        Tolerance: float,optional
        	default value is 1.0e-8
        NbIterations: int,optional
        	default value is 200
        ZEPS: float,optional
        	default value is 1.0e-12

        Returns
        -------
        None

        """
        this = _math.new_math_BFGS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DumpToString(self) -> "std::string":
        """DumpToString(math_BFGS self) -> std::string"""
        return _math.math_BFGS_DumpToString(self)


    def Gradient(self, *args) -> "void":
        """
        Returns the gradient vector at the minimum. exception notdone is raised if the minimum was not found.

        Returns
        -------
        math_Vector

        Returns the value of the gradient vector at the minimum in grad. exception notdone is raised if the minimum was not found. exception dimensionerror is raised if the range of grad is not equal to the range of the startingpoint.

        Parameters
        ----------
        Grad: math_Vector

        Returns
        -------
        None

        """
        return _math.math_BFGS_Gradient(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computations are successful, otherwise returns false.

        Returns
        -------
        bool

        """
        return _math.math_BFGS_IsDone(self, *args)


    def IsSolutionReached(self, *args) -> "Standard_Boolean":
        """
        This method is called at the end of each iteration to check if the solution is found. it can be redefined in a sub-class to implement a specific test to stop the iterations.

        Parameters
        ----------
        F: math_MultipleVarFunctionWithGradient

        Returns
        -------
        bool

        """
        return _math.math_BFGS_IsSolutionReached(self, *args)


    def Location(self, *args) -> "void":
        """
        Returns the location vector of the minimum. exception notdone is raised if the minimum was not found.

        Returns
        -------
        math_Vector

        Outputs the location vector of the minimum in loc. exception notdone is raised if the minimum was not found. exception dimensionerror is raised if the range of loc is not equal to the range of the startingpoint.

        Parameters
        ----------
        Loc: math_Vector

        Returns
        -------
        None

        """
        return _math.math_BFGS_Location(self, *args)


    def Minimum(self, *args) -> "Standard_Real":
        """
        Returns the value of the minimum. exception notdone is raised if the minimum was not found.

        Returns
        -------
        float

        """
        return _math.math_BFGS_Minimum(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        Returns the number of iterations really done in the calculation of the minimum. the exception notdone is raised if the minimum was not found.

        Returns
        -------
        int

        """
        return _math.math_BFGS_NbIterations(self, *args)


    def Perform(self, *args) -> "void":
        """
        Given the starting point startingpoint, minimization is done on the function f. the solution f = fi is found when : 2.0 * abs(fi - fi-1) <= tolerance * (abs(fi) + abs(fi-1) + zeps). tolerance, zeps and maximum number of iterations are given in the constructor.

        Parameters
        ----------
        F: math_MultipleVarFunctionWithGradient
        StartingPoint: math_Vector

        Returns
        -------
        None

        """
        return _math.math_BFGS_Perform(self, *args)


    def SetBoundary(self, *args) -> "void":
        """
        Set boundaries for conditional optimization. the expected indices range of vectors is [1, nbvariables].

        Parameters
        ----------
        theLeftBorder: math_Vector
        theRightBorder: math_Vector

        Returns
        -------
        None

        """
        return _math.math_BFGS_SetBoundary(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BFGS
    __del__ = lambda self: None
math_BFGS_swigregister = _math.math_BFGS_swigregister
math_BFGS_swigregister(math_BFGS)

class math_BissecNewton(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_BissecNewton, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_BissecNewton, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Constructor. @param thextolerance - algorithm tolerance.

        Parameters
        ----------
        theXTolerance: float

        Returns
        -------
        None

        """
        this = _math.new_math_BissecNewton(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Derivative(self, *args) -> "Standard_Real":
        """
        Returns the value of the derivative at the root. exception notdone is raised if the minimum was not found.

        Returns
        -------
        float

        """
        return _math.math_BissecNewton_Derivative(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_BissecNewton self) -> std::string"""
        return _math.math_BissecNewton_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Tests is the root has been successfully found.

        Returns
        -------
        bool

        """
        return _math.math_BissecNewton_IsDone(self, *args)


    def IsSolutionReached(self, *args) -> "Standard_Boolean":
        """
        This method is called at the end of each iteration to check if the solution has been found. it can be redefined in a sub-class to implement a specific test to stop the iterations.

        Parameters
        ----------
        theFunction: math_FunctionWithDerivative

        Returns
        -------
        bool

        """
        return _math.math_BissecNewton_IsSolutionReached(self, *args)


    def Perform(self, *args) -> "void":
        """
        A combination of newton-raphson and bissection methods is done to find the root of the function f between the bounds bound1 and bound2 on the function f. the tolerance required on the root is given by tolx. the solution is found when: abs(xi - xi-1) <= tolx and f(xi) * f(xi-1) <= 0 the maximum number of iterations allowed is given by nbiterations.

        Parameters
        ----------
        F: math_FunctionWithDerivative
        Bound1: float
        Bound2: float
        NbIterations: int,optional
        	default value is 100

        Returns
        -------
        None

        """
        return _math.math_BissecNewton_Perform(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """
        Returns the value of the root. exception notdone is raised if the minimum was not found.

        Returns
        -------
        float

        """
        return _math.math_BissecNewton_Root(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        Returns the value of the function at the root. exception notdone is raised if the minimum was not found.

        Returns
        -------
        float

        """
        return _math.math_BissecNewton_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BissecNewton
    __del__ = lambda self: None
math_BissecNewton_swigregister = _math.math_BissecNewton_swigregister
math_BissecNewton_swigregister(math_BissecNewton)

class math_BracketMinimum(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_BracketMinimum, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_BracketMinimum, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Constructor preparing a and b parameters only. it does not perform the job.

        Parameters
        ----------
        A: float
        B: float

        Returns
        -------
        None

        Given two initial values this class computes a bracketing triplet of abscissae ax, bx, cx (such that bx is between ax and cx, f(bx) is less than both f(bx) and f(cx)) the brent minimization is done on the function f.

        Parameters
        ----------
        F: math_Function
        A: float
        B: float

        Returns
        -------
        None

        Given two initial values this class computes a bracketing triplet of abscissae ax, bx, cx (such that bx is between ax and cx, f(bx) is less than both f(bx) and f(cx)) the brent minimization is done on the function f. this constructor has to be used if f(a) is known.

        Parameters
        ----------
        F: math_Function
        A: float
        B: float
        FA: float

        Returns
        -------
        None

        Given two initial values this class computes a bracketing triplet of abscissae ax, bx, cx (such that bx is between ax and cx, f(bx) is less than both f(bx) and f(cx)) the brent minimization is done on the function f. this constructor has to be used if f(a) and f(b) are known.

        Parameters
        ----------
        F: math_Function
        A: float
        B: float
        FA: float
        FB: float

        Returns
        -------
        None

        """
        this = _math.new_math_BracketMinimum(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DumpToString(self) -> "std::string":
        """DumpToString(math_BracketMinimum self) -> std::string"""
        return _math.math_BracketMinimum_DumpToString(self)


    def FunctionValues(self, *args) -> "void":
        """
        Returns the bracketed triplet function values. exceptions stdfail_notdone if the algorithm fails (and isdone returns false).

        Parameters
        ----------

        Returns
        -------
        FA: float
        FB: float
        FC: float

        """
        return _math.math_BracketMinimum_FunctionValues(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computations are successful, otherwise returns false.

        Returns
        -------
        bool

        """
        return _math.math_BracketMinimum_IsDone(self, *args)


    def Perform(self, *args) -> "void":
        """
        The method performing the job. it is called automatically by constructors with the function.

        Parameters
        ----------
        F: math_Function

        Returns
        -------
        None

        """
        return _math.math_BracketMinimum_Perform(self, *args)


    def SetFA(self, *args) -> "void":
        """
        Set function value at a.

        Parameters
        ----------
        theValue: float

        Returns
        -------
        None

        """
        return _math.math_BracketMinimum_SetFA(self, *args)


    def SetFB(self, *args) -> "void":
        """
        Set function value at b.

        Parameters
        ----------
        theValue: float

        Returns
        -------
        None

        """
        return _math.math_BracketMinimum_SetFB(self, *args)


    def SetLimits(self, *args) -> "void":
        """
        Set limits of the parameter. by default no limits are applied to the parameter change. if no minimum is found in limits then isdone() will return false. the user is in charge of providing a and b to be in limits.

        Parameters
        ----------
        theLeft: float
        theRight: float

        Returns
        -------
        None

        """
        return _math.math_BracketMinimum_SetLimits(self, *args)


    def Values(self, *args) -> "void":
        """
        Returns the bracketed triplet of abscissae. exceptions stdfail_notdone if the algorithm fails (and isdone returns false).

        Parameters
        ----------

        Returns
        -------
        A: float
        B: float
        C: float

        """
        return _math.math_BracketMinimum_Values(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BracketMinimum
    __del__ = lambda self: None
math_BracketMinimum_swigregister = _math.math_BracketMinimum_swigregister
math_BracketMinimum_swigregister(math_BracketMinimum)

class math_BracketedRoot(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_BracketedRoot, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_BracketedRoot, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        The brent method is used to find the root of the function f between the bounds bound1 and bound2 on the function f. if f(bound1)*f(bound2) >0 the brent method fails. the tolerance required for the root is given by tolerance. the solution is found when : abs(xi - xi-1) <= tolerance; the maximum number of iterations allowed is given by nbiterations.

        Parameters
        ----------
        F: math_Function
        Bound1: float
        Bound2: float
        Tolerance: float
        NbIterations: int,optional
        	default value is 100
        ZEPS: float,optional
        	default value is 1.0e-12

        Returns
        -------
        None

        """
        this = _math.new_math_BracketedRoot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DumpToString(self) -> "std::string":
        """DumpToString(math_BracketedRoot self) -> std::string"""
        return _math.math_BracketedRoot_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computations are successful, otherwise returns false.

        Returns
        -------
        bool

        """
        return _math.math_BracketedRoot_IsDone(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        Returns the number of iterations really done during the computation of the root. exception notdone is raised if the minimum was not found.

        Returns
        -------
        int

        """
        return _math.math_BracketedRoot_NbIterations(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """
        Returns the value of the root. exception notdone is raised if the minimum was not found.

        Returns
        -------
        float

        """
        return _math.math_BracketedRoot_Root(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        Returns the value of the function at the root. exception notdone is raised if the minimum was not found.

        Returns
        -------
        float

        """
        return _math.math_BracketedRoot_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BracketedRoot
    __del__ = lambda self: None
math_BracketedRoot_swigregister = _math.math_BracketedRoot_swigregister
math_BracketedRoot_swigregister(math_BracketedRoot)

class math_BrentMinimum(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_BrentMinimum, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_BrentMinimum, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        This constructor should be used in a sub-class to initialize correctly all the fields of this class.

        Parameters
        ----------
        TolX: float
        NbIterations: int,optional
        	default value is 100
        ZEPS: float,optional
        	default value is 1.0e-12

        Returns
        -------
        None

        This constructor should be used in a sub-class to initialize correctly all the fields of this class. it has to be used if f(bx) is known.

        Parameters
        ----------
        TolX: float
        Fbx: float
        NbIterations: int,optional
        	default value is 100
        ZEPS: float,optional
        	default value is 1.0e-12

        Returns
        -------
        None

        """
        this = _math.new_math_BrentMinimum(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DumpToString(self) -> "std::string":
        """DumpToString(math_BrentMinimum self) -> std::string"""
        return _math.math_BrentMinimum_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computations are successful, otherwise returns false.

        Returns
        -------
        bool

        """
        return _math.math_BrentMinimum_IsDone(self, *args)


    def IsSolutionReached(self, *args) -> "Standard_Boolean":
        """
        This method is called at the end of each iteration to check if the solution is found. it can be redefined in a sub-class to implement a specific test to stop the iterations.

        Parameters
        ----------
        theFunction: math_Function

        Returns
        -------
        bool

        """
        return _math.math_BrentMinimum_IsSolutionReached(self, *args)


    def Location(self, *args) -> "Standard_Real":
        """
        Returns the location value of the minimum. exception notdone is raised if the minimum was not found.

        Returns
        -------
        float

        """
        return _math.math_BrentMinimum_Location(self, *args)


    def Minimum(self, *args) -> "Standard_Real":
        """
        Returns the value of the minimum. exception notdone is raised if the minimum was not found.

        Returns
        -------
        float

        """
        return _math.math_BrentMinimum_Minimum(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        Returns the number of iterations really done during the computation of the minimum. exception notdone is raised if the minimum was not found.

        Returns
        -------
        int

        """
        return _math.math_BrentMinimum_NbIterations(self, *args)


    def Perform(self, *args) -> "void":
        """
        Brent minimization is performed on function f from a given bracketing triplet of abscissas ax, bx, cx (such that bx is between ax and cx, f(bx) is less than both f(bx) and f(cx)) the solution is found when: abs(xi - xi-1) <= tolx * abs(xi) + zeps;.

        Parameters
        ----------
        F: math_Function
        Ax: float
        Bx: float
        Cx: float

        Returns
        -------
        None

        """
        return _math.math_BrentMinimum_Perform(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BrentMinimum
    __del__ = lambda self: None
math_BrentMinimum_swigregister = _math.math_BrentMinimum_swigregister
math_BrentMinimum_swigregister(math_BrentMinimum)

class math_BullardGenerator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_BullardGenerator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_BullardGenerator, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates new xorshift 64-bit rng.

        Parameters
        ----------
        theSeed: unsigned int,optional
        	default value is 1

        Returns
        -------
        None

        """
        this = _math.new_math_BullardGenerator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NextInt(self, *args) -> "unsigned int":
        """
        Generates new 64-bit integer value.

        Returns
        -------
        unsigned int

        """
        return _math.math_BullardGenerator_NextInt(self, *args)


    def NextReal(self, *args) -> "Standard_Real":
        """
        Generates new floating-point value.

        Returns
        -------
        float

        """
        return _math.math_BullardGenerator_NextReal(self, *args)


    def SetSeed(self, *args) -> "void":
        """
        Setup new seed / reset defaults.

        Parameters
        ----------
        theSeed: unsigned int,optional
        	default value is 1

        Returns
        -------
        None

        """
        return _math.math_BullardGenerator_SetSeed(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_BullardGenerator
    __del__ = lambda self: None
math_BullardGenerator_swigregister = _math.math_BullardGenerator_swigregister
math_BullardGenerator_swigregister(math_BullardGenerator)

class math_ComputeGaussPointsAndWeights(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_ComputeGaussPointsAndWeights, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_ComputeGaussPointsAndWeights, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        Number: int

        Returns
        -------
        None

        """
        this = _math.new_math_ComputeGaussPointsAndWeights(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _math.math_ComputeGaussPointsAndWeights_IsDone(self, *args)


    def Points(self, *args) -> "math_Vector":
        """
        No available documentation.

        Returns
        -------
        math_Vector

        """
        return _math.math_ComputeGaussPointsAndWeights_Points(self, *args)


    def Weights(self, *args) -> "math_Vector":
        """
        No available documentation.

        Returns
        -------
        math_Vector

        """
        return _math.math_ComputeGaussPointsAndWeights_Weights(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_ComputeGaussPointsAndWeights
    __del__ = lambda self: None
math_ComputeGaussPointsAndWeights_swigregister = _math.math_ComputeGaussPointsAndWeights_swigregister
math_ComputeGaussPointsAndWeights_swigregister(math_ComputeGaussPointsAndWeights)

class math_ComputeKronrodPointsAndWeights(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_ComputeKronrodPointsAndWeights, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_ComputeKronrodPointsAndWeights, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        Number: int

        Returns
        -------
        None

        """
        this = _math.new_math_ComputeKronrodPointsAndWeights(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _math.math_ComputeKronrodPointsAndWeights_IsDone(self, *args)


    def Points(self, *args) -> "math_Vector":
        """
        No available documentation.

        Returns
        -------
        math_Vector

        """
        return _math.math_ComputeKronrodPointsAndWeights_Points(self, *args)


    def Weights(self, *args) -> "math_Vector":
        """
        No available documentation.

        Returns
        -------
        math_Vector

        """
        return _math.math_ComputeKronrodPointsAndWeights_Weights(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_ComputeKronrodPointsAndWeights
    __del__ = lambda self: None
math_ComputeKronrodPointsAndWeights_swigregister = _math.math_ComputeKronrodPointsAndWeights_swigregister
math_ComputeKronrodPointsAndWeights_swigregister(math_ComputeKronrodPointsAndWeights)

class math_Crout(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_Crout, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_Crout, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Given an input matrix a, this algorithm inverts a by the crout algorithm. the user can give only the inferior triangle for the implementation. a can be decomposed like this: a = l * d * t(l) where l is triangular inferior and d is diagonal. if one element of a is less than minpivot, a is considered as singular. exception notsquare is raised if a is not a square matrix.

        Parameters
        ----------
        A: math_Matrix
        MinPivot: float,optional
        	default value is 1.0e-20

        Returns
        -------
        None

        """
        this = _math.new_math_Crout(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Determinant(self, *args) -> "Standard_Real":
        """
        Returns the value of the determinant of the previously lu decomposed matrix a. zero is returned if the matrix a is considered as singular. exceptions stdfail_notdone if the algorithm fails (and isdone returns false).

        Returns
        -------
        float

        """
        return _math.math_Crout_Determinant(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_Crout self) -> std::string"""
        return _math.math_Crout_DumpToString(self)


    def Inverse(self, *args) -> "math_Matrix const &":
        """
        Returns the inverse matrix of a. only the inferior triangle is returned. exception notdone is raised if notdone.

        Returns
        -------
        math_Matrix

        """
        return _math.math_Crout_Inverse(self, *args)


    def Invert(self, *args) -> "void":
        """
        Returns in inv the inverse matrix of a. only the inferior triangle is returned. exception notdone is raised if notdone.

        Parameters
        ----------
        Inv: math_Matrix

        Returns
        -------
        None

        """
        return _math.math_Crout_Invert(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if all has been correctly done.

        Returns
        -------
        bool

        """
        return _math.math_Crout_IsDone(self, *args)


    def Solve(self, *args) -> "void":
        """
        Given an input vector <b>, this routine returns the solution of the set of linear equations a . x = b. exception notdone is raised if the decomposition was not done successfully. exception dimensionerror is raised if the range of b is not equal to the rowrange of a.

        Parameters
        ----------
        B: math_Vector
        X: math_Vector

        Returns
        -------
        None

        """
        return _math.math_Crout_Solve(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Crout
    __del__ = lambda self: None
math_Crout_swigregister = _math.math_Crout_swigregister
math_Crout_swigregister(math_Crout)

class math_DirectPolynomialRoots(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_DirectPolynomialRoots, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_DirectPolynomialRoots, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Computes all the real roots of the polynomial ax4 + bx3 + cx2 + dx + e using a direct method.

        Parameters
        ----------
        A: float
        B: float
        C: float
        D: float
        E: float

        Returns
        -------
        None

        Computes all the real roots of the polynomial ax3 + bx2 + cx + d using a direct method.

        Parameters
        ----------
        A: float
        B: float
        C: float
        D: float

        Returns
        -------
        None

        Computes all the real roots of the polynomial ax2 + bx + c using a direct method.

        Parameters
        ----------
        A: float
        B: float
        C: float

        Returns
        -------
        None

        Computes the real root of the polynomial ax + b.

        Parameters
        ----------
        A: float
        B: float

        Returns
        -------
        None

        """
        this = _math.new_math_DirectPolynomialRoots(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DumpToString(self) -> "std::string":
        """DumpToString(math_DirectPolynomialRoots self) -> std::string"""
        return _math.math_DirectPolynomialRoots_DumpToString(self)


    def InfiniteRoots(self, *args) -> "Standard_Boolean":
        """
        Returns true if there is an infinity of roots, otherwise returns false.

        Returns
        -------
        bool

        """
        return _math.math_DirectPolynomialRoots_InfiniteRoots(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computations are successful, otherwise returns false.

        Returns
        -------
        bool

        """
        return _math.math_DirectPolynomialRoots_IsDone(self, *args)


    def NbSolutions(self, *args) -> "Standard_Integer":
        """
        Returns the number of solutions. an exception is raised if there are an infinity of roots.

        Returns
        -------
        int

        """
        return _math.math_DirectPolynomialRoots_NbSolutions(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        Returns the value of the nieme root. an exception is raised if there are an infinity of roots. exception rangeerror is raised if nieme is < 1 or nieme > nbsolutions.

        Parameters
        ----------
        Nieme: int

        Returns
        -------
        float

        """
        return _math.math_DirectPolynomialRoots_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_DirectPolynomialRoots
    __del__ = lambda self: None
math_DirectPolynomialRoots_swigregister = _math.math_DirectPolynomialRoots_swigregister
math_DirectPolynomialRoots_swigregister(math_DirectPolynomialRoots)

class math_DoubleTab(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_DoubleTab, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_DoubleTab, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        LowerRow: int
        UpperRow: int
        LowerCol: int
        UpperCol: int

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        Tab: Standard_Address
        LowerRow: int
        UpperRow: int
        LowerCol: int
        UpperCol: int

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        Other: math_DoubleTab

        Returns
        -------
        None

        """
        this = _math.new_math_DoubleTab(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Copy(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        Other: math_DoubleTab

        Returns
        -------
        None

        """
        return _math.math_DoubleTab_Copy(self, *args)


    def Free(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _math.math_DoubleTab_Free(self, *args)


    def Init(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        InitValue: float

        Returns
        -------
        None

        """
        return _math.math_DoubleTab_Init(self, *args)


    def SetLowerCol(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        LowerCol: int

        Returns
        -------
        None

        """
        return _math.math_DoubleTab_SetLowerCol(self, *args)


    def SetLowerRow(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        LowerRow: int

        Returns
        -------
        None

        """
        return _math.math_DoubleTab_SetLowerRow(self, *args)


    def GetValue(self, RowIndex: 'Standard_Integer const', ColIndex: 'Standard_Integer const') -> "Standard_Real":
        """GetValue(math_DoubleTab self, Standard_Integer const RowIndex, Standard_Integer const ColIndex) -> Standard_Real"""
        return _math.math_DoubleTab_GetValue(self, RowIndex, ColIndex)


    def SetValue(self, RowIndex: 'Standard_Integer const', ColIndex: 'Standard_Integer const', value: 'Standard_Real') -> "void":
        """SetValue(math_DoubleTab self, Standard_Integer const RowIndex, Standard_Integer const ColIndex, Standard_Real value)"""
        return _math.math_DoubleTab_SetValue(self, RowIndex, ColIndex, value)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_DoubleTab
    __del__ = lambda self: None
math_DoubleTab_swigregister = _math.math_DoubleTab_swigregister
math_DoubleTab_swigregister(math_DoubleTab)

class math_EigenValuesSearcher(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_EigenValuesSearcher, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_EigenValuesSearcher, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        Diagonal: TColStd_Array1OfReal
        Subdiagonal: TColStd_Array1OfReal

        Returns
        -------
        None

        """
        this = _math.new_math_EigenValuesSearcher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Dimension(self, *args) -> "Standard_Integer":
        """
        Returns the dimension of matrix.

        Returns
        -------
        int

        """
        return _math.math_EigenValuesSearcher_Dimension(self, *args)


    def EigenValue(self, *args) -> "Standard_Real":
        """
        Returns the index_th eigen value of matrix index must be in [1, dimension()].

        Parameters
        ----------
        Index: int

        Returns
        -------
        float

        """
        return _math.math_EigenValuesSearcher_EigenValue(self, *args)


    def EigenVector(self, *args) -> "math_Vector":
        """
        Returns the index_th eigen vector of matrix index must be in [1, dimension()].

        Parameters
        ----------
        Index: int

        Returns
        -------
        math_Vector

        """
        return _math.math_EigenValuesSearcher_EigenVector(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns standard_true if computation is performed successfully.

        Returns
        -------
        bool

        """
        return _math.math_EigenValuesSearcher_IsDone(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_EigenValuesSearcher
    __del__ = lambda self: None
math_EigenValuesSearcher_swigregister = _math.math_EigenValuesSearcher_swigregister
math_EigenValuesSearcher_swigregister(math_EigenValuesSearcher)

class math_FRPR(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_FRPR, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_FRPR, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Initializes the computation of the minimum of f. warning: constructor does not perform computations.

        Parameters
        ----------
        theFunction: math_MultipleVarFunctionWithGradient
        theTolerance: float
        theNbIterations: int,optional
        	default value is 200
        theZEPS: float,optional
        	default value is 1.0e-12

        Returns
        -------
        None

        """
        this = _math.new_math_FRPR(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DumpToString(self) -> "std::string":
        """DumpToString(math_FRPR self) -> std::string"""
        return _math.math_FRPR_DumpToString(self)


    def Gradient(self, *args) -> "void":
        """
        Returns the gradient vector at the minimum. exception notdone is raised if the minimum was not found.

        Returns
        -------
        math_Vector

        Outputs the gradient vector at the minimum in grad. exception notdone is raised if the minimum was not found. exception dimensionerror is raised if the range of grad is not equal to the range of the startingpoint.

        Parameters
        ----------
        Grad: math_Vector

        Returns
        -------
        None

        """
        return _math.math_FRPR_Gradient(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computations are successful, otherwise returns false.

        Returns
        -------
        bool

        """
        return _math.math_FRPR_IsDone(self, *args)


    def IsSolutionReached(self, *args) -> "Standard_Boolean":
        """
        The solution f = fi is found when: 2.0 * abs(fi - fi-1) <= tolerance * (abs(fi) + abs(fi-1)) + zeps. the maximum number of iterations allowed is given by nbiterations.

        Parameters
        ----------
        theFunction: math_MultipleVarFunctionWithGradient

        Returns
        -------
        bool

        """
        return _math.math_FRPR_IsSolutionReached(self, *args)


    def Location(self, *args) -> "void":
        """
        Returns the location vector of the minimum. exception notdone is raised if the minimum was not found.

        Returns
        -------
        math_Vector

        Outputs the location vector of the minimum in loc. exception notdone is raised if the minimum was not found. exception dimensionerror is raised if the range of loc is not equal to the range of the startingpoint.

        Parameters
        ----------
        Loc: math_Vector

        Returns
        -------
        None

        """
        return _math.math_FRPR_Location(self, *args)


    def Minimum(self, *args) -> "Standard_Real":
        """
        Returns the value of the minimum. exception notdone is raised if the minimum was not found.

        Returns
        -------
        float

        """
        return _math.math_FRPR_Minimum(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        Returns the number of iterations really done during the computation of the minimum. exception notdone is raised if the minimum was not found.

        Returns
        -------
        int

        """
        return _math.math_FRPR_NbIterations(self, *args)


    def Perform(self, *args) -> "void":
        """
        The solution f = fi is found when 2.0 * abs(fi - fi-1) <= tolerance * (abs(fi) + abs(fi-1) + zeps).

        Parameters
        ----------
        theFunction: math_MultipleVarFunctionWithGradient
        theStartingPoint: math_Vector

        Returns
        -------
        None

        """
        return _math.math_FRPR_Perform(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FRPR
    __del__ = lambda self: None
math_FRPR_swigregister = _math.math_FRPR_swigregister
math_FRPR_swigregister(math_FRPR)

class math_Function(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_Function, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_Function, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetStateNumber(self, *args) -> "Standard_Integer":
        """
        Returns the state of the function corresponding to the latest call of any methods associated with the function. this function is called by each of the algorithms described later which defined the function integer algorithm::statenumber(). the algorithm has the responsibility to call this function when it has found a solution (i.e. a root or a minimum) and has to maintain the association between the solution found and this statenumber. byu default, this method returns 0 (which means for the algorithm: no state has been saved). it is the responsibility of the programmer to decide if he needs to save the current state of the function and to return an integer that allows retrieval of the state.

        Returns
        -------
        int

        """
        return _math.math_Function_GetStateNumber(self, *args)


    def Value(self, *args) -> "Standard_Boolean":
        """
        Computes the value of the function <f> for a given value of variable <x>. returns true if the computation was done successfully, false otherwise.

        Parameters
        ----------
        X: float

        Returns
        -------
        F: float

        """
        return _math.math_Function_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Function
    __del__ = lambda self: None
math_Function_swigregister = _math.math_Function_swigregister
math_Function_swigregister(math_Function)

class math_FunctionAllRoots(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_FunctionAllRoots, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_FunctionAllRoots, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        The algorithm uses the sample to find intervals on which the function is null. an interval is found if, for at least two consecutive points of the sample, ui and ui+1, we get |f(ui)|<=epsnul and |f(ui+1)|<=epsnul. the real bounds of an interval are computed with the functionroots. algorithm. between two intervals, the roots of the function f are calculated using the functionroots algorithm.

        Parameters
        ----------
        F: math_FunctionWithDerivative
        S: math_FunctionSample
        EpsX: float
        EpsF: float
        EpsNul: float

        Returns
        -------
        None

        """
        this = _math.new_math_FunctionAllRoots(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DumpToString(self) -> "std::string":
        """DumpToString(math_FunctionAllRoots self) -> std::string"""
        return _math.math_FunctionAllRoots_DumpToString(self)


    def GetInterval(self, *args) -> "void":
        """
        Returns the interval of parameter of range index. an exception is raised if isdone returns false; an exception is raised if index<=0 or index >nbintervals.

        Parameters
        ----------
        Index: int

        Returns
        -------
        A: float
        B: float

        """
        return _math.math_FunctionAllRoots_GetInterval(self, *args)


    def GetIntervalState(self, *args) -> "void":
        """
        Returns the state number associated to the interval index. an exception is raised if isdone returns false; an exception is raised if index<=0 or index >nbintervals.

        Parameters
        ----------
        Index: int

        Returns
        -------
        IFirst: int
        ILast: int

        """
        return _math.math_FunctionAllRoots_GetIntervalState(self, *args)


    def GetPoint(self, *args) -> "Standard_Real":
        """
        Returns the parameter of the point of range index. an exception is raised if isdone returns false; an exception is raised if index<=0 or index >nbpoints.

        Parameters
        ----------
        Index: int

        Returns
        -------
        float

        """
        return _math.math_FunctionAllRoots_GetPoint(self, *args)


    def GetPointState(self, *args) -> "Standard_Integer":
        """
        Returns the state number associated to the point index. an exception is raised if isdone returns false; an exception is raised if index<=0 or index >nbintervals.

        Parameters
        ----------
        Index: int

        Returns
        -------
        int

        """
        return _math.math_FunctionAllRoots_GetPointState(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computation has been done successfully.

        Returns
        -------
        bool

        """
        return _math.math_FunctionAllRoots_IsDone(self, *args)


    def NbIntervals(self, *args) -> "Standard_Integer":
        """
        Returns the number of intervals on which the function is null. an exception is raised if isdone returns false.

        Returns
        -------
        int

        """
        return _math.math_FunctionAllRoots_NbIntervals(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        Returns the number of points where the function is null. an exception is raised if isdone returns false.

        Returns
        -------
        int

        """
        return _math.math_FunctionAllRoots_NbPoints(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionAllRoots
    __del__ = lambda self: None
math_FunctionAllRoots_swigregister = _math.math_FunctionAllRoots_swigregister
math_FunctionAllRoots_swigregister(math_FunctionAllRoots)

class math_FunctionRoot(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_FunctionRoot, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_FunctionRoot, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        The newton-raphson method is done to find the root of the function f from the initial guess guess.the tolerance required on the root is given by tolerance. iterations are stopped if the expected solution does not stay in the range a..b. the solution is found when abs(xi - xi-1) <= tolerance; the maximum number of iterations allowed is given by nbiterations.

        Parameters
        ----------
        F: math_FunctionWithDerivative
        Guess: float
        Tolerance: float
        NbIterations: int,optional
        	default value is 100

        Returns
        -------
        None

        The newton-raphson method is done to find the root of the function f from the initial guess guess. the tolerance required on the root is given by tolerance. iterations are stopped if the expected solution does not stay in the range a..b the solution is found when abs(xi - xi-1) <= tolerance; the maximum number of iterations allowed is given by nbiterations.

        Parameters
        ----------
        F: math_FunctionWithDerivative
        Guess: float
        Tolerance: float
        A: float
        B: float
        NbIterations: int,optional
        	default value is 100

        Returns
        -------
        None

        """
        this = _math.new_math_FunctionRoot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Derivative(self, *args) -> "Standard_Real":
        """
        Returns the value of the derivative at the root. exception notdone is raised if the root was not found.

        Returns
        -------
        float

        """
        return _math.math_FunctionRoot_Derivative(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_FunctionRoot self) -> std::string"""
        return _math.math_FunctionRoot_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computations are successful, otherwise returns false.

        Returns
        -------
        bool

        """
        return _math.math_FunctionRoot_IsDone(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        Returns the number of iterations really done on the computation of the root. exception notdone is raised if the root was not found.

        Returns
        -------
        int

        """
        return _math.math_FunctionRoot_NbIterations(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """
        Returns the value of the root. exception notdone is raised if the root was not found.

        Returns
        -------
        float

        """
        return _math.math_FunctionRoot_Root(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        Returns the value of the function at the root. exception notdone is raised if the root was not found.

        Returns
        -------
        float

        """
        return _math.math_FunctionRoot_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionRoot
    __del__ = lambda self: None
math_FunctionRoot_swigregister = _math.math_FunctionRoot_swigregister
math_FunctionRoot_swigregister(math_FunctionRoot)

class math_FunctionRoots(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_FunctionRoots, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_FunctionRoots, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Calculates all the real roots of a function f-k within the range a..b. whithout conditions on a and b a solution x is found when abs(xi - xi-1) <= epsx and abs(f(xi)-k) <= epsf. the function is considered as null between a and b if abs(f-k) <= epsnull within this range.

        Parameters
        ----------
        F: math_FunctionWithDerivative
        A: float
        B: float
        NbSample: int
        EpsX: float,optional
        	default value is 0.0
        EpsF: float,optional
        	default value is 0.0
        EpsNull: float,optional
        	default value is 0.0
        K: float,optional
        	default value is 0.0

        Returns
        -------
        None

        """
        this = _math.new_math_FunctionRoots(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DumpToString(self) -> "std::string":
        """DumpToString(math_FunctionRoots self) -> std::string"""
        return _math.math_FunctionRoots_DumpToString(self)


    def IsAllNull(self, *args) -> "Standard_Boolean":
        """
        Returns true if the function is considered as null between a and b. exceptions stdfail_notdone if the algorithm fails (and isdone returns false).

        Returns
        -------
        bool

        """
        return _math.math_FunctionRoots_IsAllNull(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computations are successful, otherwise returns false.

        Returns
        -------
        bool

        """
        return _math.math_FunctionRoots_IsDone(self, *args)


    def NbSolutions(self, *args) -> "Standard_Integer":
        """
        Returns the number of solutions found. exceptions stdfail_notdone if the algorithm fails (and isdone returns false).

        Returns
        -------
        int

        """
        return _math.math_FunctionRoots_NbSolutions(self, *args)


    def StateNumber(self, *args) -> "Standard_Integer":
        """
        Returns the statenumber of the nieme root. exception rangeerror is raised if nieme is < 1 or nieme > nbsolutions.

        Parameters
        ----------
        Nieme: int

        Returns
        -------
        int

        """
        return _math.math_FunctionRoots_StateNumber(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        Returns the nth value of the root of function f. exceptions stdfail_notdone if the algorithm fails (and isdone returns false).

        Parameters
        ----------
        Nieme: int

        Returns
        -------
        float

        """
        return _math.math_FunctionRoots_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionRoots
    __del__ = lambda self: None
math_FunctionRoots_swigregister = _math.math_FunctionRoots_swigregister
math_FunctionRoots_swigregister(math_FunctionRoots)

class math_FunctionSample(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_FunctionSample, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_FunctionSample, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        A: float
        B: float
        N: int

        Returns
        -------
        None

        """
        this = _math.new_math_FunctionSample(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Bounds(self, *args) -> "void":
        """
        Returns the bounds of parameters.

        Parameters
        ----------

        Returns
        -------
        A: float
        B: float

        """
        return _math.math_FunctionSample_Bounds(self, *args)


    def GetParameter(self, *args) -> "Standard_Real":
        """
        Returns the value of parameter of the point of range index : a + ((index-1)/(nbpoints-1))*b. an exception is raised if index<=0 or index>nbpoints.

        Parameters
        ----------
        Index: int

        Returns
        -------
        float

        """
        return _math.math_FunctionSample_GetParameter(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        Returns the number of sample points.

        Returns
        -------
        int

        """
        return _math.math_FunctionSample_NbPoints(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionSample
    __del__ = lambda self: None
math_FunctionSample_swigregister = _math.math_FunctionSample_swigregister
math_FunctionSample_swigregister(math_FunctionSample)

class math_FunctionSet(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_FunctionSet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_FunctionSet, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetStateNumber(self, *args) -> "Standard_Integer":
        """
        Returns the state of the function corresponding to the latestcall of any methods associated with the function. this function is called by each of the algorithms described later which define the function integer algorithm::statenumber(). the algorithm has the responsibility to call this function when it has found a solution (i.e. a root or a minimum) and has to maintain the association between the solution found and this statenumber. byu default, this method returns 0 (which means for the algorithm: no state has been saved). it is the responsibility of the programmer to decide if he needs to save the current state of the function and to return an integer that allows retrieval of the state.

        Returns
        -------
        int

        """
        return _math.math_FunctionSet_GetStateNumber(self, *args)


    def NbEquations(self, *args) -> "Standard_Integer":
        """
        Returns the number of equations of the function.

        Returns
        -------
        int

        """
        return _math.math_FunctionSet_NbEquations(self, *args)


    def NbVariables(self, *args) -> "Standard_Integer":
        """
        Returns the number of variables of the function.

        Returns
        -------
        int

        """
        return _math.math_FunctionSet_NbVariables(self, *args)


    def Value(self, *args) -> "Standard_Boolean":
        """
        Computes the values <f> of the functions for the variable <x>. returns true if the computation was done successfully, false otherwise.

        Parameters
        ----------
        X: math_Vector
        F: math_Vector

        Returns
        -------
        bool

        """
        return _math.math_FunctionSet_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionSet
    __del__ = lambda self: None
math_FunctionSet_swigregister = _math.math_FunctionSet_swigregister
math_FunctionSet_swigregister(math_FunctionSet)

class math_FunctionSetRoot(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_FunctionSetRoot, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_FunctionSetRoot, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Is used in a sub-class to initialize correctly all the fields of this class. the range (1, f.nbvariables()) must be especially respected for all vectors and matrix declarations.

        Parameters
        ----------
        F: math_FunctionSetWithDerivatives
        Tolerance: math_Vector
        NbIterations: int,optional
        	default value is 100

        Returns
        -------
        None

        Is used in a sub-class to initialize correctly all the fields of this class. the range (1, f.nbvariables()) must be especially respected for all vectors and matrix declarations. the method settolerance must be called after this constructor.

        Parameters
        ----------
        F: math_FunctionSetWithDerivatives
        NbIterations: int,optional
        	default value is 100

        Returns
        -------
        None

        """
        this = _math.new_math_FunctionSetRoot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Derivative(self, *args) -> "void":
        """
        Returns the matrix value of the derivative at the root. exception notdone is raised if the root was not found.

        Returns
        -------
        math_Matrix

        Outputs the matrix value of the derivative at the root in der. exception notdone is raised if the root was not found. exception dimensionerror is raised if the column range of <der> is not equal to the range of the startingpoint.

        Parameters
        ----------
        Der: math_Matrix

        Returns
        -------
        None

        """
        return _math.math_FunctionSetRoot_Derivative(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_FunctionSetRoot self) -> std::string"""
        return _math.math_FunctionSetRoot_DumpToString(self)


    def FunctionSetErrors(self, *args) -> "void":
        """
        Returns the vector value of the error done on the functions at the root. exception notdone is raised if the root was not found.

        Returns
        -------
        math_Vector

        Outputs the vector value of the error done on the functions at the root in err. exception notdone is raised if the root was not found. exception dimensionerror is raised if the range of err is not equal to the range of the startingpoint.

        Parameters
        ----------
        Err: math_Vector

        Returns
        -------
        None

        """
        return _math.math_FunctionSetRoot_FunctionSetErrors(self, *args)


    def IsDivergent(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _math.math_FunctionSetRoot_IsDivergent(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computations are successful, otherwise returns false.

        Returns
        -------
        bool

        """
        return _math.math_FunctionSetRoot_IsDone(self, *args)


    def IsSolutionReached(self, *args) -> "Standard_Boolean":
        """
        This routine is called at the end of each iteration to check if the solution was found. it can be redefined in a sub-class to implement a specific test to stop the iterations. in this case, the solution is found when: abs(xi - xi-1) <= tolerance for all unknowns.

        Parameters
        ----------
        F: math_FunctionSetWithDerivatives

        Returns
        -------
        bool

        """
        return _math.math_FunctionSetRoot_IsSolutionReached(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        Returns the number of iterations really done during the computation of the root. exception notdone is raised if the root was not found.

        Returns
        -------
        int

        """
        return _math.math_FunctionSetRoot_NbIterations(self, *args)


    def Perform(self, *args) -> "void":
        """
        Improves the root of function from the initial guess point. the infinum and supremum may be given to constrain the solution. in this case, the solution is found when: abs(xi - xi-1)(j) <= tolerance(j) for all unknowns.

        Parameters
        ----------
        theFunction: math_FunctionSetWithDerivatives
        theStartingPoint: math_Vector
        theStopOnDivergent: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        Improves the root of function from the initial guess point. the infinum and supremum may be given to constrain the solution. in this case, the solution is found when: abs(xi - xi-1) <= tolerance for all unknowns.

        Parameters
        ----------
        theFunction: math_FunctionSetWithDerivatives
        theStartingPoint: math_Vector
        theInfBound: math_Vector
        theSupBound: math_Vector
        theStopOnDivergent: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        return _math.math_FunctionSetRoot_Perform(self, *args)


    def Root(self, *args) -> "void":
        """
        Returns the value of the root of function f. exception notdone is raised if the root was not found.

        Returns
        -------
        math_Vector

        Outputs the root vector in root. exception notdone is raised if the root was not found. exception dimensionerror is raised if the range of root is not equal to the range of the startingpoint.

        Parameters
        ----------
        Root: math_Vector

        Returns
        -------
        None

        """
        return _math.math_FunctionSetRoot_Root(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        Initializes the tolerance values.

        Parameters
        ----------
        Tolerance: math_Vector

        Returns
        -------
        None

        """
        return _math.math_FunctionSetRoot_SetTolerance(self, *args)


    def StateNumber(self, *args) -> "Standard_Integer":
        """
        Returns the statenumber (as returned by f.getstatenumber()) associated to the root found.

        Returns
        -------
        int

        """
        return _math.math_FunctionSetRoot_StateNumber(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionSetRoot
    __del__ = lambda self: None
math_FunctionSetRoot_swigregister = _math.math_FunctionSetRoot_swigregister
math_FunctionSetRoot_swigregister(math_FunctionSetRoot)

class math_Gauss(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_Gauss, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_Gauss, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Given an input n x n matrix a this constructor performs its lu decomposition with partial pivoting (interchange of rows). this lu decomposition is stored internally and may be used to do subsequent calculation. if the largest pivot found is less than minpivot the matrix a is considered as singular. exception notsquare is raised if a is not a square matrix.

        Parameters
        ----------
        A: math_Matrix
        MinPivot: float,optional
        	default value is 1.0e-20
        theProgress: Message_ProgressRange,optional
        	default value is Message_ProgressRange()

        Returns
        -------
        None

        """
        this = _math.new_math_Gauss(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Determinant(self, *args) -> "Standard_Real":
        """
        This routine returns the value of the determinant of the previously lu decomposed matrix a. exception notdone may be raised if the decomposition of a was not done successfully, zero is returned if the matrix a was considered as singular.

        Returns
        -------
        float

        """
        return _math.math_Gauss_Determinant(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_Gauss self) -> std::string"""
        return _math.math_Gauss_DumpToString(self)


    def Invert(self, *args) -> "void":
        """
        This routine outputs inv the inverse of the previously lu decomposed matrix a. exception dimensionerror is raised if the ranges of b are not equal to the ranges of a.

        Parameters
        ----------
        Inv: math_Matrix

        Returns
        -------
        None

        """
        return _math.math_Gauss_Invert(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computations are successful, otherwise returns false.

        Returns
        -------
        bool

        """
        return _math.math_Gauss_IsDone(self, *args)


    def Solve(self, *args) -> "void":
        """
        Given the input vector b this routine returns the solution x of the set of linear equations a . x = b. exception notdone is raised if the decomposition of a was not done successfully. exception dimensionerror is raised if the range of b is not equal to the number of rows of a.

        Parameters
        ----------
        B: math_Vector
        X: math_Vector

        Returns
        -------
        None

        Given the input vector b this routine solves the set of linear equations a . x = b. b is replaced by the vector solution x. exception notdone is raised if the decomposition of a was not done successfully. exception dimensionerror is raised if the range of b is not equal to the number of rows of a.

        Parameters
        ----------
        B: math_Vector

        Returns
        -------
        None

        """
        return _math.math_Gauss_Solve(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Gauss
    __del__ = lambda self: None
math_Gauss_swigregister = _math.math_Gauss_swigregister
math_Gauss_swigregister(math_Gauss)

class math_GaussLeastSquare(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_GaussLeastSquare, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_GaussLeastSquare, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Given an input n x m matrix a with n >= m this constructor performs the lu decomposition with partial pivoting (interchange of rows) of the matrix aa = a.transposed() * a; this lu decomposition is stored internally and may be used to do subsequent calculation. if the largest pivot found is less than minpivot the matrix <a> is considered as singular.

        Parameters
        ----------
        A: math_Matrix
        MinPivot: float,optional
        	default value is 1.0e-20

        Returns
        -------
        None

        """
        this = _math.new_math_GaussLeastSquare(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DumpToString(self) -> "std::string":
        """DumpToString(math_GaussLeastSquare self) -> std::string"""
        return _math.math_GaussLeastSquare_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computations are successful, otherwise returns false.e.

        Returns
        -------
        bool

        """
        return _math.math_GaussLeastSquare_IsDone(self, *args)


    def Solve(self, *args) -> "void":
        """
        Given the input vector <b> this routine solves the set of linear equations a . x = b. exception notdone is raised if the decomposition of a was not done successfully. exception dimensionerror is raised if the range of b inv is not equal to the rowrange of a. exception dimensionerror is raised if the range of x inv is not equal to the colrange of a.

        Parameters
        ----------
        B: math_Vector
        X: math_Vector

        Returns
        -------
        None

        """
        return _math.math_GaussLeastSquare_Solve(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_GaussLeastSquare
    __del__ = lambda self: None
math_GaussLeastSquare_swigregister = _math.math_GaussLeastSquare_swigregister
math_GaussLeastSquare_swigregister(math_GaussLeastSquare)

class math_GaussMultipleIntegration(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_GaussMultipleIntegration, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_GaussMultipleIntegration, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        The gauss-legendre integration with order = points of integration for each unknow, is done on the function f between the bounds lower and upper.

        Parameters
        ----------
        F: math_MultipleVarFunction
        Lower: math_Vector
        Upper: math_Vector
        Order: math_IntegerVector

        Returns
        -------
        None

        """
        this = _math.new_math_GaussMultipleIntegration(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DumpToString(self) -> "std::string":
        """DumpToString(math_GaussMultipleIntegration self) -> std::string"""
        return _math.math_GaussMultipleIntegration_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if all has been correctly done.

        Returns
        -------
        bool

        """
        return _math.math_GaussMultipleIntegration_IsDone(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        Returns the value of the integral.

        Returns
        -------
        float

        """
        return _math.math_GaussMultipleIntegration_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_GaussMultipleIntegration
    __del__ = lambda self: None
math_GaussMultipleIntegration_swigregister = _math.math_GaussMultipleIntegration_swigregister
math_GaussMultipleIntegration_swigregister(math_GaussMultipleIntegration)

class math_GaussSetIntegration(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_GaussSetIntegration, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_GaussSetIntegration, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        The gauss-legendre integration with order = points of integration for each unknow, is done on the function f between the bounds lower and upper.

        Parameters
        ----------
        F: math_FunctionSet
        Lower: math_Vector
        Upper: math_Vector
        Order: math_IntegerVector

        Returns
        -------
        None

        """
        this = _math.new_math_GaussSetIntegration(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DumpToString(self) -> "std::string":
        """DumpToString(math_GaussSetIntegration self) -> std::string"""
        return _math.math_GaussSetIntegration_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if all has been correctly done.

        Returns
        -------
        bool

        """
        return _math.math_GaussSetIntegration_IsDone(self, *args)


    def Value(self, *args) -> "math_Vector const &":
        """
        Returns the value of the integral.

        Returns
        -------
        math_Vector

        """
        return _math.math_GaussSetIntegration_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_GaussSetIntegration
    __del__ = lambda self: None
math_GaussSetIntegration_swigregister = _math.math_GaussSetIntegration_swigregister
math_GaussSetIntegration_swigregister(math_GaussSetIntegration)

class math_GaussSingleIntegration(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_GaussSingleIntegration, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_GaussSingleIntegration, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        The gauss-legendre integration with n = order points of integration, is done on the function f between the bounds lower and upper.

        Parameters
        ----------
        F: math_Function
        Lower: float
        Upper: float
        Order: int

        Returns
        -------
        None

        The gauss-legendre integration with n = order points of integration and given tolerance = tol is done on the function f between the bounds lower and upper.

        Parameters
        ----------
        F: math_Function
        Lower: float
        Upper: float
        Order: int
        Tol: float

        Returns
        -------
        None

        """
        this = _math.new_math_GaussSingleIntegration(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DumpToString(self) -> "std::string":
        """DumpToString(math_GaussSingleIntegration self) -> std::string"""
        return _math.math_GaussSingleIntegration_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if all has been correctly done.

        Returns
        -------
        bool

        """
        return _math.math_GaussSingleIntegration_IsDone(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        Returns the value of the integral.

        Returns
        -------
        float

        """
        return _math.math_GaussSingleIntegration_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_GaussSingleIntegration
    __del__ = lambda self: None
math_GaussSingleIntegration_swigregister = _math.math_GaussSingleIntegration_swigregister
math_GaussSingleIntegration_swigregister(math_GaussSingleIntegration)

class math_GlobOptMin(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_GlobOptMin, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_GlobOptMin, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Constructor. perform method is not called from it. @param thefunc - objective functional. @param thelowerborder - lower corner of the search box. @param theupperborder - upper corner of the search box. @param thec - lipschitz constant. @param thediscretizationtol - parameter space discretization tolerance. @param thesametol - functional value space indifference tolerance.

        Parameters
        ----------
        theFunc: math_MultipleVarFunction *
        theLowerBorder: math_Vector
        theUpperBorder: math_Vector
        theC: float,optional
        	default value is 9
        theDiscretizationTol: float,optional
        	default value is 1.0e-2
        theSameTol: float,optional
        	default value is 1.0e-7

        Returns
        -------
        None

        """
        this = _math.new_math_GlobOptMin(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetContinuity(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _math.math_GlobOptMin_GetContinuity(self, *args)


    def GetF(self, *args) -> "Standard_Real":
        """
        Get best functional value.

        Returns
        -------
        float

        """
        return _math.math_GlobOptMin_GetF(self, *args)


    def GetFunctionalMinimalValue(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _math.math_GlobOptMin_GetFunctionalMinimalValue(self, *args)


    def GetLipConstState(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _math.math_GlobOptMin_GetLipConstState(self, *args)


    def GetTol(self, *args) -> "void":
        """
        Method to get tolerances. @param thediscretizationtol - parameter space discretization tolerance. @param thesametol - functional value space indifference tolerance.

        Parameters
        ----------

        Returns
        -------
        theDiscretizationTol: float
        theSameTol: float

        """
        return _math.math_GlobOptMin_GetTol(self, *args)


    def NbExtrema(self, *args) -> "Standard_Integer":
        """
        Return count of global extremas.

        Returns
        -------
        int

        """
        return _math.math_GlobOptMin_NbExtrema(self, *args)


    def Perform(self, *args) -> "void":
        """
        @param isfindsinglesolution - defines whether to find single solution or all solutions.

        Parameters
        ----------
        isFindSingleSolution: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        return _math.math_GlobOptMin_Perform(self, *args)


    def Points(self, *args) -> "void":
        """
        Return solution theindex, 1 <= theindex <= nbextrema.

        Parameters
        ----------
        theIndex: int
        theSol: math_Vector

        Returns
        -------
        None

        """
        return _math.math_GlobOptMin_Points(self, *args)


    def SetContinuity(self, *args) -> "void":
        """
        Set / get continuity of local borders splits (0 ~ c0, 1 ~ c1, 2 ~ c2).

        Parameters
        ----------
        theCont: int

        Returns
        -------
        None

        """
        return _math.math_GlobOptMin_SetContinuity(self, *args)


    def SetFunctionalMinimalValue(self, *args) -> "void":
        """
        Set / get functional minimal value.

        Parameters
        ----------
        theMinimalValue: float

        Returns
        -------
        None

        """
        return _math.math_GlobOptMin_SetFunctionalMinimalValue(self, *args)


    def SetGlobalParams(self, *args) -> "void":
        """
        @param thefunc - objective functional. @param thelowerborder - lower corner of the search box. @param theupperborder - upper corner of the search box. @param thec - lipschitz constant. @param thediscretizationtol - parameter space discretization tolerance. @param thesametol - functional value space indifference tolerance.

        Parameters
        ----------
        theFunc: math_MultipleVarFunction *
        theLowerBorder: math_Vector
        theUpperBorder: math_Vector
        theC: float,optional
        	default value is 9
        theDiscretizationTol: float,optional
        	default value is 1.0e-2
        theSameTol: float,optional
        	default value is 1.0e-7

        Returns
        -------
        None

        """
        return _math.math_GlobOptMin_SetGlobalParams(self, *args)


    def SetLipConstState(self, *args) -> "void":
        """
        Set / get lipchitz constant modification state. true means that the constant is locked and unlocked otherwise.

        Parameters
        ----------
        theFlag: bool

        Returns
        -------
        None

        """
        return _math.math_GlobOptMin_SetLipConstState(self, *args)


    def SetLocalParams(self, *args) -> "void":
        """
        Method to reduce bounding box. perform will use this box. @param thelocala - lower corner of the local box. @param thelocalb - upper corner of the local box.

        Parameters
        ----------
        theLocalA: math_Vector
        theLocalB: math_Vector

        Returns
        -------
        None

        """
        return _math.math_GlobOptMin_SetLocalParams(self, *args)


    def SetTol(self, *args) -> "void":
        """
        Method to set tolerances. @param thediscretizationtol - parameter space discretization tolerance. @param thesametol - functional value space indifference tolerance.

        Parameters
        ----------
        theDiscretizationTol: float
        theSameTol: float

        Returns
        -------
        None

        """
        return _math.math_GlobOptMin_SetTol(self, *args)


    def isDone(self, *args) -> "Standard_Boolean":
        """
        Return computation state of the algorithm.

        Returns
        -------
        bool

        """
        return _math.math_GlobOptMin_isDone(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_GlobOptMin
    __del__ = lambda self: None
math_GlobOptMin_swigregister = _math.math_GlobOptMin_swigregister
math_GlobOptMin_swigregister(math_GlobOptMin)

class math_Householder(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_Householder, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_Householder, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Given an input matrix a with n>= m, given an input matrix b this constructor performs the least square resolution of the set of linear equations a.x = b for each column of b. if a column norm is less than eps, the resolution can't be done. exception dimensionerror is raised if the row number of b is different from the a row number.

        Parameters
        ----------
        A: math_Matrix
        B: math_Matrix
        EPS: float,optional
        	default value is 1.0e-20

        Returns
        -------
        None

        Given an input matrix a with n>= m, given an input matrix b this constructor performs the least square resolution of the set of linear equations a.x = b for each column of b. if a column norm is less than eps, the resolution can't be done. exception dimensionerror is raised if the row number of b is different from the a row number.

        Parameters
        ----------
        A: math_Matrix
        B: math_Matrix
        lowerArow: int
        upperArow: int
        lowerAcol: int
        upperAcol: int
        EPS: float,optional
        	default value is 1.0e-20

        Returns
        -------
        None

        Given an input matrix a with n>= m, given an input vector b this constructor performs the least square resolution of the set of linear equations a.x = b. if a column norm is less than eps, the resolution can't be done. exception dimensionerror is raised if the length of b is different from the a row number.

        Parameters
        ----------
        A: math_Matrix
        B: math_Vector
        EPS: float,optional
        	default value is 1.0e-20

        Returns
        -------
        None

        """
        this = _math.new_math_Householder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AllValues(self, *args) -> "math_Matrix const &":
        """
        Returns the matrix sol of all the solutions of the system a.x = b. exception notdone is raised is the resolution has not be done.

        Returns
        -------
        math_Matrix

        """
        return _math.math_Householder_AllValues(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_Householder self) -> std::string"""
        return _math.math_Householder_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computations are successful, otherwise returns false.

        Returns
        -------
        bool

        """
        return _math.math_Householder_IsDone(self, *args)


    def Value(self, *args) -> "void":
        """
        Given the integer index, this routine returns the corresponding least square solution sol. exception notdone is raised if the resolution has not be done. exception outofrange is raised if index <=0 or index is more than the number of columns of b.

        Parameters
        ----------
        sol: math_Vector
        Index: int,optional
        	default value is 1

        Returns
        -------
        None

        """
        return _math.math_Householder_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Householder
    __del__ = lambda self: None
math_Householder_swigregister = _math.math_Householder_swigregister
math_Householder_swigregister(math_Householder)

class math_IntegerVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_IntegerVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_IntegerVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Contructs an integervector in the range [lower..upper].

        Parameters
        ----------
        theFirst: int
        theLast: int

        Returns
        -------
        None

        Contructs an integervector in the range [lower..upper] with all the elements set to theinitialvalue.

        Parameters
        ----------
        theFirst: int
        theLast: int
        theInitialValue: int

        Returns
        -------
        None

        Constructs an integervector in the range [lower..upper] which share the 'c array' thetab.

        Parameters
        ----------
        theTab: int *
        theFirst: int
        theLast: int

        Returns
        -------
        None

        Constructs a copy for initialization. an exception is raised if the lengths of the integervectors are different.

        Parameters
        ----------
        theOther: math_IntegerVector

        Returns
        -------
        None

        """
        this = _math.new_math_IntegerVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args) -> "void":
        """
        Adds the integervector 'theright' to an integervector. an exception is raised if the integervectors have not the same length. an exception is raised if the lengths are not equal.

        Parameters
        ----------
        theRight: math_IntegerVector

        Returns
        -------
        None

        Sets an integervector to the sum of the integervector 'theleft' and the integervector 'theright'. an exception is raised if the lengths are different.

        Parameters
        ----------
        theLeft: math_IntegerVector
        theRight: math_IntegerVector

        Returns
        -------
        None

        """
        return _math.math_IntegerVector_Add(self, *args)


    def Added(self, *args) -> "math_IntegerVector":
        """
        Adds the integervector 'theright' to an integervector. an exception is raised if the integervectors have not the same length. an exception is raised if the lengths are not equal.

        Parameters
        ----------
        theRight: math_IntegerVector

        Returns
        -------
        math_IntegerVector

        """
        return _math.math_IntegerVector_Added(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_IntegerVector self) -> std::string"""
        return _math.math_IntegerVector_DumpToString(self)


    def Init(self, *args) -> "void":
        """
        Initialize an integervector with all the elements set to theinitialvalue.

        Parameters
        ----------
        theInitialValue: int

        Returns
        -------
        None

        """
        return _math.math_IntegerVector_Init(self, *args)


    def Initialized(self, *args) -> "math_IntegerVector &":
        """
        Initialises an integervector by copying 'theother'. an exception is raised if the lengths are different.

        Parameters
        ----------
        theOther: math_IntegerVector

        Returns
        -------
        math_IntegerVector

        """
        return _math.math_IntegerVector_Initialized(self, *args)


    def Inverse(self, *args) -> "math_IntegerVector":
        """
        Returns the inverse integervector of an integervector.

        Returns
        -------
        math_IntegerVector

        """
        return _math.math_IntegerVector_Inverse(self, *args)


    def Invert(self, *args) -> "void":
        """
        Inverses an integervector.

        Returns
        -------
        None

        """
        return _math.math_IntegerVector_Invert(self, *args)


    def Length(self, *args) -> "Standard_Integer":
        """
        Returns the length of an integervector.

        Returns
        -------
        int

        """
        return _math.math_IntegerVector_Length(self, *args)


    def Lower(self, *args) -> "Standard_Integer":
        """
        Returns the value of the lower index of an integervector.

        Returns
        -------
        int

        """
        return _math.math_IntegerVector_Lower(self, *args)


    def Max(self, *args) -> "Standard_Integer":
        """
        Returns the value of the index of the maximum element of an integervector.

        Returns
        -------
        int

        """
        return _math.math_IntegerVector_Max(self, *args)


    def Min(self, *args) -> "Standard_Integer":
        """
        Returns the value of the index of the minimum element of an integervector.

        Returns
        -------
        int

        """
        return _math.math_IntegerVector_Min(self, *args)


    def Multiplied(self, *args) -> "Standard_Integer":
        """
        Returns the product of an integervector by an integer value.

        Parameters
        ----------
        theRight: int

        Returns
        -------
        math_IntegerVector

        Returns the inner product of 2 integervectors. an exception is raised if the lengths are not equal.

        Parameters
        ----------
        theRight: math_IntegerVector

        Returns
        -------
        int

        """
        return _math.math_IntegerVector_Multiplied(self, *args)


    def Multiply(self, *args) -> "void":
        """
        Returns the product of an integervector by an integer value.

        Parameters
        ----------
        theRight: int

        Returns
        -------
        None

        Returns the multiplication of an integer by an integervector.

        Parameters
        ----------
        theLeft: int
        theRight: math_IntegerVector

        Returns
        -------
        None

        """
        return _math.math_IntegerVector_Multiply(self, *args)


    def Norm(self, *args) -> "Standard_Real":
        """
        Returns the value of the norm of an integervector.

        Returns
        -------
        float

        """
        return _math.math_IntegerVector_Norm(self, *args)


    def Norm2(self, *args) -> "Standard_Real":
        """
        Returns the value of the square of the norm of an integervector.

        Returns
        -------
        float

        """
        return _math.math_IntegerVector_Norm2(self, *args)


    def Opposite(self, *args) -> "math_IntegerVector":
        """
        Returns the opposite of an integervector.

        Returns
        -------
        math_IntegerVector

        """
        return _math.math_IntegerVector_Opposite(self, *args)


    def Set(self, *args) -> "void":
        """
        Sets an integervector from 'thei1' to 'thei2' to the integervector 'thev'; an exception is raised if 'thei1' is less than 'lowerindex' or 'thei2' is greater than 'upperindex' or 'thei1' is greater than 'thei2'. an exception is raised if 'thei2-thei1+1' is different from the length of 'thev'.

        Parameters
        ----------
        theI1: int
        theI2: int
        theV: math_IntegerVector

        Returns
        -------
        None

        """
        return _math.math_IntegerVector_Set(self, *args)


    def Slice(self, *args) -> "math_IntegerVector":
        """
        Slices the values of the integervector between 'thei1' and 'thei2': example: [2, 1, 2, 3, 4, 5] becomes [2, 4, 3, 2, 1, 5] between 2 and 5. an exception is raised if 'thei1' is less than 'lowerindex' or 'thei2' is greater than 'upperindex'.

        Parameters
        ----------
        theI1: int
        theI2: int

        Returns
        -------
        math_IntegerVector

        """
        return _math.math_IntegerVector_Slice(self, *args)


    def Subtract(self, *args) -> "void":
        """
        Sets an integervector to the substraction of 'theright' from 'theleft'. an exception is raised if the integervectors have not the same length.

        Parameters
        ----------
        theLeft: math_IntegerVector
        theRight: math_IntegerVector

        Returns
        -------
        None

        Returns the subtraction of 'theright' from 'me'. an exception is raised if the integervectors have not the same length.

        Parameters
        ----------
        theRight: math_IntegerVector

        Returns
        -------
        None

        """
        return _math.math_IntegerVector_Subtract(self, *args)


    def Subtracted(self, *args) -> "math_IntegerVector":
        """
        Returns the subtraction of 'theright' from 'me'. an exception is raised if the integervectors have not the same length.

        Parameters
        ----------
        theRight: math_IntegerVector

        Returns
        -------
        math_IntegerVector

        """
        return _math.math_IntegerVector_Subtracted(self, *args)


    def TMultiplied(self, *args) -> "math_IntegerVector":
        """
        Returns the product of a vector and a real value.

        Parameters
        ----------
        theRight: int

        Returns
        -------
        math_IntegerVector

        """
        return _math.math_IntegerVector_TMultiplied(self, *args)


    def Upper(self, *args) -> "Standard_Integer":
        """
        Returns the value of the upper index of an integervector.

        Returns
        -------
        int

        """
        return _math.math_IntegerVector_Upper(self, *args)


    def Value(self, *args) -> "Standard_Integer const &":
        """
        Accesses the value of index thenum of an integervector.

        Parameters
        ----------
        theNum: int

        Returns
        -------
        int

        """
        return _math.math_IntegerVector_Value(self, *args)


    def GetValue(self, theNum: 'Standard_Integer const') -> "Standard_Integer":
        """GetValue(math_IntegerVector self, Standard_Integer const theNum) -> Standard_Integer"""
        return _math.math_IntegerVector_GetValue(self, theNum)


    def SetValue(self, theNum: 'Standard_Integer const', value: 'Standard_Integer') -> "void":
        """SetValue(math_IntegerVector self, Standard_Integer const theNum, Standard_Integer value)"""
        return _math.math_IntegerVector_SetValue(self, theNum, value)


    def __mul__(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Parameters
        ----------
        theRight: int

        Returns
        -------
        math_IntegerVector

        No available documentation.

        Parameters
        ----------
        theRight: math_IntegerVector

        Returns
        -------
        int

        """
        return _math.math_IntegerVector___mul__(self, *args)


    def __imul_wrapper__(self, other: 'Standard_Integer const') -> "void":
        """__imul_wrapper__(math_IntegerVector self, Standard_Integer const other)"""
        return _math.math_IntegerVector___imul_wrapper__(self, other)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __add__(self, *args) -> "math_IntegerVector":
        """
        No available documentation.

        Parameters
        ----------
        theRight: math_IntegerVector

        Returns
        -------
        math_IntegerVector

        """
        return _math.math_IntegerVector___add__(self, *args)


    def __iadd_wrapper__(self, other: 'math_IntegerVector') -> "void":
        """__iadd_wrapper__(math_IntegerVector self, math_IntegerVector other)"""
        return _math.math_IntegerVector___iadd_wrapper__(self, other)


    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self


    def __neg__(self, *args) -> "math_IntegerVector":
        """
        No available documentation.

        Returns
        -------
        math_IntegerVector

        """
        return _math.math_IntegerVector___neg__(self, *args)


    def __sub__(self, *args) -> "math_IntegerVector":
        """
        No available documentation.

        Parameters
        ----------
        theRight: math_IntegerVector

        Returns
        -------
        math_IntegerVector

        """
        return _math.math_IntegerVector___sub__(self, *args)


    def __isub_wrapper__(self, other: 'math_IntegerVector') -> "void":
        """__isub_wrapper__(math_IntegerVector self, math_IntegerVector other)"""
        return _math.math_IntegerVector___isub_wrapper__(self, other)


    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_IntegerVector
    __del__ = lambda self: None
math_IntegerVector_swigregister = _math.math_IntegerVector_swigregister
math_IntegerVector_swigregister(math_IntegerVector)

class math_Jacobi(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_Jacobi, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_Jacobi, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Given a real n x n matrix a, this constructor computes all its eigenvalues and eigenvectors using the jacobi method. the exception notsquare is raised if the matrix is not square. no verification that the matrix a is really symmetric is done.

        Parameters
        ----------
        A: math_Matrix

        Returns
        -------
        None

        """
        this = _math.new_math_Jacobi(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DumpToString(self) -> "std::string":
        """DumpToString(math_Jacobi self) -> std::string"""
        return _math.math_Jacobi_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computations are successful, otherwise returns false.

        Returns
        -------
        bool

        """
        return _math.math_Jacobi_IsDone(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        Returns the eigenvalue number num. eigenvalues are in the range (1..n). exception notdone is raised if calculation is not done successfully.

        Parameters
        ----------
        Num: int

        Returns
        -------
        float

        """
        return _math.math_Jacobi_Value(self, *args)


    def Values(self, *args) -> "math_Vector const &":
        """
        Returns the eigenvalues vector. exception notdone is raised if calculation is not done successfully.

        Returns
        -------
        math_Vector

        """
        return _math.math_Jacobi_Values(self, *args)


    def Vector(self, *args) -> "void":
        """
        Returns the eigenvector v of number num. eigenvectors are in the range (1..n). exception notdone is raised if calculation is not done successfully.

        Parameters
        ----------
        Num: int
        V: math_Vector

        Returns
        -------
        None

        """
        return _math.math_Jacobi_Vector(self, *args)


    def Vectors(self, *args) -> "math_Matrix const &":
        """
        Returns the eigenvectors matrix. exception notdone is raised if calculation is not done successfully.

        Returns
        -------
        math_Matrix

        """
        return _math.math_Jacobi_Vectors(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Jacobi
    __del__ = lambda self: None
math_Jacobi_swigregister = _math.math_Jacobi_swigregister
math_Jacobi_swigregister(math_Jacobi)

class math_KronrodSingleIntegration(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_KronrodSingleIntegration, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_KronrodSingleIntegration, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        An empty constructor.

        Returns
        -------
        None

        Constructor. takes the function, the lower and upper bound values, the initial number of kronrod points.

        Parameters
        ----------
        theFunction: math_Function
        theLower: float
        theUpper: float
        theNbPnts: int

        Returns
        -------
        None

        Constructor. takes the function, the lower and upper bound values, the initial number of kronrod points, the tolerance value and the maximal number of iterations as parameters.

        Parameters
        ----------
        theFunction: math_Function
        theLower: float
        theUpper: float
        theNbPnts: int
        theTolerance: float
        theMaxNbIter: int

        Returns
        -------
        None

        """
        this = _math.new_math_KronrodSingleIntegration(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AbsolutError(self, *args) -> "Standard_Real":
        """
        Returns the value of the relative error reached.

        Returns
        -------
        float

        """
        return _math.math_KronrodSingleIntegration_AbsolutError(self, *args)


    def ErrorReached(self, *args) -> "Standard_Real":
        """
        Returns the value of the relative error reached.

        Returns
        -------
        float

        """
        return _math.math_KronrodSingleIntegration_ErrorReached(self, *args)


    def GKRule(*args) -> "Standard_Real &, Standard_Real &":
        """
        No available documentation.

        Parameters
        ----------
        theFunction: math_Function
        theLower: float
        theUpper: float
        theGaussP: math_Vector
        theGaussW: math_Vector
        theKronrodP: math_Vector
        theKronrodW: math_Vector

        Returns
        -------
        theValue: float
        theError: float

        """
        return _math.math_KronrodSingleIntegration_GKRule(*args)

    GKRule = staticmethod(GKRule)

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns standard_true if computation is performed successfully.

        Returns
        -------
        bool

        """
        return _math.math_KronrodSingleIntegration_IsDone(self, *args)


    def NbIterReached(self, *args) -> "Standard_Integer":
        """
        Returns the number of iterations that were made to compute result.

        Returns
        -------
        int

        """
        return _math.math_KronrodSingleIntegration_NbIterReached(self, *args)


    def OrderReached(self, *args) -> "Standard_Integer":
        """
        Returns the number of kronrod points for which the result is computed.

        Returns
        -------
        int

        """
        return _math.math_KronrodSingleIntegration_OrderReached(self, *args)


    def Perform(self, *args) -> "void":
        """
        Computation of the integral. takes the function, the lower and upper bound values, the initial number of kronrod points, the relative tolerance value and the maximal number of iterations as parameters. thenbpnts should be odd and greater then or equal to 3.

        Parameters
        ----------
        theFunction: math_Function
        theLower: float
        theUpper: float
        theNbPnts: int

        Returns
        -------
        None

        Computation of the integral. takes the function, the lower and upper bound values, the initial number of kronrod points, the relative tolerance value and the maximal number of iterations as parameters. thenbpnts should be odd and greater then or equal to 3. note that thetolerance is relative, i.e. the criterion of solution reaching is: abs(kronrod - gauss)/abs(kronrod) < thetolerance. thetolerance should be positive.

        Parameters
        ----------
        theFunction: math_Function
        theLower: float
        theUpper: float
        theNbPnts: int
        theTolerance: float
        theMaxNbIter: int

        Returns
        -------
        None

        """
        return _math.math_KronrodSingleIntegration_Perform(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        Returns the value of the integral.

        Returns
        -------
        float

        """
        return _math.math_KronrodSingleIntegration_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_KronrodSingleIntegration
    __del__ = lambda self: None
math_KronrodSingleIntegration_swigregister = _math.math_KronrodSingleIntegration_swigregister
math_KronrodSingleIntegration_swigregister(math_KronrodSingleIntegration)

def math_KronrodSingleIntegration_GKRule(*args) -> "Standard_Real &, Standard_Real &":
    """
    No available documentation.

    Parameters
    ----------
    theFunction: math_Function
    theLower: float
    theUpper: float
    theGaussP: math_Vector
    theGaussW: math_Vector
    theKronrodP: math_Vector
    theKronrodW: math_Vector

    Returns
    -------
    theValue: float
    theError: float

    """
    return _math.math_KronrodSingleIntegration_GKRule(*args)

class math_Matrix(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_Matrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_Matrix, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Constructs a non-initialized matrix of range [lowerrow..upperrow, lowercol..uppercol] for the constructed matrix: - lowerrow and upperrow are the indexes of the lower and upper bounds of a row, and - lowercol and uppercol are the indexes of the lower and upper bounds of a column.

        Parameters
        ----------
        LowerRow: int
        UpperRow: int
        LowerCol: int
        UpperCol: int

        Returns
        -------
        None

        Constructs a non-initialized matrix of range [lowerrow..upperrow, lowercol..uppercol] whose values are all initialized with the value initialvalue.

        Parameters
        ----------
        LowerRow: int
        UpperRow: int
        LowerCol: int
        UpperCol: int
        InitialValue: float

        Returns
        -------
        None

        Constructs a matrix of range [lowerrow..upperrow, lowercol..uppercol] sharing data with a 'c array' pointed by tab.

        Parameters
        ----------
        Tab: Standard_Address
        LowerRow: int
        UpperRow: int
        LowerCol: int
        UpperCol: int

        Returns
        -------
        None

        Constructs a matrix for copy in initialization. an exception is raised if the matrixes have not the same dimensions.

        Parameters
        ----------
        Other: math_Matrix

        Returns
        -------
        None

        """
        this = _math.new_math_Matrix(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args) -> "void":
        """
        Adds the matrix <right> to a matrix. an exception is raised if the dimensions are different. warning in order to save time when copying matrices, it is preferable to use operator += or the function add whenever possible.

        Parameters
        ----------
        Right: math_Matrix

        Returns
        -------
        None

        Sets a matrix to the addition of <left> and <right>. an exception is raised if the dimensions are different.

        Parameters
        ----------
        Left: math_Matrix
        Right: math_Matrix

        Returns
        -------
        None

        """
        return _math.math_Matrix_Add(self, *args)


    def Added(self, *args) -> "math_Matrix":
        """
        Adds the matrix <right> to a matrix. an exception is raised if the dimensions are different.

        Parameters
        ----------
        Right: math_Matrix

        Returns
        -------
        math_Matrix

        """
        return _math.math_Matrix_Added(self, *args)


    def Col(self, *args) -> "math_Vector":
        """
        Returns the column of index <col> of a matrix.

        Parameters
        ----------
        Col: int

        Returns
        -------
        math_Vector

        """
        return _math.math_Matrix_Col(self, *args)


    def ColNumber(self, *args) -> "Standard_Integer":
        """
        Returns the number of rows of this matrix. note that for a matrix a you always have the following relations: - a.rownumber() = a.upperrow() - a.lowerrow() + 1 - a.colnumber() = a.uppercol() - a.lowercol() + 1 - the length of a row of a is equal to the number of columns of a, - the length of a column of a is equal to the number of rows of a.returns the row range of a matrix.

        Returns
        -------
        int

        """
        return _math.math_Matrix_ColNumber(self, *args)


    def Determinant(self, *args) -> "Standard_Real":
        """
        Computes the determinant of a matrix. an exception is raised if the matrix is not a square matrix.

        Returns
        -------
        float

        """
        return _math.math_Matrix_Determinant(self, *args)


    def Divide(self, *args) -> "void":
        """
        Divides all the elements of a matrix by the value <right>. an exception is raised if <right> = 0.

        Parameters
        ----------
        Right: float

        Returns
        -------
        None

        """
        return _math.math_Matrix_Divide(self, *args)


    def Divided(self, *args) -> "math_Matrix":
        """
        Divides all the elements of a matrix by the value <right>. an exception is raised if <right> = 0.

        Parameters
        ----------
        Right: float

        Returns
        -------
        math_Matrix

        """
        return _math.math_Matrix_Divided(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_Matrix self) -> std::string"""
        return _math.math_Matrix_DumpToString(self)


    def Init(self, *args) -> "void":
        """
        Initialize all the elements of a matrix to initialvalue.

        Parameters
        ----------
        InitialValue: float

        Returns
        -------
        None

        """
        return _math.math_Matrix_Init(self, *args)


    def Initialized(self, *args) -> "math_Matrix &":
        """
        Matrixes are copied through assignement. an exception is raised if the dimensions are differents.

        Parameters
        ----------
        Other: math_Matrix

        Returns
        -------
        math_Matrix

        """
        return _math.math_Matrix_Initialized(self, *args)


    def Inverse(self, *args) -> "math_Matrix":
        """
        Returns the inverse of a matrix. exception notsquare is raised if the matrix is not square. exception singularmatrix is raised if the matrix is singular.

        Returns
        -------
        math_Matrix

        """
        return _math.math_Matrix_Inverse(self, *args)


    def Invert(self, *args) -> "void":
        """
        Inverts a matrix using gauss algorithm. exception notsquare is raised if the matrix is not square. exception singularmatrix is raised if the matrix is singular.

        Returns
        -------
        None

        """
        return _math.math_Matrix_Invert(self, *args)


    def LowerCol(self, *args) -> "Standard_Integer":
        """
        Returns the value of the lower index of the column range of a matrix.

        Returns
        -------
        int

        """
        return _math.math_Matrix_LowerCol(self, *args)


    def LowerRow(self, *args) -> "Standard_Integer":
        """
        Returns the value of the lower index of the row range of a matrix.

        Returns
        -------
        int

        """
        return _math.math_Matrix_LowerRow(self, *args)


    def Multiplied(self, *args) -> "math_Vector":
        """
        Multiplies all the elements of a matrix by the value <right>.

        Parameters
        ----------
        Right: float

        Returns
        -------
        math_Matrix

        Returns the product of 2 matrices. an exception is raised if the dimensions are different.

        Parameters
        ----------
        Right: math_Matrix

        Returns
        -------
        math_Matrix

        Returns the product of a matrix by a vector. an exception is raised if the dimensions are different.

        Parameters
        ----------
        Right: math_Vector

        Returns
        -------
        math_Vector

        """
        return _math.math_Matrix_Multiplied(self, *args)


    def Multiply(self, *args) -> "void":
        """
        Sets this matrix to the product of the matrix left, and the matrix right. example math_matrix a (1, 3, 1, 3); math_matrix b (1, 3, 1, 3); // a = ... , b = ... math_matrix c (1, 3, 1, 3); c.multiply(a, b); exceptions standard_dimensionerror if matrices are of incompatible dimensions, i.e. if: - the number of columns of matrix left, or the number of rows of matrix tleft is not equal to the number of rows of matrix right, or - the number of rows of matrix left, or the number of columns of matrix tleft is not equal to the number of rows of this matrix, or - the number of columns of matrix right is not equal to the number of columns of this matrix.

        Parameters
        ----------
        Right: float

        Returns
        -------
        None

        Computes a matrix as the product of 2 vectors. an exception is raised if the dimensions are different. <self> = <left> * <right>.

        Parameters
        ----------
        Left: math_Vector
        Right: math_Vector

        Returns
        -------
        None

        Computes a matrix as the product of 2 matrixes. an exception is raised if the dimensions are different.

        Parameters
        ----------
        Left: math_Matrix
        Right: math_Matrix

        Returns
        -------
        None

        Returns the product of 2 matrices. an exception is raised if the dimensions are different.

        Parameters
        ----------
        Right: math_Matrix

        Returns
        -------
        None

        """
        return _math.math_Matrix_Multiply(self, *args)


    def Opposite(self, *args) -> "math_Matrix":
        """
        Returns the opposite of a matrix. an exception is raised if the dimensions are different.

        Returns
        -------
        math_Matrix

        """
        return _math.math_Matrix_Opposite(self, *args)


    def Row(self, *args) -> "math_Vector":
        """
        Returns the row of index row of a matrix.

        Parameters
        ----------
        Row: int

        Returns
        -------
        math_Vector

        """
        return _math.math_Matrix_Row(self, *args)


    def RowNumber(self, *args) -> "Standard_Integer":
        """
        Returns the number of rows of this matrix. note that for a matrix a you always have the following relations: - a.rownumber() = a.upperrow() - a.lowerrow() + 1 - a.colnumber() = a.uppercol() - a.lowercol() + 1 - the length of a row of a is equal to the number of columns of a, - the length of a column of a is equal to the number of rows of a.returns the row range of a matrix.

        Returns
        -------
        int

        """
        return _math.math_Matrix_RowNumber(self, *args)


    def Set(self, *args) -> "void":
        """
        Sets the values of this matrix, - from index i1 to index i2 on the row dimension, and - from index j1 to index j2 on the column dimension, to those of matrix m. exceptions standard_dimensionerror if: - i1 is less than the index of the lower row bound of this matrix, or - i2 is greater than the index of the upper row bound of this matrix, or - j1 is less than the index of the lower column bound of this matrix, or - j2 is greater than the index of the upper column bound of this matrix, or - i2 - i1 + 1 is not equal to the number of rows of matrix m, or - j2 - j1 + 1 is not equal to the number of columns of matrix m.

        Parameters
        ----------
        I1: int
        I2: int
        J1: int
        J2: int
        M: math_Matrix

        Returns
        -------
        None

        """
        return _math.math_Matrix_Set(self, *args)


    def SetCol(self, *args) -> "void":
        """
        Sets the column of index col of a matrix to the vector <v>. an exception is raised if the dimensions are different. an exception is raises if <col> is inferior to the lower column of the matrix or <col> is superior to the upper column.

        Parameters
        ----------
        Col: int
        V: math_Vector

        Returns
        -------
        None

        """
        return _math.math_Matrix_SetCol(self, *args)


    def SetDiag(self, *args) -> "void":
        """
        Sets the diagonal of a matrix to the value <value>. an exception is raised if the matrix is not square.

        Parameters
        ----------
        Value: float

        Returns
        -------
        None

        """
        return _math.math_Matrix_SetDiag(self, *args)


    def SetRow(self, *args) -> "void":
        """
        Sets the row of index row of a matrix to the vector <v>. an exception is raised if the dimensions are different. an exception is raises if <row> is inferior to the lower row of the matrix or <row> is superior to the upper row.

        Parameters
        ----------
        Row: int
        V: math_Vector

        Returns
        -------
        None

        """
        return _math.math_Matrix_SetRow(self, *args)


    def Subtract(self, *args) -> "void":
        """
        Subtracts the matrix <right> from <self>. an exception is raised if the dimensions are different. warning in order to avoid time-consuming copying of matrices, it is preferable to use operator -= or the function subtract whenever possible.

        Parameters
        ----------
        Right: math_Matrix

        Returns
        -------
        None

        Sets a matrix to the subtraction of the matrix <right> from the matrix <left>. an exception is raised if the dimensions are different.

        Parameters
        ----------
        Left: math_Matrix
        Right: math_Matrix

        Returns
        -------
        None

        """
        return _math.math_Matrix_Subtract(self, *args)


    def Subtracted(self, *args) -> "math_Matrix":
        """
        Returns the result of the subtraction of <right> from <self>. an exception is raised if the dimensions are different.

        Parameters
        ----------
        Right: math_Matrix

        Returns
        -------
        math_Matrix

        """
        return _math.math_Matrix_Subtracted(self, *args)


    def SwapCol(self, *args) -> "void":
        """
        Swaps the columns of index <col1> and <col2>. an exception is raised if <col1> or <col2> is out of range.

        Parameters
        ----------
        Col1: int
        Col2: int

        Returns
        -------
        None

        """
        return _math.math_Matrix_SwapCol(self, *args)


    def SwapRow(self, *args) -> "void":
        """
        Swaps the rows of index row1 and row2. an exception is raised if <row1> or <row2> is out of range.

        Parameters
        ----------
        Row1: int
        Row2: int

        Returns
        -------
        None

        """
        return _math.math_Matrix_SwapRow(self, *args)


    def TMultiplied(self, *args) -> "math_Matrix":
        """
        Sets this matrix to the product of the transposed matrix tleft, and the matrix right. example math_matrix a (1, 3, 1, 3); math_matrix b (1, 3, 1, 3); // a = ... , b = ... math_matrix c (1, 3, 1, 3); c.multiply(a, b); exceptions standard_dimensionerror if matrices are of incompatible dimensions, i.e. if: - the number of columns of matrix left, or the number of rows of matrix tleft is not equal to the number of rows of matrix right, or - the number of rows of matrix left, or the number of columns of matrix tleft is not equal to the number of rows of this matrix, or - the number of columns of matrix right is not equal to the number of columns of this matrix.

        Parameters
        ----------
        Right: float

        Returns
        -------
        math_Matrix

        """
        return _math.math_Matrix_TMultiplied(self, *args)


    def TMultiply(self, *args) -> "void":
        """
        Returns the product of the transpose of a matrix with the matrix <right>. an exception is raised if the dimensions are different.

        Parameters
        ----------
        Right: math_Matrix

        Returns
        -------
        math_Matrix

        Computes a matrix to the product of the transpose of the matrix <tleft> with the matrix <right>. an exception is raised if the dimensions are different.

        Parameters
        ----------
        TLeft: math_Matrix
        Right: math_Matrix

        Returns
        -------
        None

        """
        return _math.math_Matrix_TMultiply(self, *args)


    def Transpose(self, *args) -> "void":
        """
        Transposes a given matrix. an exception is raised if the matrix is not a square matrix.

        Returns
        -------
        None

        """
        return _math.math_Matrix_Transpose(self, *args)


    def Transposed(self, *args) -> "math_Matrix":
        """
        Teturns the transposed of a matrix. an exception is raised if the matrix is not a square matrix.

        Returns
        -------
        math_Matrix

        """
        return _math.math_Matrix_Transposed(self, *args)


    def UpperCol(self, *args) -> "Standard_Integer":
        """
        Returns the value of the upper index of the column range of a matrix.

        Returns
        -------
        int

        """
        return _math.math_Matrix_UpperCol(self, *args)


    def UpperRow(self, *args) -> "Standard_Integer":
        """
        Returns the upper index of the row range of a matrix.

        Returns
        -------
        int

        """
        return _math.math_Matrix_UpperRow(self, *args)


    def GetValue(self, Row: 'Standard_Integer const', Col: 'Standard_Integer const') -> "Standard_Real":
        """GetValue(math_Matrix self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real"""
        return _math.math_Matrix_GetValue(self, Row, Col)


    def SetValue(self, Row: 'Standard_Integer const', Col: 'Standard_Integer const', value: 'Standard_Real') -> "void":
        """SetValue(math_Matrix self, Standard_Integer const Row, Standard_Integer const Col, Standard_Real value)"""
        return _math.math_Matrix_SetValue(self, Row, Col, value)


    def __mul__(self, *args) -> "math_Vector":
        """
        No available documentation.

        Parameters
        ----------
        Right: float

        Returns
        -------
        math_Matrix

        No available documentation.

        Parameters
        ----------
        Right: math_Matrix

        Returns
        -------
        math_Matrix

        No available documentation.

        Parameters
        ----------
        Right: math_Vector

        Returns
        -------
        math_Vector

        """
        return _math.math_Matrix___mul__(self, *args)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __imul_wrapper__(self, *args) -> "void":
        """
        __imul_wrapper__(math_Matrix self, Standard_Real const other)
        __imul_wrapper__(math_Matrix self, math_Matrix other)
        """
        return _math.math_Matrix___imul_wrapper__(self, *args)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __add__(self, *args) -> "math_Matrix":
        """
        No available documentation.

        Parameters
        ----------
        Right: math_Matrix

        Returns
        -------
        math_Matrix

        """
        return _math.math_Matrix___add__(self, *args)


    def __iadd_wrapper__(self, other: 'math_Matrix') -> "void":
        """__iadd_wrapper__(math_Matrix self, math_Matrix other)"""
        return _math.math_Matrix___iadd_wrapper__(self, other)


    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self


    def __sub__(self, *args) -> "math_Matrix":
        """
        No available documentation.

        Parameters
        ----------
        Right: math_Matrix

        Returns
        -------
        math_Matrix

        """
        return _math.math_Matrix___sub__(self, *args)


    def __neg__(self, *args) -> "math_Matrix":
        """
        No available documentation.

        Returns
        -------
        math_Matrix

        """
        return _math.math_Matrix___neg__(self, *args)


    def __isub_wrapper__(self, other: 'math_Matrix') -> "void":
        """__isub_wrapper__(math_Matrix self, math_Matrix other)"""
        return _math.math_Matrix___isub_wrapper__(self, other)


    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def __truediv__(self, *args):
        return _math.math_Matrix___truediv__(self, *args)
    __div__ = __truediv__



    def __itruediv_wrapper__(self, other: 'Standard_Real const') -> "void":
        """__itruediv_wrapper__(math_Matrix self, Standard_Real const other)"""
        return _math.math_Matrix___itruediv_wrapper__(self, other)


    def __itruediv__(self, right):
        self.__itruediv_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Matrix
    __del__ = lambda self: None
math_Matrix_swigregister = _math.math_Matrix_swigregister
math_Matrix_swigregister(math_Matrix)

class math_MultipleVarFunction(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_MultipleVarFunction, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_MultipleVarFunction, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetStateNumber(self, *args) -> "Standard_Integer":
        """
        Return the state of the function corresponding to the latestt call of any methods associated to the function. this function is called by each of the algorithms described later which define the function integer algorithm::statenumber(). the algorithm has the responsibility to call this function when it has found a solution (i.e. a root or a minimum) and has to maintain the association between the solution found and this statenumber. byu default, this method returns 0 (which means for the algorithm: no state has been saved). it is the responsibility of the programmer to decide if he needs to save the current state of the function and to return an integer that allows retrieval of the state.

        Returns
        -------
        int

        """
        return _math.math_MultipleVarFunction_GetStateNumber(self, *args)


    def NbVariables(self, *args) -> "Standard_Integer":
        """
        Returns the number of variables of the function.

        Returns
        -------
        int

        """
        return _math.math_MultipleVarFunction_NbVariables(self, *args)


    def Value(self, *args) -> "Standard_Boolean":
        """
        Computes the values of the functions <f> for the variable <x>. returns true if the computation was done successfully, otherwise false.

        Parameters
        ----------
        X: math_Vector

        Returns
        -------
        F: float

        """
        return _math.math_MultipleVarFunction_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_MultipleVarFunction
    __del__ = lambda self: None
math_MultipleVarFunction_swigregister = _math.math_MultipleVarFunction_swigregister
math_MultipleVarFunction_swigregister(math_MultipleVarFunction)

class math_NewtonFunctionRoot(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_NewtonFunctionRoot, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_NewtonFunctionRoot, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        The newton method is done to find the root of the function f from the initial guess guess. the tolerance required on the root is given by tolerance. the solution is found when : abs(xi - xi-1) <= epsx and abs(f(xi))<= epsf the maximum number of iterations allowed is given by nbiterations.

        Parameters
        ----------
        F: math_FunctionWithDerivative
        Guess: float
        EpsX: float
        EpsF: float
        NbIterations: int,optional
        	default value is 100

        Returns
        -------
        None

        The newton method is done to find the root of the function f from the initial guess guess. the solution must be inside the interval [a, b]. the tolerance required on the root is given by tolerance. the solution is found when : abs(xi - xi-1) <= epsx and abs(f(xi))<= epsf the maximum number of iterations allowed is given by nbiterations.

        Parameters
        ----------
        F: math_FunctionWithDerivative
        Guess: float
        EpsX: float
        EpsF: float
        A: float
        B: float
        NbIterations: int,optional
        	default value is 100

        Returns
        -------
        None

        Is used in a sub-class to initialize correctly all the fields of this class.

        Parameters
        ----------
        A: float
        B: float
        EpsX: float
        EpsF: float
        NbIterations: int,optional
        	default value is 100

        Returns
        -------
        None

        """
        this = _math.new_math_NewtonFunctionRoot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Derivative(self, *args) -> "Standard_Real":
        """
        Returns the value of the derivative at the root. exception notdone is raised if the root was not found.

        Returns
        -------
        float

        """
        return _math.math_NewtonFunctionRoot_Derivative(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_NewtonFunctionRoot self) -> std::string"""
        return _math.math_NewtonFunctionRoot_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computations are successful, otherwise returns false.

        Returns
        -------
        bool

        """
        return _math.math_NewtonFunctionRoot_IsDone(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        Returns the number of iterations really done on the computation of the root. exception notdone is raised if the root was not found.

        Returns
        -------
        int

        """
        return _math.math_NewtonFunctionRoot_NbIterations(self, *args)


    def Perform(self, *args) -> "void":
        """
        Is used internally by the constructors.

        Parameters
        ----------
        F: math_FunctionWithDerivative
        Guess: float

        Returns
        -------
        None

        """
        return _math.math_NewtonFunctionRoot_Perform(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """
        Returns the value of the root of function <f>. exception notdone is raised if the root was not found.

        Returns
        -------
        float

        """
        return _math.math_NewtonFunctionRoot_Root(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        Returns the value of the function at the root. exception notdone is raised if the root was not found.

        Returns
        -------
        float

        """
        return _math.math_NewtonFunctionRoot_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_NewtonFunctionRoot
    __del__ = lambda self: None
math_NewtonFunctionRoot_swigregister = _math.math_NewtonFunctionRoot_swigregister
math_NewtonFunctionRoot_swigregister(math_NewtonFunctionRoot)

class math_NewtonFunctionSetRoot(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_NewtonFunctionSetRoot, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_NewtonFunctionSetRoot, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Initialize correctly all the fields of this class. the range (1, f.nbvariables()) must be especially respected for all vectors and matrix declarations.

        Parameters
        ----------
        theFunction: math_FunctionSetWithDerivatives
        theXTolerance: math_Vector
        theFTolerance: float
        tehNbIterations: int,optional
        	default value is 100

        Returns
        -------
        None

        This constructor should be used in a sub-class to initialize correctly all the fields of this class. the range (1, f.nbvariables()) must be especially respected for all vectors and matrix declarations. the method settolerance must be called before performing the algorithm.

        Parameters
        ----------
        theFunction: math_FunctionSetWithDerivatives
        theFTolerance: float
        theNbIterations: int,optional
        	default value is 100

        Returns
        -------
        None

        """
        this = _math.new_math_NewtonFunctionSetRoot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Derivative(self, *args) -> "void":
        """
        Returns the matrix value of the derivative at the root. exception notdone is raised if the root was not found.

        Returns
        -------
        math_Matrix

        Outputs the matrix value of the derivative at the root in der. exception notdone is raised if the root was not found. exception dimensionerror is raised if the range of der is not equal to the range of the startingpoint.

        Parameters
        ----------
        Der: math_Matrix

        Returns
        -------
        None

        """
        return _math.math_NewtonFunctionSetRoot_Derivative(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_NewtonFunctionSetRoot self) -> std::string"""
        return _math.math_NewtonFunctionSetRoot_DumpToString(self)


    def FunctionSetErrors(self, *args) -> "void":
        """
        Returns the vector value of the error done on the functions at the root. exception notdone is raised if the root was not found.

        Returns
        -------
        math_Vector

        Outputs the vector value of the error done on the functions at the root in err. exception notdone is raised if the root was not found. exception dimensionerror is raised if the range of err is not equal to the range of the startingpoint.

        Parameters
        ----------
        Err: math_Vector

        Returns
        -------
        None

        """
        return _math.math_NewtonFunctionSetRoot_FunctionSetErrors(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computations are successful, otherwise returns false.

        Returns
        -------
        bool

        """
        return _math.math_NewtonFunctionSetRoot_IsDone(self, *args)


    def IsSolutionReached(self, *args) -> "Standard_Boolean":
        """
        This method is called at the end of each iteration to check if the solution is found. vectors deltax, fvalues and jacobian matrix are consistent with the possible solution vector sol and can be inspected to decide whether the solution is reached or not.

        Parameters
        ----------
        F: math_FunctionSetWithDerivatives

        Returns
        -------
        bool

        """
        return _math.math_NewtonFunctionSetRoot_IsSolutionReached(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        Returns the number of iterations really done during the computation of the root. exception notdone is raised if the root was not found.

        Returns
        -------
        int

        """
        return _math.math_NewtonFunctionSetRoot_NbIterations(self, *args)


    def Perform(self, *args) -> "void":
        """
        The newton method is done to improve the root of the function from the initial guess point. the solution is found when: abs(xj - xj-1)(i) <= xtol(i) and abs(fi) <= ftol for all i;.

        Parameters
        ----------
        theFunction: math_FunctionSetWithDerivatives
        theStartingPoint: math_Vector

        Returns
        -------
        None

        The newton method is done to improve the root of the function from the initial guess point. bounds may be given, to constrain the solution. the solution is found when: abs(xj - xj-1)(i) <= xtol(i) and abs(fi) <= ftol for all i;.

        Parameters
        ----------
        theFunction: math_FunctionSetWithDerivatives
        theStartingPoint: math_Vector
        theInfBound: math_Vector
        theSupBound: math_Vector

        Returns
        -------
        None

        """
        return _math.math_NewtonFunctionSetRoot_Perform(self, *args)


    def Root(self, *args) -> "void":
        """
        Returns the value of the root of function f. exceptions stdfail_notdone if the algorithm fails (and isdone returns false).

        Returns
        -------
        math_Vector

        Outputs the root vector in root. exception notdone is raised if the root was not found. exception dimensionerror is raised if the range of root is not equal to the range of the startingpoint.

        Parameters
        ----------
        Root: math_Vector

        Returns
        -------
        None

        """
        return _math.math_NewtonFunctionSetRoot_Root(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        Initializes the tolerance values for the unknowns.

        Parameters
        ----------
        XTol: math_Vector

        Returns
        -------
        None

        """
        return _math.math_NewtonFunctionSetRoot_SetTolerance(self, *args)


    __repr__ = _dumps_object

    @methodnotwrapped
    def StateNumber(self):
    	pass

    __swig_destroy__ = _math.delete_math_NewtonFunctionSetRoot
    __del__ = lambda self: None
math_NewtonFunctionSetRoot_swigregister = _math.math_NewtonFunctionSetRoot_swigregister
math_NewtonFunctionSetRoot_swigregister(math_NewtonFunctionSetRoot)

class math_NewtonMinimum(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_NewtonMinimum, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_NewtonMinimum, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        The tolerance required on the solution is given by tolerance. iteration are stopped if (!withsingularity) and h(f(xi)) is not definite positive (if the smaller eigenvalue of h < convexity) or isconverged() returns true for 2 successives iterations. warning: this constructor does not perform computation.

        Parameters
        ----------
        theFunction: math_MultipleVarFunctionWithHessian
        theTolerance: float,optional
        	default value is Precision::Confusion()
        theNbIterations: int,optional
        	default value is 40
        theConvexity: float,optional
        	default value is 1.0e-6
        theWithSingularity: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        """
        this = _math.new_math_NewtonMinimum(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DumpToString(self) -> "std::string":
        """DumpToString(math_NewtonMinimum self) -> std::string"""
        return _math.math_NewtonMinimum_DumpToString(self)


    def GetStatus(self, *args) -> "math_Status":
        """
        Returns the status of computation. the exception notdone is raised if an error has occured.

        Returns
        -------
        math_Status

        """
        return _math.math_NewtonMinimum_GetStatus(self, *args)


    def Gradient(self, *args) -> "void":
        """
        Returns the gradient vector at the minimum. exception notdone is raised if an error has occured.the minimum was not found.

        Returns
        -------
        math_Vector

        Outputs the gradient vector at the minimum in grad. exception notdone is raised if the minimum was not found. exception dimensionerror is raised if the range of grad is not equal to the range of the startingpoint.

        Parameters
        ----------
        Grad: math_Vector

        Returns
        -------
        None

        """
        return _math.math_NewtonMinimum_Gradient(self, *args)


    def IsConverged(self, *args) -> "Standard_Boolean":
        """
        This method is called at the end of each iteration to check the convergence: || xi+1 - xi || < tolerance or || f(xi+1) - f(xi)|| < tolerance * || f(xi) || it can be redefined in a sub-class to implement a specific test.

        Returns
        -------
        bool

        """
        return _math.math_NewtonMinimum_IsConverged(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Tests if an error has occured.

        Returns
        -------
        bool

        """
        return _math.math_NewtonMinimum_IsDone(self, *args)


    def Location(self, *args) -> "void":
        """
        Returns the location vector of the minimum. exception notdone is raised if an error has occured.

        Returns
        -------
        math_Vector

        Outputs the location vector of the minimum in loc. exception notdone is raised if an error has occured. exception dimensionerror is raised if the range of loc is not equal to the range of the startingpoint.

        Parameters
        ----------
        Loc: math_Vector

        Returns
        -------
        None

        """
        return _math.math_NewtonMinimum_Location(self, *args)


    def Minimum(self, *args) -> "Standard_Real":
        """
        Returns the value of the minimum. exception notdone is raised if the minimum was not found.

        Returns
        -------
        float

        """
        return _math.math_NewtonMinimum_Minimum(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        Returns the number of iterations really done in the calculation of the minimum. the exception notdone is raised if an error has occured.

        Returns
        -------
        int

        """
        return _math.math_NewtonMinimum_NbIterations(self, *args)


    def Perform(self, *args) -> "void":
        """
        Search the solution.

        Parameters
        ----------
        theFunction: math_MultipleVarFunctionWithHessian
        theStartingPoint: math_Vector

        Returns
        -------
        None

        """
        return _math.math_NewtonMinimum_Perform(self, *args)


    def SetBoundary(self, *args) -> "void":
        """
        Set boundaries.

        Parameters
        ----------
        theLeftBorder: math_Vector
        theRightBorder: math_Vector

        Returns
        -------
        None

        """
        return _math.math_NewtonMinimum_SetBoundary(self, *args)


    __repr__ = _dumps_object

    @methodnotwrapped
    def IsConvex(self):
    	pass

    __swig_destroy__ = _math.delete_math_NewtonMinimum
    __del__ = lambda self: None
math_NewtonMinimum_swigregister = _math.math_NewtonMinimum_swigregister
math_NewtonMinimum_swigregister(math_NewtonMinimum)

class math_PSO(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_PSO, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_PSO, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        /** * constructor. * * @param thefunc defines the objective function. it should exist during all lifetime of class instance. * @param thelowborder defines lower border of search space. * @param theuppborder defines upper border of search space. * @param thesteps defines steps of regular grid, used for particle generation. this parameter used to define stop condition (terminalvelocity). * @param thenbparticles defines number of particles. * @param thenbiter defines maximum number of iterations. */.

        Parameters
        ----------
        theFunc: math_MultipleVarFunction *
        theLowBorder: math_Vector
        theUppBorder: math_Vector
        theSteps: math_Vector
        theNbParticles: int,optional
        	default value is 32
        theNbIter: int,optional
        	default value is 100

        Returns
        -------
        None

        """
        this = _math.new_math_PSO(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args) -> "void":
        """
        Perform computations, particles array is constructed inside of this function.

        Parameters
        ----------
        theSteps: math_Vector
        theOutPnt: math_Vector
        theNbIter: int,optional
        	default value is 100

        Returns
        -------
        theValue: float

        Perform computations with given particles array.

        Parameters
        ----------
        theParticles: math_PSOParticlesPool
        theNbParticles: int
        theOutPnt: math_Vector
        theNbIter: int,optional
        	default value is 100

        Returns
        -------
        theValue: float

        """
        return _math.math_PSO_Perform(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_PSO
    __del__ = lambda self: None
math_PSO_swigregister = _math.math_PSO_swigregister
math_PSO_swigregister(math_PSO)

class math_PSOParticlesPool(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_PSOParticlesPool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_PSOParticlesPool, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        theParticlesCount: int
        theDimensionCount: int

        Returns
        -------
        None

        """
        this = _math.new_math_PSOParticlesPool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetBestParticle(self, *args) -> "PSO_Particle *":
        """
        No available documentation.

        Returns
        -------
        PSO_Particle *

        """
        return _math.math_PSOParticlesPool_GetBestParticle(self, *args)


    def GetParticle(self, *args) -> "PSO_Particle *":
        """
        No available documentation.

        Parameters
        ----------
        theIdx: int

        Returns
        -------
        PSO_Particle *

        """
        return _math.math_PSOParticlesPool_GetParticle(self, *args)


    def GetWorstParticle(self, *args) -> "PSO_Particle *":
        """
        No available documentation.

        Returns
        -------
        PSO_Particle *

        """
        return _math.math_PSOParticlesPool_GetWorstParticle(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_PSOParticlesPool
    __del__ = lambda self: None
math_PSOParticlesPool_swigregister = _math.math_PSOParticlesPool_swigregister
math_PSOParticlesPool_swigregister(math_PSOParticlesPool)

class math_Powell(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_Powell, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_Powell, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Constructor. initialize new entity.

        Parameters
        ----------
        theFunction: math_MultipleVarFunction
        theTolerance: float
        theNbIterations: int,optional
        	default value is 200
        theZEPS: float,optional
        	default value is 1.0e-12

        Returns
        -------
        None

        """
        this = _math.new_math_Powell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DumpToString(self) -> "std::string":
        """DumpToString(math_Powell self) -> std::string"""
        return _math.math_Powell_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computations are successful, otherwise returns false.

        Returns
        -------
        bool

        """
        return _math.math_Powell_IsDone(self, *args)


    def IsSolutionReached(self, *args) -> "Standard_Boolean":
        """
        Solution f = fi is found when: 2.0 * abs(fi - fi-1) <= tolerance * (abs(fi) + abs(fi-1)) + zeps. the maximum number of iterations allowed is given by nbiterations.

        Parameters
        ----------
        theFunction: math_MultipleVarFunction

        Returns
        -------
        bool

        """
        return _math.math_Powell_IsSolutionReached(self, *args)


    def Location(self, *args) -> "void":
        """
        Returns the location vector of the minimum. exception notdone is raised if the minimum was not found.

        Returns
        -------
        math_Vector

        Outputs the location vector of the minimum in loc. exception notdone is raised if the minimum was not found. exception dimensionerror is raised if the range of loc is not equal to the range of the startingpoint.

        Parameters
        ----------
        Loc: math_Vector

        Returns
        -------
        None

        """
        return _math.math_Powell_Location(self, *args)


    def Minimum(self, *args) -> "Standard_Real":
        """
        Returns the value of the minimum. exception notdone is raised if the minimum was not found.

        Returns
        -------
        float

        """
        return _math.math_Powell_Minimum(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        Returns the number of iterations really done during the computation of the minimum. exception notdone is raised if the minimum was not found.

        Returns
        -------
        int

        """
        return _math.math_Powell_NbIterations(self, *args)


    def Perform(self, *args) -> "void":
        """
        Computes powell minimization on the function f given thestartingpoint, and an initial matrix thestartingdirection whose columns contain the initial set of directions. the solution f = fi is found when: 2.0 * abs(fi - fi-1) =< tolerance * (abs(fi) + abs(fi-1) + zeps).

        Parameters
        ----------
        theFunction: math_MultipleVarFunction
        theStartingPoint: math_Vector
        theStartingDirections: math_Matrix

        Returns
        -------
        None

        """
        return _math.math_Powell_Perform(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Powell
    __del__ = lambda self: None
math_Powell_swigregister = _math.math_Powell_swigregister
math_Powell_swigregister(math_Powell)

class math_SVD(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_SVD, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_SVD, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Given as input an n x m matrix a with n < m, n = m or n > m this constructor performs the singular value decomposition.

        Parameters
        ----------
        A: math_Matrix

        Returns
        -------
        None

        """
        this = _math.new_math_SVD(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DumpToString(self) -> "std::string":
        """DumpToString(math_SVD self) -> std::string"""
        return _math.math_SVD_DumpToString(self)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computations are successful, otherwise returns false.

        Returns
        -------
        bool

        """
        return _math.math_SVD_IsDone(self, *args)


    def PseudoInverse(self, *args) -> "void":
        """
        Computes the inverse inv of matrix a such as a * inverse = identity. exceptions stdfail_notdone if the algorithm fails (and isdone returns false). standard_dimensionerror if the ranges of inv are compatible with the ranges of a.

        Parameters
        ----------
        Inv: math_Matrix
        Eps: float,optional
        	default value is 1.0e-6

        Returns
        -------
        None

        """
        return _math.math_SVD_PseudoInverse(self, *args)


    def Solve(self, *args) -> "void":
        """
        Given the input vector b this routine solves the set of linear equations a . x = b. exception notdone is raised if the decomposition of a was not done successfully. exception dimensionerror is raised if the range of b is not equal to the rowrange of a. exception dimensionerror is raised if the range of x is not equal to the colrange of a.

        Parameters
        ----------
        B: math_Vector
        X: math_Vector
        Eps: float,optional
        	default value is 1.0e-6

        Returns
        -------
        None

        """
        return _math.math_SVD_Solve(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_SVD
    __del__ = lambda self: None
math_SVD_swigregister = _math.math_SVD_swigregister
math_SVD_swigregister(math_SVD)

class math_TrigonometricFunctionRoots(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_TrigonometricFunctionRoots, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_TrigonometricFunctionRoots, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Given coefficients a, b, c, d , e, this constructor performs the resolution of the equation above. the solutions must be contained in [infbound, supbound]. infbound and supbound can be set by default to 0 and 2*pi.

        Parameters
        ----------
        A: float
        B: float
        C: float
        D: float
        E: float
        InfBound: float
        SupBound: float

        Returns
        -------
        None

        Given the two coefficients d and e, it performs the resolution of d*sin(x) + e = 0. the solutions must be contained in [infbound, supbound]. infbound and supbound can be set by default to 0 and 2*pi.

        Parameters
        ----------
        D: float
        E: float
        InfBound: float
        SupBound: float

        Returns
        -------
        None

        Given the three coefficients c, d and e, it performs the resolution of c*cos(x) + d*sin(x) + e = 0. the solutions must be contained in [infbound, supbound]. infbound and supbound can be set by default to 0 and 2*pi.

        Parameters
        ----------
        C: float
        D: float
        E: float
        InfBound: float
        SupBound: float

        Returns
        -------
        None

        """
        this = _math.new_math_TrigonometricFunctionRoots(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DumpToString(self) -> "std::string":
        """DumpToString(math_TrigonometricFunctionRoots self) -> std::string"""
        return _math.math_TrigonometricFunctionRoots_DumpToString(self)


    def InfiniteRoots(self, *args) -> "Standard_Boolean":
        """
        Returns true if there is an infinity of roots, otherwise returns false.

        Returns
        -------
        bool

        """
        return _math.math_TrigonometricFunctionRoots_InfiniteRoots(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computations are successful, otherwise returns false.

        Returns
        -------
        bool

        """
        return _math.math_TrigonometricFunctionRoots_IsDone(self, *args)


    def NbSolutions(self, *args) -> "Standard_Integer":
        """
        Returns the number of solutions found. an exception is raised if notdone. an exception is raised if there is an infinity of solutions.

        Returns
        -------
        int

        """
        return _math.math_TrigonometricFunctionRoots_NbSolutions(self, *args)


    def Value(self, *args) -> "Standard_Real":
        """
        Returns the solution of range index. an exception is raised if notdone. an exception is raised if index>nbsolutions. an exception is raised if there is an infinity of solutions.

        Parameters
        ----------
        Index: int

        Returns
        -------
        float

        """
        return _math.math_TrigonometricFunctionRoots_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_TrigonometricFunctionRoots
    __del__ = lambda self: None
math_TrigonometricFunctionRoots_swigregister = _math.math_TrigonometricFunctionRoots_swigregister
math_TrigonometricFunctionRoots_swigregister(math_TrigonometricFunctionRoots)

class math_Uzawa(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_Uzawa, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_Uzawa, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Given an input matrix cont, two input vectors secont and startingpoint, it solves cont*x = secont (only = equations) with a minimization of norme(x-x0). the maximun iterations number allowed is fixed to nbiterations. the tolerance epslic is fixed for the dual variable convergence. the tolerance epslix is used for the convergence of x. exception constuctionerror is raised if the line number of cont is different from the length of secont.

        Parameters
        ----------
        Cont: math_Matrix
        Secont: math_Vector
        StartingPoint: math_Vector
        EpsLix: float,optional
        	default value is 1.0e-06
        EpsLic: float,optional
        	default value is 1.0e-06
        NbIterations: int,optional
        	default value is 500

        Returns
        -------
        None

        Given an input matrix cont, two input vectors secont and startingpoint, it solves cont*x = secont (the nce first equations are equal equations and the nci last equations are inequalities <) with a minimization of norme(x-x0). the maximun iterations number allowed is fixed to nbiterations. the tolerance epslic is fixed for the dual variable convergence. the tolerance epslix is used for the convergence of x. there are no conditions on nce and nci. exception constuctionerror is raised if the line number of cont is different from the length of secont and from nce + nci.

        Parameters
        ----------
        Cont: math_Matrix
        Secont: math_Vector
        StartingPoint: math_Vector
        Nci: int
        Nce: int
        EpsLix: float,optional
        	default value is 1.0e-06
        EpsLic: float,optional
        	default value is 1.0e-06
        NbIterations: int,optional
        	default value is 500

        Returns
        -------
        None

        """
        this = _math.new_math_Uzawa(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Duale(self, *args) -> "void":
        """
        Returns the duale variables v of the systeme.

        Parameters
        ----------
        V: math_Vector

        Returns
        -------
        None

        """
        return _math.math_Uzawa_Duale(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_Uzawa self) -> std::string"""
        return _math.math_Uzawa_DumpToString(self)


    def Error(self, *args) -> "math_Vector const &":
        """
        Returns the difference between x solution and the startingpoint. an exception is raised if notdone.

        Returns
        -------
        math_Vector

        """
        return _math.math_Uzawa_Error(self, *args)


    def InitialError(self, *args) -> "math_Vector const &":
        """
        Returns the initial error cont*startingpoint-secont. an exception is raised if notdone.

        Returns
        -------
        math_Vector

        """
        return _math.math_Uzawa_InitialError(self, *args)


    def InverseCont(self, *args) -> "math_Matrix const &":
        """
        Returns the inverse matrix of (c * transposed(c)). this result is needed for the computation of the gradient when approximating a curve.

        Returns
        -------
        math_Matrix

        """
        return _math.math_Uzawa_InverseCont(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the computations are successful, otherwise returns false.

        Returns
        -------
        bool

        """
        return _math.math_Uzawa_IsDone(self, *args)


    def NbIterations(self, *args) -> "Standard_Integer":
        """
        Returns the number of iterations really done. an exception is raised if notdone.

        Returns
        -------
        int

        """
        return _math.math_Uzawa_NbIterations(self, *args)


    def Value(self, *args) -> "math_Vector const &":
        """
        Returns the vector solution of the system above. an exception is raised if notdone.

        Returns
        -------
        math_Vector

        """
        return _math.math_Uzawa_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Uzawa
    __del__ = lambda self: None
math_Uzawa_swigregister = _math.math_Uzawa_swigregister
math_Uzawa_swigregister(math_Uzawa)

class math_ValueAndWeight(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_ValueAndWeight, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_ValueAndWeight, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        theValue: float
        theWeight: float

        Returns
        -------
        None

        """
        this = _math.new_math_ValueAndWeight(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _math.math_ValueAndWeight_Value(self, *args)


    def Weight(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _math.math_ValueAndWeight_Weight(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_ValueAndWeight
    __del__ = lambda self: None
math_ValueAndWeight_swigregister = _math.math_ValueAndWeight_swigregister
math_ValueAndWeight_swigregister(math_ValueAndWeight)

class math_Vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_Vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, math_Vector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Contructs a non-initialized vector in the range [thelower..theupper] 'thelower' and 'theupper' are the indexes of the lower and upper bounds of the constructed vector.

        Parameters
        ----------
        theLower: int
        theUpper: int

        Returns
        -------
        None

        Contructs a vector in the range [thelower..theupper] whose values are all initialized with the value 'theinitialvalue'.

        Parameters
        ----------
        theLower: int
        theUpper: int
        theInitialValue: float

        Returns
        -------
        None

        Constructs a vector in the range [thelower..theupper] with the 'c array' thetab.

        Parameters
        ----------
        theTab: float *
        theLower: int
        theUpper: int

        Returns
        -------
        None

        Constructor for converting gp_xy to math_vector.

        Parameters
        ----------
        Other: gp_XY

        Returns
        -------
        None

        Constructor for converting gp_xyz to math_vector.

        Parameters
        ----------
        Other: gp_XYZ

        Returns
        -------
        None

        Constructs a copy for initialization. an exception is raised if the lengths of the vectors are different.

        Parameters
        ----------
        theOther: math_Vector

        Returns
        -------
        None

        """
        this = _math.new_math_Vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args) -> "void":
        """
        Adds the vector 'theright' to a vector. an exception is raised if the vectors have not the same length. warning in order to avoid time-consuming copying of vectors, it is preferable to use operator += or the function add whenever possible.

        Parameters
        ----------
        theRight: math_Vector

        Returns
        -------
        None

        Sets a vector to the sum of the vector 'theleft' and the vector 'theright'. an exception is raised if the lengths are different.

        Parameters
        ----------
        theLeft: math_Vector
        theRight: math_Vector

        Returns
        -------
        None

        """
        return _math.math_Vector_Add(self, *args)


    def Added(self, *args) -> "math_Vector":
        """
        Adds the vector theright to a vector. an exception is raised if the vectors have not the same length. an exception is raised if the lengths are not equal.

        Parameters
        ----------
        theRight: math_Vector

        Returns
        -------
        math_Vector

        """
        return _math.math_Vector_Added(self, *args)


    def Divide(self, *args) -> "void":
        """
        Divides a vector by the value 'theright'. an exception is raised if 'theright' = 0.

        Parameters
        ----------
        theRight: float

        Returns
        -------
        None

        """
        return _math.math_Vector_Divide(self, *args)


    def Divided(self, *args) -> "math_Vector":
        """
        Divides a vector by the value 'theright'. an exception is raised if 'theright' = 0.

        Parameters
        ----------
        theRight: float

        Returns
        -------
        math_Vector

        """
        return _math.math_Vector_Divided(self, *args)


    def DumpToString(self) -> "std::string":
        """DumpToString(math_Vector self) -> std::string"""
        return _math.math_Vector_DumpToString(self)


    def Init(self, *args) -> "void":
        """
        Initialize all the elements of a vector with 'theinitialvalue'.

        Parameters
        ----------
        theInitialValue: float

        Returns
        -------
        None

        """
        return _math.math_Vector_Init(self, *args)


    def Initialized(self, *args) -> "math_Vector &":
        """
        Initialises a vector by copying 'theother'. an exception is raised if the lengths are differents.

        Parameters
        ----------
        theOther: math_Vector

        Returns
        -------
        math_Vector

        """
        return _math.math_Vector_Initialized(self, *args)


    def Inverse(self, *args) -> "math_Vector":
        """
        Inverts this vector and creates a new vector.

        Returns
        -------
        math_Vector

        """
        return _math.math_Vector_Inverse(self, *args)


    def Invert(self, *args) -> "void":
        """
        Inverts this vector and assigns the result to this vector.

        Returns
        -------
        None

        """
        return _math.math_Vector_Invert(self, *args)


    def Length(self, *args) -> "Standard_Integer":
        """
        Returns the length of a vector.

        Returns
        -------
        int

        """
        return _math.math_Vector_Length(self, *args)


    def Lower(self, *args) -> "Standard_Integer":
        """
        Returns the value of the thelower index of a vector.

        Returns
        -------
        int

        """
        return _math.math_Vector_Lower(self, *args)


    def Max(self, *args) -> "Standard_Integer":
        """
        Returns the value of the 'index' of the maximum element of a vector.

        Returns
        -------
        int

        """
        return _math.math_Vector_Max(self, *args)


    def Min(self, *args) -> "Standard_Integer":
        """
        Returns the value of the 'index' of the minimum element of a vector.

        Returns
        -------
        int

        """
        return _math.math_Vector_Min(self, *args)


    def Multiplied(self, *args) -> "math_Vector":
        """
        Returns the product of a vector and a real value.

        Parameters
        ----------
        theRight: float

        Returns
        -------
        math_Vector

        Returns the inner product of 2 vectors. an exception is raised if the lengths are not equal.

        Parameters
        ----------
        theRight: math_Vector

        Returns
        -------
        float

        Returns the product of a vector by a matrix.

        Parameters
        ----------
        theRight: math_Matrix

        Returns
        -------
        math_Vector

        """
        return _math.math_Vector_Multiplied(self, *args)


    def Multiply(self, *args) -> "void":
        """
        Returns the product of a vector and a real value.

        Parameters
        ----------
        theRight: float

        Returns
        -------
        None

        Sets a vector to the product of the vector 'theleft' with the matrix 'theright'.

        Parameters
        ----------
        theLeft: math_Vector
        theRight: math_Matrix

        Returns
        -------
        None

        //!sets a vector to the product of the matrix 'theleft' with the vector 'theright'.

        Parameters
        ----------
        theLeft: math_Matrix
        theRight: math_Vector

        Returns
        -------
        None

        Returns the multiplication of a real by a vector. 'me' = 'theleft' * 'theright'.

        Parameters
        ----------
        theLeft: float
        theRight: math_Vector

        Returns
        -------
        None

        """
        return _math.math_Vector_Multiply(self, *args)


    def Norm(self, *args) -> "Standard_Real":
        """
        Returns the value or the square of the norm of this vector.

        Returns
        -------
        float

        """
        return _math.math_Vector_Norm(self, *args)


    def Norm2(self, *args) -> "Standard_Real":
        """
        Returns the value of the square of the norm of a vector.

        Returns
        -------
        float

        """
        return _math.math_Vector_Norm2(self, *args)


    def Normalize(self, *args) -> "void":
        """
        Normalizes this vector (the norm of the result is equal to 1.0) and assigns the result to this vector exceptions standard_nullvalue if this vector is null (i.e. if its norm is less than or equal to standard_real::realepsilon().

        Returns
        -------
        None

        """
        return _math.math_Vector_Normalize(self, *args)


    def Normalized(self, *args) -> "math_Vector":
        """
        Normalizes this vector (the norm of the result is equal to 1.0) and creates a new vector exceptions standard_nullvalue if this vector is null (i.e. if its norm is less than or equal to standard_real::realepsilon().

        Returns
        -------
        math_Vector

        """
        return _math.math_Vector_Normalized(self, *args)


    def Opposite(self, *args) -> "math_Vector":
        """
        Returns the opposite of a vector.

        Returns
        -------
        math_Vector

        """
        return _math.math_Vector_Opposite(self, *args)


    def Set(self, *args) -> "void":
        """
        Sets a vector from 'thei1' to 'thei2' to the vector 'thev'; an exception is raised if 'thei1' is less than 'lowerindex' or 'thei2' is greater than 'upperindex' or 'thei1' is greater than 'thei2'. an exception is raised if 'thei2-thei1+1' is different from the 'length' of 'thev'.

        Parameters
        ----------
        theI1: int
        theI2: int
        theV: math_Vector

        Returns
        -------
        None

        """
        return _math.math_Vector_Set(self, *args)


    def Slice(self, *args) -> "math_Vector":
        """
        //!creates a new vector by inverting the values of this vector between indexes 'thei1' and 'thei2'. if the values of this vector were (1., 2., 3., 4.,5., 6.), by slicing it between indexes 2 and 5 the values of the resulting vector are (1., 5., 4., 3., 2., 6.).

        Parameters
        ----------
        theI1: int
        theI2: int

        Returns
        -------
        math_Vector

        """
        return _math.math_Vector_Slice(self, *args)


    def Subtract(self, *args) -> "void":
        """
        Sets a vector to the subtraction of the vector theright from the vector theleft. an exception is raised if the vectors have not the same length. warning in order to avoid time-consuming copying of vectors, it is preferable to use operator -= or the function subtract whenever possible.

        Parameters
        ----------
        theLeft: math_Vector
        theRight: math_Vector

        Returns
        -------
        None

        Returns the subtraction of 'theright' from 'me'. an exception is raised if the vectors have not the same length.

        Parameters
        ----------
        theRight: math_Vector

        Returns
        -------
        None

        """
        return _math.math_Vector_Subtract(self, *args)


    def Subtracted(self, *args) -> "math_Vector":
        """
        Returns the subtraction of 'theright' from 'me'. an exception is raised if the vectors have not the same length.

        Parameters
        ----------
        theRight: math_Vector

        Returns
        -------
        math_Vector

        """
        return _math.math_Vector_Subtracted(self, *args)


    def TMultiplied(self, *args) -> "math_Vector":
        """
        Returns the product of a vector and a real value.

        Parameters
        ----------
        theRight: float

        Returns
        -------
        math_Vector

        """
        return _math.math_Vector_TMultiplied(self, *args)


    def TMultiply(self, *args) -> "void":
        """
        Sets a vector to the product of the transpose of the matrix 'thetleft' by the vector 'theright'.

        Parameters
        ----------
        theTLeft: math_Matrix
        theRight: math_Vector

        Returns
        -------
        None

        Sets a vector to the product of the vector 'theleft' by the transpose of the matrix 'thetright'.

        Parameters
        ----------
        theLeft: math_Vector
        theTRight: math_Matrix

        Returns
        -------
        None

        """
        return _math.math_Vector_TMultiply(self, *args)


    def Upper(self, *args) -> "Standard_Integer":
        """
        Returns the value of the theupper index of a vector.

        Returns
        -------
        int

        """
        return _math.math_Vector_Upper(self, *args)


    def Value(self, *args) -> "Standard_Real const &":
        """
        Accesses the value of index 'thenum' of a vector.

        Parameters
        ----------
        theNum: int

        Returns
        -------
        float

        """
        return _math.math_Vector_Value(self, *args)


    def GetValue(self, theNum: 'Standard_Integer const') -> "Standard_Real":
        """GetValue(math_Vector self, Standard_Integer const theNum) -> Standard_Real"""
        return _math.math_Vector_GetValue(self, theNum)


    def SetValue(self, theNum: 'Standard_Integer const', value: 'Standard_Real') -> "void":
        """SetValue(math_Vector self, Standard_Integer const theNum, Standard_Real value)"""
        return _math.math_Vector_SetValue(self, theNum, value)


    def __mul__(self, *args) -> "math_Vector":
        """
        No available documentation.

        Parameters
        ----------
        theRight: float

        Returns
        -------
        math_Vector

        No available documentation.

        Parameters
        ----------
        theRight: math_Vector

        Returns
        -------
        float

        No available documentation.

        Parameters
        ----------
        theRight: math_Matrix

        Returns
        -------
        math_Vector

        """
        return _math.math_Vector___mul__(self, *args)


    def __imul_wrapper__(self, other: 'Standard_Real const') -> "void":
        """__imul_wrapper__(math_Vector self, Standard_Real const other)"""
        return _math.math_Vector___imul_wrapper__(self, other)


    def __imul__(self, right):
        self.__imul_wrapper__(right)
        return self


    def __add__(self, *args) -> "math_Vector":
        """
        No available documentation.

        Parameters
        ----------
        theRight: math_Vector

        Returns
        -------
        math_Vector

        """
        return _math.math_Vector___add__(self, *args)


    def __iadd_wrapper__(self, other: 'math_Vector') -> "void":
        """__iadd_wrapper__(math_Vector self, math_Vector other)"""
        return _math.math_Vector___iadd_wrapper__(self, other)


    def __iadd__(self, right):
        self.__iadd_wrapper__(right)
        return self


    def __neg__(self, *args) -> "math_Vector":
        """
        No available documentation.

        Returns
        -------
        math_Vector

        """
        return _math.math_Vector___neg__(self, *args)


    def __sub__(self, *args) -> "math_Vector":
        """
        No available documentation.

        Parameters
        ----------
        theRight: math_Vector

        Returns
        -------
        math_Vector

        """
        return _math.math_Vector___sub__(self, *args)


    def __isub_wrapper__(self, other: 'math_Vector') -> "void":
        """__isub_wrapper__(math_Vector self, math_Vector other)"""
        return _math.math_Vector___isub_wrapper__(self, other)


    def __isub__(self, right):
        self.__isub_wrapper__(right)
        return self


    def __truediv__(self, *args):
        return _math.math_Vector___truediv__(self, *args)
    __div__ = __truediv__



    def __itruediv_wrapper__(self, other: 'Standard_Real const') -> "void":
        """__itruediv_wrapper__(math_Vector self, Standard_Real const other)"""
        return _math.math_Vector___itruediv_wrapper__(self, other)


    def __itruediv__(self, right):
        self.__itruediv_wrapper__(right)
        return self


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_Vector
    __del__ = lambda self: None
math_Vector_swigregister = _math.math_Vector_swigregister
math_Vector_swigregister(math_Vector)

class math_FunctionSetWithDerivatives(math_FunctionSet):
    __swig_setmethods__ = {}
    for _s in [math_FunctionSet]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_FunctionSetWithDerivatives, name, value)
    __swig_getmethods__ = {}
    for _s in [math_FunctionSet]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, math_FunctionSetWithDerivatives, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Derivatives(self, *args) -> "Standard_Boolean":
        """
        Returns the values <d> of the derivatives for the variable <x>. returns true if the computation was done successfully, false otherwise.

        Parameters
        ----------
        X: math_Vector
        D: math_Matrix

        Returns
        -------
        bool

        """
        return _math.math_FunctionSetWithDerivatives_Derivatives(self, *args)


    def Values(self, *args) -> "Standard_Boolean":
        """
        Returns the values <f> of the functions and the derivatives <d> for the variable <x>. returns true if the computation was done successfully, false otherwise.

        Parameters
        ----------
        X: math_Vector
        F: math_Vector
        D: math_Matrix

        Returns
        -------
        bool

        """
        return _math.math_FunctionSetWithDerivatives_Values(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionSetWithDerivatives
    __del__ = lambda self: None
math_FunctionSetWithDerivatives_swigregister = _math.math_FunctionSetWithDerivatives_swigregister
math_FunctionSetWithDerivatives_swigregister(math_FunctionSetWithDerivatives)

class math_FunctionWithDerivative(math_Function):
    __swig_setmethods__ = {}
    for _s in [math_Function]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_FunctionWithDerivative, name, value)
    __swig_getmethods__ = {}
    for _s in [math_Function]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, math_FunctionWithDerivative, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Derivative(self, *args) -> "Standard_Boolean":
        """
        Computes the derivative <d> of the function for the variable <x>. returns true if the calculation were successfully done, false otherwise.

        Parameters
        ----------
        X: float

        Returns
        -------
        D: float

        """
        return _math.math_FunctionWithDerivative_Derivative(self, *args)


    def Values(self, *args) -> "Standard_Boolean":
        """
        Computes the value <f> and the derivative <d> of the function for the variable <x>. returns true if the calculation were successfully done, false otherwise.

        Parameters
        ----------
        X: float

        Returns
        -------
        F: float
        D: float

        """
        return _math.math_FunctionWithDerivative_Values(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_FunctionWithDerivative
    __del__ = lambda self: None
math_FunctionWithDerivative_swigregister = _math.math_FunctionWithDerivative_swigregister
math_FunctionWithDerivative_swigregister(math_FunctionWithDerivative)

class math_MultipleVarFunctionWithGradient(math_MultipleVarFunction):
    __swig_setmethods__ = {}
    for _s in [math_MultipleVarFunction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_MultipleVarFunctionWithGradient, name, value)
    __swig_getmethods__ = {}
    for _s in [math_MultipleVarFunction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, math_MultipleVarFunctionWithGradient, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Gradient(self, *args) -> "Standard_Boolean":
        """
        Computes the gradient <g> of the functions for the variable <x>. returns true if the computation was done successfully, false otherwise.

        Parameters
        ----------
        X: math_Vector
        G: math_Vector

        Returns
        -------
        bool

        """
        return _math.math_MultipleVarFunctionWithGradient_Gradient(self, *args)


    def Values(self, *args) -> "Standard_Boolean":
        """
        Computes the value <f> and the gradient <g> of the functions for the variable <x>. returns true if the computation was done successfully, false otherwise.

        Parameters
        ----------
        X: math_Vector
        G: math_Vector

        Returns
        -------
        F: float

        """
        return _math.math_MultipleVarFunctionWithGradient_Values(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_MultipleVarFunctionWithGradient
    __del__ = lambda self: None
math_MultipleVarFunctionWithGradient_swigregister = _math.math_MultipleVarFunctionWithGradient_swigregister
math_MultipleVarFunctionWithGradient_swigregister(math_MultipleVarFunctionWithGradient)

class math_MultipleVarFunctionWithHessian(math_MultipleVarFunctionWithGradient):
    __swig_setmethods__ = {}
    for _s in [math_MultipleVarFunctionWithGradient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_MultipleVarFunctionWithHessian, name, value)
    __swig_getmethods__ = {}
    for _s in [math_MultipleVarFunctionWithGradient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, math_MultipleVarFunctionWithHessian, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Values(self, *args) -> "Standard_Boolean":
        """
        Computes the value <f> and the gradient <g> of the functions for the variable <x>. returns true if the computation was done successfully, false otherwise.

        Parameters
        ----------
        X: math_Vector
        G: math_Vector

        Returns
        -------
        F: float

        Computes the value <f>, the gradient <g> and the hessian <h> of the functions for the variable <x>. returns true if the computation was done successfully, false otherwise.

        Parameters
        ----------
        X: math_Vector
        G: math_Vector
        H: math_Matrix

        Returns
        -------
        F: float

        """
        return _math.math_MultipleVarFunctionWithHessian_Values(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_MultipleVarFunctionWithHessian
    __del__ = lambda self: None
math_MultipleVarFunctionWithHessian_swigregister = _math.math_MultipleVarFunctionWithHessian_swigregister
math_MultipleVarFunctionWithHessian_swigregister(math_MultipleVarFunctionWithHessian)

class math_TrigonometricEquationFunction(math_FunctionWithDerivative):
    __swig_setmethods__ = {}
    for _s in [math_FunctionWithDerivative]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, math_TrigonometricEquationFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [math_FunctionWithDerivative]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, math_TrigonometricEquationFunction, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        A: float
        B: float
        C: float
        D: float
        E: float

        Returns
        -------
        None

        """
        this = _math.new_math_TrigonometricEquationFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    __repr__ = _dumps_object

    __swig_destroy__ = _math.delete_math_TrigonometricEquationFunction
    __del__ = lambda self: None
math_TrigonometricEquationFunction_swigregister = _math.math_TrigonometricEquationFunction_swigregister
math_TrigonometricEquationFunction_swigregister(math_TrigonometricEquationFunction)



# This file is compatible with both classic and new-style classes.


