# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""
GeomLib module, see official documentation at
https://www.opencascade.com/doc/occt-7.7.0/refman/html/package_geomlib.html
"""

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _GeomLib
else:
    import _GeomLib

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GeomLib.delete_SwigPyIterator

    def value(self):
        return _GeomLib.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _GeomLib.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _GeomLib.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _GeomLib.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _GeomLib.SwigPyIterator_equal(self, x)

    def copy(self):
        return _GeomLib.SwigPyIterator_copy(self)

    def next(self):
        return _GeomLib.SwigPyIterator_next(self)

    def __next__(self):
        return _GeomLib.SwigPyIterator___next__(self)

    def previous(self):
        return _GeomLib.SwigPyIterator_previous(self)

    def advance(self, n):
        return _GeomLib.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _GeomLib.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _GeomLib.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _GeomLib.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _GeomLib.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _GeomLib.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _GeomLib.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _GeomLib:
_GeomLib.SwigPyIterator_swigregister(SwigPyIterator)

def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error, method_name, class_name):
    return _GeomLib.process_exception(error, method_name, class_name)

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.Geom
import OCC.Core.gp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.Adaptor3d
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.math
import OCC.Core.Message
import OCC.Core.OSD
import OCC.Core.AdvApprox
import OCC.Core.PLib
import OCC.Core.Geom2dAdaptor

from enum import IntEnum
from OCC.Core.Exception import *

GeomLib_NoError = _GeomLib.GeomLib_NoError
GeomLib_NotEnoughtPoints = _GeomLib.GeomLib_NotEnoughtPoints
GeomLib_DegreeSmallerThan3 = _GeomLib.GeomLib_DegreeSmallerThan3
GeomLib_InversionProblem = _GeomLib.GeomLib_InversionProblem


class GeomLib_InterpolationErrors(IntEnum):
	GeomLib_NoError = 0
	GeomLib_NotEnoughtPoints = 1
	GeomLib_DegreeSmallerThan3 = 2
	GeomLib_InversionProblem = 3
GeomLib_NoError = GeomLib_InterpolationErrors.GeomLib_NoError
GeomLib_NotEnoughtPoints = GeomLib_InterpolationErrors.GeomLib_NotEnoughtPoints
GeomLib_DegreeSmallerThan3 = GeomLib_InterpolationErrors.GeomLib_DegreeSmallerThan3
GeomLib_InversionProblem = GeomLib_InterpolationErrors.GeomLib_InversionProblem

class GeomLib_Array1OfMat(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def begin(self):
        return _GeomLib.GeomLib_Array1OfMat_begin(self)

    def end(self):
        return _GeomLib.GeomLib_Array1OfMat_end(self)

    def cbegin(self):
        return _GeomLib.GeomLib_Array1OfMat_cbegin(self)

    def cend(self):
        return _GeomLib.GeomLib_Array1OfMat_cend(self)

    def __init__(self, *args):
        _GeomLib.GeomLib_Array1OfMat_swiginit(self, _GeomLib.new_GeomLib_Array1OfMat(*args))

    def Init(self, theValue):
        return _GeomLib.GeomLib_Array1OfMat_Init(self, theValue)

    def Size(self):
        return _GeomLib.GeomLib_Array1OfMat_Size(self)

    def Length(self):
        return _GeomLib.GeomLib_Array1OfMat_Length(self)

    def IsEmpty(self):
        return _GeomLib.GeomLib_Array1OfMat_IsEmpty(self)

    def Lower(self):
        return _GeomLib.GeomLib_Array1OfMat_Lower(self)

    def Upper(self):
        return _GeomLib.GeomLib_Array1OfMat_Upper(self)

    def IsDeletable(self):
        return _GeomLib.GeomLib_Array1OfMat_IsDeletable(self)

    def IsAllocated(self):
        return _GeomLib.GeomLib_Array1OfMat_IsAllocated(self)

    def Assign(self, theOther):
        return _GeomLib.GeomLib_Array1OfMat_Assign(self, theOther)

    def Move(self, theOther):
        return _GeomLib.GeomLib_Array1OfMat_Move(self, theOther)

    def Set(self, *args):
        return _GeomLib.GeomLib_Array1OfMat_Set(self, *args)

    def First(self):
        return _GeomLib.GeomLib_Array1OfMat_First(self)

    def ChangeFirst(self):
        return _GeomLib.GeomLib_Array1OfMat_ChangeFirst(self)

    def Last(self):
        return _GeomLib.GeomLib_Array1OfMat_Last(self)

    def ChangeLast(self):
        return _GeomLib.GeomLib_Array1OfMat_ChangeLast(self)

    def Value(self, theIndex):
        return _GeomLib.GeomLib_Array1OfMat_Value(self, theIndex)

    def ChangeValue(self, theIndex):
        return _GeomLib.GeomLib_Array1OfMat_ChangeValue(self, theIndex)

    def __call__(self, *args):
        return _GeomLib.GeomLib_Array1OfMat___call__(self, *args)

    def SetValue(self, theIndex, theItem):
        return _GeomLib.GeomLib_Array1OfMat_SetValue(self, theIndex, theItem)

    def Resize(self, theLower, theUpper, theToCopyData):
        return _GeomLib.GeomLib_Array1OfMat_Resize(self, theLower, theUpper, theToCopyData)
    __swig_destroy__ = _GeomLib.delete_GeomLib_Array1OfMat

    def __getitem__(self, index):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            return self.Value(index + self.Lower())

    def __setitem__(self, index, value):
        if index + self.Lower() > self.Upper():
            raise IndexError("index out of range")
        else:
            self.SetValue(index + self.Lower(), value)

    def __len__(self):
        return self.Length()

    def __iter__(self):
        self.low = self.Lower()
        self.up = self.Upper()
        self.current = self.Lower() - 1
        return self

    def next(self):
        if self.current >= self.Upper():
            raise StopIteration
        else:
            self.current += 1
        return self.Value(self.current)

    __next__ = next


# Register GeomLib_Array1OfMat in _GeomLib:
_GeomLib.GeomLib_Array1OfMat_swigregister(GeomLib_Array1OfMat)
class geomlib(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def AdjustExtremity(*args):
        r"""

        Parameters
        ----------
        Curve: Geom_BoundedCurve
        P1: gp_Pnt
        P2: gp_Pnt
        T1: gp_Vec
        T2: gp_Vec

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        return _GeomLib.geomlib_AdjustExtremity(*args)

    @staticmethod
    def AxeOfInertia(*args):
        r"""

        Parameters
        ----------
        Points: TColgp_Array1OfPnt
        Axe: gp_Ax2
        Tol: float (optional, default to 1.0e-7)

        Return
        -------
        IsSingular: bool

        Description
        -----------
        Compute axes of inertia, of some points -- -- -- <axe>.location() is the barycentre -- -- -- -- -- <axe>.xdirection is the axe of upper inertia -- -- -- -- <axe>.direction is the normal to the average plane -- -- -- issingular is true if points are on line -- tol is used to determine singular cases.

        """
        return _GeomLib.geomlib_AxeOfInertia(*args)

    @staticmethod
    def BuildCurve3d(*args):
        r"""

        Parameters
        ----------
        Tolerance: float
        CurvePtr: Adaptor3d_CurveOnSurface
        FirstParameter: float
        LastParameter: float
        NewCurvePtr: Geom_Curve
        Continuity: GeomAbs_Shape (optional, default to GeomAbs_C1)
        MaxDegree: int (optional, default to 14)
        MaxSegment: int (optional, default to 30)

        Return
        -------
        MaxDeviation: float
        AverageDeviation: float

        Description
        -----------
        No available documentation.

        """
        return _GeomLib.geomlib_BuildCurve3d(*args)

    @staticmethod
    def CancelDenominatorDerivative(*args):
        r"""

        Parameters
        ----------
        BSurf: Geom_BSplineSurface
        UDirection: bool
        VDirection: bool

        Return
        -------
        None

        Description
        -----------
        Cancel,on the boundaries,the denominator first derivative in the directions wished by the user and set its value to 1.

        """
        return _GeomLib.geomlib_CancelDenominatorDerivative(*args)

    @staticmethod
    def DensifyArray1OfReal(*args):
        r"""

        Parameters
        ----------
        MinNumPoints: int
        InParameters: TColStd_Array1OfReal
        OutParameters: TColStd_HArray1OfReal

        Return
        -------
        None

        Description
        -----------
        This makes sure that there is at least minnumpoints in outparameters taking into account the parameters in the inparameters array provided those are in order, that is the sequence of real in the inparameter is strictly non decreasing.

        """
        return _GeomLib.geomlib_DensifyArray1OfReal(*args)

    @staticmethod
    def EvalMaxDistanceAlongParameter(*args):
        r"""

        Parameters
        ----------
        Curve: Adaptor3d_Curve
        AReferenceCurve: Adaptor3d_Curve
        Tolerance: float
        Parameters: TColStd_Array1OfReal

        Return
        -------
        MaxDistance: float

        Description
        -----------
        This will compute the maximum distance at the parameters given in the parameters array by projecting from the curve to the reference curve and taking the minimum distance than the maximum will be taken on those minimas.

        """
        return _GeomLib.geomlib_EvalMaxDistanceAlongParameter(*args)

    @staticmethod
    def EvalMaxParametricDistance(*args):
        r"""

        Parameters
        ----------
        Curve: Adaptor3d_Curve
        AReferenceCurve: Adaptor3d_Curve
        Tolerance: float
        Parameters: TColStd_Array1OfReal

        Return
        -------
        MaxDistance: float

        Description
        -----------
        This will compute the maximum distance at the parameters given in the parameters array by evaluating each parameter the two curves and taking the maximum of the evaluated distance.

        """
        return _GeomLib.geomlib_EvalMaxParametricDistance(*args)

    @staticmethod
    def ExtendCurveToPoint(*args):
        r"""

        Parameters
        ----------
        Curve: Geom_BoundedCurve
        Point: gp_Pnt
        Cont: int
        After: bool

        Return
        -------
        None

        Description
        -----------
        Extends the bounded curve curve to the point point. the extension is built: - at the end of the curve if after equals true, or - at the beginning of the curve if after equals false. the extension is performed according to a degree of continuity equal to cont, which in its turn must be equal to 1, 2 or 3. this function converts the bounded curve curve into a bspline curve. warning - nothing is done, and curve is not modified if cont is not equal to 1, 2 or 3. - it is recommended that the extension should not be too large with respect to the size of the bounded curve curve: point must not be located too far from one of the extremities of curve.

        """
        return _GeomLib.geomlib_ExtendCurveToPoint(*args)

    @staticmethod
    def ExtendSurfByLength(*args):
        r"""

        Parameters
        ----------
        Surf: Geom_BoundedSurface
        Length: float
        Cont: int
        InU: bool
        After: bool

        Return
        -------
        None

        Description
        -----------
        Extends the bounded surface surf along one of its boundaries. the chord length of the extension is equal to length. the direction of the extension is given as: - the u parametric direction of surf, if inu equals true, or - the v parametric direction of surf, if inu equals false. in this parametric direction, the extension is built on the side of: - the last parameter of surf, if after equals true, or - the first parameter of surf, if after equals false. the extension is performed according to a degree of continuity equal to cont, which in its turn must be equal to 1, 2 or 3. this function converts the bounded surface surf into a bspline surface. warning - nothing is done, and surf is not modified if cont is not equal to 1, 2 or 3. - it is recommended that length, the size of the extension should not be too large with respect to the size of the bounded surface surf. - surf must not be a periodic bspline surface in the parametric direction corresponding to the direction of extension.

        """
        return _GeomLib.geomlib_ExtendSurfByLength(*args)

    @staticmethod
    def FuseIntervals(*args):
        r"""

        Parameters
        ----------
        Interval1: TColStd_Array1OfReal
        Interval2: TColStd_Array1OfReal
        Fusion: TColStd_SequenceOfReal
        Confusion: float (optional, default to 1.0e-9)
        IsAdjustToFirstInterval: bool (optional, default to Standard_False)

        Return
        -------
        None

        Description
        -----------
        This method fuse intervals interval1 and interval2 with specified confusion @param interval1 [in] first interval to fuse @param interval2 [in] second interval to fuse @param confision [in] tolerance to compare intervals @param isadjusttofirstinterval [in] flag to set method of fusion, if intervals are close  if false, intervals are fusing by half-division methdod  if true, intervals are fusing by selecting value from interval1 @param fusion [out] output interval .

        """
        return _GeomLib.geomlib_FuseIntervals(*args)

    @staticmethod
    def GTransform(*args):
        r"""

        Parameters
        ----------
        Curve: Geom2d_Curve
        GTrsf: gp_GTrsf2d

        Return
        -------
        opencascade::handle<Geom2d_Curve>

        Description
        -----------
        Computes the curve 3d from package geom corresponding to the curve 3d from package geom, transformed with the transformation <gtrsf> warning: this method may return a null handle if it's impossible to compute the transformation of a curve. it's not implemented when: 1) the curve is an infinite parabola or hyperbola 2) the curve is an offsetcurve.

        """
        return _GeomLib.geomlib_GTransform(*args)

    @staticmethod
    def Inertia(*args):
        r"""

        Parameters
        ----------
        Points: TColgp_Array1OfPnt
        Bary: gp_Pnt
        XDir: gp_Dir
        YDir: gp_Dir

        Return
        -------
        Xgap: float
        YGap: float
        ZGap: float

        Description
        -----------
        Compute principale axes of inertia, and dispersion value of some points.

        """
        return _GeomLib.geomlib_Inertia(*args)

    @staticmethod
    def IsBSplUClosed(*args):
        r"""

        Parameters
        ----------
        S: Geom_BSplineSurface
        U1: float
        U2: float
        Tol: float

        Return
        -------
        bool

        Description
        -----------
        Returns true if the poles of u1 isoline and the poles of u2 isoline of surface are identical according to tolerance criterion. for rational surfaces weights(i)*poles(i) are checked.

        """
        return _GeomLib.geomlib_IsBSplUClosed(*args)

    @staticmethod
    def IsBSplVClosed(*args):
        r"""

        Parameters
        ----------
        S: Geom_BSplineSurface
        V1: float
        V2: float
        Tol: float

        Return
        -------
        bool

        Description
        -----------
        Returns true if the poles of v1 isoline and the poles of v2 isoline of surface are identical according to tolerance criterion. for rational surfaces weights(i)*poles(i) are checked.

        """
        return _GeomLib.geomlib_IsBSplVClosed(*args)

    @staticmethod
    def IsBzUClosed(*args):
        r"""

        Parameters
        ----------
        S: Geom_BezierSurface
        U1: float
        U2: float
        Tol: float

        Return
        -------
        bool

        Description
        -----------
        Returns true if the poles of u1 isoline and the poles of u2 isoline of surface are identical according to tolerance criterion.

        """
        return _GeomLib.geomlib_IsBzUClosed(*args)

    @staticmethod
    def IsBzVClosed(*args):
        r"""

        Parameters
        ----------
        S: Geom_BezierSurface
        V1: float
        V2: float
        Tol: float

        Return
        -------
        bool

        Description
        -----------
        Returns true if the poles of v1 isoline and the poles of v2 isoline of surface are identical according to tolerance criterion.

        """
        return _GeomLib.geomlib_IsBzVClosed(*args)

    @staticmethod
    def IsClosed(*args):
        r"""

        Parameters
        ----------
        S: Geom_Surface
        Tol: float

        Return
        -------
        isUClosed: bool
        isVClosed: bool

        Description
        -----------
        This method defines if opposite boundaries of surface coincide with given tolerance.

        """
        return _GeomLib.geomlib_IsClosed(*args)

    @staticmethod
    def NormEstim(*args):
        r"""

        Parameters
        ----------
        theSurf: Geom_Surface
        theUV: gp_Pnt2d
        theTol: float
        theNorm: gp_Dir

        Return
        -------
        int

        Description
        -----------
        Estimate surface normal at the given (u, v) point. @param[in] thesurf input surface @param[in] theuv (u, v) point coordinates on the surface @param[in] thetol estimation tolerance @param[out] thenorm computed normal return 0 if normal estimated from d1, 1 if estimated from d2 (quasysingular), >=2 in case of failure (undefined or infinite solutions).

        """
        return _GeomLib.geomlib_NormEstim(*args)

    @staticmethod
    def RemovePointsFromArray(*args):
        r"""

        Parameters
        ----------
        NumPoints: int
        InParameters: TColStd_Array1OfReal
        OutParameters: TColStd_HArray1OfReal

        Return
        -------
        None

        Description
        -----------
        Warning! this assume that the inparameter is an increasing sequence of real number and it will not check for that: unpredictable result can happen if this is not satisfied. it is the caller responsibility to check for that property. //! this method makes uniform numpoints segments s1,...snumpoints out of the segment defined by the first parameter and the last parameter of the inparameter ; keeps only one point of the inparameters set of parameter in each of the uniform segments taking care of the first and the last parameters. for the ith segment the element of the inparameter is the one that is the first to exceed the midpoint of the segment and to fall before the midpoint of the next segment there will be at the end at most numpoints + 1 if numpoints > 2 in the outparameters array.

        """
        return _GeomLib.geomlib_RemovePointsFromArray(*args)

    @staticmethod
    def SameRange(*args):
        r"""

        Parameters
        ----------
        Tolerance: float
        Curve2dPtr: Geom2d_Curve
        First: float
        Last: float
        RequestedFirst: float
        RequestedLast: float
        NewCurve2dPtr: Geom2d_Curve

        Return
        -------
        None

        Description
        -----------
        Make the curve curve2dptr have the imposed range first to list the most economic way, that is if it can change the range without changing the nature of the curve it will try to do that. otherwise it will produce a bspline curve that has the required range.

        """
        return _GeomLib.geomlib_SameRange(*args)

    @staticmethod
    def To3d(*args):
        r"""

        Parameters
        ----------
        Position: gp_Ax2
        Curve2d: Geom2d_Curve

        Return
        -------
        opencascade::handle<Geom_Curve>

        Description
        -----------
        Computes the curve 3d from package geom corresponding to curve 2d from package geom2d, on the plan defined with the local coordinate system position.

        """
        return _GeomLib.geomlib_To3d(*args)

    @staticmethod
    def buildC3dOnIsoLine(*args):
        r"""

        Parameters
        ----------
        theC2D: Adaptor2d_Curve2d
        theSurf: Adaptor3d_Surface
        theFirst: float
        theLast: float
        theTolerance: float
        theIsU: bool
        theParam: float
        theIsForward: bool

        Return
        -------
        opencascade::handle<Geom_Curve>

        Description
        -----------
        Builds 3d curve for a isoline. this method takes corresponding isoline from the input surface. @param thec2d trimmed curve to be approximated. @param theisu flag indicating that line is u const. @param theparam line parameter. @param theisforward flag indicating forward parameterization on a isoline. return standard_true when 3d curve is built and standard_false otherwise.

        """
        return _GeomLib.geomlib_buildC3dOnIsoLine(*args)

    @staticmethod
    def isIsoLine(*args):
        r"""

        Parameters
        ----------
        theC2D: Adaptor2d_Curve2d

        Return
        -------
        theIsU: bool
        theParam: float
        theIsForward: bool

        Description
        -----------
        Checks whether the 2d curve is a isoline. it can be represented by b-spline, bezier, or geometric line. this line should have natural parameterization. @param thec2d trimmed curve to be checked. @param theisu flag indicating that line is u const. @param theparam line parameter. @param theisforward flag indicating forward parameterization on a isoline. return standard_true when 2d curve is a line and standard_false otherwise.

        """
        return _GeomLib.geomlib_isIsoLine(*args)

    __repr__ = _dumps_object


    def __init__(self):
        _GeomLib.geomlib_swiginit(self, _GeomLib.new_geomlib())
    __swig_destroy__ = _GeomLib.delete_geomlib

# Register geomlib in _GeomLib:
_GeomLib.geomlib_swigregister(geomlib)
class GeomLib_Check2dBSplineCurve(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        Curve: Geom2d_BSplineCurve
        Tolerance: float
        AngularTolerance: float

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _GeomLib.GeomLib_Check2dBSplineCurve_swiginit(self, _GeomLib.new_GeomLib_Check2dBSplineCurve(*args))

    def FixTangent(self, *args):
        r"""

        Parameters
        ----------
        FirstFlag: bool
        LastFlag: bool

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        return _GeomLib.GeomLib_Check2dBSplineCurve_FixTangent(self, *args)

    def FixedTangent(self, *args):
        r"""

        Parameters
        ----------
        FirstFlag: bool
        LastFlag: bool

        Return
        -------
        opencascade::handle<Geom2d_BSplineCurve>

        Description
        -----------
        Modifies the curve by fixing the first or the last tangencies //! if index3d not in the range [1,nb3dspaces] if the approx is not done.

        """
        return _GeomLib.GeomLib_Check2dBSplineCurve_FixedTangent(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        No available documentation.

        """
        return _GeomLib.GeomLib_Check2dBSplineCurve_IsDone(self, *args)

    def NeedTangentFix(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        FirstFlag: bool
        SecondFlag: bool

        Description
        -----------
        No available documentation.

        """
        return _GeomLib.GeomLib_Check2dBSplineCurve_NeedTangentFix(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomLib.delete_GeomLib_Check2dBSplineCurve

# Register GeomLib_Check2dBSplineCurve in _GeomLib:
_GeomLib.GeomLib_Check2dBSplineCurve_swigregister(GeomLib_Check2dBSplineCurve)
class GeomLib_CheckBSplineCurve(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        Curve: Geom_BSplineCurve
        Tolerance: float
        AngularTolerance: float

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _GeomLib.GeomLib_CheckBSplineCurve_swiginit(self, _GeomLib.new_GeomLib_CheckBSplineCurve(*args))

    def FixTangent(self, *args):
        r"""

        Parameters
        ----------
        FirstFlag: bool
        LastFlag: bool

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        return _GeomLib.GeomLib_CheckBSplineCurve_FixTangent(self, *args)

    def FixedTangent(self, *args):
        r"""

        Parameters
        ----------
        FirstFlag: bool
        LastFlag: bool

        Return
        -------
        opencascade::handle<Geom_BSplineCurve>

        Description
        -----------
        Modifies the curve by fixing the first or the last tangencies //! if index3d not in the range [1,nb3dspaces] if the approx is not done.

        """
        return _GeomLib.GeomLib_CheckBSplineCurve_FixedTangent(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        No available documentation.

        """
        return _GeomLib.GeomLib_CheckBSplineCurve_IsDone(self, *args)

    def NeedTangentFix(self, *args):
        r"""

        Parameters
        ----------

        Return
        -------
        FirstFlag: bool
        SecondFlag: bool

        Description
        -----------
        No available documentation.

        """
        return _GeomLib.GeomLib_CheckBSplineCurve_NeedTangentFix(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomLib.delete_GeomLib_CheckBSplineCurve

# Register GeomLib_CheckBSplineCurve in _GeomLib:
_GeomLib.GeomLib_CheckBSplineCurve_swigregister(GeomLib_CheckBSplineCurve)
class GeomLib_CheckCurveOnSurface(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        Return
        -------
        None

        Description
        -----------
        Default constructor.

        Parameters
        ----------
        theCurve: Adaptor3d_Curve
        theTolRange: float (optional, default to Precision::PConfusion())

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _GeomLib.GeomLib_CheckCurveOnSurface_swiginit(self, _GeomLib.new_GeomLib_CheckCurveOnSurface(*args))

    def ErrorStatus(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns error status the possible values are: 0 - ok; 1 - null curve or surface or 2d curve; 2 - invalid parametric range; 3 - error in calculations.

        """
        return _GeomLib.GeomLib_CheckCurveOnSurface_ErrorStatus(self, *args)

    def Init(self, *args):
        r"""

        Parameters
        ----------
        theCurve: Adaptor3d_Curve
        theTolRange: float (optional, default to Precision::PConfusion())

        Return
        -------
        None

        Description
        -----------
        Sets the data for the algorithm.
        Return
        -------
        None

        Description
        -----------
        Initializes all members by default values.

        """
        return _GeomLib.GeomLib_CheckCurveOnSurface_Init(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if the max distance has been found.

        """
        return _GeomLib.GeomLib_CheckCurveOnSurface_IsDone(self, *args)

    def IsParallel(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns true if parallel flag is set.

        """
        return _GeomLib.GeomLib_CheckCurveOnSurface_IsParallel(self, *args)

    def MaxDistance(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        Returns max distance.

        """
        return _GeomLib.GeomLib_CheckCurveOnSurface_MaxDistance(self, *args)

    def MaxParameter(self, *args):
        r"""
        Return
        -------
        float

        Description
        -----------
        Returns parameter in which the distance is maximal.

        """
        return _GeomLib.GeomLib_CheckCurveOnSurface_MaxParameter(self, *args)

    def Perform(self, *args):
        r"""

        Parameters
        ----------
        theCurveOnSurface: Adaptor3d_CurveOnSurface

        Return
        -------
        None

        Description
        -----------
        Computes the max distance for the 3d curve <mycurve> and 2d curve <thecurveonsurface> if ismultithread == standard_true then computation will be performed in parallel.

        """
        return _GeomLib.GeomLib_CheckCurveOnSurface_Perform(self, *args)

    def SetParallel(self, *args):
        r"""

        Parameters
        ----------
        theIsParallel: bool

        Return
        -------
        None

        Description
        -----------
        Sets parallel flag.

        """
        return _GeomLib.GeomLib_CheckCurveOnSurface_SetParallel(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomLib.delete_GeomLib_CheckCurveOnSurface

# Register GeomLib_CheckCurveOnSurface in _GeomLib:
_GeomLib.GeomLib_CheckCurveOnSurface_swigregister(GeomLib_CheckCurveOnSurface)
class GeomLib_DenominatorMultiplier(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        Surface: Geom_BSplineSurface
        KnotVector: TColStd_Array1OfReal

        Return
        -------
        None

        Description
        -----------
        If the surface is rational this will define the evaluator of a real function of 2 variables a(u,v) such that if we define a new surface by: a(u,v) * n(u,v) newf(u,v) = ---------------- a(u,v) * d(u,v).

        """
        _GeomLib.GeomLib_DenominatorMultiplier_swiginit(self, _GeomLib.new_GeomLib_DenominatorMultiplier(*args))

    def Value(self, *args):
        r"""

        Parameters
        ----------
        UParameter: float
        VParameter: float

        Return
        -------
        float

        Description
        -----------
        Returns the value of a(uparameter,vparameter)= //! h0(uparameter)/denominator(umin,vparameter) //! d denominator(umin,vparameter) - ------------------------------[h1(u)]/(denominator(umin,vparameter)^2) d u //! + h3(uparameter)/denominator(umax,vparameter) //! d denominator(umax,vparameter) - ------------------------------[h2(u)]/(denominator(umax,vparameter)^2) d u.

        """
        return _GeomLib.GeomLib_DenominatorMultiplier_Value(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomLib.delete_GeomLib_DenominatorMultiplier

# Register GeomLib_DenominatorMultiplier in _GeomLib:
_GeomLib.GeomLib_DenominatorMultiplier_swigregister(GeomLib_DenominatorMultiplier)
class GeomLib_Interpolate(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        Degree: int
        NumPoints: int
        Points: TColgp_Array1OfPnt
        Parameters: TColStd_Array1OfReal

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _GeomLib.GeomLib_Interpolate_swiginit(self, _GeomLib.new_GeomLib_Interpolate(*args))

    def Curve(self, *args):
        r"""
        Return
        -------
        opencascade::handle<Geom_BSplineCurve>

        Description
        -----------
        Returns the interpolated curve of the requested degree.

        """
        return _GeomLib.GeomLib_Interpolate_Curve(self, *args)

    def Error(self, *args):
        r"""
        Return
        -------
        GeomLib_InterpolationErrors

        Description
        -----------
        Returns the error type if any.

        """
        return _GeomLib.GeomLib_Interpolate_Error(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Returns if everything went ok.

        """
        return _GeomLib.GeomLib_Interpolate_IsDone(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomLib.delete_GeomLib_Interpolate

# Register GeomLib_Interpolate in _GeomLib:
_GeomLib.GeomLib_Interpolate_swigregister(GeomLib_Interpolate)
class GeomLib_IsPlanarSurface(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        S: Geom_Surface
        Tol: float (optional, default to 1.0e-7)

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _GeomLib.GeomLib_IsPlanarSurface_swiginit(self, _GeomLib.new_GeomLib_IsPlanarSurface(*args))

    def IsPlanar(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        Return if the surface is a plan.

        """
        return _GeomLib.GeomLib_IsPlanarSurface_IsPlanar(self, *args)

    def Plan(self, *args):
        r"""
        Return
        -------
        gp_Pln

        Description
        -----------
        Return the plan definition.

        """
        return _GeomLib.GeomLib_IsPlanarSurface_Plan(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomLib.delete_GeomLib_IsPlanarSurface

# Register GeomLib_IsPlanarSurface in _GeomLib:
_GeomLib.GeomLib_IsPlanarSurface_swigregister(GeomLib_IsPlanarSurface)
class GeomLib_LogSample(OCC.Core.math.math_FunctionSample):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        A: float
        B: float
        N: int

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _GeomLib.GeomLib_LogSample_swiginit(self, _GeomLib.new_GeomLib_LogSample(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomLib.delete_GeomLib_LogSample

# Register GeomLib_LogSample in _GeomLib:
_GeomLib.GeomLib_LogSample_swigregister(GeomLib_LogSample)
class GeomLib_MakeCurvefromApprox(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        Approx: AdvApprox_ApproxAFunction

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _GeomLib.GeomLib_MakeCurvefromApprox_swiginit(self, _GeomLib.new_GeomLib_MakeCurvefromApprox(*args))

    def Curve(self, *args):
        r"""

        Parameters
        ----------
        Index3d: int

        Return
        -------
        opencascade::handle<Geom_BSplineCurve>

        Description
        -----------
        Returns a polynomial curve whose poles correspond to the index3d 3d space if index3d not in the range [1,nb3dspaces] if the approx is not done.

        Parameters
        ----------
        Index1D: int
        Index3D: int

        Return
        -------
        opencascade::handle<Geom_BSplineCurve>

        Description
        -----------
        Returns a rational curve whose poles correspond to the index3d of the 3d space and whose weights correspond to the index1d 1d space. if index1d not in the range [1,nb1dspaces] if index3d not in the range [1,nb3dspaces] if the approx is not done.

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_Curve(self, *args)

    def Curve2d(self, *args):
        r"""

        Parameters
        ----------
        Index2d: int

        Return
        -------
        opencascade::handle<Geom2d_BSplineCurve>

        Description
        -----------
        Returns a polynomial curve whose poles correspond to the index2d 2d space if index2d not in the range [1,nb2dspaces] if the approx is not done.

        Parameters
        ----------
        Index1d: int
        Index2d: int

        Return
        -------
        opencascade::handle<Geom2d_BSplineCurve>

        Description
        -----------
        Returns a rational curve whose poles correspond to the index2d of the 2d space and whose weights correspond to one dimensional space of index 1d if index1d not in the range [1,nb1dspaces] if index2d not in the range [1,nb2dspaces] if the approx is not done.

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_Curve2d(self, *args)

    def Curve2dFromTwo1d(self, *args):
        r"""

        Parameters
        ----------
        Index1d: int
        Index2d: int

        Return
        -------
        opencascade::handle<Geom2d_BSplineCurve>

        Description
        -----------
        Returns a 2d curve building it from the 1d curve in x at index1d and y at index2d amongst the 1d curves if index1d not in the range [1,nb1dspaces] if index2d not in the range [1,nb1dspaces] if the approx is not done.

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_Curve2dFromTwo1d(self, *args)

    def IsDone(self, *args):
        r"""
        Return
        -------
        bool

        Description
        -----------
        No available documentation.

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_IsDone(self, *args)

    def Nb1DSpaces(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of 1d spaces of the approx.

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_Nb1DSpaces(self, *args)

    def Nb2DSpaces(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of 3d spaces of the approx.

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_Nb2DSpaces(self, *args)

    def Nb3DSpaces(self, *args):
        r"""
        Return
        -------
        int

        Description
        -----------
        Returns the number of 3d spaces of the approx.

        """
        return _GeomLib.GeomLib_MakeCurvefromApprox_Nb3DSpaces(self, *args)

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomLib.delete_GeomLib_MakeCurvefromApprox

# Register GeomLib_MakeCurvefromApprox in _GeomLib:
_GeomLib.GeomLib_MakeCurvefromApprox_swigregister(GeomLib_MakeCurvefromApprox)
class GeomLib_PolyFunc(OCC.Core.math.math_FunctionWithDerivative):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""

        Parameters
        ----------
        Coeffs: math_Vector

        Return
        -------
        None

        Description
        -----------
        No available documentation.

        """
        _GeomLib.GeomLib_PolyFunc_swiginit(self, _GeomLib.new_GeomLib_PolyFunc(*args))

    __repr__ = _dumps_object

    __swig_destroy__ = _GeomLib.delete_GeomLib_PolyFunc

# Register GeomLib_PolyFunc in _GeomLib:
_GeomLib.GeomLib_PolyFunc_swigregister(GeomLib_PolyFunc)
class GeomLib_Tool(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def ComputeDeviation(*args):
        r"""

        Parameters
        ----------
        theCurve: Geom2dAdaptor_Curve
        theFPar: float
        theLPar: float
        theStartParameter: float
        theNbIters: int (optional, default to 100)
        thePrmOnCurve: float * (optional, default to NULL)
        thePtOnCurve: gp_Pnt2d * (optional, default to NULL)
        theVecCurvLine: gp_Vec2d * (optional, default to NULL)
        theLine: gp_Lin2d * (optional, default to NULL)

        Return
        -------
        float

        Description
        -----------
        Computes parameter in thecurve (*theprmoncurve) where maximal deviation between thecurve and the linear segment joining its points with the parameters thefpar and thelpar is obtained. returns the (positive) value of deviation. returns negative value if the deviation cannot be computed. the returned parameter (in case of successful) will always be in the range [thefpar, thelpar]. iterative method is used for computation. so, thestartparameter is needed to be set. recommend value of thestartparameter can be found with the overloaded method. additionally, following values can be returned (optionally): @param theptoncurve - the point on curve where maximal deviation is achieved; @param theprmoncurve - the parameter of theptoncurve; @param theveccurvline - the vector along which is computed (this vector is always  perpendicular theline); @param theline - the linear segment joining the point of thecurve having parameters thefpar and thelpar.

        Parameters
        ----------
        theCurve: Geom2dAdaptor_Curve
        theFPar: float
        theLPar: float
        theNbSubIntervals: int
        theNbIters: int (optional, default to 10)
        thePrmOnCurve: float * (optional, default to NULL)

        Return
        -------
        float

        Description
        -----------
        Computes parameter in thecurve (*theprmoncurve) where maximal deviation between thecurve and the linear segment joining its points with the parameters thefpar and thelpar is obtained. returns the (positive) value of deviation. returns negative value if the deviation cannot be computed. the returned parameter (in case of successful) will always be in the range [thefpar, thelpar]. thenbsubintervals defines discretization of the given interval [thefpar, thelpar] to provide better search condition. this value should be chosen taking into account complexity of the curve in considered interval. e.g. if there are many oscillations of the curve in the interval then thenbsubintervals mus be great number. however, the greater value of thenbsubintervals the slower the algorithm will compute. thenbiters sets number of iterations. attention!!! this algorithm cannot compute deviation precisely (so, there is no point in setting big value of thenbiters). but it can give some start point for the overloaded method.

        """
        return _GeomLib.GeomLib_Tool_ComputeDeviation(*args)

    @staticmethod
    def Parameter(*args):
        r"""

        Parameters
        ----------
        Curve: Geom_Curve
        Point: gp_Pnt
        MaxDist: float

        Return
        -------
        U: float

        Description
        -----------
        Extracts the parameter of a 3d point lying on a 3d curve or at a distance less than the maxdist value.

        Parameters
        ----------
        Curve: Geom2d_Curve
        Point: gp_Pnt2d
        MaxDist: float

        Return
        -------
        U: float

        Description
        -----------
        Extracts the parameter of a 2d point lying on a 2d curve or at a distance less than the maxdist value.

        """
        return _GeomLib.GeomLib_Tool_Parameter(*args)

    @staticmethod
    def Parameters(*args):
        r"""

        Parameters
        ----------
        Surface: Geom_Surface
        Point: gp_Pnt
        MaxDist: float

        Return
        -------
        U: float
        V: float

        Description
        -----------
        Extracts the parameter of a 3d point lying on a surface or at a distance less than the maxdist value.

        """
        return _GeomLib.GeomLib_Tool_Parameters(*args)

    __repr__ = _dumps_object


    def __init__(self):
        _GeomLib.GeomLib_Tool_swiginit(self, _GeomLib.new_GeomLib_Tool())
    __swig_destroy__ = _GeomLib.delete_GeomLib_Tool

# Register GeomLib_Tool in _GeomLib:
_GeomLib.GeomLib_Tool_swigregister(GeomLib_Tool)



@deprecated
def geomlib_AdjustExtremity(*args):
	return geomlib.AdjustExtremity(*args)

@deprecated
def geomlib_AxeOfInertia(*args):
	return geomlib.AxeOfInertia(*args)

@deprecated
def geomlib_BuildCurve3d(*args):
	return geomlib.BuildCurve3d(*args)

@deprecated
def geomlib_CancelDenominatorDerivative(*args):
	return geomlib.CancelDenominatorDerivative(*args)

@deprecated
def geomlib_DensifyArray1OfReal(*args):
	return geomlib.DensifyArray1OfReal(*args)

@deprecated
def geomlib_EvalMaxDistanceAlongParameter(*args):
	return geomlib.EvalMaxDistanceAlongParameter(*args)

@deprecated
def geomlib_EvalMaxParametricDistance(*args):
	return geomlib.EvalMaxParametricDistance(*args)

@deprecated
def geomlib_ExtendCurveToPoint(*args):
	return geomlib.ExtendCurveToPoint(*args)

@deprecated
def geomlib_ExtendSurfByLength(*args):
	return geomlib.ExtendSurfByLength(*args)

@deprecated
def geomlib_FuseIntervals(*args):
	return geomlib.FuseIntervals(*args)

@deprecated
def geomlib_GTransform(*args):
	return geomlib.GTransform(*args)

@deprecated
def geomlib_Inertia(*args):
	return geomlib.Inertia(*args)

@deprecated
def geomlib_IsBSplUClosed(*args):
	return geomlib.IsBSplUClosed(*args)

@deprecated
def geomlib_IsBSplVClosed(*args):
	return geomlib.IsBSplVClosed(*args)

@deprecated
def geomlib_IsBzUClosed(*args):
	return geomlib.IsBzUClosed(*args)

@deprecated
def geomlib_IsBzVClosed(*args):
	return geomlib.IsBzVClosed(*args)

@deprecated
def geomlib_IsClosed(*args):
	return geomlib.IsClosed(*args)

@deprecated
def geomlib_NormEstim(*args):
	return geomlib.NormEstim(*args)

@deprecated
def geomlib_RemovePointsFromArray(*args):
	return geomlib.RemovePointsFromArray(*args)

@deprecated
def geomlib_SameRange(*args):
	return geomlib.SameRange(*args)

@deprecated
def geomlib_To3d(*args):
	return geomlib.To3d(*args)

@deprecated
def geomlib_buildC3dOnIsoLine(*args):
	return geomlib.buildC3dOnIsoLine(*args)

@deprecated
def geomlib_isIsoLine(*args):
	return geomlib.isIsoLine(*args)

@deprecated
def GeomLib_Tool_ComputeDeviation(*args):
	return GeomLib_Tool.ComputeDeviation(*args)

@deprecated
def GeomLib_Tool_ComputeDeviation(*args):
	return GeomLib_Tool.ComputeDeviation(*args)

@deprecated
def GeomLib_Tool_Parameter(*args):
	return GeomLib_Tool.Parameter(*args)

@deprecated
def GeomLib_Tool_Parameter(*args):
	return GeomLib_Tool.Parameter(*args)

@deprecated
def GeomLib_Tool_Parameters(*args):
	return GeomLib_Tool.Parameters(*args)



