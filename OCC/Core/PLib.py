# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
PLib module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_plib.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_PLib')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_PLib')
    _PLib = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_PLib', [dirname(__file__)])
        except ImportError:
            import _PLib
            return _PLib
        try:
            _mod = imp.load_module('_PLib', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _PLib = swig_import_helper()
    del swig_import_helper
else:
    import _PLib
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _PLib.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _PLib.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _PLib.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _PLib.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _PLib.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _PLib.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _PLib.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _PLib.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _PLib.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _PLib.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _PLib.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _PLib.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _PLib.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _PLib.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _PLib.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _PLib.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _PLib.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _PLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _PLib.process_exception(error, method_name, class_name)
process_exception = _PLib.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.TColgp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.GeomAbs
import OCC.Core.math
import OCC.Core.Message
import OCC.Core.OSD
import OCC.Core.gp

from enum import IntEnum
from OCC.Core.Exception import *




def Handle_PLib_Base_Create() -> "opencascade::handle< PLib_Base >":
    return _PLib.Handle_PLib_Base_Create()
Handle_PLib_Base_Create = _PLib.Handle_PLib_Base_Create

def Handle_PLib_Base_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< PLib_Base >":
    return _PLib.Handle_PLib_Base_DownCast(t)
Handle_PLib_Base_DownCast = _PLib.Handle_PLib_Base_DownCast

def Handle_PLib_Base_IsNull(t: 'opencascade::handle< PLib_Base > const &') -> "bool":
    return _PLib.Handle_PLib_Base_IsNull(t)
Handle_PLib_Base_IsNull = _PLib.Handle_PLib_Base_IsNull

def Handle_PLib_HermitJacobi_Create() -> "opencascade::handle< PLib_HermitJacobi >":
    return _PLib.Handle_PLib_HermitJacobi_Create()
Handle_PLib_HermitJacobi_Create = _PLib.Handle_PLib_HermitJacobi_Create

def Handle_PLib_HermitJacobi_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< PLib_HermitJacobi >":
    return _PLib.Handle_PLib_HermitJacobi_DownCast(t)
Handle_PLib_HermitJacobi_DownCast = _PLib.Handle_PLib_HermitJacobi_DownCast

def Handle_PLib_HermitJacobi_IsNull(t: 'opencascade::handle< PLib_HermitJacobi > const &') -> "bool":
    return _PLib.Handle_PLib_HermitJacobi_IsNull(t)
Handle_PLib_HermitJacobi_IsNull = _PLib.Handle_PLib_HermitJacobi_IsNull

def Handle_PLib_JacobiPolynomial_Create() -> "opencascade::handle< PLib_JacobiPolynomial >":
    return _PLib.Handle_PLib_JacobiPolynomial_Create()
Handle_PLib_JacobiPolynomial_Create = _PLib.Handle_PLib_JacobiPolynomial_Create

def Handle_PLib_JacobiPolynomial_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< PLib_JacobiPolynomial >":
    return _PLib.Handle_PLib_JacobiPolynomial_DownCast(t)
Handle_PLib_JacobiPolynomial_DownCast = _PLib.Handle_PLib_JacobiPolynomial_DownCast

def Handle_PLib_JacobiPolynomial_IsNull(t: 'opencascade::handle< PLib_JacobiPolynomial > const &') -> "bool":
    return _PLib.Handle_PLib_JacobiPolynomial_IsNull(t)
Handle_PLib_JacobiPolynomial_IsNull = _PLib.Handle_PLib_JacobiPolynomial_IsNull
class plib(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plib, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plib, name)
    __repr__ = _swig_repr

    def Bin(*args) -> "Standard_Real":
        """
        Returns the binomial cnp. n should be <= bsplclib::maxdegree().

        Parameters
        ----------
        N: int
        P: int

        Returns
        -------
        float

        """
        return _PLib.plib_Bin(*args)

    Bin = staticmethod(Bin)

    def CoefficientsPoles(*args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        Coefs: TColgp_Array1OfPnt
        WCoefs: TColStd_Array1OfReal *
        Poles: TColgp_Array1OfPnt
        WPoles: TColStd_Array1OfReal *

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        Coefs: TColgp_Array1OfPnt2d
        WCoefs: TColStd_Array1OfReal *
        Poles: TColgp_Array1OfPnt2d
        WPoles: TColStd_Array1OfReal *

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        Coefs: TColStd_Array1OfReal
        WCoefs: TColStd_Array1OfReal *
        Poles: TColStd_Array1OfReal
        WPoles: TColStd_Array1OfReal *

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        dim: int
        Coefs: TColStd_Array1OfReal
        WCoefs: TColStd_Array1OfReal *
        Poles: TColStd_Array1OfReal
        WPoles: TColStd_Array1OfReal *

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        Coefs: TColgp_Array2OfPnt
        WCoefs: TColStd_Array2OfReal *
        Poles: TColgp_Array2OfPnt
        WPoles: TColStd_Array2OfReal *

        Returns
        -------
        None

        """
        return _PLib.plib_CoefficientsPoles(*args)

    CoefficientsPoles = staticmethod(CoefficientsPoles)

    def ConstraintOrder(*args) -> "GeomAbs_Shape":
        """
        Translates from integer to geomabs_shape.

        Parameters
        ----------
        NivConstr: int

        Returns
        -------
        GeomAbs_Shape

        """
        return _PLib.plib_ConstraintOrder(*args)

    ConstraintOrder = staticmethod(ConstraintOrder)

    def EvalCubicHermite(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &":
        """
        Performs the cubic hermite interpolation of given series of points with given parameters with the requested derivative order. valuearray stores the value at the first and last parameter. it has the following format : [0], [dimension-1]  : value at first param [dimension], [dimension + dimension-1] : value at last param derivative array stores the value of the derivatives at the first parameter and at the last parameter in the following format [0], [dimension-1]  : derivative at first param [dimension], [dimension + dimension-1] : derivative at last param //! parameterarray stores the first and last parameter in the following format : [0] : first parameter [1] : last parameter //! results will store things in the following format with d = derivativeorder //! [0], [dimension-1]  : value [dimension], [dimension + dimension-1] : first derivative //! [d *dimension], [d*dimension + dimension-1]: dth derivative.

        Parameters
        ----------
        U: float
        DerivativeOrder: int
        Dimension: int

        Returns
        -------
        ValueArray: float
        DerivativeArray: float
        ParameterArray: float
        Results: float

        """
        return _PLib.plib_EvalCubicHermite(*args)

    EvalCubicHermite = staticmethod(EvalCubicHermite)

    def EvalLagrange(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
        """
        Performs the lagrange interpolation of given series of points with given parameters with the requested derivative order results will store things in the following format with d = derivativeorder //! [0], [dimension-1]  : value [dimension], [dimension + dimension-1] : first derivative //! [d *dimension], [d*dimension + dimension-1]: dth derivative.

        Parameters
        ----------
        U: float
        DerivativeOrder: int
        Degree: int
        Dimension: int

        Returns
        -------
        ValueArray: float
        ParameterArray: float
        Results: float

        """
        return _PLib.plib_EvalLagrange(*args)

    EvalLagrange = staticmethod(EvalLagrange)

    def EvalLength(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
        """
        No available documentation.

        Parameters
        ----------
        Degree: int
        Dimension: int
        U1: float
        U2: float

        Returns
        -------
        PolynomialCoeff: float
        Length: float

        No available documentation.

        Parameters
        ----------
        Degree: int
        Dimension: int
        U1: float
        U2: float
        Tol: float

        Returns
        -------
        PolynomialCoeff: float
        Length: float
        Error: float

        """
        return _PLib.plib_EvalLength(*args)

    EvalLength = staticmethod(EvalLength)

    def EvalPoly2Var(*args) -> "Standard_Real &, Standard_Real &":
        """
        Applies evalpolynomial twice to evaluate the derivative of orders uderivativeorder in u, vderivativeorder in v at parameters u,v //! polynomialcoeff are stored in the following fashion c00(1) .... c00(dimension) c10(1) .... c10(dimension) .... cm0(1) .... cm0(dimension) .... c01(1) .... c01(dimension) c11(1) .... c11(dimension) .... cm1(1) .... cm1(dimension) .... c0n(1) .... c0n(dimension) c1n(1) .... c1n(dimension) .... cmn(1) .... cmn(dimension) //! where the polynomial is defined as : 2  m c00 + c10 u + c20 u + .... + cm0 u 2  m + c01 v + c11 uv + c21 u v + .... + cm1 u v n m n + .... + c0n v + .... + cmn u v //! with m = udegree and n = vdegree //! results stores the result in the following format //! f(1) f(2) .... f(dimension) //! warning: <results> and <polynomialcoeff> must be dimensioned properly.

        Parameters
        ----------
        U: float
        V: float
        UDerivativeOrder: int
        VDerivativeOrder: int
        UDegree: int
        VDegree: int
        Dimension: int

        Returns
        -------
        PolynomialCoeff: float
        Results: float

        """
        return _PLib.plib_EvalPoly2Var(*args)

    EvalPoly2Var = staticmethod(EvalPoly2Var)

    def EvalPolynomial(*args) -> "Standard_Real &, Standard_Real &":
        """
        Performs horner method with synthethic division for derivatives parameter <u>, with <degree> and <dimension>. polynomialcoeff are stored in the following fashion c0(1) c0(2) .... c0(dimension) c1(1) c1(2) .... c1(dimension) //! cdegree(1) cdegree(2) .... cdegree(dimension) where the polynomial is defined as : //! 2 degree c0 + c1 x + c2 x + .... cdegree x //! results stores the result in the following format //! f(1) f(2) .... f(dimension) (1)  (1)  (1) f (1) f (2) .... f (dimension) //! (derivativerequest) (derivativerequest) f (1)  f (dimension) //! this just evaluates the point at parameter u //! warning: <results> and <polynomialcoeff> must be dimensioned properly.

        Parameters
        ----------
        U: float
        DerivativeOrder: int
        Degree: int
        Dimension: int

        Returns
        -------
        PolynomialCoeff: float
        Results: float

        """
        return _PLib.plib_EvalPolynomial(*args)

    EvalPolynomial = staticmethod(EvalPolynomial)

    def GetPoles(*args) -> "void":
        """
        Get from fp the coordinates of the poles.

        Parameters
        ----------
        FP: TColStd_Array1OfReal
        Poles: TColgp_Array1OfPnt

        Returns
        -------
        None

        Get from fp the coordinates of the poles.

        Parameters
        ----------
        FP: TColStd_Array1OfReal
        Poles: TColgp_Array1OfPnt
        Weights: TColStd_Array1OfReal

        Returns
        -------
        None

        Get from fp the coordinates of the poles.

        Parameters
        ----------
        FP: TColStd_Array1OfReal
        Poles: TColgp_Array1OfPnt2d

        Returns
        -------
        None

        Get from fp the coordinates of the poles.

        Parameters
        ----------
        FP: TColStd_Array1OfReal
        Poles: TColgp_Array1OfPnt2d
        Weights: TColStd_Array1OfReal

        Returns
        -------
        None

        """
        return _PLib.plib_GetPoles(*args)

    GetPoles = staticmethod(GetPoles)

    def HermiteCoefficients(*args) -> "Standard_Boolean":
        """
        This build the coefficient of hermite's polynomes on [firstparameter, lastparameter] //! if j <= firstorder+1 then //! matrixcoefs[i, j] = ith coefficient of the polynome h0,j-1 //! else //! matrixcoefs[i, j] = ith coefficient of the polynome h1,k with k = j - firstorder - 2 //! return false if - |firstparameter| > 100 - |lastparameter| > 100 - |firstparameter| +|lastparameter| < 1/100 - |lastparameter - firstparameter| / (|firstparameter| +|lastparameter|) < 1/100.

        Parameters
        ----------
        FirstParameter: float
        LastParameter: float
        FirstOrder: int
        LastOrder: int
        MatrixCoefs: math_Matrix

        Returns
        -------
        bool

        """
        return _PLib.plib_HermiteCoefficients(*args)

    HermiteCoefficients = staticmethod(HermiteCoefficients)

    def HermiteInterpolate(*args) -> "Standard_Boolean":
        """
        Compute the coefficients in the canonical base of the polynomial satisfying the given constraints at the given parameters the array firstcontr(i,j) i=1,dimension j=0,firstorder contains the values of the constraint at parameter firstparameter idem for lastconstr.

        Parameters
        ----------
        Dimension: int
        FirstParameter: float
        LastParameter: float
        FirstOrder: int
        LastOrder: int
        FirstConstr: TColStd_Array2OfReal
        LastConstr: TColStd_Array2OfReal
        Coefficients: TColStd_Array1OfReal

        Returns
        -------
        bool

        """
        return _PLib.plib_HermiteInterpolate(*args)

    HermiteInterpolate = staticmethod(HermiteInterpolate)

    def JacobiParameters(*args) -> "Standard_Integer &, Standard_Integer &":
        """
        Compute the number of points used for integral computations (nbgausspoints) and the degree of jacobi polynomial (workdegree). constraintorder has to be geomabs_c0, geomabs_c1 or geomabs_c2 code: code d' init. des parametres de discretisation. = -5 = -4 = -3 = -2 = -1 = 1 calcul rapide avec precision moyenne. = 2 calcul rapide avec meilleure precision. = 3 calcul un peu plus lent avec bonne precision. = 4 calcul lent avec la meilleure precision possible.

        Parameters
        ----------
        ConstraintOrder: GeomAbs_Shape
        MaxDegree: int
        Code: int

        Returns
        -------
        NbGaussPoints: int
        WorkDegree: int

        """
        return _PLib.plib_JacobiParameters(*args)

    JacobiParameters = staticmethod(JacobiParameters)

    def NivConstr(*args) -> "Standard_Integer":
        """
        Translates from geomabs_shape to integer.

        Parameters
        ----------
        ConstraintOrder: GeomAbs_Shape

        Returns
        -------
        int

        """
        return _PLib.plib_NivConstr(*args)

    NivConstr = staticmethod(NivConstr)

    def NoDerivativeEvalPolynomial(*args) -> "Standard_Real &, Standard_Real &":
        """
        Same as above with derivativeorder = 0;.

        Parameters
        ----------
        U: float
        Degree: int
        Dimension: int
        DegreeDimension: int

        Returns
        -------
        PolynomialCoeff: float
        Results: float

        """
        return _PLib.plib_NoDerivativeEvalPolynomial(*args)

    NoDerivativeEvalPolynomial = staticmethod(NoDerivativeEvalPolynomial)

    def NoWeights(*args) -> "TColStd_Array1OfReal *":
        """
        Used as argument for a non rational functions.

        Returns
        -------
        TColStd_Array1OfReal *

        """
        return _PLib.plib_NoWeights(*args)

    NoWeights = staticmethod(NoWeights)

    def NoWeights2(*args) -> "TColStd_Array2OfReal *":
        """
        Used as argument for a non rational functions.

        Returns
        -------
        TColStd_Array2OfReal *

        """
        return _PLib.plib_NoWeights2(*args)

    NoWeights2 = staticmethod(NoWeights2)

    def RationalDerivative(*args) -> "Standard_Real &, Standard_Real &":
        """
        Computes the derivatives of a ratio at order <n> in dimension <dimension>. //! <ders> is an array containing the values of the input derivatives from 0 to min(<n>,<degree>). for orders higher than <degree> the inputcd /s2d1/bmdl/ derivatives are assumed to be 0. //! content of <ders> : //! x(1),x(2),...,x(dimension),w x'(1),x'(2),...,x'(dimension),w' x''(1),x''(2),...,x''(dimension),w'' //! if <all> is false, only the derivative at order <n> is computed. <rders> is an array of length dimension which will contain the result : //! x(1)/w , x(2)/w , ... derivated <n> times //! if <all> is true all the derivatives up to order <n> are computed. <rders> is an array of length dimension * (n+1) which will contains : //! x(1)/w , x(2)/w , ... x(1)/w , x(2)/w , ... derivated <1> times x(1)/w , x(2)/w , ... derivated <2> times ... x(1)/w , x(2)/w , ... derivated <n> times //! warning: <rders> must be dimensionned properly.

        Parameters
        ----------
        Degree: int
        N: int
        Dimension: int
        All: bool,optional
        	default value is Standard_True

        Returns
        -------
        Ders: float
        RDers: float

        """
        return _PLib.plib_RationalDerivative(*args)

    RationalDerivative = staticmethod(RationalDerivative)

    def RationalDerivatives(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
        """
        Computes derivativesrequest derivatives of a ratio at of a bspline function of degree <degree> dimension <dimension>. //! <polesderivatives> is an array containing the values of the input derivatives from 0 to <derivativerequest> for orders higher than <degree> the input derivatives are assumed to be 0. //! content of <poleasderivatives> : //! x(1),x(2),...,x(dimension) x'(1),x'(2),...,x'(dimension) x''(1),x''(2),...,x''(dimension) //! weightsderivatives is an array that contains derivatives from 0 to <derivativerequest> after returning from the routine the array rationalderivatives contains the following x(1)/w , x(2)/w , ... x(1)/w , x(2)/w , ... derivated once x(1)/w , x(2)/w , ... twice x(1)/w , x(2)/w , ... derivated <derivativerequest> times //! the array rationalderivatives and polesderivatives can be same since the overwrite is non destructive within the algorithm //! warning: <rationalderivates> must be dimensionned properly.

        Parameters
        ----------
        DerivativesRequest: int
        Dimension: int

        Returns
        -------
        PolesDerivatives: float
        WeightsDerivatives: float
        RationalDerivates: float

        """
        return _PLib.plib_RationalDerivatives(*args)

    RationalDerivatives = staticmethod(RationalDerivatives)

    def SetPoles(*args) -> "void":
        """
        Copy in fp the coordinates of the poles.

        Parameters
        ----------
        Poles: TColgp_Array1OfPnt
        FP: TColStd_Array1OfReal

        Returns
        -------
        None

        Copy in fp the coordinates of the poles.

        Parameters
        ----------
        Poles: TColgp_Array1OfPnt
        Weights: TColStd_Array1OfReal
        FP: TColStd_Array1OfReal

        Returns
        -------
        None

        Copy in fp the coordinates of the poles.

        Parameters
        ----------
        Poles: TColgp_Array1OfPnt2d
        FP: TColStd_Array1OfReal

        Returns
        -------
        None

        Copy in fp the coordinates of the poles.

        Parameters
        ----------
        Poles: TColgp_Array1OfPnt2d
        Weights: TColStd_Array1OfReal
        FP: TColStd_Array1OfReal

        Returns
        -------
        None

        """
        return _PLib.plib_SetPoles(*args)

    SetPoles = staticmethod(SetPoles)

    def Trimming(*args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        U1: float
        U2: float
        Coeffs: TColgp_Array1OfPnt
        WCoeffs: TColStd_Array1OfReal *

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        U1: float
        U2: float
        Coeffs: TColgp_Array1OfPnt2d
        WCoeffs: TColStd_Array1OfReal *

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        U1: float
        U2: float
        Coeffs: TColStd_Array1OfReal
        WCoeffs: TColStd_Array1OfReal *

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        U1: float
        U2: float
        dim: int
        Coeffs: TColStd_Array1OfReal
        WCoeffs: TColStd_Array1OfReal *

        Returns
        -------
        None

        """
        return _PLib.plib_Trimming(*args)

    Trimming = staticmethod(Trimming)

    def UTrimming(*args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        U1: float
        U2: float
        Coeffs: TColgp_Array2OfPnt
        WCoeffs: TColStd_Array2OfReal *

        Returns
        -------
        None

        """
        return _PLib.plib_UTrimming(*args)

    UTrimming = staticmethod(UTrimming)

    def VTrimming(*args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        V1: float
        V2: float
        Coeffs: TColgp_Array2OfPnt
        WCoeffs: TColStd_Array2OfReal *

        Returns
        -------
        None

        """
        return _PLib.plib_VTrimming(*args)

    VTrimming = staticmethod(VTrimming)

    __repr__ = _dumps_object


    def __init__(self):
        this = _PLib.new_plib()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _PLib.delete_plib
    __del__ = lambda self: None
plib_swigregister = _PLib.plib_swigregister
plib_swigregister(plib)

def plib_Bin(*args) -> "Standard_Real":
    """
    Returns the binomial cnp. n should be <= bsplclib::maxdegree().

    Parameters
    ----------
    N: int
    P: int

    Returns
    -------
    float

    """
    return _PLib.plib_Bin(*args)

def plib_CoefficientsPoles(*args) -> "void":
    """
    No available documentation.

    Parameters
    ----------
    Coefs: TColgp_Array1OfPnt
    WCoefs: TColStd_Array1OfReal *
    Poles: TColgp_Array1OfPnt
    WPoles: TColStd_Array1OfReal *

    Returns
    -------
    None

    No available documentation.

    Parameters
    ----------
    Coefs: TColgp_Array1OfPnt2d
    WCoefs: TColStd_Array1OfReal *
    Poles: TColgp_Array1OfPnt2d
    WPoles: TColStd_Array1OfReal *

    Returns
    -------
    None

    No available documentation.

    Parameters
    ----------
    Coefs: TColStd_Array1OfReal
    WCoefs: TColStd_Array1OfReal *
    Poles: TColStd_Array1OfReal
    WPoles: TColStd_Array1OfReal *

    Returns
    -------
    None

    No available documentation.

    Parameters
    ----------
    dim: int
    Coefs: TColStd_Array1OfReal
    WCoefs: TColStd_Array1OfReal *
    Poles: TColStd_Array1OfReal
    WPoles: TColStd_Array1OfReal *

    Returns
    -------
    None

    No available documentation.

    Parameters
    ----------
    Coefs: TColgp_Array2OfPnt
    WCoefs: TColStd_Array2OfReal *
    Poles: TColgp_Array2OfPnt
    WPoles: TColStd_Array2OfReal *

    Returns
    -------
    None

    """
    return _PLib.plib_CoefficientsPoles(*args)

def plib_ConstraintOrder(*args) -> "GeomAbs_Shape":
    """
    Translates from integer to geomabs_shape.

    Parameters
    ----------
    NivConstr: int

    Returns
    -------
    GeomAbs_Shape

    """
    return _PLib.plib_ConstraintOrder(*args)

def plib_EvalCubicHermite(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &, Standard_Real &":
    """
    Performs the cubic hermite interpolation of given series of points with given parameters with the requested derivative order. valuearray stores the value at the first and last parameter. it has the following format : [0], [dimension-1]  : value at first param [dimension], [dimension + dimension-1] : value at last param derivative array stores the value of the derivatives at the first parameter and at the last parameter in the following format [0], [dimension-1]  : derivative at first param [dimension], [dimension + dimension-1] : derivative at last param //! parameterarray stores the first and last parameter in the following format : [0] : first parameter [1] : last parameter //! results will store things in the following format with d = derivativeorder //! [0], [dimension-1]  : value [dimension], [dimension + dimension-1] : first derivative //! [d *dimension], [d*dimension + dimension-1]: dth derivative.

    Parameters
    ----------
    U: float
    DerivativeOrder: int
    Dimension: int

    Returns
    -------
    ValueArray: float
    DerivativeArray: float
    ParameterArray: float
    Results: float

    """
    return _PLib.plib_EvalCubicHermite(*args)

def plib_EvalLagrange(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
    """
    Performs the lagrange interpolation of given series of points with given parameters with the requested derivative order results will store things in the following format with d = derivativeorder //! [0], [dimension-1]  : value [dimension], [dimension + dimension-1] : first derivative //! [d *dimension], [d*dimension + dimension-1]: dth derivative.

    Parameters
    ----------
    U: float
    DerivativeOrder: int
    Degree: int
    Dimension: int

    Returns
    -------
    ValueArray: float
    ParameterArray: float
    Results: float

    """
    return _PLib.plib_EvalLagrange(*args)

def plib_EvalLength(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
    """
    No available documentation.

    Parameters
    ----------
    Degree: int
    Dimension: int
    U1: float
    U2: float

    Returns
    -------
    PolynomialCoeff: float
    Length: float

    No available documentation.

    Parameters
    ----------
    Degree: int
    Dimension: int
    U1: float
    U2: float
    Tol: float

    Returns
    -------
    PolynomialCoeff: float
    Length: float
    Error: float

    """
    return _PLib.plib_EvalLength(*args)

def plib_EvalPoly2Var(*args) -> "Standard_Real &, Standard_Real &":
    """
    Applies evalpolynomial twice to evaluate the derivative of orders uderivativeorder in u, vderivativeorder in v at parameters u,v //! polynomialcoeff are stored in the following fashion c00(1) .... c00(dimension) c10(1) .... c10(dimension) .... cm0(1) .... cm0(dimension) .... c01(1) .... c01(dimension) c11(1) .... c11(dimension) .... cm1(1) .... cm1(dimension) .... c0n(1) .... c0n(dimension) c1n(1) .... c1n(dimension) .... cmn(1) .... cmn(dimension) //! where the polynomial is defined as : 2  m c00 + c10 u + c20 u + .... + cm0 u 2  m + c01 v + c11 uv + c21 u v + .... + cm1 u v n m n + .... + c0n v + .... + cmn u v //! with m = udegree and n = vdegree //! results stores the result in the following format //! f(1) f(2) .... f(dimension) //! warning: <results> and <polynomialcoeff> must be dimensioned properly.

    Parameters
    ----------
    U: float
    V: float
    UDerivativeOrder: int
    VDerivativeOrder: int
    UDegree: int
    VDegree: int
    Dimension: int

    Returns
    -------
    PolynomialCoeff: float
    Results: float

    """
    return _PLib.plib_EvalPoly2Var(*args)

def plib_EvalPolynomial(*args) -> "Standard_Real &, Standard_Real &":
    """
    Performs horner method with synthethic division for derivatives parameter <u>, with <degree> and <dimension>. polynomialcoeff are stored in the following fashion c0(1) c0(2) .... c0(dimension) c1(1) c1(2) .... c1(dimension) //! cdegree(1) cdegree(2) .... cdegree(dimension) where the polynomial is defined as : //! 2 degree c0 + c1 x + c2 x + .... cdegree x //! results stores the result in the following format //! f(1) f(2) .... f(dimension) (1)  (1)  (1) f (1) f (2) .... f (dimension) //! (derivativerequest) (derivativerequest) f (1)  f (dimension) //! this just evaluates the point at parameter u //! warning: <results> and <polynomialcoeff> must be dimensioned properly.

    Parameters
    ----------
    U: float
    DerivativeOrder: int
    Degree: int
    Dimension: int

    Returns
    -------
    PolynomialCoeff: float
    Results: float

    """
    return _PLib.plib_EvalPolynomial(*args)

def plib_GetPoles(*args) -> "void":
    """
    Get from fp the coordinates of the poles.

    Parameters
    ----------
    FP: TColStd_Array1OfReal
    Poles: TColgp_Array1OfPnt

    Returns
    -------
    None

    Get from fp the coordinates of the poles.

    Parameters
    ----------
    FP: TColStd_Array1OfReal
    Poles: TColgp_Array1OfPnt
    Weights: TColStd_Array1OfReal

    Returns
    -------
    None

    Get from fp the coordinates of the poles.

    Parameters
    ----------
    FP: TColStd_Array1OfReal
    Poles: TColgp_Array1OfPnt2d

    Returns
    -------
    None

    Get from fp the coordinates of the poles.

    Parameters
    ----------
    FP: TColStd_Array1OfReal
    Poles: TColgp_Array1OfPnt2d
    Weights: TColStd_Array1OfReal

    Returns
    -------
    None

    """
    return _PLib.plib_GetPoles(*args)

def plib_HermiteCoefficients(*args) -> "Standard_Boolean":
    """
    This build the coefficient of hermite's polynomes on [firstparameter, lastparameter] //! if j <= firstorder+1 then //! matrixcoefs[i, j] = ith coefficient of the polynome h0,j-1 //! else //! matrixcoefs[i, j] = ith coefficient of the polynome h1,k with k = j - firstorder - 2 //! return false if - |firstparameter| > 100 - |lastparameter| > 100 - |firstparameter| +|lastparameter| < 1/100 - |lastparameter - firstparameter| / (|firstparameter| +|lastparameter|) < 1/100.

    Parameters
    ----------
    FirstParameter: float
    LastParameter: float
    FirstOrder: int
    LastOrder: int
    MatrixCoefs: math_Matrix

    Returns
    -------
    bool

    """
    return _PLib.plib_HermiteCoefficients(*args)

def plib_HermiteInterpolate(*args) -> "Standard_Boolean":
    """
    Compute the coefficients in the canonical base of the polynomial satisfying the given constraints at the given parameters the array firstcontr(i,j) i=1,dimension j=0,firstorder contains the values of the constraint at parameter firstparameter idem for lastconstr.

    Parameters
    ----------
    Dimension: int
    FirstParameter: float
    LastParameter: float
    FirstOrder: int
    LastOrder: int
    FirstConstr: TColStd_Array2OfReal
    LastConstr: TColStd_Array2OfReal
    Coefficients: TColStd_Array1OfReal

    Returns
    -------
    bool

    """
    return _PLib.plib_HermiteInterpolate(*args)

def plib_JacobiParameters(*args) -> "Standard_Integer &, Standard_Integer &":
    """
    Compute the number of points used for integral computations (nbgausspoints) and the degree of jacobi polynomial (workdegree). constraintorder has to be geomabs_c0, geomabs_c1 or geomabs_c2 code: code d' init. des parametres de discretisation. = -5 = -4 = -3 = -2 = -1 = 1 calcul rapide avec precision moyenne. = 2 calcul rapide avec meilleure precision. = 3 calcul un peu plus lent avec bonne precision. = 4 calcul lent avec la meilleure precision possible.

    Parameters
    ----------
    ConstraintOrder: GeomAbs_Shape
    MaxDegree: int
    Code: int

    Returns
    -------
    NbGaussPoints: int
    WorkDegree: int

    """
    return _PLib.plib_JacobiParameters(*args)

def plib_NivConstr(*args) -> "Standard_Integer":
    """
    Translates from geomabs_shape to integer.

    Parameters
    ----------
    ConstraintOrder: GeomAbs_Shape

    Returns
    -------
    int

    """
    return _PLib.plib_NivConstr(*args)

def plib_NoDerivativeEvalPolynomial(*args) -> "Standard_Real &, Standard_Real &":
    """
    Same as above with derivativeorder = 0;.

    Parameters
    ----------
    U: float
    Degree: int
    Dimension: int
    DegreeDimension: int

    Returns
    -------
    PolynomialCoeff: float
    Results: float

    """
    return _PLib.plib_NoDerivativeEvalPolynomial(*args)

def plib_NoWeights(*args) -> "TColStd_Array1OfReal *":
    """
    Used as argument for a non rational functions.

    Returns
    -------
    TColStd_Array1OfReal *

    """
    return _PLib.plib_NoWeights(*args)

def plib_NoWeights2(*args) -> "TColStd_Array2OfReal *":
    """
    Used as argument for a non rational functions.

    Returns
    -------
    TColStd_Array2OfReal *

    """
    return _PLib.plib_NoWeights2(*args)

def plib_RationalDerivative(*args) -> "Standard_Real &, Standard_Real &":
    """
    Computes the derivatives of a ratio at order <n> in dimension <dimension>. //! <ders> is an array containing the values of the input derivatives from 0 to min(<n>,<degree>). for orders higher than <degree> the inputcd /s2d1/bmdl/ derivatives are assumed to be 0. //! content of <ders> : //! x(1),x(2),...,x(dimension),w x'(1),x'(2),...,x'(dimension),w' x''(1),x''(2),...,x''(dimension),w'' //! if <all> is false, only the derivative at order <n> is computed. <rders> is an array of length dimension which will contain the result : //! x(1)/w , x(2)/w , ... derivated <n> times //! if <all> is true all the derivatives up to order <n> are computed. <rders> is an array of length dimension * (n+1) which will contains : //! x(1)/w , x(2)/w , ... x(1)/w , x(2)/w , ... derivated <1> times x(1)/w , x(2)/w , ... derivated <2> times ... x(1)/w , x(2)/w , ... derivated <n> times //! warning: <rders> must be dimensionned properly.

    Parameters
    ----------
    Degree: int
    N: int
    Dimension: int
    All: bool,optional
    	default value is Standard_True

    Returns
    -------
    Ders: float
    RDers: float

    """
    return _PLib.plib_RationalDerivative(*args)

def plib_RationalDerivatives(*args) -> "Standard_Real &, Standard_Real &, Standard_Real &":
    """
    Computes derivativesrequest derivatives of a ratio at of a bspline function of degree <degree> dimension <dimension>. //! <polesderivatives> is an array containing the values of the input derivatives from 0 to <derivativerequest> for orders higher than <degree> the input derivatives are assumed to be 0. //! content of <poleasderivatives> : //! x(1),x(2),...,x(dimension) x'(1),x'(2),...,x'(dimension) x''(1),x''(2),...,x''(dimension) //! weightsderivatives is an array that contains derivatives from 0 to <derivativerequest> after returning from the routine the array rationalderivatives contains the following x(1)/w , x(2)/w , ... x(1)/w , x(2)/w , ... derivated once x(1)/w , x(2)/w , ... twice x(1)/w , x(2)/w , ... derivated <derivativerequest> times //! the array rationalderivatives and polesderivatives can be same since the overwrite is non destructive within the algorithm //! warning: <rationalderivates> must be dimensionned properly.

    Parameters
    ----------
    DerivativesRequest: int
    Dimension: int

    Returns
    -------
    PolesDerivatives: float
    WeightsDerivatives: float
    RationalDerivates: float

    """
    return _PLib.plib_RationalDerivatives(*args)

def plib_SetPoles(*args) -> "void":
    """
    Copy in fp the coordinates of the poles.

    Parameters
    ----------
    Poles: TColgp_Array1OfPnt
    FP: TColStd_Array1OfReal

    Returns
    -------
    None

    Copy in fp the coordinates of the poles.

    Parameters
    ----------
    Poles: TColgp_Array1OfPnt
    Weights: TColStd_Array1OfReal
    FP: TColStd_Array1OfReal

    Returns
    -------
    None

    Copy in fp the coordinates of the poles.

    Parameters
    ----------
    Poles: TColgp_Array1OfPnt2d
    FP: TColStd_Array1OfReal

    Returns
    -------
    None

    Copy in fp the coordinates of the poles.

    Parameters
    ----------
    Poles: TColgp_Array1OfPnt2d
    Weights: TColStd_Array1OfReal
    FP: TColStd_Array1OfReal

    Returns
    -------
    None

    """
    return _PLib.plib_SetPoles(*args)

def plib_Trimming(*args) -> "void":
    """
    No available documentation.

    Parameters
    ----------
    U1: float
    U2: float
    Coeffs: TColgp_Array1OfPnt
    WCoeffs: TColStd_Array1OfReal *

    Returns
    -------
    None

    No available documentation.

    Parameters
    ----------
    U1: float
    U2: float
    Coeffs: TColgp_Array1OfPnt2d
    WCoeffs: TColStd_Array1OfReal *

    Returns
    -------
    None

    No available documentation.

    Parameters
    ----------
    U1: float
    U2: float
    Coeffs: TColStd_Array1OfReal
    WCoeffs: TColStd_Array1OfReal *

    Returns
    -------
    None

    No available documentation.

    Parameters
    ----------
    U1: float
    U2: float
    dim: int
    Coeffs: TColStd_Array1OfReal
    WCoeffs: TColStd_Array1OfReal *

    Returns
    -------
    None

    """
    return _PLib.plib_Trimming(*args)

def plib_UTrimming(*args) -> "void":
    """
    No available documentation.

    Parameters
    ----------
    U1: float
    U2: float
    Coeffs: TColgp_Array2OfPnt
    WCoeffs: TColStd_Array2OfReal *

    Returns
    -------
    None

    """
    return _PLib.plib_UTrimming(*args)

def plib_VTrimming(*args) -> "void":
    """
    No available documentation.

    Parameters
    ----------
    V1: float
    V2: float
    Coeffs: TColgp_Array2OfPnt
    WCoeffs: TColStd_Array2OfReal *

    Returns
    -------
    None

    """
    return _PLib.plib_VTrimming(*args)

class PLib_Base(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PLib_Base, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PLib_Base, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def D0(self, *args) -> "void":
        """
        Compute the values of the basis functions in u.

        Parameters
        ----------
        U: float
        BasisValue: TColStd_Array1OfReal

        Returns
        -------
        None

        """
        return _PLib.PLib_Base_D0(self, *args)


    def D1(self, *args) -> "void":
        """
        Compute the values and the derivatives values of the basis functions in u.

        Parameters
        ----------
        U: float
        BasisValue: TColStd_Array1OfReal
        BasisD1: TColStd_Array1OfReal

        Returns
        -------
        None

        """
        return _PLib.PLib_Base_D1(self, *args)


    def D2(self, *args) -> "void":
        """
        Compute the values and the derivatives values of the basis functions in u.

        Parameters
        ----------
        U: float
        BasisValue: TColStd_Array1OfReal
        BasisD1: TColStd_Array1OfReal
        BasisD2: TColStd_Array1OfReal

        Returns
        -------
        None

        """
        return _PLib.PLib_Base_D2(self, *args)


    def D3(self, *args) -> "void":
        """
        Compute the values and the derivatives values of the basis functions in u.

        Parameters
        ----------
        U: float
        BasisValue: TColStd_Array1OfReal
        BasisD1: TColStd_Array1OfReal
        BasisD2: TColStd_Array1OfReal
        BasisD3: TColStd_Array1OfReal

        Returns
        -------
        None

        """
        return _PLib.PLib_Base_D3(self, *args)


    def ReduceDegree(self, *args) -> "void":
        """
        Compute newdegree <= maxdegree so that maxerror is lower than tol. maxerror can be greater than tol if it is not possible to find a newdegree <= maxdegree. in this case newdegree = maxdegree.

        Parameters
        ----------
        Dimension: int
        MaxDegree: int
        Tol: float

        Returns
        -------
        BaseCoeff: float
        NewDegree: int
        MaxError: float

        """
        return _PLib.PLib_Base_ReduceDegree(self, *args)


    def ToCoefficients(self, *args) -> "void":
        """
        Convert the polynomial p(t) in the canonical base.

        Parameters
        ----------
        Dimension: int
        Degree: int
        CoeffinBase: TColStd_Array1OfReal
        Coefficients: TColStd_Array1OfReal

        Returns
        -------
        None

        """
        return _PLib.PLib_Base_ToCoefficients(self, *args)


    def WorkDegree(self, *args) -> "Standard_Integer":
        """
        Returns workdegree.

        Returns
        -------
        int

        """
        return _PLib.PLib_Base_WorkDegree(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_PLib_Base_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _PLib.delete_PLib_Base
    __del__ = lambda self: None
PLib_Base_swigregister = _PLib.PLib_Base_swigregister
PLib_Base_swigregister(PLib_Base)

class PLib_DoubleJacobiPolynomial(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PLib_DoubleJacobiPolynomial, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PLib_DoubleJacobiPolynomial, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        JacPolU: PLib_JacobiPolynomial
        JacPolV: PLib_JacobiPolynomial

        Returns
        -------
        None

        """
        this = _PLib.new_PLib_DoubleJacobiPolynomial(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AverageError(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Parameters
        ----------
        Dimension: int
        DegreeU: int
        DegreeV: int
        dJacCoeff: int
        JacCoeff: TColStd_Array1OfReal

        Returns
        -------
        float

        """
        return _PLib.PLib_DoubleJacobiPolynomial_AverageError(self, *args)


    def MaxError(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Parameters
        ----------
        Dimension: int
        MinDegreeU: int
        MaxDegreeU: int
        MinDegreeV: int
        MaxDegreeV: int
        dJacCoeff: int
        JacCoeff: TColStd_Array1OfReal
        Error: float

        Returns
        -------
        float

        """
        return _PLib.PLib_DoubleJacobiPolynomial_MaxError(self, *args)


    def MaxErrorU(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Parameters
        ----------
        Dimension: int
        DegreeU: int
        DegreeV: int
        dJacCoeff: int
        JacCoeff: TColStd_Array1OfReal

        Returns
        -------
        float

        """
        return _PLib.PLib_DoubleJacobiPolynomial_MaxErrorU(self, *args)


    def MaxErrorV(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Parameters
        ----------
        Dimension: int
        DegreeU: int
        DegreeV: int
        dJacCoeff: int
        JacCoeff: TColStd_Array1OfReal

        Returns
        -------
        float

        """
        return _PLib.PLib_DoubleJacobiPolynomial_MaxErrorV(self, *args)


    def ReduceDegree(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        Dimension: int
        MinDegreeU: int
        MaxDegreeU: int
        MinDegreeV: int
        MaxDegreeV: int
        dJacCoeff: int
        JacCoeff: TColStd_Array1OfReal
        EpmsCut: float

        Returns
        -------
        MaxError: float
        NewDegreeU: int
        NewDegreeV: int

        """
        return _PLib.PLib_DoubleJacobiPolynomial_ReduceDegree(self, *args)


    def TabMaxU(self, *args) -> "opencascade::handle< TColStd_HArray1OfReal >":
        """
        Returns mytabmaxu;.

        Returns
        -------
        opencascade::handle<TColStd_HArray1OfReal>

        """
        return _PLib.PLib_DoubleJacobiPolynomial_TabMaxU(self, *args)


    def TabMaxV(self, *args) -> "opencascade::handle< TColStd_HArray1OfReal >":
        """
        Returns mytabmaxv;.

        Returns
        -------
        opencascade::handle<TColStd_HArray1OfReal>

        """
        return _PLib.PLib_DoubleJacobiPolynomial_TabMaxV(self, *args)


    def U(self, *args) -> "opencascade::handle< PLib_JacobiPolynomial >":
        """
        Returns myjacpolu;.

        Returns
        -------
        opencascade::handle<PLib_JacobiPolynomial>

        """
        return _PLib.PLib_DoubleJacobiPolynomial_U(self, *args)


    def V(self, *args) -> "opencascade::handle< PLib_JacobiPolynomial >":
        """
        Returns myjacpolv;.

        Returns
        -------
        opencascade::handle<PLib_JacobiPolynomial>

        """
        return _PLib.PLib_DoubleJacobiPolynomial_V(self, *args)


    def WDoubleJacobiToCoefficients(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        Dimension: int
        DegreeU: int
        DegreeV: int
        JacCoeff: TColStd_Array1OfReal
        Coefficients: TColStd_Array1OfReal

        Returns
        -------
        None

        """
        return _PLib.PLib_DoubleJacobiPolynomial_WDoubleJacobiToCoefficients(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _PLib.delete_PLib_DoubleJacobiPolynomial
    __del__ = lambda self: None
PLib_DoubleJacobiPolynomial_swigregister = _PLib.PLib_DoubleJacobiPolynomial_swigregister
PLib_DoubleJacobiPolynomial_swigregister(PLib_DoubleJacobiPolynomial)

class PLib_HermitJacobi(PLib_Base):
    __swig_setmethods__ = {}
    for _s in [PLib_Base]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PLib_HermitJacobi, name, value)
    __swig_getmethods__ = {}
    for _s in [PLib_Base]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PLib_HermitJacobi, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Initialize the polynomial class degree has to be <= 30 constraintorder has to be geomabs_c0 geomabs_c1 geomabs_c2.

        Parameters
        ----------
        WorkDegree: int
        ConstraintOrder: GeomAbs_Shape

        Returns
        -------
        None

        """
        this = _PLib.new_PLib_HermitJacobi(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AverageError(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Parameters
        ----------
        Dimension: int
        NewDegree: int

        Returns
        -------
        HermJacCoeff: float

        """
        return _PLib.PLib_HermitJacobi_AverageError(self, *args)


    def MaxError(self, *args) -> "Standard_Real":
        """
        This method computes the maximum error on the polynomial w(t) q(t) obtained by missing the coefficients of jaccoeff from newdegree +1 to degree.

        Parameters
        ----------
        Dimension: int
        NewDegree: int

        Returns
        -------
        HermJacCoeff: float

        """
        return _PLib.PLib_HermitJacobi_MaxError(self, *args)


    def NivConstr(self, *args) -> "Standard_Integer":
        """
        Returns nivconstr.

        Returns
        -------
        int

        """
        return _PLib.PLib_HermitJacobi_NivConstr(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_PLib_HermitJacobi_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _PLib.delete_PLib_HermitJacobi
    __del__ = lambda self: None
PLib_HermitJacobi_swigregister = _PLib.PLib_HermitJacobi_swigregister
PLib_HermitJacobi_swigregister(PLib_HermitJacobi)

class PLib_JacobiPolynomial(PLib_Base):
    __swig_setmethods__ = {}
    for _s in [PLib_Base]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PLib_JacobiPolynomial, name, value)
    __swig_getmethods__ = {}
    for _s in [PLib_Base]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PLib_JacobiPolynomial, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Initialize the polynomial class degree has to be <= 30 constraintorder has to be geomabs_c0 geomabs_c1 geomabs_c2.

        Parameters
        ----------
        WorkDegree: int
        ConstraintOrder: GeomAbs_Shape

        Returns
        -------
        None

        """
        this = _PLib.new_PLib_JacobiPolynomial(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AverageError(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Parameters
        ----------
        Dimension: int
        NewDegree: int

        Returns
        -------
        JacCoeff: float

        """
        return _PLib.PLib_JacobiPolynomial_AverageError(self, *args)


    def MaxError(self, *args) -> "Standard_Real":
        """
        This method computes the maximum error on the polynomial w(t) q(t) obtained by missing the coefficients of jaccoeff from newdegree +1 to degree.

        Parameters
        ----------
        Dimension: int
        NewDegree: int

        Returns
        -------
        JacCoeff: float

        """
        return _PLib.PLib_JacobiPolynomial_MaxError(self, *args)


    def MaxValue(self, *args) -> "void":
        """
        This method loads for k=0,q the maximum value of abs ( w(t)*jk(t) )for t bellonging to [-1,1] this values are loaded is the array tabmax(0,myworkdegree-2*(mynivconst+1)) maxvalue ( me ; tabmaxpointer : in out real );.

        Parameters
        ----------
        TabMax: TColStd_Array1OfReal

        Returns
        -------
        None

        """
        return _PLib.PLib_JacobiPolynomial_MaxValue(self, *args)


    def NivConstr(self, *args) -> "Standard_Integer":
        """
        Returns nivconstr.

        Returns
        -------
        int

        """
        return _PLib.PLib_JacobiPolynomial_NivConstr(self, *args)


    def Points(self, *args) -> "void":
        """
        Returns the jacobi points for gauss integration ie the positive values of the legendre roots by increasing values nbgausspoints is the number of points choosen for the integral computation. tabpoints (0,nbgausspoints/2) tabpoints (0) is loaded only for the odd values of nbgausspoints the possible values for nbgausspoints are : 8, 10, 15, 20, 25, 30, 35, 40, 50, 61 nbgausspoints must be greater than degree.

        Parameters
        ----------
        NbGaussPoints: int
        TabPoints: TColStd_Array1OfReal

        Returns
        -------
        None

        """
        return _PLib.PLib_JacobiPolynomial_Points(self, *args)


    def Weights(self, *args) -> "void":
        """
        Returns the jacobi weigths for gauss integration only for the positive values of the legendre roots in the order they are given by the method points nbgausspoints is the number of points choosen for the integral computation. tabweights (0,nbgausspoints/2,0,degree) tabweights (0,.) are only loaded for the odd values of nbgausspoints the possible values for nbgausspoints are : 8 , 10 , 15 ,20 ,25 , 30, 35 , 40 , 50 , 61 nbgausspoints must be greater than degree.

        Parameters
        ----------
        NbGaussPoints: int
        TabWeights: TColStd_Array2OfReal

        Returns
        -------
        None

        """
        return _PLib.PLib_JacobiPolynomial_Weights(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_PLib_JacobiPolynomial_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _PLib.delete_PLib_JacobiPolynomial
    __del__ = lambda self: None
PLib_JacobiPolynomial_swigregister = _PLib.PLib_JacobiPolynomial_swigregister
PLib_JacobiPolynomial_swigregister(PLib_JacobiPolynomial)



# This file is compatible with both classic and new-style classes.


