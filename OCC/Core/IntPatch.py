# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
IntPatch module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_intpatch.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IntPatch')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IntPatch')
    _IntPatch = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IntPatch', [dirname(__file__)])
        except ImportError:
            import _IntPatch
            return _IntPatch
        try:
            _mod = imp.load_module('_IntPatch', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IntPatch = swig_import_helper()
    del swig_import_helper
else:
    import _IntPatch
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IntPatch.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _IntPatch.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _IntPatch.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _IntPatch.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _IntPatch.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _IntPatch.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _IntPatch.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _IntPatch.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _IntPatch.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _IntPatch.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _IntPatch.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _IntPatch.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _IntPatch.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _IntPatch.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _IntPatch.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _IntPatch.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _IntPatch.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _IntPatch.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _IntPatch.process_exception(error, method_name, class_name)
process_exception = _IntPatch.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.Intf
import OCC.Core.gp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.Bnd
import OCC.Core.TColgp
import OCC.Core.BVH
import OCC.Core.Adaptor3d
import OCC.Core.Geom
import OCC.Core.GeomAbs
import OCC.Core.TopAbs
import OCC.Core.Adaptor2d
import OCC.Core.Geom2d
import OCC.Core.math
import OCC.Core.Message
import OCC.Core.OSD
import OCC.Core.IntSurf
import OCC.Core.IntAna

from enum import IntEnum
from OCC.Core.Exception import *

IntPatch_SPntNone = _IntPatch.IntPatch_SPntNone
IntPatch_SPntSeamU = _IntPatch.IntPatch_SPntSeamU
IntPatch_SPntSeamV = _IntPatch.IntPatch_SPntSeamV
IntPatch_SPntSeamUV = _IntPatch.IntPatch_SPntSeamUV
IntPatch_SPntPoleSeamU = _IntPatch.IntPatch_SPntPoleSeamU
IntPatch_SPntPole = _IntPatch.IntPatch_SPntPole
IntPatch_Lin = _IntPatch.IntPatch_Lin
IntPatch_Circle = _IntPatch.IntPatch_Circle
IntPatch_Ellipse = _IntPatch.IntPatch_Ellipse
IntPatch_Parabola = _IntPatch.IntPatch_Parabola
IntPatch_Hyperbola = _IntPatch.IntPatch_Hyperbola
IntPatch_Analytic = _IntPatch.IntPatch_Analytic
IntPatch_Walking = _IntPatch.IntPatch_Walking
IntPatch_Restriction = _IntPatch.IntPatch_Restriction


class IntPatch_SpecPntType(IntEnum):
	IntPatch_SPntNone = 0
	IntPatch_SPntSeamU = 1
	IntPatch_SPntSeamV = 2
	IntPatch_SPntSeamUV = 3
	IntPatch_SPntPoleSeamU = 4
	IntPatch_SPntPole = 5
IntPatch_SPntNone = IntPatch_SpecPntType.IntPatch_SPntNone
IntPatch_SPntSeamU = IntPatch_SpecPntType.IntPatch_SPntSeamU
IntPatch_SPntSeamV = IntPatch_SpecPntType.IntPatch_SPntSeamV
IntPatch_SPntSeamUV = IntPatch_SpecPntType.IntPatch_SPntSeamUV
IntPatch_SPntPoleSeamU = IntPatch_SpecPntType.IntPatch_SPntPoleSeamU
IntPatch_SPntPole = IntPatch_SpecPntType.IntPatch_SPntPole

class IntPatch_IType(IntEnum):
	IntPatch_Lin = 0
	IntPatch_Circle = 1
	IntPatch_Ellipse = 2
	IntPatch_Parabola = 3
	IntPatch_Hyperbola = 4
	IntPatch_Analytic = 5
	IntPatch_Walking = 6
	IntPatch_Restriction = 7
IntPatch_Lin = IntPatch_IType.IntPatch_Lin
IntPatch_Circle = IntPatch_IType.IntPatch_Circle
IntPatch_Ellipse = IntPatch_IType.IntPatch_Ellipse
IntPatch_Parabola = IntPatch_IType.IntPatch_Parabola
IntPatch_Hyperbola = IntPatch_IType.IntPatch_Hyperbola
IntPatch_Analytic = IntPatch_IType.IntPatch_Analytic
IntPatch_Walking = IntPatch_IType.IntPatch_Walking
IntPatch_Restriction = IntPatch_IType.IntPatch_Restriction


def Handle_IntPatch_Line_Create() -> "opencascade::handle< IntPatch_Line >":
    return _IntPatch.Handle_IntPatch_Line_Create()
Handle_IntPatch_Line_Create = _IntPatch.Handle_IntPatch_Line_Create

def Handle_IntPatch_Line_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IntPatch_Line >":
    return _IntPatch.Handle_IntPatch_Line_DownCast(t)
Handle_IntPatch_Line_DownCast = _IntPatch.Handle_IntPatch_Line_DownCast

def Handle_IntPatch_Line_IsNull(t: 'opencascade::handle< IntPatch_Line > const &') -> "bool":
    return _IntPatch.Handle_IntPatch_Line_IsNull(t)
Handle_IntPatch_Line_IsNull = _IntPatch.Handle_IntPatch_Line_IsNull

def Handle_IntPatch_TheIWLineOfTheIWalking_Create() -> "opencascade::handle< IntPatch_TheIWLineOfTheIWalking >":
    return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_Create()
Handle_IntPatch_TheIWLineOfTheIWalking_Create = _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_Create

def Handle_IntPatch_TheIWLineOfTheIWalking_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IntPatch_TheIWLineOfTheIWalking >":
    return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_DownCast(t)
Handle_IntPatch_TheIWLineOfTheIWalking_DownCast = _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_DownCast

def Handle_IntPatch_TheIWLineOfTheIWalking_IsNull(t: 'opencascade::handle< IntPatch_TheIWLineOfTheIWalking > const &') -> "bool":
    return _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_IsNull(t)
Handle_IntPatch_TheIWLineOfTheIWalking_IsNull = _IntPatch.Handle_IntPatch_TheIWLineOfTheIWalking_IsNull

def Handle_IntPatch_ALine_Create() -> "opencascade::handle< IntPatch_ALine >":
    return _IntPatch.Handle_IntPatch_ALine_Create()
Handle_IntPatch_ALine_Create = _IntPatch.Handle_IntPatch_ALine_Create

def Handle_IntPatch_ALine_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IntPatch_ALine >":
    return _IntPatch.Handle_IntPatch_ALine_DownCast(t)
Handle_IntPatch_ALine_DownCast = _IntPatch.Handle_IntPatch_ALine_DownCast

def Handle_IntPatch_ALine_IsNull(t: 'opencascade::handle< IntPatch_ALine > const &') -> "bool":
    return _IntPatch.Handle_IntPatch_ALine_IsNull(t)
Handle_IntPatch_ALine_IsNull = _IntPatch.Handle_IntPatch_ALine_IsNull

def Handle_IntPatch_GLine_Create() -> "opencascade::handle< IntPatch_GLine >":
    return _IntPatch.Handle_IntPatch_GLine_Create()
Handle_IntPatch_GLine_Create = _IntPatch.Handle_IntPatch_GLine_Create

def Handle_IntPatch_GLine_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IntPatch_GLine >":
    return _IntPatch.Handle_IntPatch_GLine_DownCast(t)
Handle_IntPatch_GLine_DownCast = _IntPatch.Handle_IntPatch_GLine_DownCast

def Handle_IntPatch_GLine_IsNull(t: 'opencascade::handle< IntPatch_GLine > const &') -> "bool":
    return _IntPatch.Handle_IntPatch_GLine_IsNull(t)
Handle_IntPatch_GLine_IsNull = _IntPatch.Handle_IntPatch_GLine_IsNull

def Handle_IntPatch_PointLine_Create() -> "opencascade::handle< IntPatch_PointLine >":
    return _IntPatch.Handle_IntPatch_PointLine_Create()
Handle_IntPatch_PointLine_Create = _IntPatch.Handle_IntPatch_PointLine_Create

def Handle_IntPatch_PointLine_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IntPatch_PointLine >":
    return _IntPatch.Handle_IntPatch_PointLine_DownCast(t)
Handle_IntPatch_PointLine_DownCast = _IntPatch.Handle_IntPatch_PointLine_DownCast

def Handle_IntPatch_PointLine_IsNull(t: 'opencascade::handle< IntPatch_PointLine > const &') -> "bool":
    return _IntPatch.Handle_IntPatch_PointLine_IsNull(t)
Handle_IntPatch_PointLine_IsNull = _IntPatch.Handle_IntPatch_PointLine_IsNull

def Handle_IntPatch_RLine_Create() -> "opencascade::handle< IntPatch_RLine >":
    return _IntPatch.Handle_IntPatch_RLine_Create()
Handle_IntPatch_RLine_Create = _IntPatch.Handle_IntPatch_RLine_Create

def Handle_IntPatch_RLine_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IntPatch_RLine >":
    return _IntPatch.Handle_IntPatch_RLine_DownCast(t)
Handle_IntPatch_RLine_DownCast = _IntPatch.Handle_IntPatch_RLine_DownCast

def Handle_IntPatch_RLine_IsNull(t: 'opencascade::handle< IntPatch_RLine > const &') -> "bool":
    return _IntPatch.Handle_IntPatch_RLine_IsNull(t)
Handle_IntPatch_RLine_IsNull = _IntPatch.Handle_IntPatch_RLine_IsNull

def Handle_IntPatch_WLine_Create() -> "opencascade::handle< IntPatch_WLine >":
    return _IntPatch.Handle_IntPatch_WLine_Create()
Handle_IntPatch_WLine_Create = _IntPatch.Handle_IntPatch_WLine_Create

def Handle_IntPatch_WLine_DownCast(t: 'opencascade::handle< Standard_Transient > const &') -> "opencascade::handle< IntPatch_WLine >":
    return _IntPatch.Handle_IntPatch_WLine_DownCast(t)
Handle_IntPatch_WLine_DownCast = _IntPatch.Handle_IntPatch_WLine_DownCast

def Handle_IntPatch_WLine_IsNull(t: 'opencascade::handle< IntPatch_WLine > const &') -> "bool":
    return _IntPatch.Handle_IntPatch_WLine_IsNull(t)
Handle_IntPatch_WLine_IsNull = _IntPatch.Handle_IntPatch_WLine_IsNull
class IntPatch_SequenceOfIWLineOfTheIWalking(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_SequenceOfIWLineOfTheIWalking, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_SequenceOfIWLineOfTheIWalking, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Sequence< opencascade::handle< IntPatch_TheIWLineOfTheIWalking > >::iterator":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_begin(self)

    def end(self) -> "NCollection_Sequence< opencascade::handle< IntPatch_TheIWLineOfTheIWalking > >::iterator":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_end(self)

    def cbegin(self) -> "NCollection_Sequence< opencascade::handle< IntPatch_TheIWLineOfTheIWalking > >::const_iterator":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_cbegin(self)

    def cend(self) -> "NCollection_Sequence< opencascade::handle< IntPatch_TheIWLineOfTheIWalking > >::const_iterator":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_cend(self)

    def __init__(self, *args):
        this = _IntPatch.new_IntPatch_SequenceOfIWLineOfTheIWalking(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self) -> "Standard_Integer":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Size(self)

    def Length(self) -> "Standard_Integer":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Length(self)

    def Lower(self) -> "Standard_Integer":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Upper(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_IsEmpty(self)

    def Reverse(self) -> "void":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Reverse(self)

    def Exchange(self, I: 'Standard_Integer const', J: 'Standard_Integer const') -> "void":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Exchange(self, I, J)
    if _newclass:
        delNode = staticmethod(_IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_delNode)
    else:
        delNode = _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_delNode

    def Clear(self, theAllocator: 'IntSurf_Allocator'=0) -> "void":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Clear(self, theAllocator)

    def Assign(self, theOther: 'IntPatch_SequenceOfIWLineOfTheIWalking') -> "NCollection_Sequence< opencascade::handle< IntPatch_TheIWLineOfTheIWalking > > &":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Assign(self, theOther)

    def Set(self, theOther: 'IntPatch_SequenceOfIWLineOfTheIWalking') -> "NCollection_Sequence< opencascade::handle< IntPatch_TheIWLineOfTheIWalking > > &":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Set(self, theOther)

    def Remove(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Remove(self, *args)

    def Append(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Append(self, *args)

    def Prepend(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Prepend(self, *args)

    def InsertBefore(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_InsertBefore(self, *args)

    def InsertAfter(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_InsertAfter(self, *args)

    def Split(self, theIndex: 'Standard_Integer const', theSeq: 'IntPatch_SequenceOfIWLineOfTheIWalking') -> "void":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Split(self, theIndex, theSeq)

    def First(self) -> "opencascade::handle< IntPatch_TheIWLineOfTheIWalking > const &":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_First(self)

    def ChangeFirst(self) -> "opencascade::handle< IntPatch_TheIWLineOfTheIWalking > &":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_ChangeFirst(self)

    def Last(self) -> "opencascade::handle< IntPatch_TheIWLineOfTheIWalking > const &":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Last(self)

    def ChangeLast(self) -> "opencascade::handle< IntPatch_TheIWLineOfTheIWalking > &":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< IntPatch_TheIWLineOfTheIWalking > const &":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< IntPatch_TheIWLineOfTheIWalking > &":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "opencascade::handle< IntPatch_TheIWLineOfTheIWalking > &":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'opencascade::handle< IntPatch_TheIWLineOfTheIWalking > const &') -> "void":
        return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_SetValue(self, theIndex, theItem)
    __swig_destroy__ = _IntPatch.delete_IntPatch_SequenceOfIWLineOfTheIWalking
    __del__ = lambda self: None

    def __len__(self):
        return self.Size()

IntPatch_SequenceOfIWLineOfTheIWalking_swigregister = _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_swigregister
IntPatch_SequenceOfIWLineOfTheIWalking_swigregister(IntPatch_SequenceOfIWLineOfTheIWalking)

def IntPatch_SequenceOfIWLineOfTheIWalking_delNode(theNode: 'NCollection_SeqNode *', theAl: 'IntSurf_Allocator') -> "void":
    return _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_delNode(theNode, theAl)
IntPatch_SequenceOfIWLineOfTheIWalking_delNode = _IntPatch.IntPatch_SequenceOfIWLineOfTheIWalking_delNode

class IntPatch_SequenceOfLine(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_SequenceOfLine, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_SequenceOfLine, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Sequence< opencascade::handle< IntPatch_Line > >::iterator":
        return _IntPatch.IntPatch_SequenceOfLine_begin(self)

    def end(self) -> "NCollection_Sequence< opencascade::handle< IntPatch_Line > >::iterator":
        return _IntPatch.IntPatch_SequenceOfLine_end(self)

    def cbegin(self) -> "NCollection_Sequence< opencascade::handle< IntPatch_Line > >::const_iterator":
        return _IntPatch.IntPatch_SequenceOfLine_cbegin(self)

    def cend(self) -> "NCollection_Sequence< opencascade::handle< IntPatch_Line > >::const_iterator":
        return _IntPatch.IntPatch_SequenceOfLine_cend(self)

    def __init__(self, *args):
        this = _IntPatch.new_IntPatch_SequenceOfLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self) -> "Standard_Integer":
        return _IntPatch.IntPatch_SequenceOfLine_Size(self)

    def Length(self) -> "Standard_Integer":
        return _IntPatch.IntPatch_SequenceOfLine_Length(self)

    def Lower(self) -> "Standard_Integer":
        return _IntPatch.IntPatch_SequenceOfLine_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _IntPatch.IntPatch_SequenceOfLine_Upper(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _IntPatch.IntPatch_SequenceOfLine_IsEmpty(self)

    def Reverse(self) -> "void":
        return _IntPatch.IntPatch_SequenceOfLine_Reverse(self)

    def Exchange(self, I: 'Standard_Integer const', J: 'Standard_Integer const') -> "void":
        return _IntPatch.IntPatch_SequenceOfLine_Exchange(self, I, J)
    if _newclass:
        delNode = staticmethod(_IntPatch.IntPatch_SequenceOfLine_delNode)
    else:
        delNode = _IntPatch.IntPatch_SequenceOfLine_delNode

    def Clear(self, theAllocator: 'IntSurf_Allocator'=0) -> "void":
        return _IntPatch.IntPatch_SequenceOfLine_Clear(self, theAllocator)

    def Assign(self, theOther: 'IntPatch_SequenceOfLine') -> "NCollection_Sequence< opencascade::handle< IntPatch_Line > > &":
        return _IntPatch.IntPatch_SequenceOfLine_Assign(self, theOther)

    def Set(self, theOther: 'IntPatch_SequenceOfLine') -> "NCollection_Sequence< opencascade::handle< IntPatch_Line > > &":
        return _IntPatch.IntPatch_SequenceOfLine_Set(self, theOther)

    def Remove(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfLine_Remove(self, *args)

    def Append(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfLine_Append(self, *args)

    def Prepend(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfLine_Prepend(self, *args)

    def InsertBefore(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfLine_InsertBefore(self, *args)

    def InsertAfter(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfLine_InsertAfter(self, *args)

    def Split(self, theIndex: 'Standard_Integer const', theSeq: 'IntPatch_SequenceOfLine') -> "void":
        return _IntPatch.IntPatch_SequenceOfLine_Split(self, theIndex, theSeq)

    def First(self) -> "opencascade::handle< IntPatch_Line > const &":
        return _IntPatch.IntPatch_SequenceOfLine_First(self)

    def ChangeFirst(self) -> "opencascade::handle< IntPatch_Line > &":
        return _IntPatch.IntPatch_SequenceOfLine_ChangeFirst(self)

    def Last(self) -> "opencascade::handle< IntPatch_Line > const &":
        return _IntPatch.IntPatch_SequenceOfLine_Last(self)

    def ChangeLast(self) -> "opencascade::handle< IntPatch_Line > &":
        return _IntPatch.IntPatch_SequenceOfLine_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< IntPatch_Line > const &":
        return _IntPatch.IntPatch_SequenceOfLine_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "opencascade::handle< IntPatch_Line > &":
        return _IntPatch.IntPatch_SequenceOfLine_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "opencascade::handle< IntPatch_Line > &":
        return _IntPatch.IntPatch_SequenceOfLine___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'opencascade::handle< IntPatch_Line > const &') -> "void":
        return _IntPatch.IntPatch_SequenceOfLine_SetValue(self, theIndex, theItem)
    __swig_destroy__ = _IntPatch.delete_IntPatch_SequenceOfLine
    __del__ = lambda self: None

    def __len__(self):
        return self.Size()

IntPatch_SequenceOfLine_swigregister = _IntPatch.IntPatch_SequenceOfLine_swigregister
IntPatch_SequenceOfLine_swigregister(IntPatch_SequenceOfLine)

def IntPatch_SequenceOfLine_delNode(theNode: 'NCollection_SeqNode *', theAl: 'IntSurf_Allocator') -> "void":
    return _IntPatch.IntPatch_SequenceOfLine_delNode(theNode, theAl)
IntPatch_SequenceOfLine_delNode = _IntPatch.IntPatch_SequenceOfLine_delNode

class IntPatch_SequenceOfPathPointOfTheSOnBounds(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_SequenceOfPathPointOfTheSOnBounds, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_SequenceOfPathPointOfTheSOnBounds, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Sequence< IntPatch_ThePathPointOfTheSOnBounds >::iterator":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_begin(self)

    def end(self) -> "NCollection_Sequence< IntPatch_ThePathPointOfTheSOnBounds >::iterator":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_end(self)

    def cbegin(self) -> "NCollection_Sequence< IntPatch_ThePathPointOfTheSOnBounds >::const_iterator":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_cbegin(self)

    def cend(self) -> "NCollection_Sequence< IntPatch_ThePathPointOfTheSOnBounds >::const_iterator":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_cend(self)

    def __init__(self, *args):
        this = _IntPatch.new_IntPatch_SequenceOfPathPointOfTheSOnBounds(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self) -> "Standard_Integer":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Size(self)

    def Length(self) -> "Standard_Integer":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Length(self)

    def Lower(self) -> "Standard_Integer":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Upper(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_IsEmpty(self)

    def Reverse(self) -> "void":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Reverse(self)

    def Exchange(self, I: 'Standard_Integer const', J: 'Standard_Integer const') -> "void":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Exchange(self, I, J)
    if _newclass:
        delNode = staticmethod(_IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_delNode)
    else:
        delNode = _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_delNode

    def Clear(self, theAllocator: 'IntSurf_Allocator'=0) -> "void":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Clear(self, theAllocator)

    def Assign(self, theOther: 'IntPatch_SequenceOfPathPointOfTheSOnBounds') -> "NCollection_Sequence< IntPatch_ThePathPointOfTheSOnBounds > &":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Assign(self, theOther)

    def Set(self, theOther: 'IntPatch_SequenceOfPathPointOfTheSOnBounds') -> "NCollection_Sequence< IntPatch_ThePathPointOfTheSOnBounds > &":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Set(self, theOther)

    def Remove(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Remove(self, *args)

    def Append(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Append(self, *args)

    def Prepend(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Prepend(self, *args)

    def InsertBefore(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_InsertBefore(self, *args)

    def InsertAfter(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_InsertAfter(self, *args)

    def Split(self, theIndex: 'Standard_Integer const', theSeq: 'IntPatch_SequenceOfPathPointOfTheSOnBounds') -> "void":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Split(self, theIndex, theSeq)

    def First(self) -> "IntPatch_ThePathPointOfTheSOnBounds const &":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_First(self)

    def ChangeFirst(self) -> "IntPatch_ThePathPointOfTheSOnBounds &":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_ChangeFirst(self)

    def Last(self) -> "IntPatch_ThePathPointOfTheSOnBounds const &":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Last(self)

    def ChangeLast(self) -> "IntPatch_ThePathPointOfTheSOnBounds &":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "IntPatch_ThePathPointOfTheSOnBounds const &":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "IntPatch_ThePathPointOfTheSOnBounds &":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "IntPatch_ThePathPointOfTheSOnBounds &":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'IntPatch_ThePathPointOfTheSOnBounds') -> "void":
        return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_SetValue(self, theIndex, theItem)
    __swig_destroy__ = _IntPatch.delete_IntPatch_SequenceOfPathPointOfTheSOnBounds
    __del__ = lambda self: None

    def __len__(self):
        return self.Size()

IntPatch_SequenceOfPathPointOfTheSOnBounds_swigregister = _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_swigregister
IntPatch_SequenceOfPathPointOfTheSOnBounds_swigregister(IntPatch_SequenceOfPathPointOfTheSOnBounds)

def IntPatch_SequenceOfPathPointOfTheSOnBounds_delNode(theNode: 'NCollection_SeqNode *', theAl: 'IntSurf_Allocator') -> "void":
    return _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_delNode(theNode, theAl)
IntPatch_SequenceOfPathPointOfTheSOnBounds_delNode = _IntPatch.IntPatch_SequenceOfPathPointOfTheSOnBounds_delNode

class IntPatch_SequenceOfPoint(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_SequenceOfPoint, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_SequenceOfPoint, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Sequence< IntPatch_Point >::iterator":
        return _IntPatch.IntPatch_SequenceOfPoint_begin(self)

    def end(self) -> "NCollection_Sequence< IntPatch_Point >::iterator":
        return _IntPatch.IntPatch_SequenceOfPoint_end(self)

    def cbegin(self) -> "NCollection_Sequence< IntPatch_Point >::const_iterator":
        return _IntPatch.IntPatch_SequenceOfPoint_cbegin(self)

    def cend(self) -> "NCollection_Sequence< IntPatch_Point >::const_iterator":
        return _IntPatch.IntPatch_SequenceOfPoint_cend(self)

    def __init__(self, *args):
        this = _IntPatch.new_IntPatch_SequenceOfPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self) -> "Standard_Integer":
        return _IntPatch.IntPatch_SequenceOfPoint_Size(self)

    def Length(self) -> "Standard_Integer":
        return _IntPatch.IntPatch_SequenceOfPoint_Length(self)

    def Lower(self) -> "Standard_Integer":
        return _IntPatch.IntPatch_SequenceOfPoint_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _IntPatch.IntPatch_SequenceOfPoint_Upper(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _IntPatch.IntPatch_SequenceOfPoint_IsEmpty(self)

    def Reverse(self) -> "void":
        return _IntPatch.IntPatch_SequenceOfPoint_Reverse(self)

    def Exchange(self, I: 'Standard_Integer const', J: 'Standard_Integer const') -> "void":
        return _IntPatch.IntPatch_SequenceOfPoint_Exchange(self, I, J)
    if _newclass:
        delNode = staticmethod(_IntPatch.IntPatch_SequenceOfPoint_delNode)
    else:
        delNode = _IntPatch.IntPatch_SequenceOfPoint_delNode

    def Clear(self, theAllocator: 'IntSurf_Allocator'=0) -> "void":
        return _IntPatch.IntPatch_SequenceOfPoint_Clear(self, theAllocator)

    def Assign(self, theOther: 'IntPatch_SequenceOfPoint') -> "NCollection_Sequence< IntPatch_Point > &":
        return _IntPatch.IntPatch_SequenceOfPoint_Assign(self, theOther)

    def Set(self, theOther: 'IntPatch_SequenceOfPoint') -> "NCollection_Sequence< IntPatch_Point > &":
        return _IntPatch.IntPatch_SequenceOfPoint_Set(self, theOther)

    def Remove(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfPoint_Remove(self, *args)

    def Append(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfPoint_Append(self, *args)

    def Prepend(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfPoint_Prepend(self, *args)

    def InsertBefore(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfPoint_InsertBefore(self, *args)

    def InsertAfter(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfPoint_InsertAfter(self, *args)

    def Split(self, theIndex: 'Standard_Integer const', theSeq: 'IntPatch_SequenceOfPoint') -> "void":
        return _IntPatch.IntPatch_SequenceOfPoint_Split(self, theIndex, theSeq)

    def First(self) -> "IntPatch_Point const &":
        return _IntPatch.IntPatch_SequenceOfPoint_First(self)

    def ChangeFirst(self) -> "IntPatch_Point &":
        return _IntPatch.IntPatch_SequenceOfPoint_ChangeFirst(self)

    def Last(self) -> "IntPatch_Point const &":
        return _IntPatch.IntPatch_SequenceOfPoint_Last(self)

    def ChangeLast(self) -> "IntPatch_Point &":
        return _IntPatch.IntPatch_SequenceOfPoint_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "IntPatch_Point const &":
        return _IntPatch.IntPatch_SequenceOfPoint_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "IntPatch_Point &":
        return _IntPatch.IntPatch_SequenceOfPoint_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "IntPatch_Point &":
        return _IntPatch.IntPatch_SequenceOfPoint___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'IntPatch_Point') -> "void":
        return _IntPatch.IntPatch_SequenceOfPoint_SetValue(self, theIndex, theItem)
    __swig_destroy__ = _IntPatch.delete_IntPatch_SequenceOfPoint
    __del__ = lambda self: None

    def __len__(self):
        return self.Size()

IntPatch_SequenceOfPoint_swigregister = _IntPatch.IntPatch_SequenceOfPoint_swigregister
IntPatch_SequenceOfPoint_swigregister(IntPatch_SequenceOfPoint)

def IntPatch_SequenceOfPoint_delNode(theNode: 'NCollection_SeqNode *', theAl: 'IntSurf_Allocator') -> "void":
    return _IntPatch.IntPatch_SequenceOfPoint_delNode(theNode, theAl)
IntPatch_SequenceOfPoint_delNode = _IntPatch.IntPatch_SequenceOfPoint_delNode

class IntPatch_SequenceOfSegmentOfTheSOnBounds(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_SequenceOfSegmentOfTheSOnBounds, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_SequenceOfSegmentOfTheSOnBounds, name)
    __repr__ = _swig_repr

    def begin(self) -> "NCollection_Sequence< IntPatch_TheSegmentOfTheSOnBounds >::iterator":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_begin(self)

    def end(self) -> "NCollection_Sequence< IntPatch_TheSegmentOfTheSOnBounds >::iterator":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_end(self)

    def cbegin(self) -> "NCollection_Sequence< IntPatch_TheSegmentOfTheSOnBounds >::const_iterator":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_cbegin(self)

    def cend(self) -> "NCollection_Sequence< IntPatch_TheSegmentOfTheSOnBounds >::const_iterator":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_cend(self)

    def __init__(self, *args):
        this = _IntPatch.new_IntPatch_SequenceOfSegmentOfTheSOnBounds(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self) -> "Standard_Integer":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Size(self)

    def Length(self) -> "Standard_Integer":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Length(self)

    def Lower(self) -> "Standard_Integer":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Lower(self)

    def Upper(self) -> "Standard_Integer":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Upper(self)

    def IsEmpty(self) -> "Standard_Boolean":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_IsEmpty(self)

    def Reverse(self) -> "void":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Reverse(self)

    def Exchange(self, I: 'Standard_Integer const', J: 'Standard_Integer const') -> "void":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Exchange(self, I, J)
    if _newclass:
        delNode = staticmethod(_IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_delNode)
    else:
        delNode = _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_delNode

    def Clear(self, theAllocator: 'IntSurf_Allocator'=0) -> "void":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Clear(self, theAllocator)

    def Assign(self, theOther: 'IntPatch_SequenceOfSegmentOfTheSOnBounds') -> "NCollection_Sequence< IntPatch_TheSegmentOfTheSOnBounds > &":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Assign(self, theOther)

    def Set(self, theOther: 'IntPatch_SequenceOfSegmentOfTheSOnBounds') -> "NCollection_Sequence< IntPatch_TheSegmentOfTheSOnBounds > &":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Set(self, theOther)

    def Remove(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Remove(self, *args)

    def Append(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Append(self, *args)

    def Prepend(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Prepend(self, *args)

    def InsertBefore(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_InsertBefore(self, *args)

    def InsertAfter(self, *args) -> "void":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_InsertAfter(self, *args)

    def Split(self, theIndex: 'Standard_Integer const', theSeq: 'IntPatch_SequenceOfSegmentOfTheSOnBounds') -> "void":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Split(self, theIndex, theSeq)

    def First(self) -> "IntPatch_TheSegmentOfTheSOnBounds const &":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_First(self)

    def ChangeFirst(self) -> "IntPatch_TheSegmentOfTheSOnBounds &":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_ChangeFirst(self)

    def Last(self) -> "IntPatch_TheSegmentOfTheSOnBounds const &":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Last(self)

    def ChangeLast(self) -> "IntPatch_TheSegmentOfTheSOnBounds &":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_ChangeLast(self)

    def Value(self, theIndex: 'Standard_Integer const') -> "IntPatch_TheSegmentOfTheSOnBounds const &":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_Value(self, theIndex)

    def ChangeValue(self, theIndex: 'Standard_Integer const') -> "IntPatch_TheSegmentOfTheSOnBounds &":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_ChangeValue(self, theIndex)

    def __call__(self, *args) -> "IntPatch_TheSegmentOfTheSOnBounds &":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds___call__(self, *args)

    def SetValue(self, theIndex: 'Standard_Integer const', theItem: 'IntPatch_TheSegmentOfTheSOnBounds') -> "void":
        return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_SetValue(self, theIndex, theItem)
    __swig_destroy__ = _IntPatch.delete_IntPatch_SequenceOfSegmentOfTheSOnBounds
    __del__ = lambda self: None

    def __len__(self):
        return self.Size()

IntPatch_SequenceOfSegmentOfTheSOnBounds_swigregister = _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_swigregister
IntPatch_SequenceOfSegmentOfTheSOnBounds_swigregister(IntPatch_SequenceOfSegmentOfTheSOnBounds)

def IntPatch_SequenceOfSegmentOfTheSOnBounds_delNode(theNode: 'NCollection_SeqNode *', theAl: 'IntSurf_Allocator') -> "void":
    return _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_delNode(theNode, theAl)
IntPatch_SequenceOfSegmentOfTheSOnBounds_delNode = _IntPatch.IntPatch_SequenceOfSegmentOfTheSOnBounds_delNode

class IntPatch_ALineToWLine(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_ALineToWLine, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_ALineToWLine, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Constructor.

        Parameters
        ----------
        theS1: Adaptor3d_HSurface
        theS2: Adaptor3d_HSurface
        theNbPoints: int,optional
        	default value is 200

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_ALineToWLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def MakeWLine(self, *args) -> "void":
        """
        Converts aline to the set of walking-lines and adds them in thelines.

        Parameters
        ----------
        aline: IntPatch_ALine
        theLines: IntPatch_SequenceOfLine

        Returns
        -------
        None

        Converts aline (limitted by paraminf and paramsup) to the set of walking-lines and adds them in thelines.

        Parameters
        ----------
        aline: IntPatch_ALine
        paraminf: float
        paramsup: float
        theLines: IntPatch_SequenceOfLine

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_ALineToWLine_MakeWLine(self, *args)


    def SetTol3D(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        aT: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_ALineToWLine_SetTol3D(self, *args)


    def SetTolOpenDomain(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        aT: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_ALineToWLine_SetTolOpenDomain(self, *args)


    def SetTolTransition(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        aT: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_ALineToWLine_SetTolTransition(self, *args)


    def Tol3D(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_ALineToWLine_Tol3D(self, *args)


    def TolOpenDomain(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_ALineToWLine_TolOpenDomain(self, *args)


    def TolTransition(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_ALineToWLine_TolTransition(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_ALineToWLine
    __del__ = lambda self: None
IntPatch_ALineToWLine_swigregister = _IntPatch.IntPatch_ALineToWLine_swigregister
IntPatch_ALineToWLine_swigregister(IntPatch_ALineToWLine)

class IntPatch_ArcFunction(OCC.Core.math.math_FunctionWithDerivative):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.math.math_FunctionWithDerivative]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_ArcFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.math.math_FunctionWithDerivative]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_ArcFunction, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_ArcFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Arc(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d > const &":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<Adaptor2d_HCurve2d>

        """
        return _IntPatch.IntPatch_ArcFunction_Arc(self, *args)


    def LastComputedPoint(self, *args) -> "gp_Pnt const":
        """
        Returns the point, which has been computed while the last calling value() method.

        Returns
        -------
        gp_Pnt

        """
        return _IntPatch.IntPatch_ArcFunction_LastComputedPoint(self, *args)


    def NbSamples(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_ArcFunction_NbSamples(self, *args)


    def Quadric(self, *args) -> "IntSurf_Quadric const &":
        """
        No available documentation.

        Returns
        -------
        IntSurf_Quadric

        """
        return _IntPatch.IntPatch_ArcFunction_Quadric(self, *args)


    def Set(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        A: Adaptor2d_HCurve2d

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        S: Adaptor3d_HSurface

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_ArcFunction_Set(self, *args)


    def SetQuadric(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        Q: IntSurf_Quadric

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_ArcFunction_SetQuadric(self, *args)


    def Surface(self, *args) -> "opencascade::handle< Adaptor3d_HSurface > const &":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<Adaptor3d_HSurface>

        """
        return _IntPatch.IntPatch_ArcFunction_Surface(self, *args)


    def Valpoint(self, *args) -> "gp_Pnt const":
        """
        No available documentation.

        Parameters
        ----------
        Index: int

        Returns
        -------
        gp_Pnt

        """
        return _IntPatch.IntPatch_ArcFunction_Valpoint(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_ArcFunction
    __del__ = lambda self: None
IntPatch_ArcFunction_swigregister = _IntPatch.IntPatch_ArcFunction_swigregister
IntPatch_ArcFunction_swigregister(IntPatch_ArcFunction)

class IntPatch_CSFunction(OCC.Core.math.math_FunctionSetWithDerivatives):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.math.math_FunctionSetWithDerivatives]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_CSFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.math.math_FunctionSetWithDerivatives]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_CSFunction, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        S1 is the surface on which the intersection is searched. c is a curve on the surface s2.

        Parameters
        ----------
        S1: Adaptor3d_HSurface
        C: Adaptor2d_HCurve2d
        S2: Adaptor3d_HSurface

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_CSFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AuxillarCurve(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d > const &":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<Adaptor2d_HCurve2d>

        """
        return _IntPatch.IntPatch_CSFunction_AuxillarCurve(self, *args)


    def AuxillarSurface(self, *args) -> "opencascade::handle< Adaptor3d_HSurface > const &":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<Adaptor3d_HSurface>

        """
        return _IntPatch.IntPatch_CSFunction_AuxillarSurface(self, *args)


    def Point(self, *args) -> "gp_Pnt const":
        """
        No available documentation.

        Returns
        -------
        gp_Pnt

        """
        return _IntPatch.IntPatch_CSFunction_Point(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_CSFunction_Root(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_CSFunction
    __del__ = lambda self: None
IntPatch_CSFunction_swigregister = _IntPatch.IntPatch_CSFunction_swigregister
IntPatch_CSFunction_swigregister(IntPatch_CSFunction)

class IntPatch_CurvIntSurf(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_CurvIntSurf, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_CurvIntSurf, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Compute the solution point with the close point margincoef is the coefficient for extension of uv bounds. ex., ufirst -= margincoef*(ulast-ufirst).

        Parameters
        ----------
        U: float
        V: float
        W: float
        F: IntPatch_CSFunction
        TolTangency: float
        MarginCoef: float,optional
        	default value is 0.0

        Returns
        -------
        None

        Initialize the parameters to compute the solution.

        Parameters
        ----------
        F: IntPatch_CSFunction
        TolTangency: float

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_CurvIntSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Function(self, *args) -> "IntPatch_CSFunction &":
        """
        Return the math function which is used to compute the intersection.

        Returns
        -------
        IntPatch_CSFunction

        """
        return _IntPatch.IntPatch_CurvIntSurf_Function(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the creation completed without failure.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_CurvIntSurf_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_CurvIntSurf_IsEmpty(self, *args)


    def ParameterOnCurve(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_CurvIntSurf_ParameterOnCurve(self, *args)


    def ParameterOnSurface(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------

        Returns
        -------
        U: float
        V: float

        """
        return _IntPatch.IntPatch_CurvIntSurf_ParameterOnSurface(self, *args)


    def Perform(self, *args) -> "void":
        """
        Compute the solution it's possible to write to optimize: intimp_intcs inter(s1,c1,toltangency) math_functionsetroot rsnld(inter.function()) while ...{ u=... v=... w=... inter.perform(u,v,w,rsnld) } or intimp_intcs inter(toltangency) inter.setsurface(s); math_functionsetroot rsnld(inter.function()) while ...{ c=... inter.setcurve(c); u=... v=... w=... inter.perform(u,v,w,rsnld) }.

        Parameters
        ----------
        U: float
        V: float
        W: float
        Rsnld: math_FunctionSetRoot
        u0: float
        v0: float
        u1: float
        v1: float
        w0: float
        w1: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_CurvIntSurf_Perform(self, *args)


    def Point(self, *args) -> "gp_Pnt const":
        """
        Returns the intersection point the exception notdone is raised if isdone is false. the exception domainerror is raised if isempty is true.

        Returns
        -------
        gp_Pnt

        """
        return _IntPatch.IntPatch_CurvIntSurf_Point(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_CurvIntSurf
    __del__ = lambda self: None
IntPatch_CurvIntSurf_swigregister = _IntPatch.IntPatch_CurvIntSurf_swigregister
IntPatch_CurvIntSurf_swigregister(IntPatch_CurvIntSurf)

class IntPatch_HCurve2dTool(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_HCurve2dTool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_HCurve2dTool, name)
    __repr__ = _swig_repr

    def BSpline(*args) -> "opencascade::handle< Geom2d_BSplineCurve >":
        """
        No available documentation.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d

        Returns
        -------
        opencascade::handle<Geom2d_BSplineCurve>

        """
        return _IntPatch.IntPatch_HCurve2dTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def Bezier(*args) -> "opencascade::handle< Geom2d_BezierCurve >":
        """
        No available documentation.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d

        Returns
        -------
        opencascade::handle<Geom2d_BezierCurve>

        """
        return _IntPatch.IntPatch_HCurve2dTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def Circle(*args) -> "gp_Circ2d":
        """
        No available documentation.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d

        Returns
        -------
        gp_Circ2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_Circle(*args)

    Circle = staticmethod(Circle)

    def Continuity(*args) -> "GeomAbs_Shape":
        """
        No available documentation.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d

        Returns
        -------
        GeomAbs_Shape

        """
        return _IntPatch.IntPatch_HCurve2dTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def D0(*args) -> "void":
        """
        Computes the point of parameter u on the curve.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d
        U: float
        P: gp_Pnt2d

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_HCurve2dTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args) -> "void":
        """
        Computes the point of parameter u on the curve with its first derivative. raised if the continuity of the current interval is not c1.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d
        U: float
        P: gp_Pnt2d
        V: gp_Vec2d

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_HCurve2dTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args) -> "void":
        """
        Returns the point p of parameter u, the first and second derivatives v1 and v2. raised if the continuity of the current interval is not c2.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d
        U: float
        P: gp_Pnt2d
        V1: gp_Vec2d
        V2: gp_Vec2d

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_HCurve2dTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args) -> "void":
        """
        Returns the point p of parameter u, the first, the second and the third derivative. raised if the continuity of the current interval is not c3.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d
        U: float
        P: gp_Pnt2d
        V1: gp_Vec2d
        V2: gp_Vec2d
        V3: gp_Vec2d

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_HCurve2dTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args) -> "gp_Vec2d":
        """
        The returned vector gives the value of the derivative for the order of derivation n. raised if the continuity of the current interval is not cn. raised if n < 1.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d
        U: float
        N: int

        Returns
        -------
        gp_Vec2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_DN(*args)

    DN = staticmethod(DN)

    def Ellipse(*args) -> "gp_Elips2d":
        """
        No available documentation.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d

        Returns
        -------
        gp_Elips2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_Ellipse(*args)

    Ellipse = staticmethod(Ellipse)

    def FirstParameter(*args) -> "Standard_Real":
        """
        No available documentation.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_HCurve2dTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def GetType(*args) -> "GeomAbs_CurveType":
        """
        Returns the type of the curve in the current interval : line, circle, ellipse, hyperbola, parabola, beziercurve, bsplinecurve, othercurve.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d

        Returns
        -------
        GeomAbs_CurveType

        """
        return _IntPatch.IntPatch_HCurve2dTool_GetType(*args)

    GetType = staticmethod(GetType)

    def Hyperbola(*args) -> "gp_Hypr2d":
        """
        No available documentation.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d

        Returns
        -------
        gp_Hypr2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_Hyperbola(*args)

    Hyperbola = staticmethod(Hyperbola)

    def Intervals(*args) -> "void":
        """
        Stores in <t> the parameters bounding the intervals of continuity <s>. //! the array must provide enough room to accomodate for the parameters. i.e. t.length() > nbintervals().

        Parameters
        ----------
        C: Adaptor2d_HCurve2d
        T: TColStd_Array1OfReal
        S: GeomAbs_Shape

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_HCurve2dTool_Intervals(*args)

    Intervals = staticmethod(Intervals)

    def IsClosed(*args) -> "Standard_Boolean":
        """
        No available documentation.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_HCurve2dTool_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def IsPeriodic(*args) -> "Standard_Boolean":
        """
        No available documentation.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_HCurve2dTool_IsPeriodic(*args)

    IsPeriodic = staticmethod(IsPeriodic)

    def LastParameter(*args) -> "Standard_Real":
        """
        No available documentation.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_HCurve2dTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def Line(*args) -> "gp_Lin2d":
        """
        No available documentation.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d

        Returns
        -------
        gp_Lin2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_Line(*args)

    Line = staticmethod(Line)

    def NbIntervals(*args) -> "Standard_Integer":
        """
        Returns the number of intervals for continuity <s>. may be one if continuity(myclass) >= <s>.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d
        S: GeomAbs_Shape

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_HCurve2dTool_NbIntervals(*args)

    NbIntervals = staticmethod(NbIntervals)

    def NbSamples(*args) -> "Standard_Integer":
        """
        No available documentation.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d
        U0: float
        U1: float

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_HCurve2dTool_NbSamples(*args)

    NbSamples = staticmethod(NbSamples)

    def Parabola(*args) -> "gp_Parab2d":
        """
        No available documentation.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d

        Returns
        -------
        gp_Parab2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_Parabola(*args)

    Parabola = staticmethod(Parabola)

    def Period(*args) -> "Standard_Real":
        """
        No available documentation.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_HCurve2dTool_Period(*args)

    Period = staticmethod(Period)

    def Resolution(*args) -> "Standard_Real":
        """
        Returns the parametric resolution corresponding to the real space resolution <r3d>.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d
        R3d: float

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_HCurve2dTool_Resolution(*args)

    Resolution = staticmethod(Resolution)

    def Value(*args) -> "gp_Pnt2d":
        """
        Computes the point of parameter u on the curve.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d
        U: float

        Returns
        -------
        gp_Pnt2d

        """
        return _IntPatch.IntPatch_HCurve2dTool_Value(*args)

    Value = staticmethod(Value)

    __repr__ = _dumps_object


    def __init__(self):
        this = _IntPatch.new_IntPatch_HCurve2dTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPatch.delete_IntPatch_HCurve2dTool
    __del__ = lambda self: None
IntPatch_HCurve2dTool_swigregister = _IntPatch.IntPatch_HCurve2dTool_swigregister
IntPatch_HCurve2dTool_swigregister(IntPatch_HCurve2dTool)

def IntPatch_HCurve2dTool_BSpline(*args) -> "opencascade::handle< Geom2d_BSplineCurve >":
    """
    No available documentation.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d

    Returns
    -------
    opencascade::handle<Geom2d_BSplineCurve>

    """
    return _IntPatch.IntPatch_HCurve2dTool_BSpline(*args)

def IntPatch_HCurve2dTool_Bezier(*args) -> "opencascade::handle< Geom2d_BezierCurve >":
    """
    No available documentation.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d

    Returns
    -------
    opencascade::handle<Geom2d_BezierCurve>

    """
    return _IntPatch.IntPatch_HCurve2dTool_Bezier(*args)

def IntPatch_HCurve2dTool_Circle(*args) -> "gp_Circ2d":
    """
    No available documentation.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d

    Returns
    -------
    gp_Circ2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_Circle(*args)

def IntPatch_HCurve2dTool_Continuity(*args) -> "GeomAbs_Shape":
    """
    No available documentation.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d

    Returns
    -------
    GeomAbs_Shape

    """
    return _IntPatch.IntPatch_HCurve2dTool_Continuity(*args)

def IntPatch_HCurve2dTool_D0(*args) -> "void":
    """
    Computes the point of parameter u on the curve.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d
    U: float
    P: gp_Pnt2d

    Returns
    -------
    None

    """
    return _IntPatch.IntPatch_HCurve2dTool_D0(*args)

def IntPatch_HCurve2dTool_D1(*args) -> "void":
    """
    Computes the point of parameter u on the curve with its first derivative. raised if the continuity of the current interval is not c1.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d
    U: float
    P: gp_Pnt2d
    V: gp_Vec2d

    Returns
    -------
    None

    """
    return _IntPatch.IntPatch_HCurve2dTool_D1(*args)

def IntPatch_HCurve2dTool_D2(*args) -> "void":
    """
    Returns the point p of parameter u, the first and second derivatives v1 and v2. raised if the continuity of the current interval is not c2.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d
    U: float
    P: gp_Pnt2d
    V1: gp_Vec2d
    V2: gp_Vec2d

    Returns
    -------
    None

    """
    return _IntPatch.IntPatch_HCurve2dTool_D2(*args)

def IntPatch_HCurve2dTool_D3(*args) -> "void":
    """
    Returns the point p of parameter u, the first, the second and the third derivative. raised if the continuity of the current interval is not c3.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d
    U: float
    P: gp_Pnt2d
    V1: gp_Vec2d
    V2: gp_Vec2d
    V3: gp_Vec2d

    Returns
    -------
    None

    """
    return _IntPatch.IntPatch_HCurve2dTool_D3(*args)

def IntPatch_HCurve2dTool_DN(*args) -> "gp_Vec2d":
    """
    The returned vector gives the value of the derivative for the order of derivation n. raised if the continuity of the current interval is not cn. raised if n < 1.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d
    U: float
    N: int

    Returns
    -------
    gp_Vec2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_DN(*args)

def IntPatch_HCurve2dTool_Ellipse(*args) -> "gp_Elips2d":
    """
    No available documentation.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d

    Returns
    -------
    gp_Elips2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_Ellipse(*args)

def IntPatch_HCurve2dTool_FirstParameter(*args) -> "Standard_Real":
    """
    No available documentation.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d

    Returns
    -------
    float

    """
    return _IntPatch.IntPatch_HCurve2dTool_FirstParameter(*args)

def IntPatch_HCurve2dTool_GetType(*args) -> "GeomAbs_CurveType":
    """
    Returns the type of the curve in the current interval : line, circle, ellipse, hyperbola, parabola, beziercurve, bsplinecurve, othercurve.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d

    Returns
    -------
    GeomAbs_CurveType

    """
    return _IntPatch.IntPatch_HCurve2dTool_GetType(*args)

def IntPatch_HCurve2dTool_Hyperbola(*args) -> "gp_Hypr2d":
    """
    No available documentation.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d

    Returns
    -------
    gp_Hypr2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_Hyperbola(*args)

def IntPatch_HCurve2dTool_Intervals(*args) -> "void":
    """
    Stores in <t> the parameters bounding the intervals of continuity <s>. //! the array must provide enough room to accomodate for the parameters. i.e. t.length() > nbintervals().

    Parameters
    ----------
    C: Adaptor2d_HCurve2d
    T: TColStd_Array1OfReal
    S: GeomAbs_Shape

    Returns
    -------
    None

    """
    return _IntPatch.IntPatch_HCurve2dTool_Intervals(*args)

def IntPatch_HCurve2dTool_IsClosed(*args) -> "Standard_Boolean":
    """
    No available documentation.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d

    Returns
    -------
    bool

    """
    return _IntPatch.IntPatch_HCurve2dTool_IsClosed(*args)

def IntPatch_HCurve2dTool_IsPeriodic(*args) -> "Standard_Boolean":
    """
    No available documentation.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d

    Returns
    -------
    bool

    """
    return _IntPatch.IntPatch_HCurve2dTool_IsPeriodic(*args)

def IntPatch_HCurve2dTool_LastParameter(*args) -> "Standard_Real":
    """
    No available documentation.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d

    Returns
    -------
    float

    """
    return _IntPatch.IntPatch_HCurve2dTool_LastParameter(*args)

def IntPatch_HCurve2dTool_Line(*args) -> "gp_Lin2d":
    """
    No available documentation.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d

    Returns
    -------
    gp_Lin2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_Line(*args)

def IntPatch_HCurve2dTool_NbIntervals(*args) -> "Standard_Integer":
    """
    Returns the number of intervals for continuity <s>. may be one if continuity(myclass) >= <s>.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d
    S: GeomAbs_Shape

    Returns
    -------
    int

    """
    return _IntPatch.IntPatch_HCurve2dTool_NbIntervals(*args)

def IntPatch_HCurve2dTool_NbSamples(*args) -> "Standard_Integer":
    """
    No available documentation.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d
    U0: float
    U1: float

    Returns
    -------
    int

    """
    return _IntPatch.IntPatch_HCurve2dTool_NbSamples(*args)

def IntPatch_HCurve2dTool_Parabola(*args) -> "gp_Parab2d":
    """
    No available documentation.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d

    Returns
    -------
    gp_Parab2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_Parabola(*args)

def IntPatch_HCurve2dTool_Period(*args) -> "Standard_Real":
    """
    No available documentation.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d

    Returns
    -------
    float

    """
    return _IntPatch.IntPatch_HCurve2dTool_Period(*args)

def IntPatch_HCurve2dTool_Resolution(*args) -> "Standard_Real":
    """
    Returns the parametric resolution corresponding to the real space resolution <r3d>.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d
    R3d: float

    Returns
    -------
    float

    """
    return _IntPatch.IntPatch_HCurve2dTool_Resolution(*args)

def IntPatch_HCurve2dTool_Value(*args) -> "gp_Pnt2d":
    """
    Computes the point of parameter u on the curve.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d
    U: float

    Returns
    -------
    gp_Pnt2d

    """
    return _IntPatch.IntPatch_HCurve2dTool_Value(*args)

class IntPatch_HInterTool(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_HInterTool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_HInterTool, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_HInterTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Bounds(*args) -> "Standard_Real &, Standard_Real &":
        """
        Returns the parametric limits on the arc c. these limits must be finite : they are either the real limits of the arc, for a finite arc, or a bounding box for an infinite arc.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d

        Returns
        -------
        Ufirst: float
        Ulast: float

        """
        return _IntPatch.IntPatch_HInterTool_Bounds(*args)

    Bounds = staticmethod(Bounds)

    def HasBeenSeen(*args) -> "Standard_Boolean":
        """
        Returns true if all the intersection point and edges are known on the arc. the intersection point are given as vertices. the intersection edges are given as intervals between two vertices.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_HInterTool_HasBeenSeen(*args)

    HasBeenSeen = staticmethod(HasBeenSeen)

    def HasFirstPoint(*args) -> "Standard_Integer &":
        """
        Returns true when the segment of range index is not open at the left side. in that case, indfirst is the range in the list intersection points (see nbpoints) of the one which defines the left bound of the segment. otherwise, the method has to return false, and indfirst has no meaning.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d
        Index: int

        Returns
        -------
        IndFirst: int

        """
        return _IntPatch.IntPatch_HInterTool_HasFirstPoint(*args)

    HasFirstPoint = staticmethod(HasFirstPoint)

    def HasLastPoint(*args) -> "Standard_Integer &":
        """
        Returns true when the segment of range index is not open at the right side. in that case, indlast is the range in the list intersection points (see nbpoints) of the one which defines the right bound of the segment. otherwise, the method has to return false, and indlast has no meaning.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d
        Index: int

        Returns
        -------
        IndLast: int

        """
        return _IntPatch.IntPatch_HInterTool_HasLastPoint(*args)

    HasLastPoint = staticmethod(HasLastPoint)

    def IsAllSolution(*args) -> "Standard_Boolean":
        """
        Returns true when the whole restriction is solution of the intersection problem.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_HInterTool_IsAllSolution(*args)

    IsAllSolution = staticmethod(IsAllSolution)

    def IsVertex(*args) -> "Standard_Boolean":
        """
        Returns true if the intersection point of range index corresponds with a vertex on the arc a.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d
        Index: int

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_HInterTool_IsVertex(*args)

    IsVertex = staticmethod(IsVertex)

    def NbPoints(*args) -> "Standard_Integer":
        """
        Returns the number of intersection points on the arc a.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_HInterTool_NbPoints(*args)

    NbPoints = staticmethod(NbPoints)

    def NbSamplePoints(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Parameters
        ----------
        S: Adaptor3d_HSurface

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_HInterTool_NbSamplePoints(self, *args)


    def NbSamplesOnArc(*args) -> "Standard_Integer":
        """
        Returns the number of points which is used to make a sample on the arc. this number is a function of the surface and the curveonsurface complexity.

        Parameters
        ----------
        A: Adaptor2d_HCurve2d

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_HInterTool_NbSamplesOnArc(*args)

    NbSamplesOnArc = staticmethod(NbSamplesOnArc)

    def NbSamplesU(*args) -> "Standard_Integer":
        """
        No available documentation.

        Parameters
        ----------
        S: Adaptor3d_HSurface
        u1: float
        u2: float

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_HInterTool_NbSamplesU(*args)

    NbSamplesU = staticmethod(NbSamplesU)

    def NbSamplesV(*args) -> "Standard_Integer":
        """
        No available documentation.

        Parameters
        ----------
        S: Adaptor3d_HSurface
        v1: float
        v2: float

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_HInterTool_NbSamplesV(*args)

    NbSamplesV = staticmethod(NbSamplesV)

    def NbSegments(*args) -> "Standard_Integer":
        """
        Returns the number of part of a solution of the of intersection problem.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_HInterTool_NbSegments(*args)

    NbSegments = staticmethod(NbSegments)

    def Parameter(*args) -> "Standard_Real":
        """
        Returns the parameter of the vertex v on the arc a.

        Parameters
        ----------
        V: Adaptor3d_HVertex
        C: Adaptor2d_HCurve2d

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_HInterTool_Parameter(*args)

    Parameter = staticmethod(Parameter)

    def Project(*args) -> "Standard_Real &":
        """
        Projects the point p on the arc c. if the methods returns standard_true, the projection is successful, and paramproj is the parameter on the arc of the projected point, ptproj is the projected point. if the method returns standard_false, param proj and ptproj are not significant.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d
        P: gp_Pnt2d
        Ptproj: gp_Pnt2d

        Returns
        -------
        Paramproj: float

        """
        return _IntPatch.IntPatch_HInterTool_Project(*args)

    Project = staticmethod(Project)

    def SamplePoint(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        S: Adaptor3d_HSurface
        Index: int

        Returns
        -------
        U: float
        V: float

        """
        return _IntPatch.IntPatch_HInterTool_SamplePoint(self, *args)


    def SingularOnUMax(*args) -> "Standard_Boolean":
        """
        No available documentation.

        Parameters
        ----------
        S: Adaptor3d_HSurface

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_HInterTool_SingularOnUMax(*args)

    SingularOnUMax = staticmethod(SingularOnUMax)

    def SingularOnUMin(*args) -> "Standard_Boolean":
        """
        No available documentation.

        Parameters
        ----------
        S: Adaptor3d_HSurface

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_HInterTool_SingularOnUMin(*args)

    SingularOnUMin = staticmethod(SingularOnUMin)

    def SingularOnVMax(*args) -> "Standard_Boolean":
        """
        No available documentation.

        Parameters
        ----------
        S: Adaptor3d_HSurface

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_HInterTool_SingularOnVMax(*args)

    SingularOnVMax = staticmethod(SingularOnVMax)

    def SingularOnVMin(*args) -> "Standard_Boolean":
        """
        No available documentation.

        Parameters
        ----------
        S: Adaptor3d_HSurface

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_HInterTool_SingularOnVMin(*args)

    SingularOnVMin = staticmethod(SingularOnVMin)

    def Tolerance(*args) -> "Standard_Real":
        """
        Returns the parametric tolerance used to consider that the vertex and another point meet, i-e if abs(parameter(vertex) - parameter(otherpnt))<= tolerance, the points are 'merged'.

        Parameters
        ----------
        V: Adaptor3d_HVertex
        C: Adaptor2d_HCurve2d

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_HInterTool_Tolerance(*args)

    Tolerance = staticmethod(Tolerance)

    def Value(*args) -> "Standard_Real &, Standard_Real &":
        """
        Returns the value (pt), the tolerance (tol), and the parameter (u) on the arc a , of the intersection point of range index.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d
        Index: int
        Pt: gp_Pnt

        Returns
        -------
        Tol: float
        U: float

        """
        return _IntPatch.IntPatch_HInterTool_Value(*args)

    Value = staticmethod(Value)

    def Vertex(*args) -> "void":
        """
        When isvertex returns true, this method returns the vertex on the arc a.

        Parameters
        ----------
        C: Adaptor2d_HCurve2d
        Index: int
        V: Adaptor3d_HVertex

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_HInterTool_Vertex(*args)

    Vertex = staticmethod(Vertex)

    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_HInterTool
    __del__ = lambda self: None
IntPatch_HInterTool_swigregister = _IntPatch.IntPatch_HInterTool_swigregister
IntPatch_HInterTool_swigregister(IntPatch_HInterTool)

def IntPatch_HInterTool_Bounds(*args) -> "Standard_Real &, Standard_Real &":
    """
    Returns the parametric limits on the arc c. these limits must be finite : they are either the real limits of the arc, for a finite arc, or a bounding box for an infinite arc.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d

    Returns
    -------
    Ufirst: float
    Ulast: float

    """
    return _IntPatch.IntPatch_HInterTool_Bounds(*args)

def IntPatch_HInterTool_HasBeenSeen(*args) -> "Standard_Boolean":
    """
    Returns true if all the intersection point and edges are known on the arc. the intersection point are given as vertices. the intersection edges are given as intervals between two vertices.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d

    Returns
    -------
    bool

    """
    return _IntPatch.IntPatch_HInterTool_HasBeenSeen(*args)

def IntPatch_HInterTool_HasFirstPoint(*args) -> "Standard_Integer &":
    """
    Returns true when the segment of range index is not open at the left side. in that case, indfirst is the range in the list intersection points (see nbpoints) of the one which defines the left bound of the segment. otherwise, the method has to return false, and indfirst has no meaning.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d
    Index: int

    Returns
    -------
    IndFirst: int

    """
    return _IntPatch.IntPatch_HInterTool_HasFirstPoint(*args)

def IntPatch_HInterTool_HasLastPoint(*args) -> "Standard_Integer &":
    """
    Returns true when the segment of range index is not open at the right side. in that case, indlast is the range in the list intersection points (see nbpoints) of the one which defines the right bound of the segment. otherwise, the method has to return false, and indlast has no meaning.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d
    Index: int

    Returns
    -------
    IndLast: int

    """
    return _IntPatch.IntPatch_HInterTool_HasLastPoint(*args)

def IntPatch_HInterTool_IsAllSolution(*args) -> "Standard_Boolean":
    """
    Returns true when the whole restriction is solution of the intersection problem.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d

    Returns
    -------
    bool

    """
    return _IntPatch.IntPatch_HInterTool_IsAllSolution(*args)

def IntPatch_HInterTool_IsVertex(*args) -> "Standard_Boolean":
    """
    Returns true if the intersection point of range index corresponds with a vertex on the arc a.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d
    Index: int

    Returns
    -------
    bool

    """
    return _IntPatch.IntPatch_HInterTool_IsVertex(*args)

def IntPatch_HInterTool_NbPoints(*args) -> "Standard_Integer":
    """
    Returns the number of intersection points on the arc a.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d

    Returns
    -------
    int

    """
    return _IntPatch.IntPatch_HInterTool_NbPoints(*args)

def IntPatch_HInterTool_NbSamplesOnArc(*args) -> "Standard_Integer":
    """
    Returns the number of points which is used to make a sample on the arc. this number is a function of the surface and the curveonsurface complexity.

    Parameters
    ----------
    A: Adaptor2d_HCurve2d

    Returns
    -------
    int

    """
    return _IntPatch.IntPatch_HInterTool_NbSamplesOnArc(*args)

def IntPatch_HInterTool_NbSamplesU(*args) -> "Standard_Integer":
    """
    No available documentation.

    Parameters
    ----------
    S: Adaptor3d_HSurface
    u1: float
    u2: float

    Returns
    -------
    int

    """
    return _IntPatch.IntPatch_HInterTool_NbSamplesU(*args)

def IntPatch_HInterTool_NbSamplesV(*args) -> "Standard_Integer":
    """
    No available documentation.

    Parameters
    ----------
    S: Adaptor3d_HSurface
    v1: float
    v2: float

    Returns
    -------
    int

    """
    return _IntPatch.IntPatch_HInterTool_NbSamplesV(*args)

def IntPatch_HInterTool_NbSegments(*args) -> "Standard_Integer":
    """
    Returns the number of part of a solution of the of intersection problem.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d

    Returns
    -------
    int

    """
    return _IntPatch.IntPatch_HInterTool_NbSegments(*args)

def IntPatch_HInterTool_Parameter(*args) -> "Standard_Real":
    """
    Returns the parameter of the vertex v on the arc a.

    Parameters
    ----------
    V: Adaptor3d_HVertex
    C: Adaptor2d_HCurve2d

    Returns
    -------
    float

    """
    return _IntPatch.IntPatch_HInterTool_Parameter(*args)

def IntPatch_HInterTool_Project(*args) -> "Standard_Real &":
    """
    Projects the point p on the arc c. if the methods returns standard_true, the projection is successful, and paramproj is the parameter on the arc of the projected point, ptproj is the projected point. if the method returns standard_false, param proj and ptproj are not significant.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d
    P: gp_Pnt2d
    Ptproj: gp_Pnt2d

    Returns
    -------
    Paramproj: float

    """
    return _IntPatch.IntPatch_HInterTool_Project(*args)

def IntPatch_HInterTool_SingularOnUMax(*args) -> "Standard_Boolean":
    """
    No available documentation.

    Parameters
    ----------
    S: Adaptor3d_HSurface

    Returns
    -------
    bool

    """
    return _IntPatch.IntPatch_HInterTool_SingularOnUMax(*args)

def IntPatch_HInterTool_SingularOnUMin(*args) -> "Standard_Boolean":
    """
    No available documentation.

    Parameters
    ----------
    S: Adaptor3d_HSurface

    Returns
    -------
    bool

    """
    return _IntPatch.IntPatch_HInterTool_SingularOnUMin(*args)

def IntPatch_HInterTool_SingularOnVMax(*args) -> "Standard_Boolean":
    """
    No available documentation.

    Parameters
    ----------
    S: Adaptor3d_HSurface

    Returns
    -------
    bool

    """
    return _IntPatch.IntPatch_HInterTool_SingularOnVMax(*args)

def IntPatch_HInterTool_SingularOnVMin(*args) -> "Standard_Boolean":
    """
    No available documentation.

    Parameters
    ----------
    S: Adaptor3d_HSurface

    Returns
    -------
    bool

    """
    return _IntPatch.IntPatch_HInterTool_SingularOnVMin(*args)

def IntPatch_HInterTool_Tolerance(*args) -> "Standard_Real":
    """
    Returns the parametric tolerance used to consider that the vertex and another point meet, i-e if abs(parameter(vertex) - parameter(otherpnt))<= tolerance, the points are 'merged'.

    Parameters
    ----------
    V: Adaptor3d_HVertex
    C: Adaptor2d_HCurve2d

    Returns
    -------
    float

    """
    return _IntPatch.IntPatch_HInterTool_Tolerance(*args)

def IntPatch_HInterTool_Value(*args) -> "Standard_Real &, Standard_Real &":
    """
    Returns the value (pt), the tolerance (tol), and the parameter (u) on the arc a , of the intersection point of range index.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d
    Index: int
    Pt: gp_Pnt

    Returns
    -------
    Tol: float
    U: float

    """
    return _IntPatch.IntPatch_HInterTool_Value(*args)

def IntPatch_HInterTool_Vertex(*args) -> "void":
    """
    When isvertex returns true, this method returns the vertex on the arc a.

    Parameters
    ----------
    C: Adaptor2d_HCurve2d
    Index: int
    V: Adaptor3d_HVertex

    Returns
    -------
    None

    """
    return _IntPatch.IntPatch_HInterTool_Vertex(*args)

class IntPatch_ImpImpIntersection(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_ImpImpIntersection, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_ImpImpIntersection, name)
    __repr__ = _swig_repr
    IntStatus_OK = _IntPatch.IntPatch_ImpImpIntersection_IntStatus_OK
    IntStatus_InfiniteSectionCurve = _IntPatch.IntPatch_ImpImpIntersection_IntStatus_InfiniteSectionCurve
    IntStatus_Fail = _IntPatch.IntPatch_ImpImpIntersection_IntStatus_Fail


    class IntStatus(IntEnum):
    	IntStatus_OK = 0
    	IntStatus_InfiniteSectionCurve = 1
    	IntStatus_Fail = 2
    IntStatus_OK = IntStatus.IntStatus_OK
    IntStatus_InfiniteSectionCurve = IntStatus.IntStatus_InfiniteSectionCurve
    IntStatus_Fail = IntStatus.IntStatus_Fail


    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        Flag theisreqtokeeprline has been entered only for compatibility with topopebrep package. it shall be deleted after deleting topopebrep. when intersection result returns intpatch_rline and another intpatch_line (not restriction) we (in case of theisreqtokeeprline==true) will always keep both lines even if they are coincided.

        Parameters
        ----------
        S1: Adaptor3d_HSurface
        D1: Adaptor3d_TopolTool
        S2: Adaptor3d_HSurface
        D2: Adaptor3d_TopolTool
        TolArc: float
        TolTang: float
        theIsReqToKeepRLine: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_ImpImpIntersection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the calculus was successful.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_ImpImpIntersection_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        Returns true if the is no intersection.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_ImpImpIntersection_IsEmpty(self, *args)


    def Line(self, *args) -> "opencascade::handle< IntPatch_Line > const &":
        """
        Returns the line of range index. an exception is raised if index<=0 or index>nbline.

        Parameters
        ----------
        Index: int

        Returns
        -------
        opencascade::handle<IntPatch_Line>

        """
        return _IntPatch.IntPatch_ImpImpIntersection_Line(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """
        Returns the number of intersection lines.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_ImpImpIntersection_NbLines(self, *args)


    def NbPnts(self, *args) -> "Standard_Integer":
        """
        Returns the number of 'single' points.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_ImpImpIntersection_NbPnts(self, *args)


    def OppositeFaces(self, *args) -> "Standard_Boolean":
        """
        Returns true when the tangentfaces returns true and the normal vectors evaluated at a point on the first and the second surface are opposite. the exception domainerror is raised if tangentfaces returns false.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_ImpImpIntersection_OppositeFaces(self, *args)


    def Perform(self, *args) -> "void":
        """
        Flag theisreqtokeeprline has been entered only for compatibility with topopebrep package. it shall be deleted after deleting topopebrep. when intersection result returns intpatch_rline and another intpatch_line (not restriction) we (in case of theisreqtokeeprline==true) will always keep both lines even if they are coincided.

        Parameters
        ----------
        S1: Adaptor3d_HSurface
        D1: Adaptor3d_TopolTool
        S2: Adaptor3d_HSurface
        D2: Adaptor3d_TopolTool
        TolArc: float
        TolTang: float
        theIsReqToKeepRLine: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_ImpImpIntersection_Perform(self, *args)


    def Point(self, *args) -> "IntPatch_Point const &":
        """
        Returns the point of range index. an exception is raised if index<=0 or index>nbpnt.

        Parameters
        ----------
        Index: int

        Returns
        -------
        IntPatch_Point

        """
        return _IntPatch.IntPatch_ImpImpIntersection_Point(self, *args)


    def TangentFaces(self, *args) -> "Standard_Boolean":
        """
        Returns true if the two patches are considered as entirely tangent, i.e every restriction arc of one patch is inside the geometric base of the other patch.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_ImpImpIntersection_TangentFaces(self, *args)


    __repr__ = _dumps_object

    @methodnotwrapped
    def GetStatus(self):
    	pass

    __swig_destroy__ = _IntPatch.delete_IntPatch_ImpImpIntersection
    __del__ = lambda self: None
IntPatch_ImpImpIntersection_swigregister = _IntPatch.IntPatch_ImpImpIntersection_swigregister
IntPatch_ImpImpIntersection_swigregister(IntPatch_ImpImpIntersection)

class IntPatch_ImpPrmIntersection(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_ImpPrmIntersection, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_ImpPrmIntersection, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        Surf1: Adaptor3d_HSurface
        D1: Adaptor3d_TopolTool
        Surf2: Adaptor3d_HSurface
        D2: Adaptor3d_TopolTool
        TolArc: float
        TolTang: float
        Fleche: float
        Pas: float

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_ImpPrmIntersection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the calculus was succesfull.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        Returns true if the is no intersection.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_IsEmpty(self, *args)


    def Line(self, *args) -> "opencascade::handle< IntPatch_Line > const &":
        """
        Returns the line of range index. an exception is raised if index<=0 or index>nbline.

        Parameters
        ----------
        Index: int

        Returns
        -------
        opencascade::handle<IntPatch_Line>

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_Line(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """
        Returns the number of intersection lines.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_NbLines(self, *args)


    def NbPnts(self, *args) -> "Standard_Integer":
        """
        Returns the number of 'single' points.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_NbPnts(self, *args)


    def Perform(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        Surf1: Adaptor3d_HSurface
        D1: Adaptor3d_TopolTool
        Surf2: Adaptor3d_HSurface
        D2: Adaptor3d_TopolTool
        TolArc: float
        TolTang: float
        Fleche: float
        Pas: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_Perform(self, *args)


    def Point(self, *args) -> "IntPatch_Point const &":
        """
        Returns the point of range index. an exception is raised if index<=0 or index>nbpnt.

        Parameters
        ----------
        Index: int

        Returns
        -------
        IntPatch_Point

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_Point(self, *args)


    def SetStartPoint(self, *args) -> "void":
        """
        To search for solution from the given point.

        Parameters
        ----------
        U: float
        V: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_ImpPrmIntersection_SetStartPoint(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_ImpPrmIntersection
    __del__ = lambda self: None
IntPatch_ImpPrmIntersection_swigregister = _IntPatch.IntPatch_ImpPrmIntersection_swigregister
IntPatch_ImpPrmIntersection_swigregister(IntPatch_ImpPrmIntersection)

class IntPatch_InterferencePolyhedron(OCC.Core.Intf.Intf_Interference):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Intf.Intf_Interference]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_InterferencePolyhedron, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Intf.Intf_Interference]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_InterferencePolyhedron, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Constructs an empty interference of polyhedron.

        Returns
        -------
        None

        Constructs and computes an interference between the two polyhedra.

        Parameters
        ----------
        Obje1: IntPatch_Polyhedron
        Obje2: IntPatch_Polyhedron

        Returns
        -------
        None

        Constructs and computes the self interference of a polyhedron.

        Parameters
        ----------
        Obje: IntPatch_Polyhedron

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_InterferencePolyhedron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args) -> "void":
        """
        Computes the interference between the two polyhedra.

        Parameters
        ----------
        Obje1: IntPatch_Polyhedron
        Obje2: IntPatch_Polyhedron

        Returns
        -------
        None

        Computes the self interference of a polyhedron.

        Parameters
        ----------
        Obje: IntPatch_Polyhedron

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_InterferencePolyhedron_Perform(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_InterferencePolyhedron
    __del__ = lambda self: None
IntPatch_InterferencePolyhedron_swigregister = _IntPatch.IntPatch_InterferencePolyhedron_swigregister
IntPatch_InterferencePolyhedron_swigregister(IntPatch_InterferencePolyhedron)

class IntPatch_Intersection(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_Intersection, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_Intersection, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        S1: Adaptor3d_HSurface
        D1: Adaptor3d_TopolTool
        S2: Adaptor3d_HSurface
        D2: Adaptor3d_TopolTool
        TolArc: float
        TolTang: float

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        S1: Adaptor3d_HSurface
        D1: Adaptor3d_TopolTool
        TolArc: float
        TolTang: float

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_Intersection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Dump(self, *args) -> "void":
        """
        Dump of each result line. mode for more accurate dumps.

        Parameters
        ----------
        Mode: int
        S1: Adaptor3d_HSurface
        D1: Adaptor3d_TopolTool
        S2: Adaptor3d_HSurface
        D2: Adaptor3d_TopolTool

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_Intersection_Dump(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the calculus was successful.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_Intersection_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        Returns true if the is no intersection.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_Intersection_IsEmpty(self, *args)


    def Line(self, *args) -> "opencascade::handle< IntPatch_Line > const &":
        """
        Returns the line of range index. an exception is raised if index<=0 or index>nbline.

        Parameters
        ----------
        Index: int

        Returns
        -------
        opencascade::handle<IntPatch_Line>

        """
        return _IntPatch.IntPatch_Intersection_Line(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """
        Returns the number of intersection lines.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_Intersection_NbLines(self, *args)


    def NbPnts(self, *args) -> "Standard_Integer":
        """
        Returns the number of 'single' points.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_Intersection_NbPnts(self, *args)


    def OppositeFaces(self, *args) -> "Standard_Boolean":
        """
        Returns true when the tangentfaces returns true and the normal vectors evaluated at a point on the first and the second surface are opposite. the exception domainerror is raised if tangentfaces returns false.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_Intersection_OppositeFaces(self, *args)


    def Perform(self, *args) -> "void":
        """
        Flag theisreqtokeeprline has been entered only for compatibility with topopebrep package. it shall be deleted after deleting topopebrep. when intersection result returns intpatch_rline and another intpatch_line (not restriction) we (in case of theisreqtokeeprline==true) will always keep both lines even if they are coincided. flag theisreqtopostwlproc has been entered only for compatibility with topopebrep package. it shall be deleted after deleting topopebrep. if theisreqtopostwlproc == false, then we will work with walking-line obtained after intersection algorithm directly (wothout any post-processing). .

        Parameters
        ----------
        S1: Adaptor3d_HSurface
        D1: Adaptor3d_TopolTool
        S2: Adaptor3d_HSurface
        D2: Adaptor3d_TopolTool
        TolArc: float
        TolTang: float
        isGeomInt: bool,optional
        	default value is Standard_True
        theIsReqToKeepRLine: bool,optional
        	default value is Standard_False
        theIsReqToPostWLProc: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        If isgeomint == standard_false, then method param-param intersection will be used. flag theisreqtokeeprline has been entered only for compatibility with topopebrep package. it shall be deleted after deleting topopebrep. when intersection result returns intpatch_rline and another intpatch_line (not restriction) we (in case of theisreqtokeeprline==true) will always keep both lines even if they are coincided. flag theisreqtopostwlproc has been entered only for compatibility with topopebrep package. it shall be deleted after deleting topopebrep. if theisreqtopostwlproc == false, then we will work with walking-line obtained after intersection algorithm directly (without any post-processing). .

        Parameters
        ----------
        S1: Adaptor3d_HSurface
        D1: Adaptor3d_TopolTool
        S2: Adaptor3d_HSurface
        D2: Adaptor3d_TopolTool
        TolArc: float
        TolTang: float
        LOfPnts: IntSurf_ListOfPntOn2S
        isGeomInt: bool,optional
        	default value is Standard_True
        theIsReqToKeepRLine: bool,optional
        	default value is Standard_False
        theIsReqToPostWLProc: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        Perform with start point.

        Parameters
        ----------
        S1: Adaptor3d_HSurface
        D1: Adaptor3d_TopolTool
        S2: Adaptor3d_HSurface
        D2: Adaptor3d_TopolTool
        U1: float
        V1: float
        U2: float
        V2: float
        TolArc: float
        TolTang: float

        Returns
        -------
        None

        Uses for finding self-intersected surfaces.

        Parameters
        ----------
        S1: Adaptor3d_HSurface
        D1: Adaptor3d_TopolTool
        TolArc: float
        TolTang: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_Intersection_Perform(self, *args)


    def Point(self, *args) -> "IntPatch_Point const &":
        """
        Returns the point of range index. an exception is raised if index<=0 or index>nbpnt.

        Parameters
        ----------
        Index: int

        Returns
        -------
        IntPatch_Point

        """
        return _IntPatch.IntPatch_Intersection_Point(self, *args)


    def SequenceOfLine(self, *args) -> "IntPatch_SequenceOfLine const &":
        """
        No available documentation.

        Returns
        -------
        IntPatch_SequenceOfLine

        """
        return _IntPatch.IntPatch_Intersection_SequenceOfLine(self, *args)


    def SetTolerances(self, *args) -> "void":
        """
        Set the tolerances used by the algorithms: --- implicit - parametric --- parametric - parametric --- implicit - implicit //! tolarc is used to compute the intersections between the restrictions of a surface and a walking line. //! toltang is used to compute the points on a walking line, and in geometric algorithms. //! fleche is a parameter used in the walking algorithms to provide small curvatures on a line. //! uvmaxstep is a parameter used in the walking algorithms to compute the distance between to points in their respective parametric spaces.

        Parameters
        ----------
        TolArc: float
        TolTang: float
        UVMaxStep: float
        Fleche: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_Intersection_SetTolerances(self, *args)


    def TangentFaces(self, *args) -> "Standard_Boolean":
        """
        Returns true if the two patches are considered as entirely tangent, i-e every restriction arc of one patch is inside the geometric base of the other patch.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_Intersection_TangentFaces(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_Intersection
    __del__ = lambda self: None
IntPatch_Intersection_swigregister = _IntPatch.IntPatch_Intersection_swigregister
IntPatch_Intersection_swigregister(IntPatch_Intersection)

class IntPatch_Line(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_Line, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_Line, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ArcType(self, *args) -> "IntPatch_IType":
        """
        Returns the type of geometry 3d (line, circle, parabola, hyperbola, ellipse, analytic, walking, restriction).

        Returns
        -------
        IntPatch_IType

        """
        return _IntPatch.IntPatch_Line_ArcType(self, *args)


    def IsTangent(self, *args) -> "Standard_Boolean":
        """
        Returns true if the intersection is a line of tangency between the 2 patches.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_Line_IsTangent(self, *args)


    def IsUIsoOnS1(self, *args) -> "Standard_Boolean":
        """
        Returns true if the intersection is a u isoparametric curve on the first patch.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_Line_IsUIsoOnS1(self, *args)


    def IsUIsoOnS2(self, *args) -> "Standard_Boolean":
        """
        Returns true if the intersection is a u isoparametric curve on the second patch.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_Line_IsUIsoOnS2(self, *args)


    def IsVIsoOnS1(self, *args) -> "Standard_Boolean":
        """
        Returns true if the intersection is a v isoparametric curve on the first patch.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_Line_IsVIsoOnS1(self, *args)


    def IsVIsoOnS2(self, *args) -> "Standard_Boolean":
        """
        Returns true if the intersection is a v isoparametric curve on the second patch.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_Line_IsVIsoOnS2(self, *args)


    def SetValue(self, *args) -> "void":
        """
        To set the values returned by isuisos1,.... the default values are false.

        Parameters
        ----------
        Uiso1: bool
        Viso1: bool
        Uiso2: bool
        Viso2: bool

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_Line_SetValue(self, *args)


    def SituationS1(self, *args) -> "IntSurf_Situation":
        """
        Returns the situation (inside/outside/unknown) of the first patch compared to the second one, when transitionons1 or transitionons2 returns touch. otherwise, an exception is raised.

        Returns
        -------
        IntSurf_Situation

        """
        return _IntPatch.IntPatch_Line_SituationS1(self, *args)


    def SituationS2(self, *args) -> "IntSurf_Situation":
        """
        Returns the situation (inside/outside/unknown) of the second patch compared to the first one, when transitionons1 or transitionons2 returns touch. otherwise, an exception is raised.

        Returns
        -------
        IntSurf_Situation

        """
        return _IntPatch.IntPatch_Line_SituationS2(self, *args)


    def TransitionOnS1(self, *args) -> "IntSurf_TypeTrans":
        """
        Returns the type of the transition of the line for the first surface. the transition is 'constant' along the line. the transition is in if the line is oriented in such a way that the system of vector (n1,n2,t) is right-handed, where n1 is the normal to the first surface at a point p, n2 is the normal to the second surface at a point p, t is the tangent to the intersection line at p. if the system of vector is left-handed, the transition is out. when n1 and n2 are colinear all along the intersection line, the transition will be - touch, if it is possible to use the 2nd derivatives to determine the position of one surafce compared to the other (see situation) - undecided otherwise. //! if one of the transition is touch or undecided, the other one has got the same value.

        Returns
        -------
        IntSurf_TypeTrans

        """
        return _IntPatch.IntPatch_Line_TransitionOnS1(self, *args)


    def TransitionOnS2(self, *args) -> "IntSurf_TypeTrans":
        """
        Returns the type of the transition of the line for the second surface. the transition is 'constant' along the line.

        Returns
        -------
        IntSurf_TypeTrans

        """
        return _IntPatch.IntPatch_Line_TransitionOnS2(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IntPatch_Line_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_Line
    __del__ = lambda self: None
IntPatch_Line_swigregister = _IntPatch.IntPatch_Line_swigregister
IntPatch_Line_swigregister(IntPatch_Line)

class IntPatch_LineConstructor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_LineConstructor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_LineConstructor, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        mode: int

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_LineConstructor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Line(self, *args) -> "opencascade::handle< IntPatch_Line >":
        """
        No available documentation.

        Parameters
        ----------
        index: int

        Returns
        -------
        opencascade::handle<IntPatch_Line>

        """
        return _IntPatch.IntPatch_LineConstructor_Line(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_LineConstructor_NbLines(self, *args)


    def Perform(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        SL: IntPatch_SequenceOfLine
        L: IntPatch_Line
        S1: Adaptor3d_HSurface
        D1: Adaptor3d_TopolTool
        S2: Adaptor3d_HSurface
        D2: Adaptor3d_TopolTool
        Tol: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_LineConstructor_Perform(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_LineConstructor
    __del__ = lambda self: None
IntPatch_LineConstructor_swigregister = _IntPatch.IntPatch_LineConstructor_swigregister
IntPatch_LineConstructor_swigregister(IntPatch_LineConstructor)

class IntPatch_Point(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_Point, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_Point, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Empty constructor.

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_Point(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ArcOnS1(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d > const &":
        """
        Returns the arc of restriction containing the vertex. the exception domainerror is raised if isondoms1 returns false.

        Returns
        -------
        opencascade::handle<Adaptor2d_HCurve2d>

        """
        return _IntPatch.IntPatch_Point_ArcOnS1(self, *args)


    def ArcOnS2(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d > const &":
        """
        Returns the arc of restriction containing the vertex. the exception domainerror is raised if isondoms2 returns false.

        Returns
        -------
        opencascade::handle<Adaptor2d_HCurve2d>

        """
        return _IntPatch.IntPatch_Point_ArcOnS2(self, *args)


    def Dump(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_Point_Dump(self, *args)


    def IsMultiple(self, *args) -> "Standard_Boolean":
        """
        Returns true if the point belongs to several intersection lines.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_Point_IsMultiple(self, *args)


    def IsOnDomS1(self, *args) -> "Standard_Boolean":
        """
        Returns true if the point is on a boundary of the domain of the first patch.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_Point_IsOnDomS1(self, *args)


    def IsOnDomS2(self, *args) -> "Standard_Boolean":
        """
        Returns true if the point is on a boundary of the domain of the second patch.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_Point_IsOnDomS2(self, *args)


    def IsTangencyPoint(self, *args) -> "Standard_Boolean":
        """
        Returns true if the point is a tangency point between the surfaces. if the point is on one of the domain (isondoms1 returns true or isondoms2 returns true), an exception is raised.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_Point_IsTangencyPoint(self, *args)


    def IsVertexOnS1(self, *args) -> "Standard_Boolean":
        """
        Returns true if the point is a vertex on the initial restriction facet of the first surface.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_Point_IsVertexOnS1(self, *args)


    def IsVertexOnS2(self, *args) -> "Standard_Boolean":
        """
        Returns true if the point is a vertex on the initial restriction facet of the first surface.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_Point_IsVertexOnS2(self, *args)


    def ParameterOnArc1(self, *args) -> "Standard_Real":
        """
        Returns the parameter of the point on the arc returned by the method arcons2. the exception domainerror is raised if isondoms1 returns false.

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_Point_ParameterOnArc1(self, *args)


    def ParameterOnArc2(self, *args) -> "Standard_Real":
        """
        Returns the parameter of the point on the arc returned by the method arcons2. the exception domainerror is raised if isondoms2 returns false.

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_Point_ParameterOnArc2(self, *args)


    def ParameterOnLine(self, *args) -> "Standard_Real":
        """
        This method returns the parameter of the point on the intersection line. if the points does not belong to an intersection line, the value returned does not have any sens.

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_Point_ParameterOnLine(self, *args)


    def Parameters(self, *args) -> "void":
        """
        Returns the parameters on the first and on the second surface of the point.

        Parameters
        ----------

        Returns
        -------
        U1: float
        V1: float
        U2: float
        V2: float

        """
        return _IntPatch.IntPatch_Point_Parameters(self, *args)


    def ParametersOnS1(self, *args) -> "void":
        """
        Returns the parameters on the first surface of the point.

        Parameters
        ----------

        Returns
        -------
        U1: float
        V1: float

        """
        return _IntPatch.IntPatch_Point_ParametersOnS1(self, *args)


    def ParametersOnS2(self, *args) -> "void":
        """
        Returns the parameters on the second surface of the point.

        Parameters
        ----------

        Returns
        -------
        U2: float
        V2: float

        """
        return _IntPatch.IntPatch_Point_ParametersOnS2(self, *args)


    def PntOn2S(self, *args) -> "IntSurf_PntOn2S const &":
        """
        Returns the pnton2s (geometric point and the parameters).

        Returns
        -------
        IntSurf_PntOn2S

        """
        return _IntPatch.IntPatch_Point_PntOn2S(self, *args)


    def ReverseTransition(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_Point_ReverseTransition(self, *args)


    def SetArc(self, *args) -> "void":
        """
        Sets the values of a point which is on one of the domain, when both surfaces are implicit ones. if onfirst is true, the point is on the domain of the first patch, otherwise the point is on the domain of the second surface.

        Parameters
        ----------
        OnFirst: bool
        A: Adaptor2d_HCurve2d
        Param: float
        TLine: IntSurf_Transition
        TArc: IntSurf_Transition

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_Point_SetArc(self, *args)


    def SetMultiple(self, *args) -> "void":
        """
        Sets (or unsets) the point as a point on several intersection line.

        Parameters
        ----------
        IsMult: bool

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_Point_SetMultiple(self, *args)


    def SetParameter(self, *args) -> "void":
        """
        Set the value of the parameter on the intersection line.

        Parameters
        ----------
        Para: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_Point_SetParameter(self, *args)


    def SetParameters(self, *args) -> "void":
        """
        Sets the values of the parameters of the point on each surface.

        Parameters
        ----------
        U1: float
        V1: float
        U2: float
        V2: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_Point_SetParameters(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        Tol: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_Point_SetTolerance(self, *args)


    def SetValue(self, *args) -> "void":
        """
        Sets the values of a point which is on no domain, when both surfaces are implicit ones. if tangent is true, the point is a point of tangency between the surfaces.

        Parameters
        ----------
        Pt: gp_Pnt
        Tol: float
        Tangent: bool

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        Pt: gp_Pnt

        Returns
        -------
        None

        Sets the value of <pt> member.

        Parameters
        ----------
        thePOn2S: IntSurf_PntOn2S

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_Point_SetValue(self, *args)


    def SetVertex(self, *args) -> "void":
        """
        Sets the values of a point which is a vertex on the initial facet of restriction of one of the surface. if onfirst is true, the point is on the domain of the first patch, otherwise the point is on the domain of the second surface.

        Parameters
        ----------
        OnFirst: bool
        V: Adaptor3d_HVertex

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_Point_SetVertex(self, *args)


    def Tolerance(self, *args) -> "Standard_Real":
        """
        This method returns the fuzziness on the point.

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_Point_Tolerance(self, *args)


    def TransitionLineArc1(self, *args) -> "IntSurf_Transition const &":
        """
        Returns the transition of the point on the intersection line with the arc on s1. the exception domainerror is raised if isondoms1 returns false.

        Returns
        -------
        IntSurf_Transition

        """
        return _IntPatch.IntPatch_Point_TransitionLineArc1(self, *args)


    def TransitionLineArc2(self, *args) -> "IntSurf_Transition const &":
        """
        Returns the transition of the point on the intersection line with the arc on s2. the exception domainerror is raised if isondoms2 returns false.

        Returns
        -------
        IntSurf_Transition

        """
        return _IntPatch.IntPatch_Point_TransitionLineArc2(self, *args)


    def TransitionOnS1(self, *args) -> "IntSurf_Transition const &":
        """
        Returns the transition between the intersection line returned by the method line and the arc on s1 returned by arcons1(). the exception domainerror is raised if isondoms1 returns false.

        Returns
        -------
        IntSurf_Transition

        """
        return _IntPatch.IntPatch_Point_TransitionOnS1(self, *args)


    def TransitionOnS2(self, *args) -> "IntSurf_Transition const &":
        """
        Returns the transition between the intersection line returned by the method line and the arc on s2 returned by arcons2. the exception domainerror is raised if isondoms2 returns false.

        Returns
        -------
        IntSurf_Transition

        """
        return _IntPatch.IntPatch_Point_TransitionOnS2(self, *args)


    def Value(self, *args) -> "gp_Pnt const":
        """
        Returns the intersection point (geometric information).

        Returns
        -------
        gp_Pnt

        """
        return _IntPatch.IntPatch_Point_Value(self, *args)


    def VertexOnS1(self, *args) -> "opencascade::handle< Adaptor3d_HVertex > const &":
        """
        Returns the information about the point when it is on the domain of the first patch, i-e when the function isvertexons1 returns true. otherwise, an exception is raised.

        Returns
        -------
        opencascade::handle<Adaptor3d_HVertex>

        """
        return _IntPatch.IntPatch_Point_VertexOnS1(self, *args)


    def VertexOnS2(self, *args) -> "opencascade::handle< Adaptor3d_HVertex > const &":
        """
        Returns the information about the point when it is on the domain of the second patch, i-e when the function isvertexons2 returns true. otherwise, an exception is raised.

        Returns
        -------
        opencascade::handle<Adaptor3d_HVertex>

        """
        return _IntPatch.IntPatch_Point_VertexOnS2(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_Point
    __del__ = lambda self: None
IntPatch_Point_swigregister = _IntPatch.IntPatch_Point_swigregister
IntPatch_Point_swigregister(IntPatch_Point)

class IntPatch_Polygo(OCC.Core.Intf.Intf_Polygon2d):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Intf.Intf_Polygon2d]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_Polygo, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Intf.Intf_Polygon2d]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_Polygo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Dump(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_Polygo_Dump(self, *args)


    def Error(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_Polygo_Error(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_Polygo_NbPoints(self, *args)


    def Point(self, *args) -> "gp_Pnt2d":
        """
        No available documentation.

        Parameters
        ----------
        Index: int

        Returns
        -------
        gp_Pnt2d

        """
        return _IntPatch.IntPatch_Polygo_Point(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_Polygo
    __del__ = lambda self: None
IntPatch_Polygo_swigregister = _IntPatch.IntPatch_Polygo_swigregister
IntPatch_Polygo_swigregister(IntPatch_Polygo)

class IntPatch_PolyhedronTool(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_PolyhedronTool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_PolyhedronTool, name)
    __repr__ = _swig_repr

    def Bounding(*args) -> "Bnd_Box const &":
        """
        Give the bounding box of the polyhedron.

        Parameters
        ----------
        thePolyh: IntPatch_Polyhedron

        Returns
        -------
        Bnd_Box

        """
        return _IntPatch.IntPatch_PolyhedronTool_Bounding(*args)

    Bounding = staticmethod(Bounding)

    def ComponentsBounding(*args) -> "opencascade::handle< Bnd_HArray1OfBox > const &":
        """
        Give the array of boxes. the box <n> corresponding to the triangle <n>.

        Parameters
        ----------
        thePolyh: IntPatch_Polyhedron

        Returns
        -------
        opencascade::handle<Bnd_HArray1OfBox>

        """
        return _IntPatch.IntPatch_PolyhedronTool_ComponentsBounding(*args)

    ComponentsBounding = staticmethod(ComponentsBounding)

    def DeflectionOverEstimation(*args) -> "Standard_Real":
        """
        Give the tolerance of the polygon.

        Parameters
        ----------
        thePolyh: IntPatch_Polyhedron

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_PolyhedronTool_DeflectionOverEstimation(*args)

    DeflectionOverEstimation = staticmethod(DeflectionOverEstimation)

    def NbTriangles(*args) -> "Standard_Integer":
        """
        Give the number of triangles in this polyedral surface.

        Parameters
        ----------
        thePolyh: IntPatch_Polyhedron

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_PolyhedronTool_NbTriangles(*args)

    NbTriangles = staticmethod(NbTriangles)

    def Point(*args) -> "gp_Pnt const":
        """
        Give the point of index i in the polyedral surface.

        Parameters
        ----------
        thePolyh: IntPatch_Polyhedron
        Index: int

        Returns
        -------
        gp_Pnt

        """
        return _IntPatch.IntPatch_PolyhedronTool_Point(*args)

    Point = staticmethod(Point)

    def TriConnex(*args) -> "Standard_Integer &, Standard_Integer &":
        """
        Gives the addresse tricon of the triangle connexe to the triangle of address triang by the edge pivot pedge and the third point of this connexe triangle. when we are on a free edge tricon==0 but the function return the value of the triangle in the other side of pivot on the free edge. used to turn around a vertex.

        Parameters
        ----------
        thePolyh: IntPatch_Polyhedron
        Triang: int
        Pivot: int
        Pedge: int

        Returns
        -------
        TriCon: int
        OtherP: int

        """
        return _IntPatch.IntPatch_PolyhedronTool_TriConnex(*args)

    TriConnex = staticmethod(TriConnex)

    def Triangle(*args) -> "Standard_Integer &, Standard_Integer &, Standard_Integer &":
        """
        Give the indices of the 3 points of the triangle of address index in the polyhedron.

        Parameters
        ----------
        thePolyh: IntPatch_Polyhedron
        Index: int

        Returns
        -------
        P1: int
        P2: int
        P3: int

        """
        return _IntPatch.IntPatch_PolyhedronTool_Triangle(*args)

    Triangle = staticmethod(Triangle)

    __repr__ = _dumps_object


    def __init__(self):
        this = _IntPatch.new_IntPatch_PolyhedronTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPatch.delete_IntPatch_PolyhedronTool
    __del__ = lambda self: None
IntPatch_PolyhedronTool_swigregister = _IntPatch.IntPatch_PolyhedronTool_swigregister
IntPatch_PolyhedronTool_swigregister(IntPatch_PolyhedronTool)

def IntPatch_PolyhedronTool_Bounding(*args) -> "Bnd_Box const &":
    """
    Give the bounding box of the polyhedron.

    Parameters
    ----------
    thePolyh: IntPatch_Polyhedron

    Returns
    -------
    Bnd_Box

    """
    return _IntPatch.IntPatch_PolyhedronTool_Bounding(*args)

def IntPatch_PolyhedronTool_ComponentsBounding(*args) -> "opencascade::handle< Bnd_HArray1OfBox > const &":
    """
    Give the array of boxes. the box <n> corresponding to the triangle <n>.

    Parameters
    ----------
    thePolyh: IntPatch_Polyhedron

    Returns
    -------
    opencascade::handle<Bnd_HArray1OfBox>

    """
    return _IntPatch.IntPatch_PolyhedronTool_ComponentsBounding(*args)

def IntPatch_PolyhedronTool_DeflectionOverEstimation(*args) -> "Standard_Real":
    """
    Give the tolerance of the polygon.

    Parameters
    ----------
    thePolyh: IntPatch_Polyhedron

    Returns
    -------
    float

    """
    return _IntPatch.IntPatch_PolyhedronTool_DeflectionOverEstimation(*args)

def IntPatch_PolyhedronTool_NbTriangles(*args) -> "Standard_Integer":
    """
    Give the number of triangles in this polyedral surface.

    Parameters
    ----------
    thePolyh: IntPatch_Polyhedron

    Returns
    -------
    int

    """
    return _IntPatch.IntPatch_PolyhedronTool_NbTriangles(*args)

def IntPatch_PolyhedronTool_Point(*args) -> "gp_Pnt const":
    """
    Give the point of index i in the polyedral surface.

    Parameters
    ----------
    thePolyh: IntPatch_Polyhedron
    Index: int

    Returns
    -------
    gp_Pnt

    """
    return _IntPatch.IntPatch_PolyhedronTool_Point(*args)

def IntPatch_PolyhedronTool_TriConnex(*args) -> "Standard_Integer &, Standard_Integer &":
    """
    Gives the addresse tricon of the triangle connexe to the triangle of address triang by the edge pivot pedge and the third point of this connexe triangle. when we are on a free edge tricon==0 but the function return the value of the triangle in the other side of pivot on the free edge. used to turn around a vertex.

    Parameters
    ----------
    thePolyh: IntPatch_Polyhedron
    Triang: int
    Pivot: int
    Pedge: int

    Returns
    -------
    TriCon: int
    OtherP: int

    """
    return _IntPatch.IntPatch_PolyhedronTool_TriConnex(*args)

def IntPatch_PolyhedronTool_Triangle(*args) -> "Standard_Integer &, Standard_Integer &, Standard_Integer &":
    """
    Give the indices of the 3 points of the triangle of address index in the polyhedron.

    Parameters
    ----------
    thePolyh: IntPatch_Polyhedron
    Index: int

    Returns
    -------
    P1: int
    P2: int
    P3: int

    """
    return _IntPatch.IntPatch_PolyhedronTool_Triangle(*args)

class IntPatch_PrmPrmIntersection(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_PrmPrmIntersection, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_PrmPrmIntersection, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Empty constructor.

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_PrmPrmIntersection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CodeReject(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Parameters
        ----------
        x1: float
        y1: float
        z1: float
        x2: float
        y2: float
        z2: float
        x3: float
        y3: float
        z3: float

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_CodeReject(self, *args)


    def DansGrille(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Parameters
        ----------
        t: int

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_DansGrille(self, *args)


    def GrilleInteger(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Parameters
        ----------
        ix: int
        iy: int
        iz: int

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_GrilleInteger(self, *args)


    def IntegerGrille(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        t: int

        Returns
        -------
        ix: int
        iy: int
        iz: int

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_IntegerGrille(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the calculus was succesfull.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_IsDone(self, *args)


    def IsEmpty(self, *args) -> "Standard_Boolean":
        """
        Returns true if the is no intersection.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_IsEmpty(self, *args)


    def Line(self, *args) -> "opencascade::handle< IntPatch_Line > const &":
        """
        Returns the line of range index. an exception is raised if index<=0 or index>nbline.

        Parameters
        ----------
        Index: int

        Returns
        -------
        opencascade::handle<IntPatch_Line>

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_Line(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """
        Returns the number of intersection lines.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_NbLines(self, *args)


    def NbPointsGrille(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_NbPointsGrille(self, *args)


    def NewLine(self, *args) -> "opencascade::handle< IntPatch_Line >":
        """
        Computes about <nbpoints> intersection points on the line <indexline> between the points of index <lowpoint> and <highpoint>. //! all the points of the line of index <indexline> with an index between <lowpoint> and <highpoint> are in the returned line. new points are inserted between existing points if those points are not too closed. //! an exception is raised if index<=0 or index>nbline. or if isdone returns false.

        Parameters
        ----------
        Caro1: Adaptor3d_HSurface
        Caro2: Adaptor3d_HSurface
        IndexLine: int
        LowPoint: int
        HighPoint: int
        NbPoints: int

        Returns
        -------
        opencascade::handle<IntPatch_Line>

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_NewLine(self, *args)


    def Perform(self, *args) -> "void":
        """
        Performs the intersection between <caro1> and <caro2>. associated polyhedrons <polyhedron1> and <polyhedron2> are given.

        Parameters
        ----------
        Caro1: Adaptor3d_HSurface
        Polyhedron1: IntPatch_Polyhedron
        Domain1: Adaptor3d_TopolTool
        Caro2: Adaptor3d_HSurface
        Polyhedron2: IntPatch_Polyhedron
        Domain2: Adaptor3d_TopolTool
        TolTangency: float
        Epsilon: float
        Deflection: float
        Increment: float

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        Caro1: Adaptor3d_HSurface
        Polyhedron1: IntPatch_Polyhedron
        Domain1: Adaptor3d_TopolTool
        TolTangency: float
        Epsilon: float
        Deflection: float
        Increment: float

        Returns
        -------
        None

        Performs the intersection between <caro1> and <caro2>. the method computes the polyhedron on each surface.

        Parameters
        ----------
        Caro1: Adaptor3d_HSurface
        Domain1: Adaptor3d_TopolTool
        Caro2: Adaptor3d_HSurface
        Domain2: Adaptor3d_TopolTool
        TolTangency: float
        Epsilon: float
        Deflection: float
        Increment: float
        ClearFlag: bool,optional
        	default value is Standard_True

        Returns
        -------
        None

        Performs the intersection between <caro1> and <caro2>. the method computes the polyhedron on each surface.

        Parameters
        ----------
        Caro1: Adaptor3d_HSurface
        Domain1: Adaptor3d_TopolTool
        Caro2: Adaptor3d_HSurface
        Domain2: Adaptor3d_TopolTool
        TolTangency: float
        Epsilon: float
        Deflection: float
        Increment: float
        ListOfPnts: IntSurf_ListOfPntOn2S

        Returns
        -------
        None

        Performs the intersection between <caro1> and <caro2>. the method computes the polyhedron on each surface.

        Parameters
        ----------
        Caro1: Adaptor3d_HSurface
        Domain1: Adaptor3d_TopolTool
        Caro2: Adaptor3d_HSurface
        Domain2: Adaptor3d_TopolTool
        U1: float
        V1: float
        U2: float
        V2: float
        TolTangency: float
        Epsilon: float
        Deflection: float
        Increment: float

        Returns
        -------
        None

        Performs the intersection between <caro1> and <caro2>. the method computes the polyhedron on each surface.

        Parameters
        ----------
        Caro1: Adaptor3d_HSurface
        Domain1: Adaptor3d_TopolTool
        TolTangency: float
        Epsilon: float
        Deflection: float
        Increment: float

        Returns
        -------
        None

        Performs the intersection between <caro1> and <caro2>. //! the polyhedron which approximates <caro2>, <polyhedron2> is given. the other one is computed.

        Parameters
        ----------
        Caro1: Adaptor3d_HSurface
        Domain1: Adaptor3d_TopolTool
        Caro2: Adaptor3d_HSurface
        Polyhedron2: IntPatch_Polyhedron
        Domain2: Adaptor3d_TopolTool
        TolTangency: float
        Epsilon: float
        Deflection: float
        Increment: float

        Returns
        -------
        None

        Performs the intersection between <caro1> and <caro2>. //! the polyhedron which approximates <caro1>, <polyhedron1> is given. the other one is computed.

        Parameters
        ----------
        Caro1: Adaptor3d_HSurface
        Polyhedron1: IntPatch_Polyhedron
        Domain1: Adaptor3d_TopolTool
        Caro2: Adaptor3d_HSurface
        Domain2: Adaptor3d_TopolTool
        TolTangency: float
        Epsilon: float
        Deflection: float
        Increment: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_Perform(self, *args)


    def PointDepart(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        LineOn2S: IntSurf_LineOn2S
        S1: Adaptor3d_HSurface
        SU1: int
        SV1: int
        S2: Adaptor3d_HSurface
        SU2: int
        SV2: int

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_PointDepart(self, *args)


    def Remplit(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        a: int
        b: int
        c: int
        Map: IntPatch_PrmPrmIntersection_T3Bits

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_Remplit(self, *args)


    def RemplitLin(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        x1: int
        y1: int
        z1: int
        x2: int
        y2: int
        z2: int
        Map: IntPatch_PrmPrmIntersection_T3Bits

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_RemplitLin(self, *args)


    def RemplitTri(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        x1: int
        y1: int
        z1: int
        x2: int
        y2: int
        z2: int
        x3: int
        y3: int
        z3: int
        Map: IntPatch_PrmPrmIntersection_T3Bits

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_RemplitTri(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_PrmPrmIntersection
    __del__ = lambda self: None
IntPatch_PrmPrmIntersection_swigregister = _IntPatch.IntPatch_PrmPrmIntersection_swigregister
IntPatch_PrmPrmIntersection_swigregister(IntPatch_PrmPrmIntersection)

class IntPatch_PrmPrmIntersection_T3Bits(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_PrmPrmIntersection_T3Bits, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_PrmPrmIntersection_T3Bits, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        size: int

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_PrmPrmIntersection_T3Bits(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        t: int

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Add(self, *args)


    def And(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Parameters
        ----------
        Oth: IntPatch_PrmPrmIntersection_T3Bits

        Returns
        -------
        indiceprecedent: int

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_And(self, *args)


    def Destroy(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Destroy(self, *args)


    def Raz(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        t: int

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Raz(self, *args)


    def ResetAnd(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_ResetAnd(self, *args)


    def Val(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Parameters
        ----------
        t: int

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_Val(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_PrmPrmIntersection_T3Bits
    __del__ = lambda self: None
IntPatch_PrmPrmIntersection_T3Bits_swigregister = _IntPatch.IntPatch_PrmPrmIntersection_T3Bits_swigregister
IntPatch_PrmPrmIntersection_T3Bits_swigregister(IntPatch_PrmPrmIntersection_T3Bits)

class IntPatch_RstInt(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_RstInt, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_RstInt, name)
    __repr__ = _swig_repr

    def PutVertexOnLine(*args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        L: IntPatch_Line
        Surf: Adaptor3d_HSurface
        Domain: Adaptor3d_TopolTool
        OtherSurf: Adaptor3d_HSurface
        OnFirst: bool
        Tol: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_RstInt_PutVertexOnLine(*args)

    PutVertexOnLine = staticmethod(PutVertexOnLine)

    __repr__ = _dumps_object


    def __init__(self):
        this = _IntPatch.new_IntPatch_RstInt()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPatch.delete_IntPatch_RstInt
    __del__ = lambda self: None
IntPatch_RstInt_swigregister = _IntPatch.IntPatch_RstInt_swigregister
IntPatch_RstInt_swigregister(IntPatch_RstInt)

def IntPatch_RstInt_PutVertexOnLine(*args) -> "void":
    """
    No available documentation.

    Parameters
    ----------
    L: IntPatch_Line
    Surf: Adaptor3d_HSurface
    Domain: Adaptor3d_TopolTool
    OtherSurf: Adaptor3d_HSurface
    OnFirst: bool
    Tol: float

    Returns
    -------
    None

    """
    return _IntPatch.IntPatch_RstInt_PutVertexOnLine(*args)

class IntPatch_SpecialPoints(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_SpecialPoints, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_SpecialPoints, name)
    __repr__ = _swig_repr

    def AddCrossUVIsoPoint(*args) -> "Standard_Boolean":
        """
        Adds the point defined as intersection of two isolines (u = 0 and v = 0) on theqsurf in theline. therefpt is used to correct adjusting parameters. if theisreversed is true then theqsurf correspond to the second (otherwise, the first) surface while forming intersection point intsurf_pnton2s.

        Parameters
        ----------
        theQSurf: Adaptor3d_HSurface
        thePSurf: Adaptor3d_HSurface
        theRefPt: IntSurf_PntOn2S
        theTol3d: float
        theAddedPoint: IntSurf_PntOn2S
        theIsReversed: bool,optional
        	default value is Standard_False

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_SpecialPoints_AddCrossUVIsoPoint(*args)

    AddCrossUVIsoPoint = staticmethod(AddCrossUVIsoPoint)

    def AddPointOnUorVIso(*args) -> "Standard_Boolean":
        """
        Adds the point lain strictly in the isoline u = 0 or v = 0 of theqsurf, in theline. therefpt is used to correct adjusting parameters. if theisreversed is true then theqsurf corresponds to the second (otherwise, the first) surface while forming intersection point intsurf_pnton2s. all math_vector-objects must be filled as follows: [1] - u-parameter of thepsurf; [2] - v-parameter of thepsurf; [3] - u- (if v-isoline is considered) or v-parameter (if u-isoline is considered) of theqsurf.

        Parameters
        ----------
        theQSurf: Adaptor3d_HSurface
        thePSurf: Adaptor3d_HSurface
        theRefPt: IntSurf_PntOn2S
        theIsU: bool
        theIsoParameter: float
        theToler: math_Vector
        theInitPoint: math_Vector
        theInfBound: math_Vector
        theSupBound: math_Vector
        theAddedPoint: IntSurf_PntOn2S
        theIsReversed: bool,optional
        	default value is Standard_False

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_SpecialPoints_AddPointOnUorVIso(*args)

    AddPointOnUorVIso = staticmethod(AddPointOnUorVIso)

    def AddSingularPole(*args) -> "Standard_Boolean":
        """
        Computes the pole of sphere to add it in the intersection line. stores the result in theaddedpoint variable (does not add in the line). at that, cone and sphere (with singularity) must be set in theqsurf parameter. by default (if theisreversed == false), theqsurf is the first surface of the walking line. if it is not, theisreversed parameter must be set to true. theisreqrefcheck is true if and only if 3d-point of therefpt must be pole or apex for check (e.g. if it is vertex). theptiso is the reference point for obtaining isoline where must be placed the apex/pole. //! attention!!! thevertex must be initialized before calling the method .

        Parameters
        ----------
        theQSurf: Adaptor3d_HSurface
        thePSurf: Adaptor3d_HSurface
        thePtIso: IntSurf_PntOn2S
        theVertex: IntPatch_Point
        theAddedPoint: IntSurf_PntOn2S
        theIsReversed: bool,optional
        	default value is Standard_False
        theIsReqRefCheck: bool,optional
        	default value is Standard_False

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_SpecialPoints_AddSingularPole(*args)

    AddSingularPole = staticmethod(AddSingularPole)

    def AdjustPointAndVertex(*args) -> "void":
        """
        Sets thenewpoint parameters in 2d-space the closest to therefpoint with help of adding/subtracting corresponding periods. thearrperiods must be filled as follows: {<u-period of 1st surface>, <v-period of 1st surface>, <u-period of 2nd surface>, <v-period of 2nd surface>}. if thevertex != 0 then its parameters will be filled as corresponding parameters of thenewpoint. //! attention!!! thenewpoint is not only output parameter. it is input/output one. i.e. thenewpoint is reference point together with therefpt.

        Parameters
        ----------
        theRefPoint: IntSurf_PntOn2S
        theArrPeriods: float
        theNewPoint: IntSurf_PntOn2S
        theVertex: IntPatch_Point *,optional
        	default value is 0

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_SpecialPoints_AdjustPointAndVertex(*args)

    AdjustPointAndVertex = staticmethod(AdjustPointAndVertex)

    def ContinueAfterSpecialPoint(*args) -> "Standard_Boolean":
        """
        Special point has already been added in the line. now, we need in correct prolongation of the line or in start new line. this function returns new point. //! attention!!! thenewpoint is not only output parameter. it is input/output one. i.e. thenewpoint is reference point together with therefpt.

        Parameters
        ----------
        theQSurf: Adaptor3d_HSurface
        thePSurf: Adaptor3d_HSurface
        theRefPt: IntSurf_PntOn2S
        theSPType: IntPatch_SpecPntType
        theTol2D: float
        theNewPoint: IntSurf_PntOn2S
        theIsReversed: bool,optional
        	default value is Standard_False

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_SpecialPoints_ContinueAfterSpecialPoint(*args)

    ContinueAfterSpecialPoint = staticmethod(ContinueAfterSpecialPoint)

    __repr__ = _dumps_object


    def __init__(self):
        this = _IntPatch.new_IntPatch_SpecialPoints()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPatch.delete_IntPatch_SpecialPoints
    __del__ = lambda self: None
IntPatch_SpecialPoints_swigregister = _IntPatch.IntPatch_SpecialPoints_swigregister
IntPatch_SpecialPoints_swigregister(IntPatch_SpecialPoints)

def IntPatch_SpecialPoints_AddCrossUVIsoPoint(*args) -> "Standard_Boolean":
    """
    Adds the point defined as intersection of two isolines (u = 0 and v = 0) on theqsurf in theline. therefpt is used to correct adjusting parameters. if theisreversed is true then theqsurf correspond to the second (otherwise, the first) surface while forming intersection point intsurf_pnton2s.

    Parameters
    ----------
    theQSurf: Adaptor3d_HSurface
    thePSurf: Adaptor3d_HSurface
    theRefPt: IntSurf_PntOn2S
    theTol3d: float
    theAddedPoint: IntSurf_PntOn2S
    theIsReversed: bool,optional
    	default value is Standard_False

    Returns
    -------
    bool

    """
    return _IntPatch.IntPatch_SpecialPoints_AddCrossUVIsoPoint(*args)

def IntPatch_SpecialPoints_AddPointOnUorVIso(*args) -> "Standard_Boolean":
    """
    Adds the point lain strictly in the isoline u = 0 or v = 0 of theqsurf, in theline. therefpt is used to correct adjusting parameters. if theisreversed is true then theqsurf corresponds to the second (otherwise, the first) surface while forming intersection point intsurf_pnton2s. all math_vector-objects must be filled as follows: [1] - u-parameter of thepsurf; [2] - v-parameter of thepsurf; [3] - u- (if v-isoline is considered) or v-parameter (if u-isoline is considered) of theqsurf.

    Parameters
    ----------
    theQSurf: Adaptor3d_HSurface
    thePSurf: Adaptor3d_HSurface
    theRefPt: IntSurf_PntOn2S
    theIsU: bool
    theIsoParameter: float
    theToler: math_Vector
    theInitPoint: math_Vector
    theInfBound: math_Vector
    theSupBound: math_Vector
    theAddedPoint: IntSurf_PntOn2S
    theIsReversed: bool,optional
    	default value is Standard_False

    Returns
    -------
    bool

    """
    return _IntPatch.IntPatch_SpecialPoints_AddPointOnUorVIso(*args)

def IntPatch_SpecialPoints_AddSingularPole(*args) -> "Standard_Boolean":
    """
    Computes the pole of sphere to add it in the intersection line. stores the result in theaddedpoint variable (does not add in the line). at that, cone and sphere (with singularity) must be set in theqsurf parameter. by default (if theisreversed == false), theqsurf is the first surface of the walking line. if it is not, theisreversed parameter must be set to true. theisreqrefcheck is true if and only if 3d-point of therefpt must be pole or apex for check (e.g. if it is vertex). theptiso is the reference point for obtaining isoline where must be placed the apex/pole. //! attention!!! thevertex must be initialized before calling the method .

    Parameters
    ----------
    theQSurf: Adaptor3d_HSurface
    thePSurf: Adaptor3d_HSurface
    thePtIso: IntSurf_PntOn2S
    theVertex: IntPatch_Point
    theAddedPoint: IntSurf_PntOn2S
    theIsReversed: bool,optional
    	default value is Standard_False
    theIsReqRefCheck: bool,optional
    	default value is Standard_False

    Returns
    -------
    bool

    """
    return _IntPatch.IntPatch_SpecialPoints_AddSingularPole(*args)

def IntPatch_SpecialPoints_AdjustPointAndVertex(*args) -> "void":
    """
    Sets thenewpoint parameters in 2d-space the closest to therefpoint with help of adding/subtracting corresponding periods. thearrperiods must be filled as follows: {<u-period of 1st surface>, <v-period of 1st surface>, <u-period of 2nd surface>, <v-period of 2nd surface>}. if thevertex != 0 then its parameters will be filled as corresponding parameters of thenewpoint. //! attention!!! thenewpoint is not only output parameter. it is input/output one. i.e. thenewpoint is reference point together with therefpt.

    Parameters
    ----------
    theRefPoint: IntSurf_PntOn2S
    theArrPeriods: float
    theNewPoint: IntSurf_PntOn2S
    theVertex: IntPatch_Point *,optional
    	default value is 0

    Returns
    -------
    None

    """
    return _IntPatch.IntPatch_SpecialPoints_AdjustPointAndVertex(*args)

def IntPatch_SpecialPoints_ContinueAfterSpecialPoint(*args) -> "Standard_Boolean":
    """
    Special point has already been added in the line. now, we need in correct prolongation of the line or in start new line. this function returns new point. //! attention!!! thenewpoint is not only output parameter. it is input/output one. i.e. thenewpoint is reference point together with therefpt.

    Parameters
    ----------
    theQSurf: Adaptor3d_HSurface
    thePSurf: Adaptor3d_HSurface
    theRefPt: IntSurf_PntOn2S
    theSPType: IntPatch_SpecPntType
    theTol2D: float
    theNewPoint: IntSurf_PntOn2S
    theIsReversed: bool,optional
    	default value is Standard_False

    Returns
    -------
    bool

    """
    return _IntPatch.IntPatch_SpecialPoints_ContinueAfterSpecialPoint(*args)

class IntPatch_TheIWLineOfTheIWalking(OCC.Core.Standard.Standard_Transient):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_TheIWLineOfTheIWalking, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.Standard.Standard_Transient]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_TheIWLineOfTheIWalking, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Parameters
        ----------
        theAllocator: IntSurf_Allocator,optional
        	default value is 0

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_TheIWLineOfTheIWalking(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddIndexPassing(self, *args) -> "void":
        """
        Associer a l 'indice du point sur la ligne l'indice du point passant dans l'iterateur de depart.

        Parameters
        ----------
        Index: int

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_AddIndexPassing(self, *args)


    def AddPoint(self, *args) -> "void":
        """
        Add a point in the line.

        Parameters
        ----------
        P: IntSurf_PntOn2S

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_AddPoint(self, *args)


    def AddStatusFirst(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        Closed: bool
        HasFirst: bool

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        Closed: bool
        HasLast: bool
        Index: int
        P: IntSurf_PathPoint

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_AddStatusFirst(self, *args)


    def AddStatusFirstLast(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        Closed: bool
        HasFirst: bool
        HasLast: bool

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_AddStatusFirstLast(self, *args)


    def AddStatusLast(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        HasLast: bool

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        HasLast: bool
        Index: int
        P: IntSurf_PathPoint

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_AddStatusLast(self, *args)


    def Cut(self, *args) -> "void":
        """
        Cut the line at the point of rank index.

        Parameters
        ----------
        Index: int

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_Cut(self, *args)


    def FirstPoint(self, *args) -> "IntSurf_PathPoint const &":
        """
        Returns the first point of the line when it is a marching point. an exception is raised if hasfirstpoint returns false.

        Returns
        -------
        IntSurf_PathPoint

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_FirstPoint(self, *args)


    def FirstPointIndex(self, *args) -> "Standard_Integer":
        """
        Returns the index of first point of the line when it is a marching point.this index is the index in the pointstartiterator. an exception is raised if hasfirstpoint returns false.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_FirstPointIndex(self, *args)


    def HasFirstPoint(self, *args) -> "Standard_Boolean":
        """
        Returns true if the first point of the line is a marching point . when is hasfirstpoint==false ,the line begins on the natural bound of the surface.the line can be too long.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args) -> "Standard_Boolean":
        """
        Returns true if the end point of the line is a marching point (point from intws). when is hasfirstpoint==false ,the line ends on the natural bound of the surface.the line can be too long.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_HasLastPoint(self, *args)


    def IsClosed(self, *args) -> "Standard_Boolean":
        """
        Returns true if the line is closed.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_IsClosed(self, *args)


    def IsTangentAtBegining(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_IsTangentAtBegining(self, *args)


    def IsTangentAtEnd(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_IsTangentAtEnd(self, *args)


    def LastPoint(self, *args) -> "IntSurf_PathPoint const &":
        """
        Returns the last point of the line when it is a marching point. an exception is raised if haslastpoint returns false.

        Returns
        -------
        IntSurf_PathPoint

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_LastPoint(self, *args)


    def LastPointIndex(self, *args) -> "Standard_Integer":
        """
        Returns the index of last point of the line when it is a marching point.this index is the index in the pointstartiterator. an exception is raised if haslastpoint returns false.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_LastPointIndex(self, *args)


    def Line(self, *args) -> "opencascade::handle< IntSurf_LineOn2S > const &":
        """
        Returns the lineon2s contained in the walking line.

        Returns
        -------
        opencascade::handle<IntSurf_LineOn2S>

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_Line(self, *args)


    def NbPassingPoint(self, *args) -> "Standard_Integer":
        """
        Returns the number of points belonging to pnts1 which are passing point.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_NbPassingPoint(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        Returns the number of points of the line (including first point and end point : see haslastpoint and hasfirstpoint).

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_NbPoints(self, *args)


    def PassingPoint(self, *args) -> "void":
        """
        Returns the index of the point belonging to the line which is associated to the passing point belonging to pnts1 an exception is raised if index > nbpassingpoint().

        Parameters
        ----------
        Index: int

        Returns
        -------
        IndexLine: int
        IndexPnts: int

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_PassingPoint(self, *args)


    def Reverse(self, *args) -> "void":
        """
        Reverse the points in the line. hasfirst, haslast are kept.

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_Reverse(self, *args)


    def SetTangencyAtBegining(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        IsTangent: bool

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_SetTangencyAtBegining(self, *args)


    def SetTangencyAtEnd(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        IsTangent: bool

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_SetTangencyAtEnd(self, *args)


    def SetTangentVector(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        V: gp_Vec
        Index: int

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_SetTangentVector(self, *args)


    def TangentVector(self, *args) -> "gp_Vec const":
        """
        No available documentation.

        Parameters
        ----------

        Returns
        -------
        Index: int

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_TangentVector(self, *args)


    def Value(self, *args) -> "IntSurf_PntOn2S const &":
        """
        Returns the point of range index. if index <= 0 or index > nbpoints, an exception is raised.

        Parameters
        ----------
        Index: int

        Returns
        -------
        IntSurf_PntOn2S

        """
        return _IntPatch.IntPatch_TheIWLineOfTheIWalking_Value(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IntPatch_TheIWLineOfTheIWalking_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_TheIWLineOfTheIWalking
    __del__ = lambda self: None
IntPatch_TheIWLineOfTheIWalking_swigregister = _IntPatch.IntPatch_TheIWLineOfTheIWalking_swigregister
IntPatch_TheIWLineOfTheIWalking_swigregister(IntPatch_TheIWLineOfTheIWalking)

class IntPatch_TheIWalking(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_TheIWalking, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_TheIWalking, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Deflection is the maximum deflection admitted between two consecutive points on a resulting polyline. step is the maximum increment admitted between two consecutive points (in 2d space). epsilon is the tolerance beyond which 2 points are confused. thetofillholes is the flag defining whether possible holes between resulting curves are filled or not in case of intpatch walking thetofillholes is false.

        Parameters
        ----------
        Epsilon: float
        Deflection: float
        Step: float
        theToFillHoles: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_TheIWalking(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the calculus was successful.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_TheIWalking_IsDone(self, *args)


    def NbLines(self, *args) -> "Standard_Integer":
        """
        Returns the number of resulting polylines. an exception is raised if isdone returns false.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_TheIWalking_NbLines(self, *args)


    def NbSinglePnts(self, *args) -> "Standard_Integer":
        """
        Returns the number of points belonging to pnts on which no line starts or ends. an exception is raised if isdone returns false.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_TheIWalking_NbSinglePnts(self, *args)


    def Perform(self, *args) -> "void":
        """
        Searches a set of polylines starting on a point of pnts1 or pnts2. each point on a resulting polyline verifies f(u,v)=0.

        Parameters
        ----------
        Pnts1: IntSurf_SequenceOfPathPoint
        Pnts2: IntSurf_SequenceOfInteriorPoint
        Func: IntPatch_TheSurfFunction
        S: Adaptor3d_HSurface
        Reversed: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        Searches a set of polylines starting on a point of pnts1. each point on a resulting polyline verifies f(u,v)=0.

        Parameters
        ----------
        Pnts1: IntSurf_SequenceOfPathPoint
        Func: IntPatch_TheSurfFunction
        S: Adaptor3d_HSurface
        Reversed: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_TheIWalking_Perform(self, *args)


    def SetTolerance(self, *args) -> "void":
        """
        Deflection is the maximum deflection admitted between two consecutive points on a resulting polyline. step is the maximum increment admitted between two consecutive points (in 2d space). epsilon is the tolerance beyond which 2 points are confused.

        Parameters
        ----------
        Epsilon: float
        Deflection: float
        Step: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_TheIWalking_SetTolerance(self, *args)


    def SinglePnt(self, *args) -> "IntSurf_PathPoint const &":
        """
        Returns the point of range index . an exception is raised if isdone returns false. an exception is raised if index<=0 or index > nbsinglepnts.

        Parameters
        ----------
        Index: int

        Returns
        -------
        IntSurf_PathPoint

        """
        return _IntPatch.IntPatch_TheIWalking_SinglePnt(self, *args)


    def Value(self, *args) -> "opencascade::handle< IntPatch_TheIWLineOfTheIWalking > const &":
        """
        Returns the polyline of range index. an exception is raised if isdone is false. an exception is raised if index<=0 or index>nblines.

        Parameters
        ----------
        Index: int

        Returns
        -------
        opencascade::handle<IntPatch_TheIWLineOfTheIWalking>

        """
        return _IntPatch.IntPatch_TheIWalking_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_TheIWalking
    __del__ = lambda self: None
IntPatch_TheIWalking_swigregister = _IntPatch.IntPatch_TheIWalking_swigregister
IntPatch_TheIWalking_swigregister(IntPatch_TheIWalking)

class IntPatch_ThePathPointOfTheSOnBounds(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_ThePathPointOfTheSOnBounds, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_ThePathPointOfTheSOnBounds, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        P: gp_Pnt
        Tol: float
        V: Adaptor3d_HVertex
        A: Adaptor2d_HCurve2d
        Parameter: float

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        P: gp_Pnt
        Tol: float
        A: Adaptor2d_HCurve2d
        Parameter: float

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_ThePathPointOfTheSOnBounds(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Arc(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d > const &":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<Adaptor2d_HCurve2d>

        """
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Arc(self, *args)


    def IsNew(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_IsNew(self, *args)


    def Parameter(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Parameter(self, *args)


    def SetValue(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        P: gp_Pnt
        Tol: float
        V: Adaptor3d_HVertex
        A: Adaptor2d_HCurve2d
        Parameter: float

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        P: gp_Pnt
        Tol: float
        A: Adaptor2d_HCurve2d
        Parameter: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_SetValue(self, *args)


    def Tolerance(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Tolerance(self, *args)


    def Value(self, *args) -> "gp_Pnt const":
        """
        No available documentation.

        Returns
        -------
        gp_Pnt

        """
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Value(self, *args)


    def Vertex(self, *args) -> "opencascade::handle< Adaptor3d_HVertex > const &":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<Adaptor3d_HVertex>

        """
        return _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_Vertex(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_ThePathPointOfTheSOnBounds
    __del__ = lambda self: None
IntPatch_ThePathPointOfTheSOnBounds_swigregister = _IntPatch.IntPatch_ThePathPointOfTheSOnBounds_swigregister
IntPatch_ThePathPointOfTheSOnBounds_swigregister(IntPatch_ThePathPointOfTheSOnBounds)

class IntPatch_TheSOnBounds(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_TheSOnBounds, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_TheSOnBounds, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Empty constructor.

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_TheSOnBounds(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AllArcSolution(self, *args) -> "Standard_Boolean":
        """
        Returns true if all arc of the arcs are solution (inside the surface). an exception is raised if isdone returns false.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_TheSOnBounds_AllArcSolution(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        Returns true if the calculus was successful.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_TheSOnBounds_IsDone(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        Returns the number of resulting points. an exception is raised if isdone returns false (notdone).

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_TheSOnBounds_NbPoints(self, *args)


    def NbSegments(self, *args) -> "Standard_Integer":
        """
        Returns the number of the resulting segments. an exception is raised if isdone returns false (notdone).

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_TheSOnBounds_NbSegments(self, *args)


    def Perform(self, *args) -> "void":
        """
        Algorithm to find the points and parts of curves of domain (domain of of restriction of a surface) which verify f = 0. tolboundary defines if a curve is on q. toltangency defines if a point is on q.

        Parameters
        ----------
        F: IntPatch_ArcFunction
        Domain: Adaptor3d_TopolTool
        TolBoundary: float
        TolTangency: float
        RecheckOnRegularity: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_TheSOnBounds_Perform(self, *args)


    def Point(self, *args) -> "IntPatch_ThePathPointOfTheSOnBounds const &":
        """
        Returns the resulting point of range index. the exception notdone is raised if isdone() returns false. the exception outofrange is raised if index <= 0 or index > nbpoints.

        Parameters
        ----------
        Index: int

        Returns
        -------
        IntPatch_ThePathPointOfTheSOnBounds

        """
        return _IntPatch.IntPatch_TheSOnBounds_Point(self, *args)


    def Segment(self, *args) -> "IntPatch_TheSegmentOfTheSOnBounds const &":
        """
        Returns the resulting segment of range index. the exception notdone is raised if isdone() returns false. the exception outofrange is raised if index <= 0 or index > nbpoints.

        Parameters
        ----------
        Index: int

        Returns
        -------
        IntPatch_TheSegmentOfTheSOnBounds

        """
        return _IntPatch.IntPatch_TheSOnBounds_Segment(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_TheSOnBounds
    __del__ = lambda self: None
IntPatch_TheSOnBounds_swigregister = _IntPatch.IntPatch_TheSOnBounds_swigregister
IntPatch_TheSOnBounds_swigregister(IntPatch_TheSOnBounds)

class IntPatch_TheSearchInside(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_TheSearchInside, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_TheSearchInside, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        F: IntPatch_TheSurfFunction
        Surf: Adaptor3d_HSurface
        T: Adaptor3d_TopolTool
        Epsilon: float

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_TheSearchInside(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_TheSearchInside_IsDone(self, *args)


    def NbPoints(self, *args) -> "Standard_Integer":
        """
        Returns the number of points. the exception notdone if raised if isdone returns false.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_TheSearchInside_NbPoints(self, *args)


    def Perform(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        F: IntPatch_TheSurfFunction
        Surf: Adaptor3d_HSurface
        T: Adaptor3d_TopolTool
        Epsilon: float

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        F: IntPatch_TheSurfFunction
        Surf: Adaptor3d_HSurface
        UStart: float
        VStart: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_TheSearchInside_Perform(self, *args)


    def Value(self, *args) -> "IntSurf_InteriorPoint const &":
        """
        Returns the point of range index. the exception notdone if raised if isdone returns false. the exception outofrange if raised if index <= 0 or index > nbpoints.

        Parameters
        ----------
        Index: int

        Returns
        -------
        IntSurf_InteriorPoint

        """
        return _IntPatch.IntPatch_TheSearchInside_Value(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_TheSearchInside
    __del__ = lambda self: None
IntPatch_TheSearchInside_swigregister = _IntPatch.IntPatch_TheSearchInside_swigregister
IntPatch_TheSearchInside_swigregister(IntPatch_TheSearchInside)

class IntPatch_TheSegmentOfTheSOnBounds(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_TheSegmentOfTheSOnBounds, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_TheSegmentOfTheSOnBounds, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Empty constructor.

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_TheSegmentOfTheSOnBounds(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Curve(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d > const &":
        """
        Returns the geometric curve on the surface 's domain which is solution.

        Returns
        -------
        opencascade::handle<Adaptor2d_HCurve2d>

        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_Curve(self, *args)


    def FirstPoint(self, *args) -> "IntPatch_ThePathPointOfTheSOnBounds const &":
        """
        Returns the first point.

        Returns
        -------
        IntPatch_ThePathPointOfTheSOnBounds

        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_FirstPoint(self, *args)


    def HasFirstPoint(self, *args) -> "Standard_Boolean":
        """
        Returns true if there is a vertex (thepathpoint) defining the lowest valid parameter on the arc.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args) -> "Standard_Boolean":
        """
        Returns true if there is a vertex (thepathpoint) defining the greatest valid parameter on the arc.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_HasLastPoint(self, *args)


    def LastPoint(self, *args) -> "IntPatch_ThePathPointOfTheSOnBounds const &":
        """
        Returns the last point.

        Returns
        -------
        IntPatch_ThePathPointOfTheSOnBounds

        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_LastPoint(self, *args)


    def SetLimitPoint(self, *args) -> "void":
        """
        Defines the first point or the last point, depending on the value of the boolean first.

        Parameters
        ----------
        V: IntPatch_ThePathPointOfTheSOnBounds
        First: bool

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_SetLimitPoint(self, *args)


    def SetValue(self, *args) -> "void":
        """
        Defines the concerned arc.

        Parameters
        ----------
        A: Adaptor2d_HCurve2d

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_SetValue(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_TheSegmentOfTheSOnBounds
    __del__ = lambda self: None
IntPatch_TheSegmentOfTheSOnBounds_swigregister = _IntPatch.IntPatch_TheSegmentOfTheSOnBounds_swigregister
IntPatch_TheSegmentOfTheSOnBounds_swigregister(IntPatch_TheSegmentOfTheSOnBounds)

class IntPatch_TheSurfFunction(OCC.Core.math.math_FunctionSetWithDerivatives):
    __swig_setmethods__ = {}
    for _s in [OCC.Core.math.math_FunctionSetWithDerivatives]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_TheSurfFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [OCC.Core.math.math_FunctionSetWithDerivatives]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_TheSurfFunction, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        PS: Adaptor3d_HSurface
        IS: IntSurf_Quadric

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        IS: IntSurf_Quadric

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_TheSurfFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Direction2d(self, *args) -> "gp_Dir2d const":
        """
        No available documentation.

        Returns
        -------
        gp_Dir2d

        """
        return _IntPatch.IntPatch_TheSurfFunction_Direction2d(self, *args)


    def Direction3d(self, *args) -> "gp_Vec const":
        """
        No available documentation.

        Returns
        -------
        gp_Vec

        """
        return _IntPatch.IntPatch_TheSurfFunction_Direction3d(self, *args)


    def ISurface(self, *args) -> "IntSurf_Quadric const &":
        """
        No available documentation.

        Returns
        -------
        IntSurf_Quadric

        """
        return _IntPatch.IntPatch_TheSurfFunction_ISurface(self, *args)


    def IsTangent(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_TheSurfFunction_IsTangent(self, *args)


    def PSurface(self, *args) -> "opencascade::handle< Adaptor3d_HSurface > const &":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<Adaptor3d_HSurface>

        """
        return _IntPatch.IntPatch_TheSurfFunction_PSurface(self, *args)


    def Point(self, *args) -> "gp_Pnt const":
        """
        No available documentation.

        Returns
        -------
        gp_Pnt

        """
        return _IntPatch.IntPatch_TheSurfFunction_Point(self, *args)


    def Root(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_TheSurfFunction_Root(self, *args)


    def Set(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        PS: Adaptor3d_HSurface

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        Tolerance: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_TheSurfFunction_Set(self, *args)


    def SetImplicitSurface(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        IS: IntSurf_Quadric

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_TheSurfFunction_SetImplicitSurface(self, *args)


    def Tolerance(self, *args) -> "Standard_Real":
        """
        Returns the value tol so that if abs(func.root())<tol the function is considered null.

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_TheSurfFunction_Tolerance(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_TheSurfFunction
    __del__ = lambda self: None
IntPatch_TheSurfFunction_swigregister = _IntPatch.IntPatch_TheSurfFunction_swigregister
IntPatch_TheSurfFunction_swigregister(IntPatch_TheSurfFunction)

class IntPatch_WLineTool(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_WLineTool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_WLineTool, name)
    __repr__ = _swig_repr

    def ComputePurgedWLine(*args) -> "opencascade::handle< IntPatch_WLine >":
        """
        I removes equal points (leave one of equal points) from thewline and recompute vertex parameters. //! ii removes point out of borders in case of non periodic surfaces. //! iii removes exceed points using tube criteria: delete 7d point if it lies near to expected lines in 2d and 3d. each task (2d, 2d, 3d) have its own tolerance and checked separately. //! returns new wline or null wline if the number of the points is less than 2.

        Parameters
        ----------
        theWLine: IntPatch_WLine
        theS1: Adaptor3d_HSurface
        theS2: Adaptor3d_HSurface
        theDom1: Adaptor3d_TopolTool
        theDom2: Adaptor3d_TopolTool

        Returns
        -------
        opencascade::handle<IntPatch_WLine>

        """
        return _IntPatch.IntPatch_WLineTool_ComputePurgedWLine(*args)

    ComputePurgedWLine = staticmethod(ComputePurgedWLine)

    def ExtendTwoWLines(*args) -> "void":
        """
        Extends every line from theslin (if it is possible) to be started/finished in strictly determined point (in the place of joint of two lines). as result, some gaps between two lines will vanish. the walking lines are supposed (algorithm will do nothing for not-walking line) to be computed as a result of intersection. both thes1 and thes2 must be quadrics. other cases are not supported. thearrperiods must be filled as follows (every value must not be negative; if the surface is not periodic the period must be equal to 0.0 strictly): {<u-period of 1st surface>, <v-period of 1st surface>, <u-period of 2nd surface>, <v-period of 2nd surface>}. thelistofcriticalpoints must contain 3d-points where joining is disabled.

        Parameters
        ----------
        theSlin: IntPatch_SequenceOfLine
        theS1: Adaptor3d_HSurface
        theS2: Adaptor3d_HSurface
        theToler3D: float
        theArrPeriods: float *
        theBoxS1: Bnd_Box2d
        theBoxS2: Bnd_Box2d
        theListOfCriticalPoints: NCollection_List<gp_Pnt>

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_WLineTool_ExtendTwoWLines(*args)

    ExtendTwoWLines = staticmethod(ExtendTwoWLines)

    def JoinWLines(*args) -> "void":
        """
        Joins all wlines from theslin to one if it is possible and records the result into theslin again. lines will be kept to be split if: a) they are separated (has no common points); b) resulted line (after joining) go through seam-edges or surface boundaries. //! in addition, if points in thespnt lies at least in one of the line in theslin, this point will be deleted.

        Parameters
        ----------
        theSlin: IntPatch_SequenceOfLine
        theSPnt: IntPatch_SequenceOfPoint
        theS1: Adaptor3d_HSurface
        theS2: Adaptor3d_HSurface
        theTol3D: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_WLineTool_JoinWLines(*args)

    JoinWLines = staticmethod(JoinWLines)

    __repr__ = _dumps_object


    def __init__(self):
        this = _IntPatch.new_IntPatch_WLineTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPatch.delete_IntPatch_WLineTool
    __del__ = lambda self: None
IntPatch_WLineTool_swigregister = _IntPatch.IntPatch_WLineTool_swigregister
IntPatch_WLineTool_swigregister(IntPatch_WLineTool)

def IntPatch_WLineTool_ComputePurgedWLine(*args) -> "opencascade::handle< IntPatch_WLine >":
    """
    I removes equal points (leave one of equal points) from thewline and recompute vertex parameters. //! ii removes point out of borders in case of non periodic surfaces. //! iii removes exceed points using tube criteria: delete 7d point if it lies near to expected lines in 2d and 3d. each task (2d, 2d, 3d) have its own tolerance and checked separately. //! returns new wline or null wline if the number of the points is less than 2.

    Parameters
    ----------
    theWLine: IntPatch_WLine
    theS1: Adaptor3d_HSurface
    theS2: Adaptor3d_HSurface
    theDom1: Adaptor3d_TopolTool
    theDom2: Adaptor3d_TopolTool

    Returns
    -------
    opencascade::handle<IntPatch_WLine>

    """
    return _IntPatch.IntPatch_WLineTool_ComputePurgedWLine(*args)

def IntPatch_WLineTool_ExtendTwoWLines(*args) -> "void":
    """
    Extends every line from theslin (if it is possible) to be started/finished in strictly determined point (in the place of joint of two lines). as result, some gaps between two lines will vanish. the walking lines are supposed (algorithm will do nothing for not-walking line) to be computed as a result of intersection. both thes1 and thes2 must be quadrics. other cases are not supported. thearrperiods must be filled as follows (every value must not be negative; if the surface is not periodic the period must be equal to 0.0 strictly): {<u-period of 1st surface>, <v-period of 1st surface>, <u-period of 2nd surface>, <v-period of 2nd surface>}. thelistofcriticalpoints must contain 3d-points where joining is disabled.

    Parameters
    ----------
    theSlin: IntPatch_SequenceOfLine
    theS1: Adaptor3d_HSurface
    theS2: Adaptor3d_HSurface
    theToler3D: float
    theArrPeriods: float *
    theBoxS1: Bnd_Box2d
    theBoxS2: Bnd_Box2d
    theListOfCriticalPoints: NCollection_List<gp_Pnt>

    Returns
    -------
    None

    """
    return _IntPatch.IntPatch_WLineTool_ExtendTwoWLines(*args)

def IntPatch_WLineTool_JoinWLines(*args) -> "void":
    """
    Joins all wlines from theslin to one if it is possible and records the result into theslin again. lines will be kept to be split if: a) they are separated (has no common points); b) resulted line (after joining) go through seam-edges or surface boundaries. //! in addition, if points in thespnt lies at least in one of the line in theslin, this point will be deleted.

    Parameters
    ----------
    theSlin: IntPatch_SequenceOfLine
    theSPnt: IntPatch_SequenceOfPoint
    theS1: Adaptor3d_HSurface
    theS2: Adaptor3d_HSurface
    theTol3D: float

    Returns
    -------
    None

    """
    return _IntPatch.IntPatch_WLineTool_JoinWLines(*args)

class IntPatch_ALine(IntPatch_Line):
    __swig_setmethods__ = {}
    for _s in [IntPatch_Line]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_ALine, name, value)
    __swig_getmethods__ = {}
    for _s in [IntPatch_Line]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_ALine, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates an analytic intersection line when the transitions are in or out.

        Parameters
        ----------
        C: IntAna_Curve
        Tang: bool
        Trans1: IntSurf_TypeTrans
        Trans2: IntSurf_TypeTrans

        Returns
        -------
        None

        Creates an analytic intersection line when the transitions are touch.

        Parameters
        ----------
        C: IntAna_Curve
        Tang: bool
        Situ1: IntSurf_Situation
        Situ2: IntSurf_Situation

        Returns
        -------
        None

        Creates an analytic intersection line when the transitions are undecided.

        Parameters
        ----------
        C: IntAna_Curve
        Tang: bool

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_ALine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddVertex(self, *args) -> "void":
        """
        To add a vertex in the list.

        Parameters
        ----------
        Pnt: IntPatch_Point

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_ALine_AddVertex(self, *args)


    def ChangeVertex(self, *args) -> "IntPatch_Point &":
        """
        Allows modifying the vertex with index theindex on the line.

        Parameters
        ----------
        theIndex: int

        Returns
        -------
        IntPatch_Point

        """
        return _IntPatch.IntPatch_ALine_ChangeVertex(self, *args)


    def ComputeVertexParameters(self, *args) -> "void":
        """
        Set the parameters of all the vertex on the line. if a vertex is already in the line, its parameter is modified else a new point in the line is inserted.

        Parameters
        ----------
        Tol: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_ALine_ComputeVertexParameters(self, *args)


    def Curve(self, *args) -> "IntAna_Curve const &":
        """
        No available documentation.

        Returns
        -------
        IntAna_Curve

        """
        return _IntPatch.IntPatch_ALine_Curve(self, *args)


    def D1(self, *args) -> "Standard_Boolean":
        """
        Returns standard_true when the derivative at parameter u is defined on the analytic intersection line. in that case, du is the derivative. returns standard_false when it is not possible to evaluate the derivative. in both cases, p is the point at parameter u on the intersection.

        Parameters
        ----------
        U: float
        P: gp_Pnt
        Du: gp_Vec

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_ALine_D1(self, *args)


    def FindParameter(self, *args) -> "void":
        """
        Tries to find the parameters of the point p on the curve. if the method returns false, the 'projection' is impossible. if the method returns true at least one parameter has been found. theparams is always sorted in ascending order.

        Parameters
        ----------
        P: gp_Pnt
        theParams: TColStd_ListOfReal

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_ALine_FindParameter(self, *args)


    def FirstParameter(self, *args) -> "Standard_Real":
        """
        Returns the first parameter on the intersection line. if isincluded returns true, value and d1 methods can be call with a parameter equal to firstparamater. otherwise, the parameter must be greater than firstparameter.

        Parameters
        ----------

        Returns
        -------
        IsIncluded: bool

        """
        return _IntPatch.IntPatch_ALine_FirstParameter(self, *args)


    def FirstPoint(self, *args) -> "IntPatch_Point const &":
        """
        Returns the intpoint corresponding to the firstpoint. an exception is raised when hasfirstpoint returns false.

        Returns
        -------
        IntPatch_Point

        """
        return _IntPatch.IntPatch_ALine_FirstPoint(self, *args)


    def HasFirstPoint(self, *args) -> "Standard_Boolean":
        """
        Returns true if the line has a known first point. this point is given by the method firstpoint().

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_ALine_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args) -> "Standard_Boolean":
        """
        Returns true if the line has a known last point. this point is given by the method lastpoint().

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_ALine_HasLastPoint(self, *args)


    def LastParameter(self, *args) -> "Standard_Real":
        """
        Returns the last parameter on the intersection line. if isincluded returns true, value and d1 methods can be call with a parameter equal to lastparamater. otherwise, the parameter must be less than lastparameter.

        Parameters
        ----------

        Returns
        -------
        IsIncluded: bool

        """
        return _IntPatch.IntPatch_ALine_LastParameter(self, *args)


    def LastPoint(self, *args) -> "IntPatch_Point const &":
        """
        Returns the intpoint corresponding to the lastpoint. an exception is raised when haslastpoint returns false.

        Returns
        -------
        IntPatch_Point

        """
        return _IntPatch.IntPatch_ALine_LastPoint(self, *args)


    def NbVertex(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_ALine_NbVertex(self, *args)


    def Replace(self, *args) -> "void":
        """
        Replaces the element of range index in the list of points.

        Parameters
        ----------
        Index: int
        Pnt: IntPatch_Point

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_ALine_Replace(self, *args)


    def SetFirstPoint(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        IndFirst: int

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_ALine_SetFirstPoint(self, *args)


    def SetLastPoint(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        IndLast: int

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_ALine_SetLastPoint(self, *args)


    def Value(self, *args) -> "gp_Pnt":
        """
        Returns the point of parameter u on the analytic intersection line.

        Parameters
        ----------
        U: float

        Returns
        -------
        gp_Pnt

        """
        return _IntPatch.IntPatch_ALine_Value(self, *args)


    def Vertex(self, *args) -> "IntPatch_Point const &":
        """
        Returns the vertex of range index on the line.

        Parameters
        ----------
        Index: int

        Returns
        -------
        IntPatch_Point

        """
        return _IntPatch.IntPatch_ALine_Vertex(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IntPatch_ALine_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_ALine
    __del__ = lambda self: None
IntPatch_ALine_swigregister = _IntPatch.IntPatch_ALine_swigregister
IntPatch_ALine_swigregister(IntPatch_ALine)

class IntPatch_GLine(IntPatch_Line):
    __swig_setmethods__ = {}
    for _s in [IntPatch_Line]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_GLine, name, value)
    __swig_getmethods__ = {}
    for _s in [IntPatch_Line]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_GLine, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a line as intersection line when the transitions are in or out.

        Parameters
        ----------
        L: gp_Lin
        Tang: bool
        Trans1: IntSurf_TypeTrans
        Trans2: IntSurf_TypeTrans

        Returns
        -------
        None

        Creates a line as intersection line when the transitions are touch.

        Parameters
        ----------
        L: gp_Lin
        Tang: bool
        Situ1: IntSurf_Situation
        Situ2: IntSurf_Situation

        Returns
        -------
        None

        Creates a line as intersection line when the transitions are undecided.

        Parameters
        ----------
        L: gp_Lin
        Tang: bool

        Returns
        -------
        None

        Creates a circle as intersection line when the transitions are in or out.

        Parameters
        ----------
        C: gp_Circ
        Tang: bool
        Trans1: IntSurf_TypeTrans
        Trans2: IntSurf_TypeTrans

        Returns
        -------
        None

        Creates a circle as intersection line when the transitions are touch.

        Parameters
        ----------
        C: gp_Circ
        Tang: bool
        Situ1: IntSurf_Situation
        Situ2: IntSurf_Situation

        Returns
        -------
        None

        Creates a circle as intersection line when the transitions are undecided.

        Parameters
        ----------
        C: gp_Circ
        Tang: bool

        Returns
        -------
        None

        Creates an ellipse as intersection line when the transitions are in or out.

        Parameters
        ----------
        E: gp_Elips
        Tang: bool
        Trans1: IntSurf_TypeTrans
        Trans2: IntSurf_TypeTrans

        Returns
        -------
        None

        Creates an ellispe as intersection line when the transitions are touch.

        Parameters
        ----------
        E: gp_Elips
        Tang: bool
        Situ1: IntSurf_Situation
        Situ2: IntSurf_Situation

        Returns
        -------
        None

        Creates an ellipse as intersection line when the transitions are undecided.

        Parameters
        ----------
        E: gp_Elips
        Tang: bool

        Returns
        -------
        None

        Creates a parabola as intersection line when the transitions are in or out.

        Parameters
        ----------
        P: gp_Parab
        Tang: bool
        Trans1: IntSurf_TypeTrans
        Trans2: IntSurf_TypeTrans

        Returns
        -------
        None

        Creates a parabola as intersection line when the transitions are touch.

        Parameters
        ----------
        P: gp_Parab
        Tang: bool
        Situ1: IntSurf_Situation
        Situ2: IntSurf_Situation

        Returns
        -------
        None

        Creates a parabola as intersection line when the transitions are undecided.

        Parameters
        ----------
        P: gp_Parab
        Tang: bool

        Returns
        -------
        None

        Creates an hyperbola as intersection line when the transitions are in or out.

        Parameters
        ----------
        H: gp_Hypr
        Tang: bool
        Trans1: IntSurf_TypeTrans
        Trans2: IntSurf_TypeTrans

        Returns
        -------
        None

        Creates an hyperbola as intersection line when the transitions are touch.

        Parameters
        ----------
        H: gp_Hypr
        Tang: bool
        Situ1: IntSurf_Situation
        Situ2: IntSurf_Situation

        Returns
        -------
        None

        Creates an hyperbola as intersection line when the transitions are undecided.

        Parameters
        ----------
        H: gp_Hypr
        Tang: bool

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_GLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddVertex(self, *args) -> "void":
        """
        To add a vertex in the list.

        Parameters
        ----------
        Pnt: IntPatch_Point

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_GLine_AddVertex(self, *args)


    def Circle(self, *args) -> "gp_Circ":
        """
        Returns the circ from gp corrsponding to the intersection when arctype returns intpatch_circle.

        Returns
        -------
        gp_Circ

        """
        return _IntPatch.IntPatch_GLine_Circle(self, *args)


    def ComputeVertexParameters(self, *args) -> "void":
        """
        Set the parameters of all the vertex on the line. if a vertex is already in the line, its parameter is modified else a new point in the line is inserted.

        Parameters
        ----------
        Tol: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_GLine_ComputeVertexParameters(self, *args)


    def Ellipse(self, *args) -> "gp_Elips":
        """
        Returns the elips from gp corrsponding to the intersection when arctype returns intpatch_ellipse.

        Returns
        -------
        gp_Elips

        """
        return _IntPatch.IntPatch_GLine_Ellipse(self, *args)


    def FirstPoint(self, *args) -> "IntPatch_Point const &":
        """
        Returns the intpoint corresponding to the firstpoint. an exception is raised when hasfirstpoint returns false.

        Returns
        -------
        IntPatch_Point

        """
        return _IntPatch.IntPatch_GLine_FirstPoint(self, *args)


    def HasFirstPoint(self, *args) -> "Standard_Boolean":
        """
        Returns true if the line has a known first point. this point is given by the method firstpoint().

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_GLine_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args) -> "Standard_Boolean":
        """
        Returns true if the line has a known last point. this point is given by the method lastpoint().

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_GLine_HasLastPoint(self, *args)


    def Hyperbola(self, *args) -> "gp_Hypr":
        """
        Returns the hypr from gp corrsponding to the intersection when arctype returns intpatch_hyperbola.

        Returns
        -------
        gp_Hypr

        """
        return _IntPatch.IntPatch_GLine_Hyperbola(self, *args)


    def LastPoint(self, *args) -> "IntPatch_Point const &":
        """
        Returns the intpoint corresponding to the lastpoint. an exception is raised when haslastpoint returns false.

        Returns
        -------
        IntPatch_Point

        """
        return _IntPatch.IntPatch_GLine_LastPoint(self, *args)


    def Line(self, *args) -> "gp_Lin":
        """
        Returns the lin from gp corresponding to the intersection when arctype returns intpatch_line.

        Returns
        -------
        gp_Lin

        """
        return _IntPatch.IntPatch_GLine_Line(self, *args)


    def NbVertex(self, *args) -> "Standard_Integer":
        """
        No available documentation.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_GLine_NbVertex(self, *args)


    def Parabola(self, *args) -> "gp_Parab":
        """
        Returns the parab from gp corrsponding to the intersection when arctype returns intpatch_parabola.

        Returns
        -------
        gp_Parab

        """
        return _IntPatch.IntPatch_GLine_Parabola(self, *args)


    def Replace(self, *args) -> "void":
        """
        To replace the element of range index in the list of points.

        Parameters
        ----------
        Index: int
        Pnt: IntPatch_Point

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_GLine_Replace(self, *args)


    def SetFirstPoint(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        IndFirst: int

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_GLine_SetFirstPoint(self, *args)


    def SetLastPoint(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        IndLast: int

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_GLine_SetLastPoint(self, *args)


    def Vertex(self, *args) -> "IntPatch_Point const &":
        """
        Returns the vertex of range index on the line.

        Parameters
        ----------
        Index: int

        Returns
        -------
        IntPatch_Point

        """
        return _IntPatch.IntPatch_GLine_Vertex(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IntPatch_GLine_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_GLine
    __del__ = lambda self: None
IntPatch_GLine_swigregister = _IntPatch.IntPatch_GLine_swigregister
IntPatch_GLine_swigregister(IntPatch_GLine)

class IntPatch_PointLine(IntPatch_Line):
    __swig_setmethods__ = {}
    for _s in [IntPatch_Line]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_PointLine, name, value)
    __swig_getmethods__ = {}
    for _s in [IntPatch_Line]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_PointLine, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AddVertex(self, *args) -> "void":
        """
        Adds a vertex in the list. if theisprepend == true the new vertex will be added before the first element of vertices sequence. otherwise, to the end of the sequence.

        Parameters
        ----------
        Pnt: IntPatch_Point
        theIsPrepend: bool,optional
        	default value is Standard_False

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_PointLine_AddVertex(self, *args)


    def ChangeVertex(self, *args) -> "IntPatch_Point &":
        """
        Returns the vertex of range index on the line.

        Parameters
        ----------
        Index: int

        Returns
        -------
        IntPatch_Point

        """
        return _IntPatch.IntPatch_PointLine_ChangeVertex(self, *args)


    def ClearVertexes(self, *args) -> "void":
        """
        Removes vertices from the line.

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_PointLine_ClearVertexes(self, *args)


    def CurvatureRadiusOfIntersLine(*args) -> "Standard_Real":
        """
        Returns the radius of curvature of the intersection line in given point. returns negative value if computation is not possible.

        Parameters
        ----------
        theS1: Adaptor3d_HSurface
        theS2: Adaptor3d_HSurface
        theUVPoint: IntSurf_PntOn2S

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_PointLine_CurvatureRadiusOfIntersLine(*args)

    CurvatureRadiusOfIntersLine = staticmethod(CurvatureRadiusOfIntersLine)

    def Curve(self, *args) -> "opencascade::handle< IntSurf_LineOn2S >":
        """
        Returns set of intersection points.

        Returns
        -------
        opencascade::handle<IntSurf_LineOn2S>

        """
        return _IntPatch.IntPatch_PointLine_Curve(self, *args)


    def IsOutBox(self, *args) -> "Standard_Boolean":
        """
        Returns true if p is out of the box built from 3d-points.

        Parameters
        ----------
        P: gp_Pnt

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_PointLine_IsOutBox(self, *args)


    def IsOutSurf1Box(self, *args) -> "Standard_Boolean":
        """
        Returns true if p1 is out of the box built from the points on 1st surface.

        Parameters
        ----------
        P1: gp_Pnt2d

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_PointLine_IsOutSurf1Box(self, *args)


    def IsOutSurf2Box(self, *args) -> "Standard_Boolean":
        """
        Returns true if p2 is out of the box built from the points on 2nd surface.

        Parameters
        ----------
        P2: gp_Pnt2d

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_PointLine_IsOutSurf2Box(self, *args)


    def NbPnts(self, *args) -> "Standard_Integer":
        """
        Returns the number of intersection points.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_PointLine_NbPnts(self, *args)


    def NbVertex(self, *args) -> "Standard_Integer":
        """
        Returns number of vertices (intpatch_point) of the line.

        Returns
        -------
        int

        """
        return _IntPatch.IntPatch_PointLine_NbVertex(self, *args)


    def Point(self, *args) -> "IntSurf_PntOn2S const &":
        """
        Returns the intersection point of range index.

        Parameters
        ----------
        Index: int

        Returns
        -------
        IntSurf_PntOn2S

        """
        return _IntPatch.IntPatch_PointLine_Point(self, *args)


    def RemoveVertex(self, *args) -> "void":
        """
        Removes single vertex from the line.

        Parameters
        ----------
        theIndex: int

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_PointLine_RemoveVertex(self, *args)


    def Vertex(self, *args) -> "IntPatch_Point const &":
        """
        Returns the vertex of range index on the line.

        Parameters
        ----------
        Index: int

        Returns
        -------
        IntPatch_Point

        """
        return _IntPatch.IntPatch_PointLine_Vertex(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IntPatch_PointLine_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_PointLine
    __del__ = lambda self: None
IntPatch_PointLine_swigregister = _IntPatch.IntPatch_PointLine_swigregister
IntPatch_PointLine_swigregister(IntPatch_PointLine)

def IntPatch_PointLine_CurvatureRadiusOfIntersLine(*args) -> "Standard_Real":
    """
    Returns the radius of curvature of the intersection line in given point. returns negative value if computation is not possible.

    Parameters
    ----------
    theS1: Adaptor3d_HSurface
    theS2: Adaptor3d_HSurface
    theUVPoint: IntSurf_PntOn2S

    Returns
    -------
    float

    """
    return _IntPatch.IntPatch_PointLine_CurvatureRadiusOfIntersLine(*args)

class IntPatch_PolyArc(IntPatch_Polygo):
    __swig_setmethods__ = {}
    for _s in [IntPatch_Polygo]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_PolyArc, name, value)
    __swig_getmethods__ = {}
    for _s in [IntPatch_Polygo]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_PolyArc, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates the polygon of the arc a on the surface s. the arc is limited by the parameters pfirst and plast. none of these parameters can be infinite.

        Parameters
        ----------
        A: Adaptor2d_HCurve2d
        NbSample: int
        Pfirst: float
        Plast: float
        BoxOtherPolygon: Bnd_Box2d

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_PolyArc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Parameter(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Parameters
        ----------
        Index: int

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_PolyArc_Parameter(self, *args)


    def SetOffset(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        OffsetX: float
        OffsetY: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_PolyArc_SetOffset(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_PolyArc
    __del__ = lambda self: None
IntPatch_PolyArc_swigregister = _IntPatch.IntPatch_PolyArc_swigregister
IntPatch_PolyArc_swigregister(IntPatch_PolyArc)

class IntPatch_PolyLine(IntPatch_Polygo):
    __swig_setmethods__ = {}
    for _s in [IntPatch_Polygo]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_PolyLine, name, value)
    __swig_getmethods__ = {}
    for _s in [IntPatch_Polygo]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_PolyLine, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        No available documentation.

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        InitDefle: float

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_PolyLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ResetError(self, *args) -> "void":
        """
        No available documentation.

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_PolyLine_ResetError(self, *args)


    def SetRLine(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        OnFirst: bool
        Line: IntPatch_RLine

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_PolyLine_SetRLine(self, *args)


    def SetWLine(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        OnFirst: bool
        Line: IntPatch_WLine

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_PolyLine_SetWLine(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_PolyLine
    __del__ = lambda self: None
IntPatch_PolyLine_swigregister = _IntPatch.IntPatch_PolyLine_swigregister
IntPatch_PolyLine_swigregister(IntPatch_PolyLine)

class IntPatch_RLine(IntPatch_PointLine):
    __swig_setmethods__ = {}
    for _s in [IntPatch_PointLine]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_RLine, name, value)
    __swig_getmethods__ = {}
    for _s in [IntPatch_PointLine]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_RLine, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Creates a restriction as an intersection line when the transitions are in or out.

        Parameters
        ----------
        Tang: bool
        Trans1: IntSurf_TypeTrans
        Trans2: IntSurf_TypeTrans

        Returns
        -------
        None

        Creates a restriction as an intersection line when the transitions are touch.

        Parameters
        ----------
        Tang: bool
        Situ1: IntSurf_Situation
        Situ2: IntSurf_Situation

        Returns
        -------
        None

        Creates a restriction as an intersection line when the transitions are undecided.

        Parameters
        ----------
        Tang: bool

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_RLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        L: IntSurf_LineOn2S

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_RLine_Add(self, *args)


    def ArcOnS1(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d > const &":
        """
        Returns the concerned arc.

        Returns
        -------
        opencascade::handle<Adaptor2d_HCurve2d>

        """
        return _IntPatch.IntPatch_RLine_ArcOnS1(self, *args)


    def ArcOnS2(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d > const &":
        """
        Returns the concerned arc.

        Returns
        -------
        opencascade::handle<Adaptor2d_HCurve2d>

        """
        return _IntPatch.IntPatch_RLine_ArcOnS2(self, *args)


    def ComputeVertexParameters(self, *args) -> "void":
        """
        Set the parameters of all the vertex on the line. if a vertex is already in the line, its parameter is modified else a new point in the line is inserted.

        Parameters
        ----------
        Tol: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_RLine_ComputeVertexParameters(self, *args)


    def Dump(self, *args) -> "void":
        """
        If (themode == 0) then prints the information about wline if (themode == 1) then prints the list of 3d-points if (themode == 2) then prints the list of 2d-points on the 1st surface otherwise, prints list of 2d-points on the 2nd surface.

        Parameters
        ----------
        theMode: int

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_RLine_Dump(self, *args)


    def FirstPoint(self, *args) -> "IntPatch_Point const &":
        """
        Returns the intpoint corresponding to the firstpoint. an exception is raised when hasfirstpoint returns false.

        Returns
        -------
        IntPatch_Point

        """
        return _IntPatch.IntPatch_RLine_FirstPoint(self, *args)


    def HasFirstPoint(self, *args) -> "Standard_Boolean":
        """
        Returns true if the line has a known first point. this point is given by the method firstpoint().

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_RLine_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args) -> "Standard_Boolean":
        """
        Returns true if the line has a known last point. this point is given by the method lastpoint().

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_RLine_HasLastPoint(self, *args)


    def HasPolygon(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_RLine_HasPolygon(self, *args)


    def IsArcOnS1(self, *args) -> "Standard_Boolean":
        """
        Returns true if the intersection is on the domain of the first patch. returns false if the intersection is on the domain of the second patch.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_RLine_IsArcOnS1(self, *args)


    def IsArcOnS2(self, *args) -> "Standard_Boolean":
        """
        Returns true if the intersection is on the domain of the first patch. returns false if the intersection is on the domain of the second patch.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_RLine_IsArcOnS2(self, *args)


    def LastPoint(self, *args) -> "IntPatch_Point const &":
        """
        Returns the intpoint corresponding to the lastpoint. an exception is raised when haslastpoint returns false.

        Returns
        -------
        IntPatch_Point

        """
        return _IntPatch.IntPatch_RLine_LastPoint(self, *args)


    def ParamOnS1(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------

        Returns
        -------
        p1: float
        p2: float

        """
        return _IntPatch.IntPatch_RLine_ParamOnS1(self, *args)


    def ParamOnS2(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------

        Returns
        -------
        p1: float
        p2: float

        """
        return _IntPatch.IntPatch_RLine_ParamOnS2(self, *args)


    def Replace(self, *args) -> "void":
        """
        Replaces the element of range index in the list of points.

        Parameters
        ----------
        Index: int
        Pnt: IntPatch_Point

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_RLine_Replace(self, *args)


    def SetArcOnS1(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        A: Adaptor2d_HCurve2d

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_RLine_SetArcOnS1(self, *args)


    def SetArcOnS2(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        A: Adaptor2d_HCurve2d

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_RLine_SetArcOnS2(self, *args)


    def SetCurve(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        theNewCurve: IntSurf_LineOn2S

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_RLine_SetCurve(self, *args)


    def SetFirstPoint(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        IndFirst: int

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_RLine_SetFirstPoint(self, *args)


    def SetLastPoint(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        IndLast: int

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_RLine_SetLastPoint(self, *args)


    def SetPoint(self, *args) -> "void":
        """
        Set the point of index <index> in the lineon2s.

        Parameters
        ----------
        Index: int
        Pnt: IntPatch_Point

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_RLine_SetPoint(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IntPatch_RLine_DownCast(t)


    __repr__ = _dumps_object

    @methodnotwrapped
    def SetParamOnS1(self):
    	pass

    @methodnotwrapped
    def SetParamOnS2(self):
    	pass

    __swig_destroy__ = _IntPatch.delete_IntPatch_RLine
    __del__ = lambda self: None
IntPatch_RLine_swigregister = _IntPatch.IntPatch_RLine_swigregister
IntPatch_RLine_swigregister(IntPatch_RLine)

class IntPatch_WLine(IntPatch_PointLine):
    __swig_setmethods__ = {}
    for _s in [IntPatch_PointLine]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntPatch_WLine, name, value)
    __swig_getmethods__ = {}
    for _s in [IntPatch_PointLine]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntPatch_WLine, name)
    __repr__ = _swig_repr
    IntPatch_WLUnknown = _IntPatch.IntPatch_WLine_IntPatch_WLUnknown
    IntPatch_WLImpImp = _IntPatch.IntPatch_WLine_IntPatch_WLImpImp
    IntPatch_WLImpPrm = _IntPatch.IntPatch_WLine_IntPatch_WLImpPrm
    IntPatch_WLPrmPrm = _IntPatch.IntPatch_WLine_IntPatch_WLPrmPrm


    class IntPatch_WLType(IntEnum):
    	IntPatch_WLUnknown = 0
    	IntPatch_WLImpImp = 1
    	IntPatch_WLImpPrm = 2
    	IntPatch_WLPrmPrm = 3
    IntPatch_WLUnknown = IntPatch_WLType.IntPatch_WLUnknown
    IntPatch_WLImpImp = IntPatch_WLType.IntPatch_WLImpImp
    IntPatch_WLImpPrm = IntPatch_WLType.IntPatch_WLImpPrm
    IntPatch_WLPrmPrm = IntPatch_WLType.IntPatch_WLPrmPrm


    def __init__(self, *args):
        """
        Creates a wline as an intersection when the transitions are in or out.

        Parameters
        ----------
        Line: IntSurf_LineOn2S
        Tang: bool
        Trans1: IntSurf_TypeTrans
        Trans2: IntSurf_TypeTrans

        Returns
        -------
        None

        Creates a wline as an intersection when the transitions are touch.

        Parameters
        ----------
        Line: IntSurf_LineOn2S
        Tang: bool
        Situ1: IntSurf_Situation
        Situ2: IntSurf_Situation

        Returns
        -------
        None

        Creates a wline as an intersection when the transitions are undecided.

        Parameters
        ----------
        Line: IntSurf_LineOn2S
        Tang: bool

        Returns
        -------
        None

        """
        this = _IntPatch.new_IntPatch_WLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ComputeVertexParameters(self, *args) -> "void":
        """
        Set the parameters of all the vertex on the line. if a vertex is already in the line, its parameter is modified else a new point in the line is inserted.

        Parameters
        ----------
        Tol: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_WLine_ComputeVertexParameters(self, *args)


    def Dump(self, *args) -> "void":
        """
        If (themode == 0) then prints the information about wline if (themode == 1) then prints the list of 3d-points if (themode == 2) then prints the list of 2d-points on the 1st surface otherwise, prints list of 2d-points on the 2nd surface.

        Parameters
        ----------
        theMode: int

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_WLine_Dump(self, *args)


    def EnablePurging(self, *args) -> "void":
        """
        Allows or forbids purging of existing wline.

        Parameters
        ----------
        theIsEnabled: bool

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_WLine_EnablePurging(self, *args)


    def FirstPoint(self, *args) -> "IntPatch_Point const &":
        """
        Returns the point corresponding to the firstpoint.

        Returns
        -------
        IntPatch_Point

        Returns the point corresponding to the firstpoint. indfirst is the index of the first in the list of vertices.

        Parameters
        ----------

        Returns
        -------
        Indfirst: int

        """
        return _IntPatch.IntPatch_WLine_FirstPoint(self, *args)


    def GetArcOnS1(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d > const &":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<Adaptor2d_HCurve2d>

        """
        return _IntPatch.IntPatch_WLine_GetArcOnS1(self, *args)


    def GetArcOnS2(self, *args) -> "opencascade::handle< Adaptor2d_HCurve2d > const &":
        """
        No available documentation.

        Returns
        -------
        opencascade::handle<Adaptor2d_HCurve2d>

        """
        return _IntPatch.IntPatch_WLine_GetArcOnS2(self, *args)


    def GetCreatingWay(self, *args) -> "IntPatch_WLine::IntPatch_WLType":
        """
        Returns the way of <*this> creation.

        Returns
        -------
        IntPatch_WLine::IntPatch_WLType

        """
        return _IntPatch.IntPatch_WLine_GetCreatingWay(self, *args)


    def HasArcOnS1(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_WLine_HasArcOnS1(self, *args)


    def HasArcOnS2(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_WLine_HasArcOnS2(self, *args)


    def HasFirstPoint(self, *args) -> "Standard_Boolean":
        """
        Returns true if the line has a known first point. this point is given by the method firstpoint().

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_WLine_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args) -> "Standard_Boolean":
        """
        Returns true if the line has a known last point. this point is given by the method lastpoint().

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_WLine_HasLastPoint(self, *args)


    def InsertVertexBefore(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        theIndex: int
        thePnt: IntPatch_Point

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_WLine_InsertVertexBefore(self, *args)


    def IsPurgingAllowed(self, *args) -> "Standard_Boolean":
        """
        Returns true if purging is allowed or forbidden for existing wline.

        Returns
        -------
        bool

        """
        return _IntPatch.IntPatch_WLine_IsPurgingAllowed(self, *args)


    def LastPoint(self, *args) -> "IntPatch_Point const &":
        """
        Returns the point corresponding to the lastpoint.

        Returns
        -------
        IntPatch_Point

        Returns the point corresponding to the lastpoint. indlast is the index of the last in the list of vertices.

        Parameters
        ----------

        Returns
        -------
        Indlast: int

        """
        return _IntPatch.IntPatch_WLine_LastPoint(self, *args)


    def Replace(self, *args) -> "void":
        """
        Replaces the element of range index in the list of points. the exception outofrange is raised when index <= 0 or index > nbvertex.

        Parameters
        ----------
        Index: int
        Pnt: IntPatch_Point

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_WLine_Replace(self, *args)


    def SetArcOnS1(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        A: Adaptor2d_HCurve2d

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_WLine_SetArcOnS1(self, *args)


    def SetArcOnS2(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        A: Adaptor2d_HCurve2d

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_WLine_SetArcOnS2(self, *args)


    def SetCreatingWayInfo(self, *args) -> "void":
        """
        Sets the info about the way of <*this> creation.

        Parameters
        ----------
        theAlgo: IntPatch_WLType

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_WLine_SetCreatingWayInfo(self, *args)


    def SetFirstPoint(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        IndFirst: int

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_WLine_SetFirstPoint(self, *args)


    def SetLastPoint(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        IndLast: int

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_WLine_SetLastPoint(self, *args)


    def SetPeriod(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        pu1: float
        pv1: float
        pu2: float
        pv2: float

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_WLine_SetPeriod(self, *args)


    def SetPoint(self, *args) -> "void":
        """
        Set the point of index <index> in the lineon2s.

        Parameters
        ----------
        Index: int
        Pnt: IntPatch_Point

        Returns
        -------
        None

        """
        return _IntPatch.IntPatch_WLine_SetPoint(self, *args)


    def U1Period(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_WLine_U1Period(self, *args)


    def U2Period(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_WLine_U2Period(self, *args)


    def V1Period(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_WLine_V1Period(self, *args)


    def V2Period(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _IntPatch.IntPatch_WLine_V2Period(self, *args)



    @staticmethod
    def DownCast(t):
      return Handle_IntPatch_WLine_DownCast(t)


    __repr__ = _dumps_object

    __swig_destroy__ = _IntPatch.delete_IntPatch_WLine
    __del__ = lambda self: None
IntPatch_WLine_swigregister = _IntPatch.IntPatch_WLine_swigregister
IntPatch_WLine_swigregister(IntPatch_WLine)


@classnotwrapped
class IntPatch_Polyhedron:
	pass



IntPatch_SearchPnt=OCC.Core.Intf.Intf_InterferencePolygon2d

# This file is compatible with both classic and new-style classes.


