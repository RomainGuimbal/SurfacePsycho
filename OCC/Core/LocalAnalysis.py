# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
LocalAnalysis module, see official documentation at
https://www.opencascade.com/doc/occt-7.4.0/refman/html/package_localanalysis.html
"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_LocalAnalysis')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_LocalAnalysis')
    _LocalAnalysis = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_LocalAnalysis', [dirname(__file__)])
        except ImportError:
            import _LocalAnalysis
            return _LocalAnalysis
        try:
            _mod = imp.load_module('_LocalAnalysis', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _LocalAnalysis = swig_import_helper()
    del swig_import_helper
else:
    import _LocalAnalysis
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _LocalAnalysis.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _LocalAnalysis.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _LocalAnalysis.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _LocalAnalysis.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _LocalAnalysis.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _LocalAnalysis.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _LocalAnalysis.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _LocalAnalysis.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _LocalAnalysis.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _LocalAnalysis.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _LocalAnalysis.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _LocalAnalysis.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _LocalAnalysis.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _LocalAnalysis.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _LocalAnalysis.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _LocalAnalysis.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _LocalAnalysis.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _LocalAnalysis.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def _dumps_object(klass):
    """ Overwrite default string output for any wrapped object.
    By default, __repr__ method returns something like:
    <OCC.Core.TopoDS.TopoDS_Shape; proxy of <Swig Object of type 'TopoDS_Shape *' at 0x02BB0758> >
    This is too much verbose.
    We prefer :
    <class 'gp_Pnt'>
    or
    <class 'TopoDS_Shape'>
    """
    klass_name = str(klass.__class__).split(".")[3].split("'")[0]
    repr_string = "<class '" + klass_name + "'"
# for TopoDS_Shape, we also look for the base type
    if klass_name == "TopoDS_Shape":
        if klass.IsNull():
            repr_string += ": Null>"
            return repr_string
        st = klass.ShapeType()
        types = {OCC.Core.TopAbs.TopAbs_VERTEX: "Vertex",
                 OCC.Core.TopAbs.TopAbs_SOLID: "Solid",
                 OCC.Core.TopAbs.TopAbs_EDGE: "Edge",
                 OCC.Core.TopAbs.TopAbs_FACE: "Face",
                 OCC.Core.TopAbs.TopAbs_SHELL: "Shell",
                 OCC.Core.TopAbs.TopAbs_WIRE: "Wire",
                 OCC.Core.TopAbs.TopAbs_COMPOUND: "Compound",
                 OCC.Core.TopAbs.TopAbs_COMPSOLID: "Compsolid"}
        repr_string += "; Type:%s" % types[st]        
    elif hasattr(klass, "IsNull"):
        if klass.IsNull():
            repr_string += "; Null"
    repr_string += ">"
    return repr_string


def process_exception(error: 'Standard_Failure', method_name: 'std::string', class_name: 'std::string') -> "void":
    return _LocalAnalysis.process_exception(error, method_name, class_name)
process_exception = _LocalAnalysis.process_exception

from six import with_metaclass
import warnings
from OCC.Wrapper.wrapper_utils import Proxy, deprecated

import OCC.Core.Standard
import OCC.Core.NCollection
import OCC.Core.Geom
import OCC.Core.gp
import OCC.Core.TColStd
import OCC.Core.TCollection
import OCC.Core.GeomAbs
import OCC.Core.TColgp
import OCC.Core.Geom2d
import OCC.Core.GeomLProp

from enum import IntEnum
from OCC.Core.Exception import *

LocalAnalysis_NullFirstDerivative = _LocalAnalysis.LocalAnalysis_NullFirstDerivative
LocalAnalysis_NullSecondDerivative = _LocalAnalysis.LocalAnalysis_NullSecondDerivative
LocalAnalysis_TangentNotDefined = _LocalAnalysis.LocalAnalysis_TangentNotDefined
LocalAnalysis_NormalNotDefined = _LocalAnalysis.LocalAnalysis_NormalNotDefined
LocalAnalysis_CurvatureNotDefined = _LocalAnalysis.LocalAnalysis_CurvatureNotDefined


class LocalAnalysis_StatusErrorType(IntEnum):
	LocalAnalysis_NullFirstDerivative = 0
	LocalAnalysis_NullSecondDerivative = 1
	LocalAnalysis_TangentNotDefined = 2
	LocalAnalysis_NormalNotDefined = 3
	LocalAnalysis_CurvatureNotDefined = 4
LocalAnalysis_NullFirstDerivative = LocalAnalysis_StatusErrorType.LocalAnalysis_NullFirstDerivative
LocalAnalysis_NullSecondDerivative = LocalAnalysis_StatusErrorType.LocalAnalysis_NullSecondDerivative
LocalAnalysis_TangentNotDefined = LocalAnalysis_StatusErrorType.LocalAnalysis_TangentNotDefined
LocalAnalysis_NormalNotDefined = LocalAnalysis_StatusErrorType.LocalAnalysis_NormalNotDefined
LocalAnalysis_CurvatureNotDefined = LocalAnalysis_StatusErrorType.LocalAnalysis_CurvatureNotDefined

class localanalysis(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, localanalysis, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, localanalysis, name)
    __repr__ = _swig_repr

    __repr__ = _dumps_object


    def __init__(self):
        this = _LocalAnalysis.new_localanalysis()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _LocalAnalysis.delete_localanalysis
    __del__ = lambda self: None
localanalysis_swigregister = _LocalAnalysis.localanalysis_swigregister
localanalysis_swigregister(localanalysis)

class LocalAnalysis_CurveContinuity(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LocalAnalysis_CurveContinuity, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LocalAnalysis_CurveContinuity, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        -u1 is the parameter of the point on curv1 -u2 is the parameter of the point on curv2 -order is the required continuity: geomabs_c0 geomabs_c1 geomabs_c2 geomabs_g1 geomabs_g2 //! -epsnul is used to detect a a vector with nul magnitude (in mm) //! -epsc0 is used for c0 continuity to confuse two points (in mm) //! -epsc1 is an angular tolerance in radians used for c1 continuity to compare the angle between the first derivatives //! -epsc2 is an angular tolerance in radians used for c2 continuity to compare the angle between the second derivatives //! -epsg1 is an angular tolerance in radians used for g1 continuity to compare the angle between the tangents //! -epsg2 is an angular tolerance in radians used for g2 continuity to compare the angle between the normals //! - percent : percentage of curvature variation (unitless) used for g2 continuity //! - maxlen is the maximum length of curv1 or curv2 in meters used to detect nul curvature (in mm) //! the constructor computes the quantities which are necessary to check the continuity in the following cases: //! case c0 -------- - the distance between p1 and p2 with p1=curv1 (u1) and p2=curv2(u2) //! case c1 ------- //! - the angle between the first derivatives dcurv1(u1)  dcurv2(u2) -------- and --------- du  du //! - the ratio between the magnitudes of the first derivatives //! the angle value is between 0 and pi/2 //! case c2 ------- - the angle between the second derivatives 2  2 d curv1(u1) d curv2(u2) ---------- ---------- 2  2 du du //! the angle value is between 0 and pi/2 //! - the ratio between the magnitudes of the second derivatives //! case g1 ------- the angle between the tangents at each point //! the angle value is between 0 and pi/2 //! case g2 ------- -the angle between the normals at each point //! the angle value is between 0 and pi/2 //! - the relative variation of curvature: |curvat1-curvat2| ------------------ 1/2 (curvat1*curvat2) //! where curvat1 is the curvature at the first point and curvat2 the curvature at the second point.

        Parameters
        ----------
        Curv1: Geom_Curve
        u1: float
        Curv2: Geom_Curve
        u2: float
        Order: GeomAbs_Shape
        EpsNul: float,optional
        	default value is 0.001
        EpsC0: float,optional
        	default value is 0.001
        EpsC1: float,optional
        	default value is 0.001
        EpsC2: float,optional
        	default value is 0.001
        EpsG1: float,optional
        	default value is 0.001
        EpsG2: float,optional
        	default value is 0.001
        Percent: float,optional
        	default value is 0.01
        Maxlen: float,optional
        	default value is 10000

        Returns
        -------
        None

        """
        this = _LocalAnalysis.new_LocalAnalysis_CurveContinuity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def C0Value(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_C0Value(self, *args)


    def C1Angle(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_C1Angle(self, *args)


    def C1Ratio(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_C1Ratio(self, *args)


    def C2Angle(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_C2Angle(self, *args)


    def C2Ratio(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_C2Ratio(self, *args)


    def ContinuityStatus(self, *args) -> "GeomAbs_Shape":
        """
        No available documentation.

        Returns
        -------
        GeomAbs_Shape

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_ContinuityStatus(self, *args)


    def G1Angle(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_G1Angle(self, *args)


    def G2Angle(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_G2Angle(self, *args)


    def G2CurvatureVariation(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_G2CurvatureVariation(self, *args)


    def IsC0(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_IsC0(self, *args)


    def IsC1(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_IsC1(self, *args)


    def IsC2(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_IsC2(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_IsDone(self, *args)


    def IsG1(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_IsG1(self, *args)


    def IsG2(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_IsG2(self, *args)


    def StatusError(self, *args) -> "LocalAnalysis_StatusErrorType":
        """
        No available documentation.

        Returns
        -------
        LocalAnalysis_StatusErrorType

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_StatusError(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _LocalAnalysis.delete_LocalAnalysis_CurveContinuity
    __del__ = lambda self: None
LocalAnalysis_CurveContinuity_swigregister = _LocalAnalysis.LocalAnalysis_CurveContinuity_swigregister
LocalAnalysis_CurveContinuity_swigregister(LocalAnalysis_CurveContinuity)

class LocalAnalysis_SurfaceContinuity(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LocalAnalysis_SurfaceContinuity, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LocalAnalysis_SurfaceContinuity, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        -u1,v1 are the parameters of the point on surf1 -u2,v2 are the parameters of the point on surf2 -order is the required continuity: geomabs_c0 geomabs_c1 geomabs_c2 geomabs_g1 geomabs_g2 //! -epsnul is used to detect a a vector with nul magnitude //! -epsc0 is used for c0 continuity to confuse two points (in mm) //! -epsc1 is an angular tolerance in radians used for c1 continuity to compare the angle between the first derivatives //! -epsc2 is an angular tolerance in radians used for c2 continuity to compare the angle between the second derivatives //! -epsg1 is an angular tolerance in radians used for g1 continuity to compare the angle between the normals //! -percent : percentage of curvature variation (unitless) used for g2 continuity //! - maxlen is the maximum length of surf1 or surf2 in meters used to detect null curvature (in mm) //! the constructor computes the quantities which are necessary to check the continuity in the following cases: //! case c0 -------- - the distance between p1 and p2 with p1=surf (u1,v1) and p2=surfv2(u2,v2) //! case c1 ------- //! - the angle between the first derivatives in u : //! dsurf1(u1,v1) dsurf2(u2,v2) ----------- and --------- du  du //! the angle value is between 0 and pi/2 //! - the angle between the first derivatives in v : //! dsurf1(u1,v1) dsurf2(u2,v2) -------- and --------- dv  dv //! - the ratio between the magnitudes of the first derivatives in u - the ratio between the magnitudes of the first derivatives in v //! the angle value is between 0 and pi/2 //! case c2 ------- - the angle between the second derivatives in u 2 2 d surf1(u1,v1) d surf2(u2,v2) ---------- ---------- 2 2 d u d u //! - the ratio between the magnitudes of the second derivatives in u - the ratio between the magnitudes of the second derivatives in v //! the angle value is between 0 and pi/2 //! case g1 ------- -the angle between the normals at each point the angle value is between 0 and pi/2 //! case g2 ------- - the maximum normal curvature gap between the two points.

        Parameters
        ----------
        Surf1: Geom_Surface
        u1: float
        v1: float
        Surf2: Geom_Surface
        u2: float
        v2: float
        Order: GeomAbs_Shape
        EpsNul: float,optional
        	default value is 0.001
        EpsC0: float,optional
        	default value is 0.001
        EpsC1: float,optional
        	default value is 0.001
        EpsC2: float,optional
        	default value is 0.001
        EpsG1: float,optional
        	default value is 0.001
        Percent: float,optional
        	default value is 0.01
        Maxlen: float,optional
        	default value is 10000

        Returns
        -------
        None

        No available documentation.

        Parameters
        ----------
        curv1: Geom2d_Curve
        curv2: Geom2d_Curve
        U: float
        Surf1: Geom_Surface
        Surf2: Geom_Surface
        Order: GeomAbs_Shape
        EpsNul: float,optional
        	default value is 0.001
        EpsC0: float,optional
        	default value is 0.001
        EpsC1: float,optional
        	default value is 0.001
        EpsC2: float,optional
        	default value is 0.001
        EpsG1: float,optional
        	default value is 0.001
        Percent: float,optional
        	default value is 0.01
        Maxlen: float,optional
        	default value is 10000

        Returns
        -------
        None

        This constructor is used when we want to compute many analysis. after we use the method computeanalysis.

        Parameters
        ----------
        EpsNul: float,optional
        	default value is 0.001
        EpsC0: float,optional
        	default value is 0.001
        EpsC1: float,optional
        	default value is 0.001
        EpsC2: float,optional
        	default value is 0.001
        EpsG1: float,optional
        	default value is 0.001
        Percent: float,optional
        	default value is 0.01
        Maxlen: float,optional
        	default value is 10000

        Returns
        -------
        None

        """
        this = _LocalAnalysis.new_LocalAnalysis_SurfaceContinuity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def C0Value(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_C0Value(self, *args)


    def C1UAngle(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_C1UAngle(self, *args)


    def C1URatio(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_C1URatio(self, *args)


    def C1VAngle(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_C1VAngle(self, *args)


    def C1VRatio(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_C1VRatio(self, *args)


    def C2UAngle(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_C2UAngle(self, *args)


    def C2URatio(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_C2URatio(self, *args)


    def C2VAngle(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_C2VAngle(self, *args)


    def C2VRatio(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_C2VRatio(self, *args)


    def ComputeAnalysis(self, *args) -> "void":
        """
        No available documentation.

        Parameters
        ----------
        Surf1: GeomLProp_SLProps
        Surf2: GeomLProp_SLProps
        Order: GeomAbs_Shape

        Returns
        -------
        None

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_ComputeAnalysis(self, *args)


    def ContinuityStatus(self, *args) -> "GeomAbs_Shape":
        """
        No available documentation.

        Returns
        -------
        GeomAbs_Shape

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_ContinuityStatus(self, *args)


    def G1Angle(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_G1Angle(self, *args)


    def G2CurvatureGap(self, *args) -> "Standard_Real":
        """
        No available documentation.

        Returns
        -------
        float

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_G2CurvatureGap(self, *args)


    def IsC0(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_IsC0(self, *args)


    def IsC1(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_IsC1(self, *args)


    def IsC2(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_IsC2(self, *args)


    def IsDone(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_IsDone(self, *args)


    def IsG1(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_IsG1(self, *args)


    def IsG2(self, *args) -> "Standard_Boolean":
        """
        No available documentation.

        Returns
        -------
        bool

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_IsG2(self, *args)


    def StatusError(self, *args) -> "LocalAnalysis_StatusErrorType":
        """
        No available documentation.

        Returns
        -------
        LocalAnalysis_StatusErrorType

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_StatusError(self, *args)


    __repr__ = _dumps_object

    __swig_destroy__ = _LocalAnalysis.delete_LocalAnalysis_SurfaceContinuity
    __del__ = lambda self: None
LocalAnalysis_SurfaceContinuity_swigregister = _LocalAnalysis.LocalAnalysis_SurfaceContinuity_swigregister
LocalAnalysis_SurfaceContinuity_swigregister(LocalAnalysis_SurfaceContinuity)



# This file is compatible with both classic and new-style classes.


